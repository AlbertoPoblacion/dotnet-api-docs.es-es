<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2bcbb356421d8771d79a334e95a0d90410dc304d" /><Meta Name="ms.sourcegitcommit" Value="662f143e6be46d519ff8ab4451d543d91e651478" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/18/2018" /><Meta Name="ms.locfileid" Value="53568699" /></Metadata><TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HttpWebRequest = class&#xA;    inherit WebRequest&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.FriendAccessAllowed</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona una implementación específica de HTTP de la clase <see cref="T:System.Net.WebRequest" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
>  No se recomienda que utilice `HttpWebRequest` para nuevo desarrollo. En su lugar, use la <xref:System.Net.Http.HttpClient?displayProperty=nameWithType> clase.

 El <xref:System.Net.HttpWebRequest> proporciona compatibilidad para las propiedades y métodos definidos en <xref:System.Net.WebRequest> y para las propiedades y métodos que permiten al usuario interactuar directamente con los servidores mediante HTTP adicionales.  
  
 No utilice el <xref:System.Net.HttpWebRequest.%23ctor%2A> constructor. Use la <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> método para inicializar nuevas <xref:System.Net.HttpWebRequest> objetos. Si el esquema para el identificador uniforme de recursos (URI) es `http://` o `https://`, <xref:System.Net.WebRequest.Create%2A> devuelve un <xref:System.Net.HttpWebRequest> objeto.  
  
 El <xref:System.Net.HttpWebRequest.GetResponse%2A> método realiza una solicitud sincrónica al recurso especificado en el <xref:System.Net.HttpWebRequest.RequestUri%2A> propiedad y devuelve un <xref:System.Net.HttpWebResponse> que contiene el objeto de respuesta. Se pueden recibir los datos de respuesta mediante el uso de la secuencia devuelta por <xref:System.Net.HttpWebResponse.GetResponseStream%2A>. Si el objeto de respuesta o la secuencia de respuesta está cerrada, se perderá los datos restantes. Los datos restantes se se agotará y el socket será volver a usar para las solicitudes posteriores al cerrar la secuencia o el objeto de respuesta si se mantiene en las condiciones siguientes: es una solicitud canalizada o keep-alive, sólo una pequeña cantidad de datos debe recibirse, o los datos restantes se reciben en un pequeño intervalo de tiempo. Si ninguna de las condiciones mencionadas mantenga o se supera el tiempo de purga, se cerrará el socket. Para las conexiones canalizadas o persistente, se recomienda encarecidamente que la aplicación lee las secuencias hasta EOF. Esto garantiza que el socket se reutilizará para lo que mejora el rendimiento y menos recursos que usa las solicitudes posteriores.  
  
 Cuando desea enviar datos al recurso, el <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método devuelve un <xref:System.IO.Stream> objeto que se va a usar para enviar datos. El <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> y <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> métodos proporcionan acceso asincrónico al flujo de datos de envío.  
  
 Para la autenticación de cliente con <xref:System.Net.HttpWebRequest>, el certificado de cliente debe instalarse en el almacén de certificados My del usuario actual.  
  
 El <xref:System.Net.HttpWebRequest> clase produce una <xref:System.Net.WebException> cuando se producen errores al obtener acceso a un recurso. El <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> propiedad contiene un <xref:System.Net.WebExceptionStatus> valor que indica el origen del error. Cuando <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> es <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>, <xref:System.Net.WebException.Response%2A> propiedad contiene el <xref:System.Net.HttpWebResponse> recibidos del recurso.  
  
 <xref:System.Net.HttpWebRequest> expone los valores de encabezado HTTP comunes enviados al recurso de Internet como propiedades, métodos establecen o establecido por el sistema; en la tabla siguiente contiene una lista completa. Puede establecer otros encabezados en el <xref:System.Net.HttpWebRequest.Headers%2A> propiedad como pares nombre/valor. Tenga en cuenta que los servidores y las memorias caché pueden cambiar o agregar encabezados durante la solicitud.  
  
 En la tabla siguiente se enumera los encabezados HTTP que se establecen mediante las propiedades o métodos o el sistema.  
  
|Header|Establecido por|  
|------------|------------|  
|Aceptar|Establecer el <xref:System.Net.HttpWebRequest.Accept%2A> propiedad.|  
|Conexión|Establecer el <xref:System.Net.HttpWebRequest.Connection%2A> propiedad <xref:System.Net.HttpWebRequest.KeepAlive%2A> propiedad.|  
|Longitud del contenido|Establecer el <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad.|  
|Content-Type|Establecer el <xref:System.Net.HttpWebRequest.ContentType%2A> propiedad.|  
|Esperar|Establecer el <xref:System.Net.HttpWebRequest.Expect%2A> propiedad.|  
|Fecha|Establecido por el sistema hasta la fecha actual.|  
|administrador de flujos de trabajo|Establecido por el sistema a la información de host actual.|  
|If-Modified-Since|Establecer el <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad.|  
|Intervalo|Establecer el <xref:System.Net.HttpWebRequest.AddRange%2A> método.|  
|Sitio de referencia|Establecer el <xref:System.Net.HttpWebRequest.Referer%2A> propiedad.|  
|Codificación de transferencia|Establecer el <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propiedad (el <xref:System.Net.HttpWebRequest.SendChunked%2A> propiedad debe ser `true`).|  
|Agente de usuario|Establecer el <xref:System.Net.HttpWebRequest.UserAgent%2A> propiedad.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> se registra automáticamente. No es necesario llamar a la <xref:System.Net.WebRequest.RegisterPrefix%2A> método para registrar <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> antes de usar los URI a partir `http://` o `https://`.  
  
 El equipo local o un archivo de configuración de la aplicación puede especificar que se usa un proxy predeterminado. Si el <xref:System.Net.HttpWebRequest.Proxy%2A> se especifica la propiedad, a continuación, la configuración de proxy de la <xref:System.Net.HttpWebRequest.Proxy%2A> el equipo local o un archivo de configuración de aplicación de reemplazo de propiedad y el <xref:System.Net.HttpWebRequest> instancia usará la configuración de proxy especificada. Si no se especifica ningún proxy en un archivo de configuración y el <xref:System.Net.HttpWebRequest.Proxy%2A> propiedad no se especifica, el <xref:System.Net.HttpWebRequest> clase utiliza la configuración de proxy heredada de Internet Explorer en el equipo local. Si no hay ninguna configuración de proxy en Internet Explorer, la solicitud se envía directamente al servidor.  
  
 La <xref:System.Net.HttpWebRequest> clase analiza una lista de omisión de proxy con caracteres comodín heredados desde Internet Explorer de forma diferente a la lista de omisión se analiza directamente por Internet Explorer. Por ejemplo, el <xref:System.Net.HttpWebRequest> clase analizará una lista de omisión de "nt *" de Internet Explorer como una expresión regular de "nt. $". Esto difiere del comportamiento nativo de Internet Explorer. Por lo tanto una dirección URL de "`http://intxxxxx`" omitiría el proxy utilizando la <xref:System.Net.HttpWebRequest> clase, pero no se podrían omitir el proxy con Internet Explorer.  
  
> [!NOTE]
>  El marco de trabajo se almacena en caché las sesiones SSL cuando se crean y se intenta reutilizar una sesión almacenada en caché para una nueva solicitud, si es posible. Al intentar reutilizar una sesión SSL, el marco de trabajo usa el primer elemento de <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (si hay alguno), o intenta reutilizar una sesión anónima si <xref:System.Net.HttpWebRequest.ClientCertificates%2A> está vacío.  
  
> [!NOTE]
>  Por motivos de seguridad, las cookies están deshabilitadas de forma predeterminada. Si desea utilizar cookies, utilice el <xref:System.Net.HttpWebRequest.CookieContainer%2A> propiedad para permitir las cookies.  
  
 .NET Framework 4.6 incluye una nueva característica de seguridad que bloquea el cifrado inseguro y algoritmos para las conexiones de hash. Las aplicaciones mediante TLS/SSL a través de las API como HttpClient, HttpWebRequest, FTPClient, SmtpClient, SslStream, etc. y dirigidas a .NET Framework 4.6 obtener el comportamiento más seguras de forma predeterminada.  
  
 Los desarrolladores que desee deshabilitar este comportamiento para mantener la compatibilidad con sus servicios SSL3 existentes o TLS con servicios de RC4. [En este artículo](https://support.microsoft.com/kb/3069494) explica cómo modificar el código para que el nuevo comportamiento está deshabilitado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Net.HttpWebRequest> para el URI http://www.contoso.com/.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">Para obtener acceso al URI solicitado o cualquier URI que se redirige la solicitud. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
    <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (configuración de red)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Cambios en la autenticación NTLM para HTTPWebRequest en la versión 3.5 SP1</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.HttpWebRequest" />. Estos constructores están obsoletos; vea la sección Comentarios para obtener más información.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Ambos <xref:System.Net.HttpWebRequest> constructores están obsoletos y no debe usarse. Llame a la <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType> método para inicializar nuevas <xref:System.Net.HttpWebRequest> objetos.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.HttpWebRequest" />. Este constructor está obsoleto.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : Uri -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest uri" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene la información requerida para serializar el nuevo objeto <see cref="T:System.Net.HttpWebRequest" />.</param>
        <param name="streamingContext">Objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene el origen y el destino de la secuencia serializada asociada al nuevo objeto <see cref="T:System.Net.HttpWebRequest" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.HttpWebRequest" /> desde las instancias especificadas de las clases <see cref="T:System.Runtime.Serialization.SerializationInfo" /> y <see cref="T:System.Runtime.Serialization.StreamingContext" />. Este constructor está obsoleto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una aplicación debe ejecutarse en modo de plena confianza al utilizar la serialización.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Para obtener acceso sin restricciones a los recursos de red. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Serialización de SOAP y XML</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="httpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancela una solicitud de un recurso de Internet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.Abort%2A> método cancela una solicitud a un recurso. Después de cancela una solicitud, una llamada a la <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, o <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> método causas un <xref:System.Net.WebException> con el <xref:System.Net.WebException.Status%2A> propiedad establecida en <xref:System.Net.WebExceptionStatus.RequestCanceled>.  
  
 El <xref:System.Net.HttpWebRequest.Abort%2A> método sincrónicamente ejecutará la devolución de llamada especificada para el <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> métodos si el <xref:System.Net.HttpWebRequest.Abort%2A> se llama al método mientras cualquiera de estas operaciones están pendiente. Esto puede causar problemas de interbloqueo potencial.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [Network Tracing](https://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 En el caso de las solicitudes asincrónicas, es responsabilidad de la aplicación cliente para implementar su propio mecanismo de tiempo de espera. El ejemplo de código siguiente muestra cómo hacerlo.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Accept : string with get, set" Usage="System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor del encabezado HTTP <see langword="Accept" />.</summary>
        <value>Valor del encabezado HTTP <see langword="Accept" />. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para borrar el `Accept` encabezado HTTP, establezca el <xref:System.Net.HttpWebRequest.Accept%2A> propiedad `null`.  
  
> [!NOTE]
>  El valor de esta propiedad se almacena en <xref:System.Net.WebHeaderCollection>. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.Accept%2A> propiedad.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega un encabezado de intervalo a la solicitud.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dado que todas las entidades HTTP se representan en los mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Los servidores no tienen que admitir solicitudes de encabezado de intervalo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">Punto inicial o final del intervalo.</param>
        <summary>Agrega un encabezado de intervalo de bytes a una solicitud de un intervalo específico desde el principio o el final de los datos solicitados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método agrega un encabezado de intervalo de bytes a la solicitud.  
  
 Si `range` es positivo, el `range` parámetro especifica el punto inicial del intervalo. El servidor debería empezar a enviar datos desde el `range` los parámetros especificados al final de los datos de la entidad HTTP.  
  
 Si `range` es negativo, el `range` parámetro especifica el punto final del intervalo. El servidor debería empezar a enviar datos desde el principio de los datos de la entidad HTTP en el `range` los parámetros especificados.  
  
 Dado que todas las entidades HTTP se representan en los mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Los servidores no tienen que admitir solicitudes de encabezado de intervalo.  
  
 Un ejemplo de un encabezado de intervalo en una solicitud de protocolo HTTP que solicita al servidor que envíe los primeros 100 bytes (desde el principio hasta la posición del byte 99) sería la siguiente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 En este ejemplo, el `range` parámetro sería -99.  
  
 Un servidor HTTP indica compatibilidad para encabezados de intervalo con el encabezado Accept-Ranges. Un ejemplo del encabezado Accept-Ranges desde un servidor que admite intervalos de bytes sería como sigue:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si no se recibe un encabezado Accept-Ranges en el encabezado de la respuesta del servidor, el servidor no admite los encabezados de intervalo. Un ejemplo del encabezado Accept-Ranges desde un servidor que no admite intervalos, pero que reconoce el encabezado Accept-Ranges, sería como sigue:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Al recibir la respuesta de una solicitud de intervalo, solo los encabezados HTTP asociados a la solicitud completa se puede analizar y están disponibles a través de las propiedades de la <xref:System.Net.HttpWebResponse> clase. Encabezados asociados con cada intervalo se devuelven en la respuesta.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se agrega un encabezado de intervalo a la solicitud.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">No se pudo agregar el encabezado de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">Punto inicial o final del intervalo.</param>
        <summary>Agrega un encabezado de intervalo de bytes a una solicitud de un intervalo específico desde el principio o el final de los datos solicitados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método agrega un encabezado de intervalo de bytes a la solicitud.  
  
 Si `range` es positivo, el `range` parámetro especifica el punto inicial del intervalo. El servidor debería empezar a enviar datos desde el `range` los parámetros especificados al final de los datos de la entidad HTTP.  
  
 Si `range` es negativo, el `range` parámetro especifica el punto final del intervalo. El servidor debería empezar a enviar datos desde el principio de los datos de la entidad HTTP en el `range` los parámetros especificados.  
  
 Dado que todas las entidades HTTP se representan en los mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Los servidores no tienen que admitir solicitudes de encabezado de intervalo.  
  
 Un ejemplo de un encabezado de intervalo en una solicitud de protocolo HTTP que solicita al servidor que envíe los primeros 100 bytes (desde el principio hasta la posición del byte 99) sería la siguiente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 En este ejemplo, el `range` parámetro sería -99.  
  
 Un servidor HTTP indica compatibilidad para encabezados de intervalo con el encabezado Accept-Ranges. Un ejemplo del encabezado Accept-Ranges desde un servidor que admite intervalos de bytes sería como sigue:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si no se recibe un encabezado Accept-Ranges en el encabezado de la respuesta del servidor, el servidor no admite los encabezados de intervalo. Un ejemplo del encabezado Accept-Ranges desde un servidor que no admite intervalos, pero que reconoce el encabezado Accept-Ranges, sería como sigue:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Al recibir la respuesta de una solicitud de intervalo, solo los encabezados HTTP asociados a la solicitud completa se puede analizar y están disponibles a través de las propiedades de la <xref:System.Net.HttpWebResponse> clase. Encabezados asociados con cada intervalo se devuelven en la respuesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">No se pudo agregar el encabezado de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int * int -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">Posición en la que se va a empezar a enviar datos.</param>
        <param name="to">Posición en la que se va a terminar de enviar datos.</param>
        <summary>Agrega un encabezado de intervalo de bytes a la solicitud de un intervalo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método agrega un encabezado de intervalo de bytes a la solicitud.  
  
 Dado que todas las entidades HTTP se representan en los mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Los servidores no tienen que admitir solicitudes de encabezado de intervalo.  
  
 Un ejemplo de un encabezado de intervalo en una solicitud de protocolo HTTP que serían las solicitudes de los primeros 100 bytes sería el siguiente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 En este ejemplo, el `from` parámetro se especifica como 0 y el `to` parámetro se especificaría como 99. El especificador de intervalo se establece automáticamente como "bytes" por este método.  
  
 Un servidor HTTP indica compatibilidad para encabezados de intervalo con el encabezado Accept-Ranges. Un ejemplo del encabezado Accept-Ranges desde un servidor que admite intervalos de bytes sería como sigue:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si no se recibe un encabezado Accept-Ranges en el encabezado de la respuesta del servidor, el servidor no admite los encabezados de intervalo. Un ejemplo del encabezado Accept-Ranges desde un servidor que no admite intervalos, pero que reconoce el encabezado Accept-Ranges, sería como sigue:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Al recibir la respuesta de una solicitud de intervalo, solo los encabezados HTTP asociados a la solicitud completa se puede analizar y están disponibles a través de las propiedades de la <xref:System.Net.HttpWebResponse> clase. Encabezados asociados con cada intervalo se devuelven en la respuesta.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se agrega un encabezado de intervalo a la solicitud.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> no es válido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> es mayor que <paramref name="to" />.  
  
O bien 
 <paramref name="from" /> o <paramref name="to" /> es menor que 0.</exception>
        <exception cref="T:System.InvalidOperationException">No se pudo agregar el encabezado de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">Posición en la que se va a empezar a enviar datos.</param>
        <param name="to">Posición en la que se va a terminar de enviar datos.</param>
        <summary>Agrega un encabezado de intervalo de bytes a la solicitud de un intervalo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método agrega un encabezado de intervalo de bytes a la solicitud.  
  
 Dado que todas las entidades HTTP se representan en los mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Los servidores no tienen que admitir solicitudes de encabezado de intervalo.  
  
 Un ejemplo de un encabezado de intervalo en una solicitud de protocolo HTTP que serían las solicitudes de los primeros 100 bytes sería el siguiente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 En este ejemplo, el `from` parámetro se especifica como 0 y el `to` parámetro se especificaría como 99. El especificador de intervalo se establece automáticamente como "bytes" por este método.  
  
 Un servidor HTTP indica compatibilidad para encabezados de intervalo con el encabezado Accept-Ranges. Un ejemplo del encabezado Accept-Ranges desde un servidor que admite intervalos de bytes sería como sigue:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si no se recibe un encabezado Accept-Ranges en el encabezado de la respuesta del servidor, el servidor no admite los encabezados de intervalo. Un ejemplo del encabezado Accept-Ranges desde un servidor que no admite intervalos, pero que reconoce el encabezado Accept-Ranges, sería como sigue:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Al recibir la respuesta de una solicitud de intervalo, solo los encabezados HTTP asociados a la solicitud completa se puede analizar y están disponibles a través de las propiedades de la <xref:System.Net.HttpWebResponse> clase. Encabezados asociados con cada intervalo se devuelven en la respuesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> no es válido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> es mayor que <paramref name="to" />.  
  
O bien 
 <paramref name="from" /> o <paramref name="to" /> es menor que 0.</exception>
        <exception cref="T:System.InvalidOperationException">No se pudo agregar el encabezado de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Descripción del intervalo.</param>
        <param name="range">Punto inicial o final del intervalo.</param>
        <summary>Agrega un encabezado Range a una solicitud de un intervalo específico del principio o del final de los datos solicitados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método agrega un encabezado de intervalo a la solicitud.  
  
 Si `range` es positivo, el `range` parámetro especifica el punto inicial del intervalo. El servidor debería empezar a enviar datos desde el `range` los parámetros especificados al final de los datos de la entidad HTTP.  
  
 Si `range` es negativo, el `range` parámetro especifica el punto final del intervalo. El servidor debería empezar a enviar datos desde el principio de los datos de la entidad HTTP en el `range` los parámetros especificados.  
  
 Dado que todas las entidades HTTP se representan en los mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Los servidores no tienen que admitir solicitudes de encabezado de intervalo.  
  
 El `rangeSpecifier` parámetro normalmente se especificaría como "bytes", puesto que es el único especificador de intervalo reconocido por la mayoría de los servidores HTTP. Establecer el `rangeSpecifier` parámetro a alguna otra cadena permite la compatibilidad con los especificadores de intervalo personalizado que no sea de bytes (el especificador de intervalo de bytes definido en RFC 2616 por el IETF).  
  
 Un ejemplo de un encabezado de intervalo en una solicitud de protocolo HTTP que serían las solicitudes de los primeros 100 bytes sería el siguiente:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 En este ejemplo, el `rangeSpecifier` parámetro se especificaría como "bytes" y el `range` parámetro sería -99.  
  
 Un servidor HTTP indica compatibilidad para encabezados de intervalo con el encabezado Accept-Ranges en la respuesta. Un ejemplo del encabezado Accept-Ranges desde un servidor que admite intervalos de bytes sería como sigue:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si no se recibe un encabezado Accept-Ranges en el encabezado de la respuesta del servidor, el servidor no admite los encabezados de intervalo. Un ejemplo del encabezado Accept-Ranges desde un servidor que no admite intervalos, pero que reconoce el encabezado Accept-Ranges, sería como sigue:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Al recibir la respuesta de una solicitud de intervalo, solo los encabezados HTTP asociados a la solicitud completa se puede analizar y están disponibles a través de las propiedades de la <xref:System.Net.HttpWebResponse> clase. Encabezados asociados con cada intervalo se devuelven en la respuesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rangeSpecifier" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">No se pudo agregar el encabezado de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Descripción del intervalo.</param>
        <param name="range">Punto inicial o final del intervalo.</param>
        <summary>Agrega un encabezado Range a una solicitud de un intervalo específico del principio o del final de los datos solicitados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método agrega un encabezado de intervalo a la solicitud.  
  
 Si `range` es positivo, el `range` parámetro especifica el punto inicial del intervalo. El servidor debería empezar a enviar datos desde el `range` los parámetros especificados al final de los datos de la entidad HTTP.  
  
 Si `range` es negativo, el `range` parámetro especifica el punto final del intervalo. El servidor debería empezar a enviar datos desde el principio de los datos de la entidad HTTP en el `range` los parámetros especificados.  
  
 Dado que todas las entidades HTTP se representan en los mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Los servidores no tienen que admitir solicitudes de encabezado de intervalo.  
  
 El `rangeSpecifier` parámetro normalmente se especificaría como "bytes", puesto que es el único especificador de intervalo reconocido por la mayoría de los servidores HTTP. Establecer el `rangeSpecifier` parámetro a alguna otra cadena permite la compatibilidad con los especificadores de intervalo personalizado que no sea de bytes (el especificador de intervalo de bytes definido en RFC 2616 por el IETF).  
  
 Un ejemplo de un encabezado de intervalo en una solicitud de protocolo HTTP que serían las solicitudes de los primeros 100 bytes sería el siguiente:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 En este ejemplo, el `rangeSpecifier` parámetro se especificaría como "bytes" y el `range` parámetro sería -99.  
  
 Un servidor HTTP indica compatibilidad para encabezados de intervalo con el encabezado Accept-Ranges en la respuesta. Un ejemplo del encabezado Accept-Ranges desde un servidor que admite intervalos de bytes sería como sigue:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si no se recibe un encabezado Accept-Ranges en el encabezado de la respuesta del servidor, el servidor no admite los encabezados de intervalo. Un ejemplo del encabezado Accept-Ranges desde un servidor que no admite intervalos, pero que reconoce el encabezado Accept-Ranges, sería como sigue:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Al recibir la respuesta de una solicitud de intervalo, solo los encabezados HTTP asociados a la solicitud completa se puede analizar y están disponibles a través de las propiedades de la <xref:System.Net.HttpWebResponse> clase. Encabezados asociados con cada intervalo se devuelven en la respuesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rangeSpecifier" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">No se pudo agregar el encabezado de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Descripción del intervalo.</param>
        <param name="from">Posición en la que se va a empezar a enviar datos.</param>
        <param name="to">Posición en la que se va a terminar de enviar datos.</param>
        <summary>Agrega un encabezado de intervalo a una solicitud de un intervalo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método agrega un encabezado de intervalo a la solicitud.  
  
 Dado que todas las entidades HTTP se representan en los mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Los servidores no tienen que admitir solicitudes de encabezado de intervalo.  
  
 El `rangeSpecifier` parámetro normalmente se especificaría como "bytes", puesto que es el único especificador de intervalo reconocido por la mayoría de los servidores HTTP. Establecer el `rangeSpecifier` parámetro a alguna otra cadena permite la compatibilidad con los especificadores de intervalo personalizado que no sea de bytes (el especificador de intervalo de bytes definido en RFC 2616 por el IETF).  
  
 Un ejemplo de un encabezado de intervalo en una solicitud de protocolo HTTP que serían las solicitudes de los primeros 100 bytes sería el siguiente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 En este ejemplo, el `rangeSpecifier` parámetro se especificaría como "bytes", la `from` parámetro sería 0 y el `to` parámetro sería 99.  
  
 Un servidor HTTP indica compatibilidad para encabezados de intervalo con el encabezado Accept-Ranges en la respuesta. Un ejemplo del encabezado Accept-Ranges desde un servidor que admite intervalos de bytes sería como sigue:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 La cadena especificada en el encabezado Accept-Ranges es el especificador de rango que se especificarían por en el `rangeSpecifier` parámetro para este método.  
  
 Si no se recibe un encabezado Accept-Ranges en el encabezado de la respuesta del servidor, el servidor no admite los encabezados de intervalo. Un ejemplo del encabezado Accept-Ranges desde un servidor que no admite intervalos, pero que reconoce el encabezado Accept-Ranges, sería como sigue:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Al recibir la respuesta de una solicitud de intervalo, solo los encabezados HTTP asociados a la solicitud completa se puede analizar y están disponibles a través de las propiedades de la <xref:System.Net.HttpWebResponse> clase. Encabezados asociados con cada intervalo se devuelven en la respuesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rangeSpecifier" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> es mayor que <paramref name="to" />.  
  
O bien 
 <paramref name="from" /> o <paramref name="to" /> es menor que 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">No se pudo agregar el encabezado de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Descripción del intervalo.</param>
        <param name="from">Posición en la que se va a empezar a enviar datos.</param>
        <param name="to">Posición en la que se va a terminar de enviar datos.</param>
        <summary>Agrega un encabezado de intervalo a una solicitud de un intervalo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método agrega un encabezado de intervalo a la solicitud.  
  
 Dado que todas las entidades HTTP se representan en los mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Los servidores no tienen que admitir solicitudes de encabezado de intervalo.  
  
 El `rangeSpecifier` parámetro normalmente se especificaría como "bytes", puesto que es el único especificador de intervalo reconocido por la mayoría de los servidores HTTP. Establecer el `rangeSpecifier` parámetro a alguna otra cadena permite la compatibilidad con los especificadores de intervalo personalizado que no sea de bytes (el especificador de intervalo de bytes definido en RFC 2616 por el IETF).  
  
 Un ejemplo de un encabezado de intervalo en una solicitud de protocolo HTTP que serían las solicitudes de los primeros 100 bytes sería el siguiente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 En este ejemplo, el `rangeSpecifier` parámetro se especificaría como "bytes", la `from` parámetro sería 0 y el `to` parámetro sería 99.  
  
 Un servidor HTTP indica compatibilidad para encabezados de intervalo con el encabezado Accept-Ranges en la respuesta. Un ejemplo del encabezado Accept-Ranges desde un servidor que admite intervalos de bytes sería como sigue:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 La cadena especificada en el encabezado Accept-Ranges es el especificador de rango que se especificarían por en el `rangeSpecifier` parámetro para este método.  
  
 Si no se recibe un encabezado Accept-Ranges en el encabezado de la respuesta del servidor, el servidor no admite los encabezados de intervalo. Un ejemplo del encabezado Accept-Ranges desde un servidor que no admite intervalos, pero que reconoce el encabezado Accept-Ranges, sería como sigue:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Al recibir la respuesta de una solicitud de intervalo, solo los encabezados HTTP asociados a la solicitud completa se puede analizar y están disponibles a través de las propiedades de la <xref:System.Net.HttpWebResponse> clase. Encabezados asociados con cada intervalo se devuelven en la respuesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rangeSpecifier" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> es mayor que <paramref name="to" />.  
  
O bien 
 <paramref name="from" /> o <paramref name="to" /> es menor que 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">No se pudo agregar el encabezado de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri" Usage="System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador URI del recurso de Internet que respondió realmente a la solicitud.</summary>
        <value><see cref="T:System.Uri" /> que identifica el recurso de Internet que responde realmente a la solicitud. El valor predeterminado es el identificador URI utilizado por el método <see cref="M:System.Net.WebRequest.Create(System.String)" /> para inicializar la solicitud.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.Address%2A> propiedad está establecida en el URI una vez completados los redireccionamientos que se producen durante la solicitud.  
  
 El URI de la solicitud original se mantiene en el <xref:System.Net.HttpWebRequest.RequestUri%2A> propiedad.  
  
   
  
## Examples  
 El siguiente código de ejemplo comprueba si el <xref:System.Net.HttpWebRequest> objeto `req` se ha redirigido a otra ubicación para atender la solicitud y establece el valor de la `hasChanged` variable `true` si la solicitud se redirigió; encasocontrario`hasChanged`está establecido en `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la solicitud debe seguir las respuestas de redirección.</summary>
        <value><see langword="true" /> si la solicitud debe seguir automáticamente las respuestas de redirección recibidas del recurso de Internet; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> a `true` si desea que la solicitud siga automáticamente los encabezados de redireccionamiento de HTTP a la nueva ubicación del recurso. Establece el número máximo de redirecciones que se va a seguir el <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> propiedad.  
  
 Si <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> está establecido en `false`, todas las respuestas con un código de estado HTTP entre 300 y 399 se devuelve a la aplicación.  
  
 El encabezado de autorización está desactivado en redirecciones automáticas y <xref:System.Net.HttpWebRequest> intenta automáticamente volver a autenticarse en la ubicación redirigida. En la práctica, esto significa que una aplicación no puede poner la información de autenticación personalizada en el encabezado de autorización si es posible encontrar redirección. En su lugar, la aplicación debe implementar y registrar un módulo de autenticación personalizado. El <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> y la clase relacionada se usan para implementar un módulo de autenticación personalizado. El <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> método registra un módulo de autenticación personalizado.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> propiedad para permitir que la solicitud para seguir las respuestas de redirección.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowReadStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si los datos recibidos del recurso de Internet deben almacenarse en el búfer.</summary>
        <value><see langword="true" /> para habilitar el almacenamiento en búfer de los datos recibidos del recurso de Internet; <see langword="false" /> para deshabilitar el almacenamiento en búfer. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowWriteStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se deben almacenar en el búfer los datos enviados al recurso de Internet.</summary>
        <value><see langword="true" /> para habilitar el almacenamiento de los datos enviados al recurso de Internet en el búfer; <see langword="false" /> para deshabilitar el almacenamiento en el búfer. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> es `true`, los datos se almacena en búfer en memoria para que esté listo para ser reenviados en el caso de las redirecciones o la autenticación de solicitudes.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> propiedad para deshabilitar el almacenamiento en búfer de datos.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Establecer <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> a <see langword="true" /> podría causar problemas de rendimiento al cargar grandes conjuntos de datos, ya que el búfer de datos podría usar toda la memoria disponible.</para></block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tipo de descompresión que se utiliza.</summary>
        <value>Un <see cref="T:System.Net.DecompressionMethods" /> objeto que indica el tipo de descompresión que se utiliza.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">El estado del objeto actual no permite establecer esta propiedad.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objeto de estado de esta solicitud.</param>
        <summary>Inicia una solicitud asincrónica de un objeto <see cref="T:System.IO.Stream" /> que se va a utilizar para escribir datos.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia a la solicitud asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método inicia una solicitud asincrónica de una secuencia utilizada para enviar datos para el <xref:System.Net.HttpWebRequest>. El método de devolución de llamada asincrónico usa la <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> método para devolver la secuencia real.  
  
 El <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método requiere algunas tareas de configuración sincrónico para completar (resolución de DNS, la detección de proxy y conexión de socket TCP, por ejemplo) antes de que este método se convierte en asincrónica. Como resultado, este método nunca se debería llamar en un subproceso de interfaz de usuario porque puede tardar un tiempo considerable (hasta varios minutos, según la configuración de red) para completar las tareas de configuración inicial de sincrónica antes de una excepción para que se produce un error o el método tiene éxito.  
  
 Para obtener más información sobre el grupo de subprocesos, vea [el grupo de subprocesos administrados](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  La aplicación no puede mezclar métodos sincrónicos y asincrónicos para una solicitud determinada. Si se llama a la <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método, debe usar el <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método para recuperar la respuesta.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método para realizar una solicitud asincrónica de una instancia de la secuencia.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">La propiedad <see cref="P:System.Net.HttpWebRequest.Method" /> es GET o HEAD.  
  
O bien 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> es <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> es <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> es -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> es <see langword="false" /> y <see cref="P:System.Net.HttpWebRequest.Method" /> es POST o PUT.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia ya la está usando una llamada anterior a <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.  
  
O bien 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> se establece en un valor y <see cref="P:System.Net.HttpWebRequest.SendChunked" /> es <see langword="false" />.  
  
O bien 
El grupo de subprocesos se está quedando sin subprocesos.</exception>
        <exception cref="T:System.NotSupportedException">El validador de caché de solicitud indicó que la respuesta para esta solicitud se puede atender desde la memoria caché; sin embargo, las solicitudes que escriben datos no deben usar la caché. Esta excepción puede producirse si usa un validador de caché personalizado que se implementa incorrectamente.</exception>
        <exception cref="T:System.Net.WebException">Se llamó a <see cref="M:System.Net.HttpWebRequest.Abort" /> anteriormente.</exception>
        <exception cref="T:System.ObjectDisposedException">En una aplicación de .NET Compact Framework, no se obtuvo una secuencia de solicitud con longitud de contenido cero y se cerró correctamente. Para más información sobre cómo controlar solicitudes de longitud de contenido cero, vea [Programación para redes en .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (configuración de red)</related>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objeto de estado de esta solicitud.</param>
        <summary>Inicia una solicitud asincrónica de un recurso de Internet.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia a la solicitud asincrónica de una respuesta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método inicia una solicitud asincrónica de una respuesta del recurso de Internet. El método de devolución de llamada asincrónico usa la <xref:System.Net.HttpWebRequest.EndGetResponse%2A> método para devolver los datos reales <xref:System.Net.WebResponse>.  
  
 Un <xref:System.Net.ProtocolViolationException> se produce en varios casos cuando las propiedades se establecen en el <xref:System.Net.HttpWebRequest> clase están en conflicto. Esta excepción se produce si una aplicación establece el <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad y el <xref:System.Net.HttpWebRequest.SendChunked%2A> propiedad `true`y, a continuación, envía una solicitud HTTP GET. Esta excepción se produce si una aplicación intenta enviar bloques a un servidor que sólo admite el protocolo HTTP 1.0, donde no se admite. Esta excepción se produce si una aplicación intenta enviar datos sin establecer el <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad o el <xref:System.Net.HttpWebRequest.SendChunked%2A> es `false` cuando está deshabilitado el almacenamiento en búfer y en una conexión Keep-Alive (la <xref:System.Net.HttpWebRequest.KeepAlive%2A> propiedad es `true`)`.`  
  
 Si un <xref:System.Net.WebException> es produce, utilice el <xref:System.Net.WebException.Response%2A> y <xref:System.Net.WebException.Status%2A> propiedades de la excepción para determinar la respuesta del servidor.  
  
 El <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método requiere algunas tareas de configuración sincrónico para completar (resolución de DNS, la detección de proxy y conexión de socket TCP, por ejemplo) antes de que este método se convierte en asincrónica. Como resultado, este método nunca se debería llamar en un subproceso de interfaz de usuario porque puede tardar un tiempo considerable (hasta varios minutos, según la configuración de red) para completar las tareas de configuración inicial de sincrónica antes de una excepción para que se produce un error o el método tiene éxito.  
  
 Para obtener más información sobre el grupo de subprocesos, vea [el grupo de subprocesos administrados](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  La aplicación no puede mezclar métodos sincrónicos y asincrónicos para una solicitud determinada. Si se llama a la <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método, debe usar el <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método para recuperar la respuesta.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [ &#91; \<topic://conUsingNetworkTracing >&#93;](https://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método para realizar una solicitud asincrónica de un recurso de Internet.  
  
> [!NOTE]
>  En el caso de las solicitudes asincrónicas, es responsabilidad de la aplicación cliente para implementar su propio mecanismo de tiempo de espera. El ejemplo de código siguiente muestra cómo hacerlo.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La secuencia ya la está usando una llamada anterior a <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  
  
O bien 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> se establece en un valor y <see cref="P:System.Net.HttpWebRequest.SendChunked" /> es <see langword="false" />.  
  
O bien 
El grupo de subprocesos se está quedando sin subprocesos.</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> es GET o HEAD y <see cref="P:System.Net.HttpWebRequest.ContentLength" /> es mayor o igual que cero o <see cref="P:System.Net.HttpWebRequest.SendChunked" /> es <see langword="true" />.  
  
O bien 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> es <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> es <see langword="false" /> y <see cref="P:System.Net.HttpWebRequest.ContentLength" /> es -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> es <see langword="false" /> y <see cref="P:System.Net.HttpWebRequest.Method" /> es POST o PUT.  
  
O bien 
La <see cref="T:System.Net.HttpWebRequest" /> tiene un cuerpo de entidad, pero el método <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> se invoca sin llamar al método <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.  
  
O bien 
<see cref="P:System.Net.HttpWebRequest.ContentLength" /> es mayor que cero, pero la aplicación no escribe todos los datos prometidos.</exception>
        <exception cref="T:System.Net.WebException">Se llamó a <see cref="M:System.Net.HttpWebRequest.Abort" /> anteriormente.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (configuración de red)</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.HttpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la colección de certificados de seguridad asociados a esta solicitud.</summary>
        <value><see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> que contiene los certificados de seguridad asociados a esta solicitud.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una aplicación puede agregar un certificado a una colección, pero podría no tener derechos de acceso a él. Para usar un certificado incluido en la colección, la aplicación debe tener los mismos derechos de acceso que la entidad que emitió el certificado.  
  
> [!NOTE]
>  El marco de trabajo se almacena en caché las sesiones SSL cuando se crean y se intenta reutilizar una sesión almacenada en caché para una nueva solicitud, si es posible. Al intentar reutilizar una sesión SSL, el marco de trabajo usa el primer elemento de <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (si hay alguno), o intenta reutilizar una sesión anónima si <xref:System.Net.HttpWebRequest.ClientCertificates%2A> está vacío.  
  
> [!NOTE]
>  Por motivos de rendimiento, no debe agregar un certificado de cliente a un <xref:System.Net.HttpWebRequest> a menos que sepa que se le solicitará el servidor.  
>   
>  Para obtener un ejemplo de código que ilustra cómo enumerar los certificados en el almacén de certificados de cliente, consulte el <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor especificado para una operación Set es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Connection : string with get, set" Usage="System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor del encabezado HTTP <see langword="Connection" />.</summary>
        <value>Valor del encabezado HTTP <see langword="Connection" />. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La solicitud se envía el <xref:System.Net.HttpWebRequest.Connection%2A> propiedad al recurso de Internet como el `Connection` encabezado HTTP. Si el valor de la <xref:System.Net.HttpWebRequest.KeepAlive%2A> propiedad es `true`, el valor "Keep-alive" se anexa al final de la `Connection` encabezado.  
  
 Para borrar el `Connection` encabezado HTTP, establezca el <xref:System.Net.HttpWebRequest.Connection%2A> propiedad `null`.  
  
 Cambiar el <xref:System.Net.HttpWebRequest.Connection%2A> propiedad una vez iniciada la solicitud mediante una llamada a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método produce una <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  El valor de esta propiedad se almacena en <xref:System.Net.WebHeaderCollection>. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.Connection%2A> propiedad para establecer el valor del encabezado HTTP de conexión.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <see cref="P:System.Net.HttpWebRequest.Connection" /> se establece en Mantener conexión o Cerrar.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del grupo de conexiones para la solicitud.</summary>
        <value>Nombre del grupo de conexiones para esta solicitud. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> propiedad le permite asociar una solicitud a un grupo de conexiones. Esto es útil cuando la aplicación realiza solicitudes a un servidor para usuarios diferentes, como un sitio Web que recupera información del cliente de un servidor de base de datos.  
  
   
  
## Examples  
 El ejemplo de código siguientes muestran cómo usar la información de usuario para formar un grupo de conexiones, suponiendo que las variables `username`, `password`, y `domain` establecidos por la aplicación antes de llama a este código.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cada grupo de conexiones crea conexiones adicionales para un servidor. Esto puede producir si se supera el número de conexiones establecidas por el <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> propiedad para ese servidor.</para></block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
        <related type="Article" href="~/docs/framework/network-programming/connection-grouping.md">Agrupación de conexiones</related>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el encabezado HTTP <see langword="Content-length" />.</summary>
        <value>Número de bytes de los datos enviados al recurso de Internet. El valor predeterminado es -1, que indica que no se estableció el valor de la propiedad y no hay datos de solicitud para enviar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad contiene el valor que se envían como el `Content-length` encabezado HTTP con la solicitud.  
  
 Cualquier valor distinto de -1 en el <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad indica que la solicitud de carga los datos y que se permiten solo los métodos que cargan datos debe establecerse el <xref:System.Net.HttpWebRequest.Method%2A> propiedad.  
  
 Después de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad se establece en un valor, ese número de bytes debe escribirse en la secuencia de solicitud que se devuelve mediante una llamada a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método o ambos el <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> y <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> métodos.  
  
> [!NOTE]
>  El valor de esta propiedad se almacena en <xref:System.Net.WebHeaderCollection>. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad a la longitud de la cadena que se va a registrar.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La solicitud se ha iniciado mediante la llamada al método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> o <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El nuevo valor de <see cref="P:System.Net.HttpWebRequest.ContentLength" /> es menor que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor del encabezado HTTP <see langword="Content-type" />.</summary>
        <value>Valor del encabezado HTTP <see langword="Content-type" />. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.ContentType%2A> propiedad contiene el tipo de medio de la solicitud. Los valores asignados a la <xref:System.Net.HttpWebRequest.ContentType%2A> propiedad reemplazan cualquier contenido existente cuando la solicitud se envía el `Content-type` encabezado HTTP.  
  
 Para borrar el `Content-type` encabezado HTTP, establezca el <xref:System.Net.HttpWebRequest.ContentType%2A> propiedad `null`.  
  
> [!NOTE]
>  El valor de esta propiedad se almacena en <xref:System.Net.WebHeaderCollection> . Si <xref:System.Net.WebHeaderCollection> está establecido, se pierde el valor de propiedad.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.ContentType%2A> propiedad.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueDelegate : System.Net.HttpContinueDelegate with get, set" Usage="System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el método de delegado al que se llama cuando se recibe una respuesta HTTP 100-continue desde el recurso de Internet.</summary>
        <value>Delegado que implementa el método de devolución de llamada que se ejecuta cuando se devuelve una respuesta HTTP Continue desde el recurso de Internet. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> propiedad especifica el método de devolución de llamada debe llamar cuando el cliente recibe 100-continuar la respuesta.  
  
 Cuando el <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> propiedad está establecida, el cliente llama al delegado siempre que las respuestas de tipo de protocolo <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) se reciben. Esto es útil si desea que el cliente para mostrar el estado de los datos recibidos del recurso de Internet.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tiempo de espera, en milisegundos, para esperar hasta que se reciba 100-Continue del servidor.</summary>
        <value>El tiempo de espera, en milisegundos, que se espera hasta que se recibe 100-Continue.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si los 100-continuar se recibe respuesta antes de que expire el tiempo de espera, se puede enviar el cuerpo de entidad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.HttpWebRequest.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece las cookies asociadas a la solicitud.</summary>
        <value><see cref="T:System.Net.CookieContainer" /> que contiene las cookies asociadas a esta solicitud.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.CookieContainer%2A> propiedad proporciona una instancia de la <xref:System.Net.CookieContainer> clase que contiene las cookies asociadas con esta solicitud.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> es `null` de forma predeterminada. Debe asignar un <xref:System.Net.CookieContainer> objeto a la propiedad para tener las cookies devueltas en el <xref:System.Net.HttpWebResponse.Cookies%2A> propiedad de la <xref:System.Net.HttpWebResponse> devuelto por la <xref:System.Net.HttpWebRequest.GetResponse%2A> método.  
  
> [!NOTE]
>  Por motivos de seguridad, las cookies están deshabilitadas de forma predeterminada. Si desea utilizar cookies, utilice el <xref:System.Net.HttpWebRequest.CookieContainer%2A> propiedad para permitir las cookies.  
  
   
  
## Examples  
 El siguiente ejemplo de código envía una solicitud a una dirección URL y muestra las cookies devueltas en la respuesta.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la información de autenticación para la solicitud.</summary>
        <value><see cref="T:System.Net.ICredentials" /> que contiene las credenciales de autenticación asociadas a la solicitud. De manera predeterminada, es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.Credentials%2A> propiedad contiene información de autenticación para identificar al creador de la solicitud. El <xref:System.Net.HttpWebRequest.Credentials%2A> propiedad puede ser un <xref:System.Net.NetworkCredential>, en qué caso el usuario, la contraseña y la información de dominio que contiene el <xref:System.Net.NetworkCredential> objeto se usa para autenticar la solicitud, o puede ser un <xref:System.Net.CredentialCache>, en cuyo caso el uniforme de recursos Identificador (URI) de la solicitud se usa para determinar el usuario, la contraseña y la información de dominio se utiliza para autenticar la solicitud.  
  
 En la mayoría de los escenarios de cliente, debe usar el <xref:System.Net.CredentialCache.DefaultCredentials%2A> propiedad, que contiene las credenciales del usuario que ha iniciado sesión actualmente. Para ello, establezca el <xref:System.Net.WebClient.UseDefaultCredentials%2A> propiedad `true` en lugar de establecer esta propiedad.  
  
 Si el <xref:System.Net.HttpWebRequest> clase se utiliza en una aplicación de nivel intermedio, como una aplicación de ASP.NET, las credenciales en el <xref:System.Net.CredentialCache.DefaultCredentials%2A> propiedad pertenece a la cuenta de ejecución de la página ASP (las credenciales del servidor). Normalmente, establecería esta propiedad en las credenciales del cliente en cuyo nombre se realiza la solicitud.  
  
> [!NOTE]
>  El esquema de autenticación NTLM no puede usarse para suplantar a otro usuario. Kerberos debe configurarse específicamente para admitir la suplantación.  
  
 Para restringir HttpWebRequest a uno o varios métodos de autenticación, utilice la <xref:System.Net.CredentialCache> clase y enlazar sus credenciales a uno o varios esquemas de autenticación  
  
 Esquemas de autenticación admitidos incluyen Digest, Negotiate, Kerberos, NTLM y Basic.  
  
 Por motivos de seguridad, al seguir automáticamente las redirecciones, almacene las credenciales que desea que se incluirán en la redirección en una <xref:System.Net.CredentialCache> y asignarlo a esta propiedad. Esta propiedad se establecerá automáticamente en `null` tras la redirección si contiene nada excepto un <xref:System.Net.CredentialCache>. Tener el valor de esta propiedad se establece automáticamente en `null` en dichas condiciones impide que las credenciales que se envían a cualquier destino imprevisto.
  
## Examples  
 El ejemplo de código siguiente establece las credenciales para una solicitud.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime with get, set" Usage="System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor del encabezado HTTP <see langword="Date" /> que se va a usar en una solicitud HTTP.</summary>
        <value>Valor del encabezado Date de la solicitud HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el encabezado de fecha es `null`, a continuación, el valor devuelto se establecerá en <xref:System.DateTime.MinValue?displayProperty=nameWithType>.  
  
 El <xref:System.Net.HttpWebRequest.Date%2A> propiedad es un estándar <xref:System.DateTime?displayProperty=nameWithType> objeto y puede contener un <xref:System.DateTimeKind?displayProperty=nameWithType> campo de <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, o <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Se puede establecer cualquier intervalo de tiempo cuando se usa el <xref:System.Net.HttpWebRequest.Date%2A> propiedad. Si <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> se establece o recupera, el <xref:System.Net.HttpWebRequest.Date%2A> propiedad se supone que <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (hora local).  
  
 Las clases en el <xref:System.Net> espacio de nombres siempre escriben el <xref:System.Net.HttpWebRequest.Date%2A> propiedad en la conexión durante la transmisión en formulario estándar utilizando el formato GMT (Utc).  
  
 Si el <xref:System.Net.HttpWebRequest.Date%2A> propiedad está establecida en <xref:System.DateTime.MinValue?displayProperty=nameWithType>, el `Date` se quita el encabezado HTTP de la <xref:System.Net.HttpWebRequest.Headers%2A> propiedad y el <xref:System.Net.WebHeaderCollection>.  
  
 Si el <xref:System.Net.HttpWebRequest.Date%2A> propiedad es <xref:System.DateTime.MinValue?displayProperty=nameWithType>, esto indica que el `Date` encabezado HTTP no está incluido en el <xref:System.Net.HttpWebRequest.Headers%2A> propiedad y el <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  El valor de esta propiedad se almacena en <xref:System.Net.WebHeaderCollection>. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  
  
 Si el <xref:System.Net.HttpWebRequest.Date%2A> está establecida y se realiza un intento para enviar un <xref:System.Net.HttpWebRequest> sin cuerpo, con un <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> producirá la <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, y <xref:System.Net.HttpWebRequest.EndGetResponse%2A> métodos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la directiva de caché predeterminada para esta solicitud.</summary>
        <value><see cref="T:System.Net.Cache.HttpRequestCachePolicy" /> que especifica la directiva de caché activa para esta solicitud cuando ninguna otra directiva es aplicable.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al establecer esta propiedad registra la directiva especificada para los esquemas HTTP y HTTPS. Esta directiva se usa para esta solicitud si:  
  
 No hay ningún <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> propiedad especificada para esta solicitud.  
  
O bien
  
 La configuración del equipo y aplicación archivos no se especifican una directiva de caché que se aplica para el identificador uniforme de recursos (URI) que se usa para crear esta solicitud.  
  
 La directiva de caché determina si el recurso solicitado puede realizarse desde una caché en lugar de enviar la solicitud al equipo host del recurso.  
  
 Una copia de un recurso solo se agrega a la memoria caché si la secuencia de respuesta para el recurso se recupera y leer hasta el final de la secuencia. Por lo que otra solicitud para el mismo recurso podría usar una copia en caché, según el nivel de directiva de caché para esta solicitud.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Para obtener acceso sin restricciones a los recursos de red. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumErrorResponseLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la longitud máxima predeterminada de una respuesta de error de HTTP.</summary>
        <value>Longitud máxima predeterminada de una respuesta de error de HTTP.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor es menor que 0 y no es igual a -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor predeterminado de la propiedad <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />.</summary>
        <value>Longitud, en kilobytes (1024 bytes), del valor máximo predeterminado para los encabezados de respuesta recibidos. El archivo de configuración predeterminado establece este valor en 64 kilobytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longitud del encabezado de respuesta había recibido de la línea de estado de respuesta y caracteres de control adicionales que se reciben como parte del protocolo HTTP. Un valor de-1 significa que se impone ningún límite en los encabezados de respuesta recibidos; un valor de 0 significa que no todas las solicitudes.  
  
 También se puede cambiar este valor en el archivo de configuración. El impacto de esta propiedad se puede invalidar estableciendo la <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propiedad en una instancia de la <xref:System.Net.HttpWebRequest> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor no es igual a -1 y es inferior a cero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Finaliza una solicitud asincrónica para utilizar un objeto <see cref="T:System.IO.Stream" /> para escribir datos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Solicitud pendiente de un flujo.</param>
        <summary>Finaliza una solicitud asincrónica para utilizar un objeto <see cref="T:System.IO.Stream" /> para escribir datos.</summary>
        <returns><see cref="T:System.IO.Stream" /> que se utiliza para escribir los datos de la solicitud.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> método completa una solicitud asincrónica de una secuencia que se inició con la <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método. Después de la <xref:System.IO.Stream> ha devuelto el objeto, puede enviar datos con el <xref:System.Net.HttpWebRequest> utilizando el <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> método.  
  
> [!NOTE]
>  Debe establecer el valor de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad antes de escribir datos en la secuencia.  
  
> [!CAUTION]
>  Debe llamar a la <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> para cerrar la secuencia y liberar la conexión para su reutilización. Error al cerrar la secuencia, la aplicación se quedará sin conexiones.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> método para finalizar una solicitud asincrónica de una instancia de secuencia.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">No se completó la solicitud y no hay ninguna secuencia disponible.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> no se devolvió por la instancia actual de una llamada a <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Este método se llamó previamente mediante <paramref name="asyncResult" /></exception>
        <exception cref="T:System.Net.WebException">Se llamó a <see cref="M:System.Net.HttpWebRequest.Abort" /> anteriormente.  
  
O bien 
Error al procesar la solicitud.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult *  -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, transportContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" />
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Solicitud pendiente de un flujo.</param>
        <param name="context"><see cref="T:System.Net.TransportContext" /> para <see cref="T:System.IO.Stream" />.</param>
        <param name="transportContext"><see cref="T:System.Net.TransportContext" /> para <see cref="T:System.IO.Stream" />.</param>
        <summary>Finaliza una solicitud asincrónica de un objeto <see cref="T:System.IO.Stream" /> que se va a usar para escribir los datos y genera el objeto <see cref="T:System.Net.TransportContext" /> asociado a la secuencia.</summary>
        <returns><see cref="T:System.IO.Stream" /> que se utiliza para escribir los datos de la solicitud.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> método completa una solicitud asincrónica de una secuencia que se inició con la <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método y salidas el <xref:System.Net.TransportContext> asociado a la secuencia. Después de la <xref:System.IO.Stream> ha devuelto el objeto, puede enviar datos con el <xref:System.Net.HttpWebRequest> utilizando el <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> método.  
  
 Algunas aplicaciones que usan la autenticación de Windows integrada con protección ampliada que deba poder consultar la capa de transporte utilizada por <xref:System.Net.HttpWebRequest> con el fin de recuperar el token de enlace de canal (CBT) del canal TLS subyacente. El <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método proporciona acceso a esta información para los métodos HTTP que tienen un cuerpo de solicitud (`POST` y `PUT` solicitudes). Esto solo es necesario si la aplicación está implementando su propia autenticación y necesita tener acceso a CBT.  
  
> [!NOTE]
>  Si una aplicación necesita establecer el valor de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad y, después, esto debe hacerse antes de recuperar la secuencia y escribir datos en él.  
  
> [!CAUTION]
>  Debe llamar a la <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> para cerrar la secuencia y liberar la conexión para su reutilización. Error al cerrar la secuencia, la aplicación se quedará sin conexiones.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> no fue devuelto por la instancia actual de una llamada a <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó previamente a este método mediante <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.IO.IOException">No se completó la solicitud y no hay ninguna secuencia disponible.</exception>
        <exception cref="T:System.Net.WebException">Se llamó a <see cref="M:System.Net.HttpWebRequest.Abort" /> anteriormente.  
  
O bien 
Error al procesar la solicitud.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="httpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Solicitud de una respuesta pendiente.</param>
        <summary>Finaliza una solicitud asincrónica de un recurso de Internet.</summary>
        <returns><see cref="T:System.Net.WebResponse" /> que contiene la respuesta del recurso de Internet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.EndGetResponse%2A> método completa una solicitud asincrónica de un recurso de Internet que se inició mediante una llamada a la <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método.  
  
> [!CAUTION]
>  Debe llamar a la <xref:System.Net.HttpWebResponse.Close%2A> para cerrar la secuencia y liberar la conexión. Si no lo hace puede hacer que la aplicación se quedará sin conexiones.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.EndGetResponse%2A> método para finalizar una solicitud asincrónica de un recurso de Internet.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Este método se llamó previamente mediante <paramref name="asyncResult." />  
  
O bien 
La propiedad <see cref="P:System.Net.HttpWebRequest.ContentLength" /> es mayor que 0 pero los datos no se han escrito en la secuencia de solicitud.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> se llamó previamente.  
  
O bien 
Error al procesar la solicitud.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> no fue devuelto por la instancia actual de una llamada a <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Expect : string with get, set" Usage="System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor del encabezado HTTP <see langword="Expect" />.</summary>
        <value>Contenido del encabezado HTTP <see langword="Expect" />. El valor predeterminado es <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 El valor de esta propiedad se almacena en <see cref="T:System.Net.WebHeaderCollection" />. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  
  
</para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><see langword="Expect" /> se establece en una cadena que contiene "100-continue" como subcadena.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (configuración de red)</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="httpWebRequest.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor hash para una instancia de <see cref="T:System.Net.WebRequest" />.</summary>
        <returns>Valor hash entero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
El método GetHashCode devuelve un código hash de la solicitud web. Este valor puede utilizarse como clave en las tablas hash.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="httpWebRequest.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> que se rellena con datos.</param>
        <param name="streamingContext"><see cref="T:System.Runtime.Serialization.StreamingContext" /> que especifica el destino de esta serialización.</param>
        <summary>Rellena <see cref="T:System.Runtime.Serialization.SerializationInfo" /> con los datos necesarios para serializar el objeto de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los objetos incluidos en el <xref:System.Runtime.Serialization.SerializationInfo> automáticamente se realiza un seguimiento y serializan el formateador.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.IO.Stream" /> que se utilizará para escribir los datos de la solicitud.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.IO.Stream" /> que se utilizará para escribir los datos de la solicitud.</summary>
        <returns><see cref="T:System.IO.Stream" /> que se utiliza para escribir los datos de la solicitud.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método devuelve una secuencia que se utiliza para enviar datos para el <xref:System.Net.HttpWebRequest>. Después de la <xref:System.IO.Stream> ha devuelto el objeto, puede enviar datos con el <xref:System.Net.HttpWebRequest> utilizando el <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> método.  
  
 Si una aplicación necesita establecer el valor de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad y, después, esto debe hacerse antes de recuperar la secuencia.  
  
 Debe llamar a la <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> para cerrar la secuencia y liberar la conexión para su reutilización. Error al cerrar la secuencia, la aplicación se quedará sin conexiones.  
  
> [!NOTE]
>  La aplicación no puede mezclar métodos sincrónicos y asincrónicos para una solicitud determinada. Si se llama a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método, debe usar el <xref:System.Net.HttpWebRequest.GetResponse%2A> método para recuperar la respuesta.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método para devolver una instancia de secuencia.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">La propiedad <see cref="P:System.Net.HttpWebRequest.Method" /> es GET o HEAD.  
  
O bien 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> es <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> es <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> es -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> es <see langword="false" /> y <see cref="P:System.Net.HttpWebRequest.Method" /> es POST o PUT.</exception>
        <exception cref="T:System.InvalidOperationException">No puede llamarse al método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> más de una vez.  
  
O bien 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> se establece en un valor y <see cref="P:System.Net.HttpWebRequest.SendChunked" /> es <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">El validador de caché de solicitud indicó que la respuesta para esta solicitud se puede atender desde la memoria caché; sin embargo, las solicitudes que escriben datos no deben usar la caché. Esta excepción puede producirse si usa un validador de caché personalizado que se implementa incorrectamente.</exception>
        <exception cref="T:System.Net.WebException">Se llamó a <see cref="M:System.Net.HttpWebRequest.Abort" /> anteriormente.  
  
O bien 
Ha caducado el período del tiempo de espera de la solicitud.  
  
O bien 
Error al procesar la solicitud.</exception>
        <exception cref="T:System.ObjectDisposedException">En una aplicación de .NET Compact Framework, no se obtuvo una secuencia de solicitud con longitud de contenido cero y se cerró correctamente. Para más información sobre cómo controlar solicitudes de longitud de contenido cero, vea [Programación para redes en .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (configuración de red)</related>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream :  -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.Net.TransportContext" /> para <see cref="T:System.IO.Stream" />.</param>
        <summary>Obtiene un objeto <see cref="T:System.IO.Stream" /> que se va a usar para escribir los datos de la solicitud y genera el objeto <see cref="T:System.Net.TransportContext" /> asociado a la secuencia.</summary>
        <returns><see cref="T:System.IO.Stream" /> que se utiliza para escribir los datos de la solicitud.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método devuelve una secuencia que se utiliza para enviar datos para el <xref:System.Net.HttpWebRequest> y genera el <xref:System.Net.TransportContext> asociado a la secuencia. Después de la <xref:System.IO.Stream> ha devuelto el objeto, puede enviar datos con el <xref:System.Net.HttpWebRequest> utilizando el <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> método.  
  
 Algunas aplicaciones que usan la autenticación de Windows integrada con protección ampliada que deba poder consultar la capa de transporte utilizada por <xref:System.Net.HttpWebRequest> con el fin de recuperar el token de enlace de canal (CBT) del canal TLS subyacente. El <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método proporciona acceso a esta información para los métodos HTTP que tienen un cuerpo de solicitud (`POST` y `PUT` solicitudes). Esto solo es necesario si la aplicación está implementando su propia autenticación y necesita tener acceso a CBT.  
  
 Si una aplicación necesita establecer el valor de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad y, después, esto debe hacerse antes de recuperar la secuencia.  
  
 Debe llamar a la <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> para cerrar la secuencia y liberar la conexión para su reutilización. Error al cerrar la secuencia, la aplicación se quedará sin conexiones.  
  
> [!NOTE]
>  La aplicación no puede mezclar métodos sincrónicos y asincrónicos para una solicitud determinada. Si se llama a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método, debe usar el <xref:System.Net.HttpWebRequest.GetResponse%2A> método para recuperar la respuesta.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">El método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> no pudo obtener <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.InvalidOperationException">No puede llamarse al método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> más de una vez.  
  
O bien 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> se establece en un valor y <see cref="P:System.Net.HttpWebRequest.SendChunked" /> es <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">El validador de caché de solicitud indicó que la respuesta para esta solicitud se puede atender desde la memoria caché; sin embargo, las solicitudes que escriben datos no deben usar la caché. Esta excepción puede producirse si usa un validador de caché personalizado que se implementa incorrectamente.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">La propiedad <see cref="P:System.Net.HttpWebRequest.Method" /> es GET o HEAD.  
  
O bien 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> es <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> es <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> es -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> es <see langword="false" /> y <see cref="P:System.Net.HttpWebRequest.Method" /> es POST o PUT.</exception>
        <exception cref="T:System.Net.WebException">Se llamó a <see cref="M:System.Net.HttpWebRequest.Abort" /> anteriormente.  
  
O bien 
Ha caducado el período del tiempo de espera de la solicitud.  
  
O bien 
Error al procesar la solicitud.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="httpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una respuesta de un recurso de Internet.</summary>
        <returns><see cref="T:System.Net.WebResponse" /> que contiene la respuesta del recurso de Internet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.GetResponse%2A> método devuelve un <xref:System.Net.WebResponse> objeto que contiene la respuesta del recurso de Internet. La instancia real devuelto es un <xref:System.Net.HttpWebResponse>y se puede convertir a esa clase a las propiedades de acceso específica de HTTP.  
  
 Un <xref:System.Net.ProtocolViolationException> se produce en varios casos cuando las propiedades se establecen en el <xref:System.Net.HttpWebRequest> clase están en conflicto. Esta excepción se produce si una aplicación establece el <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad y el <xref:System.Net.HttpWebRequest.SendChunked%2A> propiedad `true`y, a continuación, envía una solicitud HTTP GET. Esta excepción se produce si una aplicación intenta enviar bloques a un servidor que sólo admite el protocolo HTTP 1.0, donde no se admite. Esta excepción se produce si una aplicación intenta enviar datos sin establecer el <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad o el <xref:System.Net.HttpWebRequest.SendChunked%2A> es `false` cuando está deshabilitado el almacenamiento en búfer y en una conexión Keep-Alive (la <xref:System.Net.HttpWebRequest.KeepAlive%2A> propiedad es `true`)`.`  
  
> [!CAUTION]
>  Debe llamar a la <xref:System.Net.HttpWebResponse.Close%2A> para cerrar la secuencia y liberar la conexión. Si no lo hace puede hacer que la aplicación se quedará sin conexiones.  
  
 Cuando se usa el método POST, debe obtener la secuencia de solicitud, escribir los datos que se publicará y cerrar la secuencia. Este método bloquea mientras espera el contenido que se envía; Si no hay ningún conjunto de tiempo de espera y no proporcionan contenido, que realiza la llamada bloquea el subproceso indefinidamente.  
  
> [!NOTE]
>  Varias llamadas a <xref:System.Net.HttpWebRequest.GetResponse%2A> devuelven el mismo objeto de respuesta; la solicitud no se vuelve a emitir.  
  
> [!NOTE]
>  La aplicación no puede mezclar métodos sincrónicos y asincrónicos para una solicitud determinada. Si se llama a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método, debe usar el <xref:System.Net.HttpWebRequest.GetResponse%2A> método para recuperar la respuesta.  
  
> [!NOTE]
>  Si un <xref:System.Net.WebException> es produce, utilice el <xref:System.Net.WebException.Response%2A> y <xref:System.Net.WebException.Status%2A> propiedades de la excepción para determinar la respuesta del servidor.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Por motivos de seguridad, las cookies están deshabilitadas de forma predeterminada. Si desea utilizar cookies, utilice el <xref:System.Net.HttpWebRequest.CookieContainer%2A> propiedad para permitir las cookies.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene la respuesta para una solicitud.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Una llamada anterior a <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> ya usa la secuencia.  
  
O bien 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> se establece en un valor y <see cref="P:System.Net.HttpWebRequest.SendChunked" /> es <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> es GET o HEAD y <see cref="P:System.Net.HttpWebRequest.ContentLength" /> es mayor o igual a cero o <see cref="P:System.Net.HttpWebRequest.SendChunked" /> es <see langword="true" />.  
  
O bien 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> es <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> es <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> es -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> es <see langword="false" /> y <see cref="P:System.Net.HttpWebRequest.Method" /> es POST o PUT.  
  
O bien 
La <see cref="T:System.Net.HttpWebRequest" /> tiene un cuerpo de entidad, pero el método <see cref="M:System.Net.HttpWebRequest.GetResponse" /> se invoca sin llamar al método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />.  
  
O bien 
<see cref="P:System.Net.HttpWebRequest.ContentLength" /> es mayor que cero, pero la aplicación no escribe todos los datos prometidos.</exception>
        <exception cref="T:System.NotSupportedException">El validador de caché de la solicitud indicó que la respuesta para esta solicitud se puede atender desde la memoria caché; sin embargo, esta solicitud incluye datos que se deben enviar al servidor. Las solicitudes que envían datos no deben usar la caché. Esta excepción puede producirse si usa un validador de caché personalizado que se implementa incorrectamente.</exception>
        <exception cref="T:System.Net.WebException">Se llamó a <see cref="M:System.Net.HttpWebRequest.Abort" /> anteriormente.  
  
O bien 
Ha caducado el período del tiempo de espera de la solicitud.  
  
O bien 
Error al procesar la solicitud.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (configuración de red)</related>
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HaveResponse : bool" Usage="System.Net.HttpWebRequest.HaveResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se ha recibido una respuesta de un recurso de Internet.</summary>
        <value><see langword="true" /> si se ha recibido una respuesta; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente código de ejemplo se comprueba el <xref:System.Net.HttpWebRequest.HaveResponse%2A> propiedad para determinar si se recibió una respuesta desde un recurso de Internet.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica una colección de los pares nombre/valor que componen los encabezados HTTP.</summary>
        <value><see cref="T:System.Net.WebHeaderCollection" /> que contiene los pares nombre-valor que componen los encabezados de la solicitud HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.Headers%2A> colección contiene los encabezados de protocolo asociados a la solicitud. En la tabla siguiente se enumera los encabezados HTTP que no se almacenan en el <xref:System.Net.HttpWebRequest.Headers%2A> colección pero están en establecido por el sistema o en conjunto, propiedades o métodos.  
  
|Header|Establecido por|  
|------------|------------|  
|Aceptar|Establecer el <xref:System.Net.HttpWebRequest.Accept%2A> propiedad.|  
|Conexión|Establecer el <xref:System.Net.HttpWebRequest.Connection%2A> propiedad y <xref:System.Net.HttpWebRequest.KeepAlive%2A> propiedad.|  
|Longitud del contenido|Establecer el <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad.|  
|Content-Type|Establecer el <xref:System.Net.HttpWebRequest.ContentType%2A> propiedad.|  
|Esperar|Establecer el <xref:System.Net.HttpWebRequest.Expect%2A> propiedad.|  
|Fecha|Establecer el <xref:System.Net.HttpWebRequest.Date%2A> propiedad.|  
|administrador de flujos de trabajo|Establecer el <xref:System.Net.HttpWebRequest.Host%2A> propiedad.|  
|If-Modified-Since|Establecer el <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad.|  
|Intervalo|Establecer el <xref:System.Net.HttpWebRequest.AddRange%2A> método.|  
|Sitio de referencia|Establecer el <xref:System.Net.HttpWebRequest.Referer%2A> propiedad.|  
|Codificación de transferencia|Establecer el <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propiedad (el <xref:System.Net.HttpWebRequest.SendChunked%2A> propiedad debe ser true).|  
|Agente de usuario|Establecer el <xref:System.Net.HttpWebRequest.UserAgent%2A> propiedad.|  
  
 El <xref:System.Net.WebHeaderCollection.Add%2A> método produce una <xref:System.ArgumentException> si se intenta establecer uno de estos encabezados protegidos.  
  
 Cambiar el <xref:System.Net.HttpWebRequest.Headers%2A> propiedad una vez iniciada la solicitud mediante una llamada a <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método produce una <xref:System.InvalidOperationException>.  
  
 No debe suponer que los valores de encabezado permanecerá sin cambios, ya que las memorias caché y los servidores Web pueden cambiar o agregar encabezados a una solicitud Web.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.Headers%2A> propiedad para imprimir los pares de nombre/valor de encabezado HTTP en la consola.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La solicitud se ha iniciado mediante la llamada al método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> o <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : string with get, set" Usage="System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor del encabezado Host que se va a usar en una solicitud HTTP independiente del identificador URI de la solicitud.</summary>
        <value>Valor del encabezado Host de la solicitud HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.Host%2A> propiedad puede usarse para establecer el Host del valor de encabezado que se usa en una solicitud HTTP independiente desde el URI de solicitud. El <xref:System.Net.HttpWebRequest.Host%2A> propiedad puede constar de un nombre de host y un número de puerto opcional. Un encabezado de Host sin información de puerto implica el puerto predeterminado para el servicio solicitado (puerto 80 de una dirección URL HTTP, por ejemplo).  
  
 El formato para especificar un host y puerto debe seguir las reglas en la sección 14.23 de RFC2616 publicados por el IETF. Un ejemplo que cumpla estos requisitos que especifica un puerto 8080 sería el siguiente valor para el <xref:System.Net.HttpWebRequest.Host%2A> propiedad:  
  
 `www.contoso.com:8080`  
  
 Mediante el <xref:System.Net.HttpWebRequest.Host%2A> propiedad para especificar explícitamente un valor de encabezado de Host personalizado también afecta a las áreas de almacenamiento en caché, las cookies y la autenticación. Cuando una aplicación proporciona credenciales para un prefijo URI concreto, las aplicaciones debe asegurarse de que use el URI que contiene el valor del encabezado de Host, no el servidor de destino en el URI. La clave se usa al almacenar en caché los recursos, utiliza el valor del encabezado Host en lugar de en el URI de solicitud. Las cookies se almacenan en un <xref:System.Net.CookieContainer> y lógicamente agrupadas por el nombre de dominio del servidor. Si la aplicación especifica un encabezado de Host, este valor se usará como dominio.  
  
 Si el <xref:System.Net.HttpWebRequest.Host%2A> no se establece la propiedad y, después, el valor del encabezado Host para usar en una solicitud HTTP se basa en el URI de solicitud.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El encabezado host no se puede establecer en <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El encabezado host no se puede establecer en un valor no válido.</exception>
        <exception cref="T:System.InvalidOperationException">El encabezado host no se puede establecer después de que empiece a enviarse la <see cref="T:System.Net.HttpWebRequest" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.IfModifiedSince : DateTime with get, set" Usage="System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor del encabezado HTTP <see langword="If-Modified-Since" />.</summary>
        <value><see cref="T:System.DateTime" /> que contiene el contenido del encabezado HTTP <see langword="If-Modified-Since" />. El valor predeterminado es el de la fecha y la hora actuales.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad es un estándar <xref:System.DateTime?displayProperty=nameWithType> objeto y puede contener un <xref:System.DateTimeKind?displayProperty=nameWithType> campo de <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, o <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Se puede establecer cualquier intervalo de tiempo cuando se usa el <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad. Si <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> se establece o recupera, el <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad se supone que <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (hora local).  
  
 Las clases en el <xref:System.Net> espacio de nombres siempre escriben el <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad en la conexión durante la transmisión en formulario estándar utilizando el formato GMT (Utc).  
  
 Si el <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad está establecida en <xref:System.DateTime.MinValue?displayProperty=nameWithType>, el `If-Modified-Since` se quita el encabezado HTTP de la <xref:System.Net.HttpWebRequest.Headers%2A> propiedad y el <xref:System.Net.WebHeaderCollection>.  
  
 Si el <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad es <xref:System.DateTime.MinValue?displayProperty=nameWithType>, esto indica que el `If-Modified-Since` encabezado HTTP no está incluido en el <xref:System.Net.HttpWebRequest.Headers%2A> propiedad y el <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  El valor de esta propiedad se almacena en <xref:System.Net.WebHeaderCollection>. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  
  
   
  
## Examples  
 El siguiente código de ejemplo se comprueba el <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se debe establecer una conexión persistente en el recurso de Internet.</summary>
        <value><see langword="true" /> si la solicitud al recurso de Internet debe contener un encabezado HTTP <see langword="Connection" /> con el valor Keep-alive; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establezca esta propiedad en `true` para enviar un `Connection` encabezado HTTP con el valor Keep-alive. Una aplicación usa <xref:System.Net.HttpWebRequest.KeepAlive%2A> para indicar una preferencia para las conexiones persistentes. Cuando el <xref:System.Net.HttpWebRequest.KeepAlive%2A> propiedad es `true`, la aplicación realiza conexiones persistentes en los servidores que las admiten.  
  
> [!NOTE]
>  Cuando se usa HTTP/1.1, Keep-Alive está activada de forma predeterminada. Establecer <xref:System.Net.HttpWebRequest.KeepAlive%2A> a `false` es posible enviar un `Connection: Close` encabezado para el servidor.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.KeepAlive%2A> propiedad `false` para evitar que se establezca una conexión persistente con el recurso de Internet.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumAutomaticRedirections : int with get, set" Usage="System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número máximo de redirecciones que seguirá la solicitud.</summary>
        <value>El número máximo de respuestas de redirección que seguirá la solicitud. El valor predeterminado es 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> propiedad establece el número máximo de redirecciones de la solicitud a seguir si la <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> propiedad es `true`.  
  
   
  
## Examples  
 El ejemplo de código siguiente establece el valor de esta propiedad.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor está establecido en 0 o menos.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la longitud máxima permitida de los encabezados de respuesta.</summary>
        <value>La longitud en kilobytes (1024 bytes) de los encabezados de respuesta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longitud del encabezado de respuesta incluye la línea de estado de respuesta y caracteres de control adicionales que se reciben como parte del protocolo HTTP. Un valor de-1 significa que se impone ningún límite en los encabezados de respuesta; un valor de 0 significa que no todas las solicitudes.  
  
 Si el <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propiedad no se establece explícitamente, el valor predeterminado es el valor de la <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> propiedad.  
  
 Si la longitud del encabezado de respuesta recibido supera el valor de la <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propiedad, el <xref:System.Net.HttpWebRequest.EndGetResponse%2A> o <xref:System.Net.HttpWebRequest.GetResponse%2A> métodos producirán un <xref:System.Net.WebException> con el <xref:System.Net.WebException.Status%2A> propiedad establecida en <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 El ejemplo de código siguiente establece el valor de esta propiedad.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad se establece después de enviarse la solicitud.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor es menor que 0 y no es igual a -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string with get, set" Usage="System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tipo del medio de la solicitud.</summary>
        <value>Tipo del medio de la solicitud. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de la <xref:System.Net.HttpWebRequest.MediaType%2A> afecta a la propiedad el <xref:System.Net.HttpWebResponse.CharacterSet%2A> propiedad. Al establecer el <xref:System.Net.HttpWebRequest.MediaType%2A> en la solicitud, se elige el tipo de medio correspondiente en la lista de conjuntos de caracteres devuelto en la respuesta `Content-type` encabezado HTTP.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el método para la solicitud.</summary>
        <value>Método de solicitud que se debe utilizar para establecer contacto con el recurso de Internet. El valor predeterminado es GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.Method%2A> propiedad puede establecerse en cualquiera de los verbos del protocolo HTTP 1.1: GET, HEAD, POST, PUT, DELETE, seguimiento u opciones de.  
  
 Si el <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad está establecida en cualquier valor distinto de -1, el <xref:System.Net.HttpWebRequest.Method%2A> propiedad debe establecerse en una propiedad de protocolo que carga los datos.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.Method%2A> propiedad a POST.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No se proporciona ningún método.  
  
O bien 
La cadena de método contiene caracteres no válidos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Pipelined : bool with get, set" Usage="System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se debe canalizar la solicitud en el recurso de Internet.</summary>
        <value><see langword="true" /> si la solicitud debe canalizarse; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una aplicación usa el <xref:System.Net.HttpWebRequest.Pipelined%2A> propiedad para indicar una preferencia por las conexiones canalizadas. Cuando <xref:System.Net.HttpWebRequest.Pipelined%2A> es `true`, una aplicación realiza conexiones canalizadas en los servidores que las admiten.  
  
 Las conexiones canalizadas sólo se realizan cuando el <xref:System.Net.HttpWebRequest.KeepAlive%2A> propiedad también es `true`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se imprime el valor de la <xref:System.Net.HttpWebRequest.Pipelined%2A> propiedad a la consola.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se envía un encabezado de autorización con la solicitud.</summary>
        <value><see langword="true" /> para enviar un encabezado de autorización HTTP con las solicitudes después de que tenga lugar la autenticación; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de una solicitud de cliente a un determinado <xref:System.Uri> se autentica correctamente, si <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> es `true` y se proporcionan las credenciales, el encabezado de autorización se envía con cada solicitud a cualquiera <xref:System.Uri> que coincida con la específica <xref:System.Uri>hasta la última barra diagonal. Por tanto, si la solicitud del cliente autenticado correctamente en un determinado <xref:System.Uri> que contenga lo siguiente:  
  
 `http://www.contoso.com/firstpath/`  
  
 El encabezado de autorización para la autenticación previa se envían con cada solicitud a cualquiera de los siguientes <xref:System.Uri> instancias:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 Sin embargo, el encabezado de autorización no se envía con las solicitudes a cualquiera de los siguientes <xref:System.Uri> instancias:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Si el cliente solicita un determinado <xref:System.Uri> es autenticado no correctamente, la solicitud utiliza los procedimientos de autenticación estándar.  
  
 A excepción de la primera solicitud, el <xref:System.Net.WebRequest.PreAuthenticate%2A> propiedad indica si se debe enviar información de autenticación con las solicitudes posteriores para un <xref:System.Uri> que coincida con la específica <xref:System.Uri> hasta la última barra diagonal sin tener que esperar a ser desafío del servidor.  
  
 El siguiente cuadro de diálogo entre cliente y servidor muestra el efecto de esta propiedad. El cuadro de diálogo, se da por supuesto que la autenticación básica está en uso.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> es `false`:  
  
 Cliente: OBTENER someUrl  
  
 Servidor: 401 WWW-Authenticate Basic  
  
 Cliente: EMPEZAR con los encabezados de autorización  
  
 Servidor: 200 OK  
  
 Cliente: OBTENER someUrl  
  
 Servidor: 401 WWW-Authenticate Basic  
  
 Cliente: EMPEZAR con los encabezados de autorización  
  
 Servidor: 200 OK  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> es `true`:  
  
 Cliente: OBTENER someUrl  
  
 Servidor: 401 WWW-Authenticate Basic  
  
 Cliente: EMPEZAR con los encabezados de autorización  
  
 Servidor: 200 OK  
  
 Cliente: GET someUrl con encabezados de autorización  
  
 Si el esquema de autenticación no es compatible con la autenticación previa, se omite el valor de esta propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la versión de HTTP que se va a utilizar para la solicitud.</summary>
        <value>Versión HTTP que se va a utilizar para la solicitud. De manera predeterminada, es <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Net.HttpWebRequest> clase admite solo las versiones 1.0 y 1.1 de HTTP. Establecer <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> a una versión diferente, produce una excepción.  
  
> [!NOTE]
>  Para establecer la versión HTTP de la solicitud actual, use el <xref:System.Net.HttpVersion.Version10> y <xref:System.Net.HttpVersion.Version11> campos de la <xref:System.Net.HttpVersion> clase.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> propiedad.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La versión HTTP está establecida en un valor distinto de 1.0 o 1.1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la información de proxy para la solicitud.</summary>
        <value>Objeto <see cref="T:System.Net.IWebProxy" /> que se utiliza para especificar el servidor proxy de la solicitud. El valor predeterminado se establece mediante una llamada a la propiedad <see cref="P:System.Net.GlobalProxySelection.Select" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.Proxy%2A> propiedad identifica el <xref:System.Net.WebProxy> objeto que se utiliza para procesar las solicitudes a recursos de Internet. Para especificar que no se debe usar ningún proxy, establezca la <xref:System.Net.HttpWebRequest.Proxy%2A> propiedad a la instancia del proxy devuelta por la <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> método.  
  
 El equipo local o un archivo de configuración de la aplicación puede especificar que se usa un proxy predeterminado. Si el <xref:System.Net.HttpWebRequest.Proxy%2A> se especifica la propiedad, a continuación, la configuración de proxy de la <xref:System.Net.HttpWebRequest.Proxy%2A> el equipo local o un archivo de configuración de aplicación de reemplazo de propiedad y el <xref:System.Net.HttpWebRequest> instancia usará la configuración de proxy especificada. Si no se especifica ningún proxy en un archivo de configuración y el <xref:System.Net.HttpWebRequest.Proxy%2A> propiedad no se especifica, el <xref:System.Net.HttpWebRequest> clase utiliza la configuración de proxy heredada de Internet Explorer en el equipo local. Si no hay ninguna configuración de proxy en Internet Explorer, la solicitud se envía directamente al servidor.  
  
 La <xref:System.Net.HttpWebRequest> clase analiza una lista de omisión de proxy con caracteres comodín heredada de Internet Explorer la misma mientras se analiza la lista de omisión directamente por Internet Explorer. Por ejemplo, el <xref:System.Net.HttpWebRequest> clase analizará una lista de omisión de "nt *" de Internet Explorer como una expresión regular de "nt.\*". Por lo tanto una dirección URL de "`http://nt.com`" omitiría el proxy utilizando la <xref:System.Net.HttpWebRequest> clase y el uso de Internet Explorer.  
  
 La <xref:System.Net.HttpWebRequest> clase admite la omisión de proxy local. La clase se considera que un destino local si se cumple alguna de las condiciones siguientes:  
  
-   El destino contiene un nombre sin formato (sin puntos en la dirección URL).  
  
-   El destino contiene una dirección de bucle invertido (<xref:System.Net.IPAddress.Loopback> o <xref:System.Net.IPAddress.IPv6Loopback>) o el destino contiene un <xref:System.Net.IPAddress> asignada al equipo local.  
  
-   El sufijo de dominio de destino coincide con sufijo de dominio del equipo local (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 Cambiar el <xref:System.Net.HttpWebRequest.Proxy%2A> propiedad una vez iniciada la solicitud mediante una llamada a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método produce una <xref:System.InvalidOperationException>. Para obtener información sobre el elemento de proxy [ \&lt; defaultProxy\&gt; Elemento (configuración de red)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.Proxy%2A> método para obtener la información de proxy para la solicitud.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <see cref="P:System.Net.HttpWebRequest.Proxy" /> está establecido en <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La solicitud se ha iniciado mediante una llamada a <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> o <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">El autor de llamada no tiene permiso para la operación solicitada.</exception>
        <permission cref="T:System.Net.WebPermission">Para obtener o establecer el <see cref="P:System.Net.HttpWebRequest.Proxy" /> propiedad. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (configuración de red)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/bb707c72-eed2-4a82-8800-c9e68df2fd4f">Configuración de aplicaciones de Internet</related>
        <related type="Article" href="https://msdn.microsoft.com/library/353c0a8b-4cee-44f6-8e65-60e286743df9">Configuración de proxy</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fcd9c3bd-93de-4c92-8ff3-837327ad18de">Detección automática de proxy</related>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un tiempo de espera, en milisegundos, al leer o escribir una secuencia.</summary>
        <value>El número de milisegundos antes de que se agote el tiempo de espera de la operación de lectura o escritura. El valor predeterminado es 300.000 milisegundos (5 minutos).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propiedad se utiliza cuando se escribe en la secuencia devuelta por la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método o la lectura de la secuencia devuelta por la <xref:System.Net.HttpWebResponse.GetResponseStream%2A> método.  
  
 En concreto, el <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propiedad controla el tiempo de espera para la <xref:System.IO.Stream.Read%2A> método, que se utiliza para leer la secuencia devuelta por la <xref:System.Net.HttpWebResponse.GetResponseStream%2A> método y para el <xref:System.IO.Stream.Write%2A> método, que se usa para escribir en la secuencia devuelta por la <xref:System.Net.HttpWebRequest.GetRequestStream%2A>método.  
  
 Para especificar la cantidad de tiempo de espera para que finalice la solicitud, use el <xref:System.Net.HttpWebRequest.Timeout%2A> propiedad.  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra cómo establecer la propiedad <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ya se ha enviado la solicitud.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor especificado para una operación set es menor o igual que cero y no es igual a <see cref="F:System.Threading.Timeout.Infinite" /></exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Referer : string with get, set" Usage="System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor del encabezado HTTP <see langword="Referer" />.</summary>
        <value>Valor del encabezado HTTP <see langword="Referer" />. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> propiedad es `true`, el <xref:System.Net.HttpWebRequest.Referer%2A> propiedad se establece automáticamente cuando la solicitud se redirige a otro sitio.  
  
 Para borrar el `Referer` encabezado HTTP, establezca el <xref:System.Net.HttpWebRequest.Referer%2A> propiedad `null`.  
  
> [!NOTE]
>  El valor de esta propiedad se almacena en <xref:System.Net.WebHeaderCollection>. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.Referer%2A> propiedad.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador URI original de la solicitud.</summary>
        <value><see cref="T:System.Uri" /> que contiene el identificador URI del recurso de Internet pasado al método <see cref="M:System.Net.WebRequest.Create(System.String)" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri> objeto pasa a <xref:System.Net.HttpWebRequest> por la llamada a <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>.  
  
 Después de una redirección de encabezado no cambia el <xref:System.Net.HttpWebRequest.RequestUri%2A> propiedad. Para obtener el URI real que respondió a la solicitud, examine el <xref:System.Net.HttpWebRequest.Address%2A> propiedad.  
  
   
  
## Examples  
 El siguiente código de ejemplo comprueba si el <xref:System.Net.HttpWebRequest> objeto `req` se ha redirigido a otra ubicación para atender la solicitud y establece el valor de la `hasChanged` variable `true` si la solicitud se ha redirigido; de lo contrario, `hasChanged` está establecido en `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se deben enviar los datos en segmentos al recurso de Internet.</summary>
        <value><see langword="true" /> para que los datos se envíen en segmentos al recurso de Internet; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Net.HttpWebRequest.SendChunked%2A> es `true`, la solicitud envía los datos en segmentos al recurso de Internet. El recurso de Internet debe admitir la recepción de datos fragmentados.  
  
 Cambiar el <xref:System.Net.HttpWebRequest.SendChunked%2A> propiedad una vez iniciada la solicitud mediante una llamada a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método produce una <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.SendChunked%2A> propiedad `true` para que se pueden enviar datos en segmentos al recurso de Internet.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La solicitud se ha iniciado mediante la llamada al método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> o <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una función de devolución de llamada para validar el certificado de servidor.</summary>
        <value>Función de devolución de llamada para validar el certificado de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor predeterminado es que se ha establecido ninguna función de devolución de llamada y el <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> propiedad es `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el punto de servicio que se va a utilizar para la solicitud.</summary>
        <value><see cref="T:System.Net.ServicePoint" /> que representa la conexión de red con el recurso de Internet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> propiedad puede ser diferente de <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> si se redirige la solicitud.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsCookieContainer : bool" Usage="System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la solicitud admite un <see cref="T:System.Net.CookieContainer" />.</summary>
        <value><see langword="true" /> si la solicitud admite un <see cref="T:System.Net.CookieContainer" />; en caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> que se rellena con datos.</param>
        <param name="streamingContext"><see cref="T:System.Runtime.Serialization.StreamingContext" /> que especifica el destino de esta serialización.</param>
        <summary>Llena <see cref="T:System.Runtime.Serialization.SerializationInfo" /> con los datos necesarios para serializar el objeto de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los objetos incluidos en el <xref:System.Runtime.Serialization.SerializationInfo> automáticamente se realiza un seguimiento y serializan el formateador.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor de tiempo de espera, en milisegundos, para los métodos <see cref="M:System.Net.HttpWebRequest.GetResponse" /> y <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />.</summary>
        <value>Número de milisegundos que se va a esperar antes de que se agote el tiempo de espera de la solicitud. El valor predeterminado es 100.000 milisegundos (100 segundos).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> es el número de milisegundos que una solicitud sincrónica subsiguientes realizada con la <xref:System.Net.HttpWebRequest.GetResponse%2A> método espera una respuesta y el <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método espera a que una secuencia. El <xref:System.Net.HttpWebRequest.Timeout%2A> se aplica a la solicitud completa y la respuesta, no individualmente a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> y <xref:System.Net.HttpWebRequest.GetResponse%2A> las llamadas a métodos. Si el recurso no se devuelve dentro del período de tiempo de espera, la solicitud produce un <xref:System.Net.WebException> con el <xref:System.Net.WebException.Status%2A> propiedad establecida en <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>.  
  
 El <xref:System.Net.HttpWebRequest.Timeout%2A> propiedad debe establecerse antes de la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> o <xref:System.Net.HttpWebRequest.GetResponse%2A> se llama al método. Cambiar el <xref:System.Net.HttpWebRequest.Timeout%2A> propiedad después de llamar a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> o <xref:System.Net.HttpWebRequest.GetResponse%2A> método no tiene ningún efecto.  
  
 El <xref:System.Net.HttpWebRequest.Timeout%2A> propiedad no tiene ningún efecto en las solicitudes asincrónicas realizadas con la <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> o <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método.  
  
> [!CAUTION]
>  En el caso de las solicitudes asincrónicas, la aplicación cliente implementa su propio mecanismo de tiempo de espera. Consulte el ejemplo en el <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método.  
  
 Para especificar la cantidad de tiempo de espera antes de una lectura o escritura agota el tiempo de operación, use el <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propiedad.  
  
 Una consulta de sistema de nombres de dominio (DNS) puede tardar hasta 15 segundos para devolver o tiempo de espera. Si la solicitud contiene un nombre de host que requiere resolución y establece <xref:System.Net.FileWebRequest.Timeout%2A> en un valor inferior a 15 segundos, puede tardar 15 segundos o más antes de un <xref:System.Net.WebException> se produce para indicar un tiempo de espera de la solicitud.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.Timeout%2A> propiedad de la <xref:System.Net.HttpWebRequest> objeto.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor especificado es inferior a cero y no es <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransferEncoding : string with get, set" Usage="System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor del encabezado HTTP <see langword="Transfer-encoding" />.</summary>
        <value>Valor del encabezado HTTP <see langword="Transfer-encoding" />. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para poder establecer la <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propiedad, primero debe establecer la <xref:System.Net.HttpWebRequest.SendChunked%2A> propiedad `true`. Borrar <xref:System.Net.HttpWebRequest.TransferEncoding%2A> estableciendo en `null` no tiene ningún efecto en el valor de <xref:System.Net.HttpWebRequest.SendChunked%2A>.  
  
 Los valores asignados a la <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propiedad reemplazan cualquier contenido existente.  
  
> [!NOTE]
>  El valor de esta propiedad se almacena en <xref:System.Net.WebHeaderCollection>. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> se establece cuando <see cref="P:System.Net.HttpWebRequest.SendChunked" /> es <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> se establece en el valor "Chunked".</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se permite el uso compartido de las conexiones de alta velocidad autenticadas por NTLM.</summary>
        <value><see langword="true" /> para mantener abierta la conexión autenticada; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor predeterminado para esta propiedad es `false`, lo que hace que la conexión actual que se cerrará después de completar una solicitud. La aplicación debe pasar por la secuencia de autenticación cada vez que emite una solicitud nueva.  
  
 Si esta propiedad se establece en `true`, la conexión utilizada para recuperar la respuesta permanece abierta después de haber realizado la autenticación. En este caso, otras solicitudes que tienen esta propiedad establecida en `true` puede usar la conexión sin volver a autenticar. En otras palabras, si se ha autenticado una conexión para un usuario, el usuario B puede volver a usar la conexión; solicitud del usuario B se cumple en función de las credenciales del usuario A.  
  
> [!CAUTION]
>  Dado que es posible que una aplicación usar la conexión sin autenticarse, debe asegurarse de que no hay ninguna vulnerabilidad administrativa en el sistema al establecer esta propiedad en `true`. Si la aplicación envía solicitudes de varios usuarios (suplanta a varias cuentas de usuario) y se basa en la autenticación para proteger los recursos, no establezca esta propiedad en `true` a menos que use grupos de conexión como se describe a continuación.  
  
 Puede desear considerar habilitar este mecanismo si los problemas de rendimiento y la aplicación se ejecuta en un servidor Web con autenticación integrada de Windows.  
  
 Si habilita a esta configuración, abre el sistema a riesgos de seguridad. Si establece la <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> propiedad `true` Asegúrese de tomar las precauciones siguientes:  
  
-   Use el <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> propiedad para administrar las conexiones de usuarios diferentes. Esto evita la posible uso de la conexión por las aplicaciones no autenticadas. Por ejemplo, un usuario debe tener un nombre de grupo de conexión único que es diferente del usuario B. Esto proporciona una capa de aislamiento para cada cuenta de usuario.  
  
-   Ejecute la aplicación en un entorno protegido para evitar vulnerabilidades de seguridad de conexión posible.  
  
 Si controla el servidor back-end, como alternativa se puede desactivar la persistencia de autenticación. Esto aumenta el rendimiento en menor grado, pero es más seguro. Para obtener más detalles, busque AuthPersistence en MSDN library en [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library).  
  
> [!NOTE]
>  Si ambos <xref:System.Net.WebRequest.PreAuthenticate%2A> y <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> se establecen en `true`, cada solicitud se envía mediante una conexión del grupo no seguro, pero con un encabezado de autorización.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Se requiere el permiso no restringido de Web para establecer esta propiedad.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor <see cref="T:System.Boolean" /> que controla si se envían las credenciales predeterminadas con las solicitudes.</summary>
        <value>Es <see langword="true" /> si se utilizan las credenciales predeterminadas; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establezca esta propiedad en `true` cuando las solicitudes realizadas por este <xref:System.Net.HttpWebRequest> objeto, si lo solicita el servidor, se debe autenticar con las credenciales del usuario que ha iniciado sesión actualmente. Para las aplicaciones cliente, este es el comportamiento deseado en la mayoría de los escenarios. Para las aplicaciones de nivel intermedio, como las aplicaciones ASP.NET, en lugar de usar esta propiedad, normalmente se establecería el <xref:System.Net.HttpWebRequest.Credentials%2A> propiedad a las credenciales del cliente en cuyo nombre se realiza la solicitud.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se intentó establecer esta propiedad después de que se enviara la solicitud.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string with get, set" Usage="System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor del encabezado HTTP <see langword="User-agent" />.</summary>
        <value>Valor del encabezado HTTP <see langword="User-agent" />. El valor predeterminado es <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 El valor de esta propiedad se almacena en <see cref="T:System.Net.WebHeaderCollection" />. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.UserAgent%2A> propiedad.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>