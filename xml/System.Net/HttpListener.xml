<Type Name="HttpListener" FullName="System.Net.HttpListener">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="82573ef12ea9f2297019f9e271a52a13621c873d" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33682641" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpListener : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListener extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListener" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListener&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListener sealed : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Proporciona un agente de escucha del protocolo HTTP sencillo y controlado mediante programación. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mediante el <xref:System.Net.HttpListener> (clase), puede crear una escucha de protocolo HTTP sencilla que responde a las solicitudes HTTP. El agente de escucha está activo durante la vigencia de la <xref:System.Net.HttpListener> objeto y se ejecuta dentro de la aplicación con sus permisos.
   
 Usar <xref:System.Net.HttpListener>, crear una nueva instancia de la clase utilizando el <xref:System.Net.HttpListener> constructor y use la <xref:System.Net.HttpListener.Prefixes%2A> propiedad para obtener acceso a la colección que contiene las cadenas que especifican que los prefijos de identificador uniforme de recursos (URI) el <xref:System.Net.HttpListener> debe procesar.
  
 Una cadena del prefijo URI se compone de un esquema (http o https), un host, un puerto opcional y una ruta de acceso opcional. Un ejemplo de una cadena de prefijo completa es * http://www.contoso.com:8080/customerData/ *. Los prefijos deben finalizar en una barra diagonal ("/"). La <xref:System.Net.HttpListener> objeto con el prefijo que mejor se ajuste a un identificador URI solicitado responde a la solicitud. Varios <xref:System.Net.HttpListener> objetos no pueden agregar el mismo prefijo; <xref:System.ComponentModel.Win32Exception> excepción se produce si un <xref:System.Net.HttpListener> agrega un prefijo que ya está en uso.
  
 Cuando se especifica un puerto, el elemento de host se puede reemplazar con "\*" para indicar que el <xref:System.Net.HttpListener> acepta las solicitudes enviadas al puerto si el identificador URI solicitado no coincide con ningún otro prefijo. Por ejemplo recibir todas las solicitudes enviadas al puerto 8080 cuando no se controla el URI solicitado por ninguna <xref:System.Net.HttpListener>, el prefijo es *http://\*: 8080 /*. De forma similar, para especificar que el <xref:System.Net.HttpListener> acepta todas las solicitudes enviadas a un puerto, reemplace el elemento de host con el carácter "+". For example, *https://+:8080*. El "\*" y "+" caracteres pueden estar presentes en prefijos que incluyen rutas de acceso.
  
 A partir de .NET Core 2.0 o .NET Framework 4.6 en Windows 10, comodín subdominios se admiten en prefijos URI que se administran mediante un <xref:System.Net.HttpListener> objeto. Para especificar un subdominio de carácter comodín, utilice la "\*" caracteres como parte del nombre de host en un prefijo de URI. Por ejemplo, *http://\*.foo.com/*. Pasar como argumento para el <xref:System.Net.HttpListenerPrefixCollection.Add%2A> método. Esto funciona a partir de .NET Core 2.0 o .NET Framework 4.6 en Windows 10; en versiones anteriores, esto genera un <xref:System.Net.HttpListenerException>.

 > [!WARNING]
 > Enlaces de carácter comodín de nivel superior (*http://\*: 8080 /* y * http://+:8080 *) debe **no** utilizarse. Los enlaces de carácter comodín de nivel superior pueden exponer su aplicación a vulnerabilidades de seguridad. Esto se aplica tanto a los caracteres comodín fuertes como a los débiles. Use nombres de host explícitos en lugar de caracteres comodín. Los enlaces de carácter comodín de subdominio (por ejemplo, `*.mysub.com`) no suponen este riesgo de seguridad si se controla todo el dominio primario (a diferencia de `*.com`, que sí es vulnerable). Vea la [sección 5.4 de RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.4) para obtener más información.
  
 Para empezar a escuchar las solicitudes de clientes, agregue los prefijos URI a la colección y llamar a la <xref:System.Net.HttpListener.Start%2A> método. <xref:System.Net.HttpListener> ofrece modelos sincrónicos y asincrónicos para procesar las solicitudes de cliente. Las solicitudes y sus respuestas asociadas son accesibles mediante la <xref:System.Net.HttpListenerContext> objeto devuelto por la <xref:System.Net.HttpListener.GetContext%2A> método o sus homólogos asincrónicos, el <xref:System.Net.HttpListener.BeginGetContext%2A> y <xref:System.Net.HttpListener.EndGetContext%2A> métodos.
  
 El modelo sincrónico es adecuado si la aplicación debe bloquearse mientras espera una solicitud de cliente y si desea procesar únicamente una solicitud a la vez. Con el modelo sincrónico, llame a la <xref:System.Net.HttpListener.GetContext%2A> método, que espera a que un cliente envíe una solicitud. El método devuelve un <xref:System.Net.HttpListenerContext> objeto para el procesamiento cuando uno se produce.
  
 En el modelo asincrónico más complejo, la aplicación no se bloquea mientras espera para las solicitudes y cada solicitud se procesa en su propio subproceso de ejecución. Use la <xref:System.Net.HttpListener.BeginGetContext%2A> método para especificar un método definido por la aplicación al que llamar para cada solicitud entrante. Dentro de ese método, llame a la <xref:System.Net.HttpListener.EndGetContext%2A> para obtener la solicitud, procesarlo y responder.
  
 En ambos casos, las solicitudes entrantes son accesibles mediante la <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType> propiedad y se representan mediante <xref:System.Net.HttpListenerRequest> objetos. De forma similar, las respuestas son accesibles mediante la <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=nameWithType> propiedad y se representan mediante <xref:System.Net.HttpListenerResponse> objetos. Estos objetos comparten algunas funcionalidades con el <xref:System.Net.HttpWebRequest> y <xref:System.Net.HttpWebResponse> objetos, pero los objetos de este últimos no se puede usar junto con <xref:System.Net.HttpListener> porque implementan cliente no, servidor de comportamientos.
  
 Un <xref:System.Net.HttpListener> puede requerir la autenticación de cliente. Puede especificar un determinado esquema que se usará para la autenticación, o puede especificar a un delegado que determina el esquema que se usará. Se necesita algún tipo de autenticación para obtener información sobre la identidad del cliente. Para obtener más información, consulte el <xref:System.Net.HttpListenerContext.User%2A>, <xref:System.Net.HttpListener.AuthenticationSchemes%2A>, y <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> propiedades.
  
> [!NOTE]
> Si crea un <xref:System.Net.HttpListener> mediante https, debe seleccionar un certificado de servidor para ese agente de escucha. En caso contrario, un <xref:System.Net.HttpWebRequest> consultas de este <xref:System.Net.HttpListener> se producirá un error con el cierre inesperado de la conexión.
  
> [!NOTE]
> Puede configurar certificados de servidor y otras opciones de agente de escucha mediante Shell de red (netsh.exe). Vea [Shell de red (Netsh)](/windows-server/networking/technologies/netsh/netsh) para obtener más detalles. El archivo ejecutable suministrará con Windows Server 2008 y Windows Vista.
  
> [!NOTE]
> Si especifica varios esquemas de autenticación para la <xref:System.Net.HttpListener>, el agente de escucha supondrán un reto para los clientes en el siguiente orden: `Negotiate`, `NTLM`, `Digest`y, a continuación, `Basic`.
  
   
  
## Examples
 En el ejemplo de código siguiente se muestra cómo utilizar un <xref:System.Net.HttpListener>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpListener();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de usar la instancia devuelta por este constructor, debe invocar su <xref:System.Net.HttpListener.Start%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Net.HttpListener> constructor para crear un nuevo <xref:System.Net.HttpListener> objeto. Para obtener un ejemplo completo, vea el <xref:System.Net.HttpListener> tema de la clase.  
  
 [!code-csharp[Net_listener_Basic#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Esta clase no se puede utilizar en el sistema operativo actual. Se requiere Windows Server 2003 o Windows XP SP2 para poder utilizar instancias de esta clase.</exception>
        <block subset="none" type="usage">
          <para>Nota: Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra inmediatamente el objeto <see cref="T:System.Net.HttpListener" />, descartando todas las solicitudes actualmente puestas en la cola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método elimina todos los recursos mantenidos por este agente de escucha. Cualquier solicitud pendiente es no se puede completar.  
  
 Después de llamar a este método, recibirá un <xref:System.ObjectDisposedException> si intenta utilizar este <xref:System.Net.HttpListener>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este método.  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemes">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.AuthenticationSchemes AuthenticationSchemes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemes" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemes As AuthenticationSchemes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemes AuthenticationSchemes { System::Net::AuthenticationSchemes get(); void set(System::Net::AuthenticationSchemes value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el esquema utilizado para autenticar los clientes.</summary>
        <value>Una combinación bit a bit de valores de la enumeración <see cref="T:System.Net.AuthenticationSchemes" /> que indica cómo serán autenticados los clientes. El valor predeterminado es <see cref="F:System.Net.AuthenticationSchemes.Anonymous" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpListener> utiliza el esquema especificado para autenticar todas las solicitudes entrantes. El <xref:System.Net.HttpListener.GetContext%2A> y <xref:System.Net.HttpListener.EndGetContext%2A> métodos devuelven una solicitud de cliente entrante solo si el <xref:System.Net.HttpListener> se autentica correctamente la solicitud.  
  
 Puede consultar la identidad de un cliente autenticado correctamente mediante el uso de la <xref:System.Net.HttpListenerContext.User%2A?displayProperty=nameWithType> propiedad.  
  
 Si desea que un <xref:System.Net.HttpListener> objeto para utilizar mecanismos de autenticación diferentes basándose en características de las solicitudes que recibe (por ejemplo, la solicitud <xref:System.Net.HttpListenerRequest.Url%2A> o <xref:System.Net.HttpListenerRequest.UserHostName%2A> propiedad), debe implementar un método que elige el esquema de autenticación. Para obtener instrucciones acerca de cómo hacerlo, consulte el <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> documentación de la propiedad.  
  
> [!NOTE]
>  Para establecer esta propiedad para habilitar Digest, NTLM o Negotiate se requiere el <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Net.HttpListener.AuthenticationSchemes%2A> propiedad para especificar un esquema de autenticación.  
  
 [!code-csharp[Net_listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemeSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemeSelectorDelegate As AuthenticationSchemeSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemeSelector ^ AuthenticationSchemeSelectorDelegate { System::Net::AuthenticationSchemeSelector ^ get(); void set(System::Net::AuthenticationSchemeSelector ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemeSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el delegado al que se llama para determinar el protocolo utilizado para autenticar los clientes.</summary>
        <value>Un delegado <see cref="T:System.Net.AuthenticationSchemeSelector" /> que invoca el método utilizado para seleccionar un protocolo de autenticación. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Si desea que el mismo protocolo de autenticación que se usará para todas las solicitudes administradas por una instancia determinada de <xref:System.Net.HttpListener>, no es necesario establecer esta propiedad. Para especificar un protocolo que se usará para todas las solicitudes de cliente, utilice la <xref:System.Net.HttpListener.AuthenticationSchemes%2A> propiedad.  
  
 Si el cliente no ha especificado la información de autenticación en sus encabezados, el <xref:System.Net.HttpListener> llama al delegado especificado para cada solicitud entrante no autenticada determinar lo que, si lo hay, protocolo utiliza para autenticar el cliente. El <xref:System.Net.HttpListener.GetContext%2A> y <xref:System.Net.HttpListener.EndGetContext%2A> métodos devuelven una solicitud entrante solamente si la <xref:System.Net.HttpListener> autentica correctamente la solicitud. Si no se puede autenticar una solicitud, el <xref:System.Net.HttpListener> automáticamente devuelve una respuesta 401. Puede obtener la identidad de un cliente autenticado correctamente mediante la <xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=nameWithType> propiedad.  
  
 La capacidad para delegar la elección del protocolo de autenticación a un método específico de la aplicación es útil si desea que una instancia de <xref:System.Net.HttpListener> utilizar protocolos de autenticación diferentes según las características de las solicitudes que recibe (por ejemplo, la solicitud <xref:System.Net.HttpListenerRequest.Url%2A> o <xref:System.Net.HttpListenerRequest.UserHostAddress%2A> propiedad).  
  
> [!NOTE]
>  Para establecer esta propiedad para habilitar Digest, NTLM o Negotiate se requiere el <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se establece el valor de esta propiedad.  
  
 [!code-csharp[NclListener#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#2)]
 [!code-vb[NclListener#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#2)]  
  
 En el ejemplo de código siguiente se proporciona una implementación de un método invocado por un <xref:System.Net.AuthenticationSchemeSelector> delegar.  
  
 [!code-csharp[NclListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#1)]
 [!code-vb[NclListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetContext">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetContext (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetContext(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetContext (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetContext(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Un delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invoca cuando está disponible una solicitud de cliente.</param>
        <param name="state">Objeto definido por el usuario que contiene información sobre la operación. Este objeto se pasa al delegado <c>callback</c> cuando la operación finaliza.</param>
        <summary>Empieza a recuperar de forma asincrónica una solicitud de entrada.</summary>
        <returns>Un objeto <see cref="T:System.IAsyncResult" /> que indica el estado de la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpListener.BeginGetContext%2A> método comienza una llamada asincrónica (sin bloqueo) para recibir solicitudes de cliente entrantes. Antes de llamar a este método, debe llamar a la <xref:System.Net.HttpListener.Start%2A> método y agregue al menos un prefijo de identificador uniforme de recursos (URI) para escuchar, agregando las cadenas URI para el <xref:System.Net.HttpListenerPrefixCollection> devuelto por la <xref:System.Net.HttpListener.Prefixes%2A> propiedad.  
  
 Debe completarse la operación asincrónica mediante una llamada a la <xref:System.Net.HttpListener.EndGetContext%2A> método. Normalmente, se invoca el método por el `callback` delegar.  
  
 Este método no se bloquea mientras se completa la operación. Para obtener una solicitud y el bloque entrantes hasta que se complete la operación, llame a la <xref:System.Net.HttpListener.GetContext%2A> método.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [al llamar a métodos sincrónicos asincrónicamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Net.HttpListener.BeginGetContext%2A> método para especificar un método de devolución de llamada que controlará las solicitudes de cliente entrantes.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 En el ejemplo de código siguiente se implementa un método de devolución de llamada.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Se ha producido un error en una llamada de función de Win32. Examine la propiedad <see cref="P:System.Net.HttpListenerException.ErrorCode" /> de la excepción para determinar su causa.</exception>
        <exception cref="T:System.InvalidOperationException">Este objeto no se ha iniciado o actualmente está detenido.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto está cerrado.</exception>
        <block subset="none" type="usage">
          <para>Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de llamar a este método, no podrá usar la <xref:System.Net.HttpListener> objeto. Para detener temporalmente un <xref:System.Net.HttpListener> objeto, utilice el <xref:System.Net.HttpListener.Stop%2A> método.  
  
 Este método apaga listas desplegables del <xref:System.Net.HttpListener> objeto sin tener que procesar solicitudes en cola. Cualquier solicitud pendiente es no se puede completar.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este método.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefaultServiceNames">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.DefaultServiceNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultServiceNames As ServiceNameCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ DefaultServiceNames { System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ServiceNameCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una lista predeterminada de nombres de proveedores de servicios (SPN) determinada por los prefijos registrados.</summary>
        <value>
          <see cref="T:System.Security.Authentication.ExtendedProtection.ServiceNameCollection" /> que contiene una lista de SPN.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpListener.DefaultServiceNames%2A> propiedad se utiliza con la autenticación integrada de Windows para proporcionar la protección extendida. La lista de los SPN se inicializa desde la <xref:System.Net.HttpListener.Prefixes%2A> propiedad cuando tiene acceso y se borra cuando se agregan los prefijos de nuevo a la <xref:System.Net.HttpListener.Prefixes%2A> propiedad.  
  
 El <xref:System.Net.HttpListener.DefaultServiceNames%2A> propiedad se utiliza si una aplicación no estableció la <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A> propiedad en su directiva de protección extendida.  
  
 El <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection> que se recupera con el <xref:System.Net.HttpListener.DefaultServiceNames%2A> propiedad se crea a partir del <xref:System.Net.HttpListener.Prefixes%2A> propiedad de acuerdo con las reglas siguientes:  
  
1.  Si el nombre de host es "+", "*", o un literal de IPv4 o IPv6 (equivalente a "\*" pero restringidos a una interfaz local específica), se agrega el siguiente SPN:  
  
 `"HTTP/"` junto con el nombre de dominio completo del equipo.  
  
1.  Si el nombre del host no contiene puntos (ningún dominios o subdominios), se realiza un intento para resolver el nombre de dominio completo mediante DNS (el mismo comportamiento utilizado por <xref:System.Net.HttpWebRequest>). Si se puede resolver el nombre de dominio completo, se agregan los siguientes SPN:  
  
 `"HTTP/"` Además, el nombre de host (el nombre corto).  
  
 `"HTTP/"` Además, el nombre de dominio completo del nombre de host.  
  
1.  Si el nombre del host no contiene puntos (ningún dominios o subdominios) y no se puede resolver un nombre de dominio completo, se agrega el siguiente SPN:  
  
 `"HTTP/"` Además, el nombre de host.  
  
1.  Si el nombre de host contiene puntos (dominios o subdominios), se agrega el siguiente SPN:  
  
 `"HTTP/"` Además, el nombre de host.  
  
 El <xref:System.Net.HttpListener.DefaultServiceNames%2A> propiedad puede utilizarse por una aplicación para revisar la lista de los SPN predeterminados que se usará para la autenticación si se especifica ninguna lista personalizada. Si se necesita otros SPN, una aplicación puede agregarlos utilizando uno de los <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A> métodos.  
  
 No es seguro para la ejecución cuando se usa la protección extendida para tomar decisiones de directiva basadas en la dirección URL solicitada, ya que esto puede ser suplantada. En su lugar, las aplicaciones deben depender del <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> o <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> propiedades a tomar estas decisiones de directiva.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="EndGetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext EndGetContext(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetContext (asyncResult As IAsyncResult) As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ EndGetContext(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Un objeto <see cref="T:System.IAsyncResult" /> que se obtuvo al iniciar la operación asincrónica.</param>
        <summary>Finaliza una operación asincrónica para recuperar una solicitud de cliente de entrada.</summary>
        <returns>Un objeto <see cref="T:System.Net.HttpListenerContext" /> que representa la solicitud de cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpListener.EndGetContext%2A> método se llama, normalmente dentro de un método de devolución de llamada definida por la aplicación que invoca un delegado, para obtener el <xref:System.Net.HttpListenerContext> objeto que contiene una solicitud de cliente entrante y su respuesta asociada. Este método completa una operación iniciada previamente mediante una llamada a la <xref:System.Net.HttpListener.BeginGetContext%2A> método. Si no se ha completado la operación, este método se bloquea hasta que lo hace.  
  
 Porque una llamada a la <xref:System.Net.HttpListener.EndGetContext%2A> método requiere el <xref:System.Net.HttpListener> objeto, este objeto se pasa normalmente a un método de devolución de llamada por mediante el objeto de estado pasado a la <xref:System.Net.HttpListener.BeginGetContext%2A> método. Puede obtener este objeto de estado mediante la <xref:System.IAsyncResult.AsyncState%2A> propiedad de la `asyncResult` objeto.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [al llamar a métodos sincrónicos asincrónicamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la implementación de un método de devolución de llamada que llama el <xref:System.Net.HttpListener.EndGetContext%2A> método.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          No se ha obtenido el valor <paramref name="asyncResult" /> llamando al método <see cref="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se llamó al método <see cref="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" /> para el objeto <paramref name="asyncResult" /> especificado.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto está cerrado.</exception>
        <block subset="none" type="usage">
          <para>Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionPolicy">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionPolicy As ExtendedProtectionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ ExtendedProtectionPolicy { System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ get(); void set(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("not used anywhere in the implementation")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> que se va a emplear para la protección extendida para una sesión.</summary>
        <value>Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> que especifica la directiva que se va a usar para la protección extendida.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> propiedad se utiliza con la autenticación integrada de Windows para proporcionar la protección extendida. El <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> propiedad permite la configuración de la directiva de protección extendida para todo el <xref:System.Net.HttpListener> sesión. El <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> propiedad permite la configuración de la directiva de protección extendida para cada solicitud individual.  
  
 La propiedad <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> debe ser `null`. El <xref:System.Net.HttpListener> instancia obtiene el enlace de Token canal (CBT) directamente desde su propia sesión TLS si hay alguno.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se intentó establecer la propiedad <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />, pero la propiedad <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> no era <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Se intentó establecer la propiedad <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> en <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se intentó establecer la propiedad <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> después de que ya se hubiera llamado al método <see cref="M:System.Net.HttpListener.Start" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto está cerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La propiedad <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement" /> se estableció en <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> en una plataforma que no admite la protección extendida.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListener/ExtendedProtectionSelector ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionSelectorDelegate As HttpListener.ExtendedProtectionSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListener::ExtendedProtectionSelector ^ ExtendedProtectionSelectorDelegate { System::Net::HttpListener::ExtendedProtectionSelector ^ get(); void set(System::Net::HttpListener::ExtendedProtectionSelector ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListener+ExtendedProtectionSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el delegado llamado para determinar el objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> que se va a emplear para cada solicitud.</summary>
        <value>Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> que especifica la directiva que se va a usar para la protección extendida.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> propiedad se utiliza con la autenticación integrada de Windows para proporcionar la protección extendida. El <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> propiedad permite la configuración de la directiva de protección extendida para todo el <xref:System.Net.HttpListener> sesión. El <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> propiedad permite la configuración de la directiva de protección extendida por solicitud individual.  
  
 La propiedad <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> debe ser `null`. El <xref:System.Net.HttpListener> instancia obtiene el enlace de Token canal (CBT) directamente desde su propia sesión TLS si hay alguno.  
  
 Para cada solicitud, el delegado puede elegir la configuración que el <xref:System.Net.HttpListener> instancia usará para proporcionar la protección extendida.  
  
 Si un delegado devuelve `null` para esta propiedad, esto representa un <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy> que la <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> propiedad establecida en <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se intentó establecer la propiedad <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />, pero la propiedad <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> debe ser <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Se intentó establecer la propiedad <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> en <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se intentó establecer la propiedad <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> después de que ya se hubiera llamado al método <see cref="M:System.Net.HttpListener.Start" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto está cerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Se hizo un intento de establecer la propiedad <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> en una plataforma que no admite la protección extendida.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="GetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext GetContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext GetContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContext () As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ GetContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Espera a una solicitud de entrada y vuelve cuando se recibe una.</summary>
        <returns>Un objeto <see cref="T:System.Net.HttpListenerContext" /> que representa una solicitud de cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de llamar a este método, debe llamar a la <xref:System.Net.HttpListener.Start%2A> método y agregue al menos un prefijo URI para escuchar, agregando las cadenas URI para el <xref:System.Net.HttpListenerPrefixCollection> devuelto por la <xref:System.Net.HttpListener.Prefixes%2A> propiedad. Para obtener una descripción detallada de los prefijos, vea la <xref:System.Net.HttpListener> Introducción a la clase.  
  
 Este método se bloquea mientras se espera una solicitud entrante. Si desea que las solicitudes entrantes a procesarse forma asincrónica (en subprocesos independientes) para que no bloquee la aplicación, use la <xref:System.Net.HttpListener.BeginGetContext%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este método.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Se ha producido un error en una llamada de función de Win32. Examine la propiedad <see cref="P:System.Net.HttpListenerException.ErrorCode" /> de la excepción para determinar su causa.</exception>
        <exception cref="T:System.InvalidOperationException">Este objeto no se ha iniciado o actualmente está detenido.  
  
 O bien  
  
 El objeto <see cref="T:System.Net.HttpListener" /> no tiene un prefijo de identificador URI al que responder.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto está cerrado.</exception>
        <block subset="none" type="usage">
          <para>Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetContextAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt; GetContextAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.HttpListenerContext&gt; GetContextAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContextAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextAsync () As Task(Of HttpListenerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::HttpListenerContext ^&gt; ^ GetContextAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Espera una solicitud entrante como una operación asincrónica.</summary>
        <returns>Devuelve <see cref="T:System.Threading.Tasks.Task`1" />.  
  
 Objeto de tarea que representa la operación asincrónica. La propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> en el objeto de tarea devuelve un objeto <see cref="T:System.Net.HttpListenerContext" /> que representa una solicitud de cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operación no se bloqueará. El valor devuelto <xref:System.Threading.Tasks.Task%601> objeto se completará cuando se ha recibido la solicitud entrante.  
  
 Antes de llamar a este método, debe llamar a la <xref:System.Net.HttpListener.Start%2A> método y agregue al menos un prefijo URI para escuchar, agregando las cadenas URI para el <xref:System.Net.HttpListenerPrefixCollection> devuelto por la <xref:System.Net.HttpListener.Prefixes%2A> propiedad. Para obtener una descripción detallada de los prefijos, vea la <xref:System.Net.HttpListener> Introducción a la clase.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListenerContext" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreWriteExceptions">
      <MemberSignature Language="C#" Value="public bool IgnoreWriteExceptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreWriteExceptions" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreWriteExceptions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreWriteExceptions { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor <see cref="T:System.Boolean" /> que especifica si su aplicación recibe las excepciones que aparecen cuando <see cref="T:System.Net.HttpListener" /> envía la respuesta al cliente.</summary>
        <value>
          Es <see langword="true" /> si <see cref="T:System.Net.HttpListener" /> no debe devolver las excepciones que aparecen cuando envía la respuesta al cliente; de lo contrario <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establezca esta propiedad en `true` si la aplicación no requiere que una respuesta se ha enviado correctamente a cada cliente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo establecer esta propiedad.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsListening">
      <MemberSignature Language="C#" Value="public bool IsListening { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsListening" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsListening" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsListening As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsListening { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se ha iniciado <see cref="T:System.Net.HttpListener" />.</summary>
        <value>
          Es <see langword="true" /> si se inició <see cref="T:System.Net.HttpListener" />; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para iniciar un <xref:System.Net.HttpListener>, llame a la <xref:System.Net.HttpListener.Start%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar esta propiedad para determinar el estado de escucha de una instancia.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSupported">
      <MemberSignature Language="C#" Value="public static bool IsSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsSupported" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsSupported { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Net.HttpListener" /> se puede utilizar con el sistema operativo actual.</summary>
        <value>
          Es <see langword="true" /> si se admite <see cref="T:System.Net.HttpListener" />; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta clase solo está disponible en equipos que ejecutan los sistemas operativos Windows XP SP2 o Windows Server 2003.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.HttpListener.IsSupported%2A> propiedad para detectar si un <xref:System.Net.HttpListener> objeto puede utilizarse con el sistema operativo actual.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixes">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerPrefixCollection Prefixes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerPrefixCollection Prefixes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Prefixes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Prefixes As HttpListenerPrefixCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerPrefixCollection ^ Prefixes { System::Net::HttpListenerPrefixCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerPrefixCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los prefijos de identificador uniforme de recursos (URI) controlados por este objeto <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Un objeto <see cref="T:System.Net.HttpListenerPrefixCollection" /> que contiene los prefijos URI que la configuración de este objeto <see cref="T:System.Net.HttpListener" /> le permite controlar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los prefijos están en forma canónica. Para obtener una descripción detallada de los prefijos, vea la <xref:System.Net.HttpListener> Introducción a la clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Net.HttpListener.Prefixes%2A> propiedad para obtener e imprimir los prefijos URI que se controlan.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Realm">
      <MemberSignature Language="C#" Value="public string Realm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Realm" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Realm" />
      <MemberSignature Language="VB.NET" Value="Public Property Realm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Realm { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el territorio, o partición de recurso, asociado con el objeto <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Un valor <see cref="T:System.String" /> que contiene el nombre del territorio asociado al objeto <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los servidores usan los dominios para particionar recursos protegidos; cada partición puede tener su propia base de datos de esquema o autorización de autenticación. Los dominios sólo se utilizan para la autenticación básica e implícita. Cuando un cliente se autentica correctamente, la autenticación es válida para todos los recursos de un dominio kerberos determinado. Para obtener una descripción detallada de los dominios, consulte RFC 2617 en [ https://www.ietf.org/ ](https://www.ietf.org/).  
  
 Una instancia de <xref:System.Net.HttpListener> tiene solo un dominio asociado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se demuestra cómo establecer el <xref:System.Net.HttpListener.Realm%2A> propiedad.  
  
 [!code-csharp[Net_Listener_Basic#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que esta instancia reciba solicitudes de entrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe llamar a este método antes de llamar a la <xref:System.Net.HttpListener.GetContext%2A> o <xref:System.Net.HttpListener.BeginGetContext%2A> método.  
  
 Después de haber iniciado una <xref:System.Net.HttpListener> objeto, puede usar el <xref:System.Net.HttpListener.Stop%2A> método para detenerlo.  
  
> [!NOTE]
>  Si esta instancia de agente de escucha utiliza https, debe instalar y seleccionar un certificado de servidor. En caso contrario, un <xref:System.Net.HttpWebRequest> consultas de este <xref:System.Net.HttpListener> se producirá un error con el cierre inesperado de la conexión. Puede configurar certificados de servidor y otras opciones de agente de escucha mediante HttpCfg.exe. Vea [ http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp ](http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) para obtener más detalles.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Net.HttpListener.Start%2A> método comience a procesar las solicitudes entrantes.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Se ha producido un error en una llamada de función de Win32. Examine la propiedad <see cref="P:System.Net.HttpListenerException.ErrorCode" /> de la excepción para determinar su causa.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto está cerrado.</exception>
        <block subset="none" type="usage">
          <para>Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hace que esta instancia deje de recibir solicitudes de entrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si esta instancia se ha detenido, llamar a este método no tiene efecto.  
  
 Después de haber detenido un <xref:System.Net.HttpListener> objeto, puede usar el <xref:System.Net.HttpListener.Start%2A> método reiniciarlo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Net.HttpListener.Stop%2A> método deje de procesar las solicitudes entrantes.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <block subset="none" type="usage">
          <para>Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos mantenidos por este objeto <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las aplicaciones deben utilizar el <xref:System.Net.HttpListener.Close%2A> método en lugar de llamar a este método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeoutManager">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerTimeoutManager TimeoutManager" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.TimeoutManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeoutManager As HttpListenerTimeoutManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerTimeoutManager ^ TimeoutManager { System::Net::HttpListenerTimeoutManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerTimeoutManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>El administrador de tiempo de espera para esta instancia <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Devuelve <see cref="T:System.Net.HttpListenerTimeoutManager" />.  
  
 El administrador de tiempo de espera para esta instancia <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El Administrador de tiempo de espera define los límites de tiempo de espera de conexión para esta <xref:System.Net.HttpListener> instancia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeConnectionNtlmAuthentication">
      <MemberSignature Language="C#" Value="public bool UnsafeConnectionNtlmAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeConnectionNtlmAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeConnectionNtlmAuthentication { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Support for NTLM needs some loving.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor <see cref="T:System.Boolean" /> que controla si, cuando se utiliza NTLM, se requieren solicitudes adicionales que utilicen la misma conexión del protocolo TCP (Protocolo de control de transmisión) para la autenticación.</summary>
        <value>
          Es <see langword="true" /> si el objeto <see cref="T:System.Security.Principal.IIdentity" /> de la primera solicitud debe utilizarse para las solicitudes posteriores de la misma conexión; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando esta propiedad se establece en `true` y la primera solicitud a través de una conexión TCP determinada se autentica utilizando NTLM, las solicitudes posteriores de la misma conexión TCP se procesarán utilizando la información de autenticación (<xref:System.Security.Principal.IIdentity>) de la solicitud inicial.  
  
 Esta propiedad no tiene ningún efecto si el protocolo de autenticación no es NTLM. Cuando se especifica Negotiate como protocolo de autenticación, esta propiedad no tiene un efecto sólo si NTLM es el protocolo utilizado para la autenticación.  
  
> [!NOTE]
>  Al establecer esta propiedad en `true` aumenta el rendimiento porque el <xref:System.Net.HttpListener> no no envío adicionales desafíos de autenticación NTLM, se corre el riesgo de seguridad no exigir a todas las solicitudes para proporcionar información de autenticación. Estudie si el aumento de rendimiento compensa este riesgo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo establecer esta propiedad.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
      </Docs>
    </Member>
  </Members>
</Type>