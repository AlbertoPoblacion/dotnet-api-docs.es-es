<Type Name="HttpListener" FullName="System.Net.HttpListener">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5cf85e11d98a02e74b8f4e39b325f1e6ce724e9e" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="59014917" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpListener : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListener extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListener" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListener&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListener sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type HttpListener = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Proporciona un agente de escucha del protocolo HTTP sencillo y controlado mediante programación. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mediante el <xref:System.Net.HttpListener> (clase), puede crear un agente de escucha de protocolo HTTP sencillo que responde a las solicitudes HTTP. El agente de escucha está activo durante la vigencia de la <xref:System.Net.HttpListener> objeto y se ejecuta dentro de la aplicación con sus permisos.
   
 Para usar <xref:System.Net.HttpListener>, crear una nueva instancia de la clase con el <xref:System.Net.HttpListener> constructor y use la <xref:System.Net.HttpListener.Prefixes%2A> la deprefijosdepropiedadparateneraccesoalacolecciónquecontienelascadenasqueespecificanquéidentificadoruniformederecursos(URI)<xref:System.Net.HttpListener>debe procesar.
  
 Una cadena de prefijo URI se compone de un esquema (http o https), un host, un puerto opcional y una ruta de acceso opcional. Un ejemplo de una cadena de prefijo completa es *http://www.contoso.com:8080/customerData/*. Los prefijos deben terminar en una barra diagonal ("/"). La <xref:System.Net.HttpListener> objeto con el prefijo que mejor coincida con un identificador URI solicitado responde a la solicitud. Varios <xref:System.Net.HttpListener> objetos no pueden agregar el mismo prefijo; un <xref:System.ComponentModel.Win32Exception> excepción se produce si un <xref:System.Net.HttpListener> agrega un prefijo que ya está en usar.
  
 Cuando se especifica un puerto, el elemento host puede reemplazarse por "\*" para indicar que el <xref:System.Net.HttpListener> acepta las solicitudes enviadas al puerto si el URI solicitado no coincide con ningún otro prefijo. Por ejemplo recibir todas las solicitudes enviadas al puerto 8080 al URI solicitado no se controla por cualquier <xref:System.Net.HttpListener>, el prefijo es *http://\*: 8080 /*. De forma similar, para especificar que el <xref:System.Net.HttpListener> acepta todas las solicitudes enviadas a un puerto, reemplace el elemento de host con el carácter "+". Por ejemplo, *https://+:8080*. El "\*" y "+" caracteres pueden estar presentes en prefijos que incluyen rutas de acceso.
  
 A partir de .NET Core 2.0 o .NET Framework 4.6 en Windows 10, subdominios comodín se admiten en los prefijos URI que se administran mediante un <xref:System.Net.HttpListener> objeto. Para especificar un comodín de subdominio, use la "\*" caracteres como parte del nombre de host en un prefijo de identificador URI. Por ejemplo, *http://\*.foo.com/*. Esto pasa como argumento para el <xref:System.Net.HttpListenerPrefixCollection.Add%2A> método. Esto funciona a partir de .NET Core 2.0 o .NET Framework 4.6 en Windows 10; en versiones anteriores, esto genera un <xref:System.Net.HttpListenerException>.

 > [!WARNING]
 > Enlaces de carácter comodín de nivel superior (*http://\*: 8080 /* y *http://+:8080*) debe **no** usarse. Los enlaces de carácter comodín de nivel superior pueden exponer su aplicación a vulnerabilidades de seguridad. Esto se aplica tanto a los caracteres comodín fuertes como a los débiles. Use nombres de host explícitos en lugar de caracteres comodín. Los enlaces de carácter comodín de subdominio (por ejemplo, `*.mysub.com`) no suponen este riesgo de seguridad si se controla todo el dominio primario (a diferencia de `*.com`, que sí es vulnerable). Vea la [sección 5.4 de RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.4) para obtener más información.
  
 Para empezar a escuchar las solicitudes de clientes, agregue los prefijos URI a la colección y llamar a la <xref:System.Net.HttpListener.Start%2A> método. <xref:System.Net.HttpListener> ofrece modelos sincrónicos y asincrónicos para procesar las solicitudes de cliente. Las solicitudes y sus respuestas asociadas son accesibles mediante el <xref:System.Net.HttpListenerContext> objeto devuelto por la <xref:System.Net.HttpListener.GetContext%2A> método o sus equivalentes asincrónicos, el <xref:System.Net.HttpListener.BeginGetContext%2A> y <xref:System.Net.HttpListener.EndGetContext%2A> métodos.
  
 El modelo sincrónico es adecuado si la aplicación debe bloquearse mientras espera una solicitud de cliente y si desea procesar una solicitud a la vez. Con el modelo sincrónico, llame a la <xref:System.Net.HttpListener.GetContext%2A> método, que espera a que un cliente enviar una solicitud. El método devuelve un <xref:System.Net.HttpListenerContext> objeto de procesamiento cuando uno se realiza.
  
 En el modelo asincrónico más complejo, la aplicación no se bloquea mientras espera de solicitudes y cada solicitud se procesa en su propio subproceso de ejecución. Use el <xref:System.Net.HttpListener.BeginGetContext%2A> método para especificar un método definido por la aplicación al que llamar para cada solicitud entrante. Dentro de ese método, llame a la <xref:System.Net.HttpListener.EndGetContext%2A> método para obtener la solicitud, procesarla y responder.
  
 En ambos casos, las solicitudes entrantes son accesibles mediante el <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType> propiedad y se representan mediante <xref:System.Net.HttpListenerRequest> objetos. De forma similar, las respuestas son accesibles mediante el <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=nameWithType> propiedad y se representan mediante <xref:System.Net.HttpListenerResponse> objetos. Estos objetos comparten algunas funciones con el <xref:System.Net.HttpWebRequest> y <xref:System.Net.HttpWebResponse> objetos, pero los objetos de este últimos no se puede usar junto con <xref:System.Net.HttpListener> porque implementan cliente, no de servidor, los comportamientos.
  
 Un <xref:System.Net.HttpListener> puede requerir la autenticación de cliente. Puede especificar un esquema concreto que se usará para la autenticación, o puede especificar a un delegado que determina el esquema que se usará. Necesita algún tipo de autenticación para obtener información sobre la identidad del cliente. Para obtener más información, consulte el <xref:System.Net.HttpListenerContext.User%2A>, <xref:System.Net.HttpListener.AuthenticationSchemes%2A>, y <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> propiedades.
  
> [!NOTE]
> Si creas un <xref:System.Net.HttpListener> mediante https, debe seleccionar un certificado de servidor para ese agente de escucha. En caso contrario, un <xref:System.Net.HttpWebRequest> consultas de este <xref:System.Net.HttpListener> se producirá un error con el cierre inesperado de la conexión.
  
> [!NOTE]
> Puede configurar certificados de servidor y otras opciones de agente de escucha mediante Shell de red (netsh.exe). Consulte [Shell de red (Netsh)](/windows-server/networking/technologies/netsh/netsh) para obtener más detalles. El archivo ejecutable suministrará con Windows Server 2008 y Windows Vista.
  
> [!NOTE]
> Si especifica varios esquemas de autenticación para el <xref:System.Net.HttpListener>, el agente de escucha supondrán un reto para los clientes en el siguiente orden: `Negotiate`, `NTLM`, `Digest`y, a continuación, `Basic`.
  
   
  
## Examples
 En el ejemplo de código siguiente se muestra cómo utilizar un <xref:System.Net.HttpListener>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Cambios en la autenticación NTLM para HTTPWebRequest en la versión 3.5 SP1</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpListener();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de usar la instancia devuelta por este constructor, debe invocar su <xref:System.Net.HttpListener.Start%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Net.HttpListener> constructor para crear un nuevo <xref:System.Net.HttpListener> objeto. Para obtener un ejemplo completo, vea el <xref:System.Net.HttpListener> tema de la clase.  
  
 [!code-csharp[Net_listener_Basic#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Esta clase no se puede utilizar en el sistema operativo actual. Se requiere Windows Server 2003 o Windows XP SP2 para poder utilizar instancias de esta clase.</exception>
        <block subset="none" type="usage"><para>Nota: Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpListener.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra inmediatamente el objeto <see cref="T:System.Net.HttpListener" />, descartando todas las solicitudes actualmente puestas en la cola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método elimina todos los recursos mantenidos por este agente de escucha. Las solicitudes pendientes son no se puede completar.  
  
 Después de llamar a este método, recibirá un <xref:System.ObjectDisposedException> si intenta utilizar este <xref:System.Net.HttpListener>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este método.  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemes">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.AuthenticationSchemes AuthenticationSchemes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemes" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemes As AuthenticationSchemes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemes AuthenticationSchemes { System::Net::AuthenticationSchemes get(); void set(System::Net::AuthenticationSchemes value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemes : System.Net.AuthenticationSchemes with get, set" Usage="System.Net.HttpListener.AuthenticationSchemes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el esquema utilizado para autenticar los clientes.</summary>
        <value>Una combinación bit a bit de valores de la enumeración <see cref="T:System.Net.AuthenticationSchemes" /> que indica cómo serán autenticados los clientes. El valor predeterminado es <see cref="F:System.Net.AuthenticationSchemes.Anonymous" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpListener> utiliza el esquema especificado para autenticar todas las solicitudes entrantes. El <xref:System.Net.HttpListener.GetContext%2A> y <xref:System.Net.HttpListener.EndGetContext%2A> métodos devuelven una solicitud de cliente entrante solo si el <xref:System.Net.HttpListener> la solicitud se autentica correctamente.  
  
 Puede consultar la identidad de un cliente autenticado correctamente mediante el uso de la <xref:System.Net.HttpListenerContext.User%2A?displayProperty=nameWithType> propiedad.  
  
 Si desea que un <xref:System.Net.HttpListener> objeto va a utilizar distintos mecanismos de autenticación en función de las características de las solicitudes que recibe (por ejemplo, la solicitud <xref:System.Net.HttpListenerRequest.Url%2A> o <xref:System.Net.HttpListenerRequest.UserHostName%2A> propiedad), debe implementar un método que elige el esquema de autenticación. Para obtener instrucciones sobre cómo hacerlo, consulte el <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> documentación de la propiedad.  
  
> [!NOTE]
>  Para establecer esta propiedad para habilitar Digest, NTLM o Negotiate requiere la <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Net.HttpListener.AuthenticationSchemes%2A> propiedad para especificar un esquema de autenticación.  
  
 [!code-csharp[Net_listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemeSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemeSelectorDelegate As AuthenticationSchemeSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemeSelector ^ AuthenticationSchemeSelectorDelegate { System::Net::AuthenticationSchemeSelector ^ get(); void set(System::Net::AuthenticationSchemeSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemeSelectorDelegate : System.Net.AuthenticationSchemeSelector with get, set" Usage="System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemeSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el delegado al que se llama para determinar el protocolo utilizado para autenticar los clientes.</summary>
        <value>Un delegado <see cref="T:System.Net.AuthenticationSchemeSelector" /> que invoca el método utilizado para seleccionar un protocolo de autenticación. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Si desea que el mismo protocolo de autenticación que se usará para todas las solicitudes controladas por una instancia determinada de <xref:System.Net.HttpListener>, no es necesario establecer esta propiedad. Para especificar un protocolo que se usará para todas las solicitudes de cliente, use el <xref:System.Net.HttpListener.AuthenticationSchemes%2A> propiedad.  
  
 Si el cliente no ha especificado la información de autenticación en sus encabezados, el <xref:System.Net.HttpListener> llama al delegado especificado para cada solicitud entrante no autenticada determinar que, si los hay, protocolo a utilizar para autenticar el cliente. El <xref:System.Net.HttpListener.GetContext%2A> y <xref:System.Net.HttpListener.EndGetContext%2A> métodos devuelven un solicitud entrante solamente si la <xref:System.Net.HttpListener> autenticado correctamente la solicitud. Si no se puede autenticar una solicitud, el <xref:System.Net.HttpListener> automáticamente envía de vuelta una respuesta 401. Puede obtener la identidad de un cliente autenticado correctamente mediante la <xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=nameWithType> propiedad.  
  
 La capacidad de delegar la elección del protocolo de autenticación a un método específico de la aplicación es útil si desea que una instancia de <xref:System.Net.HttpListener> usar protocolos de autenticación diferentes según las características de las solicitudes que recibe (para ejemplo, la solicitud <xref:System.Net.HttpListenerRequest.Url%2A> o <xref:System.Net.HttpListenerRequest.UserHostAddress%2A> propiedad).  
  
> [!NOTE]
>  Para establecer esta propiedad para habilitar Digest, NTLM o Negotiate requiere la <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 El ejemplo de código siguiente establece el valor de esta propiedad.  
  
 [!code-csharp[NclListener#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#2)]
 [!code-vb[NclListener#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#2)]  
  
 En el ejemplo de código siguiente se proporciona una implementación de un método invocado por un <xref:System.Net.AuthenticationSchemeSelector> delegar.  
  
 [!code-csharp[NclListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#1)]
 [!code-vb[NclListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetContext">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetContext (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetContext(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetContext (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetContext(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginGetContext : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpListener.BeginGetContext (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Un delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invoca cuando está disponible una solicitud de cliente.</param>
        <param name="state">Objeto definido por el usuario que contiene información sobre la operación. Este objeto se pasa al delegado de <paramref name="callback" /> cuando la operación ha terminado.</param>
        <summary>Empieza a recuperar de forma asincrónica una solicitud de entrada.</summary>
        <returns>Un objeto <see cref="T:System.IAsyncResult" /> que indica el estado de la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpListener.BeginGetContext%2A> método comienza una llamada asincrónica (sin bloqueo) para recibir solicitudes de cliente entrantes. Antes de llamar a este método, debe llamar a la <xref:System.Net.HttpListener.Start%2A> método y agregue al menos un prefijo de identificador uniforme de recursos (URI) para que escuche agregando las cadenas URI para el <xref:System.Net.HttpListenerPrefixCollection> devuelto por la <xref:System.Net.HttpListener.Prefixes%2A> propiedad.  
  
 Debe completar la operación asincrónica mediante una llamada a la <xref:System.Net.HttpListener.EndGetContext%2A> método. Normalmente, se invoca el método por el `callback` delegar.  
  
 Este método no bloquea mientras se completa la operación. Para obtener una solicitud y el bloque entrantes hasta que se complete la operación, llame a la <xref:System.Net.HttpListener.GetContext%2A> método.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Net.HttpListener.BeginGetContext%2A> método para especificar un método de devolución de llamada que controlará las solicitudes de cliente entrantes.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 El ejemplo de código siguiente implementa un método de devolución de llamada.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Se ha producido un error en una llamada de función de Win32. Examine la propiedad <see cref="P:System.Net.HttpListenerException.ErrorCode" /> de la excepción para determinar su causa.</exception>
        <exception cref="T:System.InvalidOperationException">Este objeto no se ha iniciado o actualmente está detenido.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto está cerrado.</exception>
        <block subset="none" type="usage"><para>Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpListener.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de llamar a este método, ya no puede usar el <xref:System.Net.HttpListener> objeto. Para detener temporalmente una <xref:System.Net.HttpListener> de objeto, utilice el <xref:System.Net.HttpListener.Stop%2A> método.  
  
 Este método cierra listas desplegables del <xref:System.Net.HttpListener> objeto sin tener que procesar solicitudes en cola. Las solicitudes pendientes son no se puede completar.  
  
## Examples  

El ejemplo de código siguiente se muestra cómo llamar el `Close` método:
  
[!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DefaultServiceNames">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.DefaultServiceNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultServiceNames As ServiceNameCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ DefaultServiceNames { System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultServiceNames : System.Security.Authentication.ExtendedProtection.ServiceNameCollection" Usage="System.Net.HttpListener.DefaultServiceNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ServiceNameCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una lista predeterminada de nombres de proveedores de servicios (SPN) determinada por los prefijos registrados.</summary>
        <value><see cref="T:System.Security.Authentication.ExtendedProtection.ServiceNameCollection" /> que contiene una lista de SPN.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpListener.DefaultServiceNames%2A> propiedad se utiliza con la autenticación integrada de Windows para proporcionar la protección extendida. La lista de los SPN se inicializa desde la <xref:System.Net.HttpListener.Prefixes%2A> propiedad cuando tiene acceso a y se borra cuando se agregan los prefijos de nuevo a la <xref:System.Net.HttpListener.Prefixes%2A> propiedad.  
  
 El <xref:System.Net.HttpListener.DefaultServiceNames%2A> propiedad se utiliza si una aplicación no estableció la <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A> propiedad en su directiva de protección extendida.  
  
 El <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection> que se recupera con el <xref:System.Net.HttpListener.DefaultServiceNames%2A> propiedad se crea a partir del <xref:System.Net.HttpListener.Prefixes%2A> propiedad según las reglas siguientes:  
  
1.  Si es el nombre de host "+", "*", o un literal IPv4 o IPv6 (equivalente a "\*", pero se restringe a una interfaz local específica), se agrega el SPN siguiente:  
  
 `"HTTP/"` Además, el nombre de dominio completo del equipo.  
  
1.  Si el nombre de host no contiene puntos (no hay dominios o subdominios), se realiza un intento para resolver el nombre de dominio completo mediante DNS (el mismo comportamiento usando <xref:System.Net.HttpWebRequest>). Si se puede resolver el nombre de dominio completo, se agregan los siguientes SPN:  
  
 `"HTTP/"` Además, el nombre de host (el nombre corto).  
  
 `"HTTP/"` Además, el nombre de dominio completo del nombre de host.  
  
1.  Si el nombre de host no contiene puntos (no hay dominios o subdominios) y no se puede resolver un nombre de dominio completo, se agrega el SPN siguiente:  
  
 `"HTTP/"` Además, el nombre de host.  
  
1.  Si el nombre de host contiene puntos (dominios o subdominios), se agrega el SPN siguiente:  
  
 `"HTTP/"` Además, el nombre de host.  
  
 El <xref:System.Net.HttpListener.DefaultServiceNames%2A> propiedad puede utilizarse por una aplicación para revisar la lista de los SPN predeterminados que se usará para la autenticación si se especifica ninguna lista personalizada. Si se necesita otros SPN, una aplicación puede agregarlos mediante uno de los <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A> métodos.  
  
 No es seguro al usar protección ampliada para tomar decisiones de directiva basadas en la dirección URL solicitada, ya que esto puede ser suplantada. En su lugar, las aplicaciones deben basarse en el <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> o <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> las propiedades para adaptar estas decisiones de directiva.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext EndGetContext(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetContext (asyncResult As IAsyncResult) As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ EndGetContext(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndGetContext : IAsyncResult -&gt; System.Net.HttpListenerContext" Usage="httpListener.EndGetContext asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Un objeto <see cref="T:System.IAsyncResult" /> que se obtuvo al iniciar la operación asincrónica.</param>
        <summary>Finaliza una operación asincrónica para recuperar una solicitud de cliente de entrada.</summary>
        <returns>Un objeto <see cref="T:System.Net.HttpListenerContext" /> que representa la solicitud de cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpListener.EndGetContext%2A> se denomina método, normalmente dentro de un método de devolución de llamada definido por la aplicación por un delegado para obtener el <xref:System.Net.HttpListenerContext> objeto que contiene una solicitud de cliente entrantes y su respuesta asociada. Este método completa una operación iniciada previamente mediante una llamada a la <xref:System.Net.HttpListener.BeginGetContext%2A> método. Si no se ha completado la operación, este método se bloquea hasta que lo haga.  
  
 Dado que una llamada a la <xref:System.Net.HttpListener.EndGetContext%2A> método requiere el <xref:System.Net.HttpListener> objeto, este objeto normalmente se pasa a un método de devolución de llamada por utilizando el objeto de estado pasado a la <xref:System.Net.HttpListener.BeginGetContext%2A> método. Puede obtener este objeto de estado mediante la <xref:System.IAsyncResult.AsyncState%2A> propiedad de la `asyncResult` objeto.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la implementación de un método de devolución de llamada que llama el <xref:System.Net.HttpListener.EndGetContext%2A> método.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No se ha obtenido el valor <paramref name="asyncResult" /> llamando al método <see cref="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.HttpListenerException">Se ha producido un error en una llamada de función de Win32. Examine la propiedad <see cref="P:System.Net.HttpListenerException.ErrorCode" /> de la excepción para determinar su causa.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se llamó al método <see cref="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" /> para el objeto <paramref name="asyncResult" /> especificado.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto está cerrado.</exception>
        <block subset="none" type="usage"><para>Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionPolicy">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionPolicy As ExtendedProtectionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ ExtendedProtectionPolicy { System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ get(); void set(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionPolicy : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy with get, set" Usage="System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("not used anywhere in the implementation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> que se va a emplear para la protección extendida para una sesión.</summary>
        <value>Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> que especifica la directiva que se va a usar para la protección extendida.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> propiedad se utiliza con la autenticación integrada de Windows para proporcionar la protección extendida. El <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> propiedad permite la configuración de la directiva de protección extendida para todo el <xref:System.Net.HttpListener> sesión. El <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> propiedad permite la configuración de la directiva de protección extendida para cada solicitud individual.  
  
 La propiedad <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> debe ser `null`. El <xref:System.Net.HttpListener> instancia obtiene el canal de enlace de Token (CBT) directamente desde su propia sesión TLS si hay alguno.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se intentó establecer la propiedad <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />, pero la propiedad <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> no era <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Se intentó establecer la propiedad <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> en <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se intentó establecer la propiedad <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> después de que ya se hubiera llamado al método <see cref="M:System.Net.HttpListener.Start" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto está cerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La propiedad <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement" /> se estableció en <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> en una plataforma que no admite la protección extendida.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListener/ExtendedProtectionSelector ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionSelectorDelegate As HttpListener.ExtendedProtectionSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListener::ExtendedProtectionSelector ^ ExtendedProtectionSelectorDelegate { System::Net::HttpListener::ExtendedProtectionSelector ^ get(); void set(System::Net::HttpListener::ExtendedProtectionSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionSelectorDelegate : System.Net.HttpListener.ExtendedProtectionSelector with get, set" Usage="System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListener+ExtendedProtectionSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el delegado llamado para determinar el objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> que se va a emplear para cada solicitud.</summary>
        <value>Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> que especifica la directiva que se va a usar para la protección extendida.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> propiedad se utiliza con la autenticación integrada de Windows para proporcionar la protección extendida. El <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> propiedad permite la configuración de la directiva de protección extendida para todo el <xref:System.Net.HttpListener> sesión. El <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> propiedad permite la configuración de la directiva de protección extendida por solicitud individual.  
  
 La propiedad <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> debe ser `null`. El <xref:System.Net.HttpListener> instancia obtiene el canal de enlace de Token (CBT) directamente desde su propia sesión TLS si hay alguno.  
  
 Para cada solicitud, el delegado puede elegir la configuración que el <xref:System.Net.HttpListener> instancia usará para proporcionar protección extendida.  
  
 Si devuelve un delegado `null` para esta propiedad, esto representa un <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy> que la <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> propiedad establecida en <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se intentó establecer la propiedad <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />, pero la propiedad <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> debe ser <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Se intentó establecer la propiedad <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> en <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se intentó establecer la propiedad <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> después de que ya se hubiera llamado al método <see cref="M:System.Net.HttpListener.Start" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto está cerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Se hizo un intento de establecer la propiedad <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> en una plataforma que no admite la protección extendida.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <Member MemberName="GetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext GetContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext GetContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContext () As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ GetContext();" />
      <MemberSignature Language="F#" Value="member this.GetContext : unit -&gt; System.Net.HttpListenerContext" Usage="httpListener.GetContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Espera a una solicitud de entrada y vuelve cuando se recibe una.</summary>
        <returns>Un objeto <see cref="T:System.Net.HttpListenerContext" /> que representa una solicitud de cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de llamar a este método, debe llamar a la <xref:System.Net.HttpListener.Start%2A> método y agregue al menos un prefijo de identificador URI para que escuche agregando las cadenas URI para el <xref:System.Net.HttpListenerPrefixCollection> devuelto por la <xref:System.Net.HttpListener.Prefixes%2A> propiedad. Para obtener una descripción detallada de los prefijos, vea el <xref:System.Net.HttpListener> información general de clases.  
  
 Este método se bloquea mientras espera una solicitud entrante. Si desea que las solicitudes entrantes se procesa asincrónicamente (en subprocesos independientes) para que no bloquee la aplicación, utilice el <xref:System.Net.HttpListener.BeginGetContext%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este método.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Se ha producido un error en una llamada de función de Win32. Examine la propiedad <see cref="P:System.Net.HttpListenerException.ErrorCode" /> de la excepción para determinar su causa.</exception>
        <exception cref="T:System.InvalidOperationException">Este objeto no se ha iniciado o actualmente está detenido.  
  
O bien 
El objeto <see cref="T:System.Net.HttpListener" /> no tiene un prefijo de identificador URI al que responder.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto está cerrado.</exception>
        <block subset="none" type="usage"><para>Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetContextAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt; GetContextAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.HttpListenerContext&gt; GetContextAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContextAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextAsync () As Task(Of HttpListenerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::HttpListenerContext ^&gt; ^ GetContextAsync();" />
      <MemberSignature Language="F#" Value="member this.GetContextAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;" Usage="httpListener.GetContextAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Espera una solicitud entrante como una operación asincrónica.</summary>
        <returns>Objeto de tarea que representa la operación asincrónica. La propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> en el objeto de tarea devuelve un objeto <see cref="T:System.Net.HttpListenerContext" /> que representa una solicitud de cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operación no se bloqueará. El valor devuelto <xref:System.Threading.Tasks.Task%601> objeto se completará cuando se ha recibido la solicitud entrante.  
  
 Antes de llamar a este método, debe llamar a la <xref:System.Net.HttpListener.Start%2A> método y agregue al menos un prefijo de identificador URI para que escuche agregando las cadenas URI para el <xref:System.Net.HttpListenerPrefixCollection> devuelto por la <xref:System.Net.HttpListener.Prefixes%2A> propiedad. Para obtener una descripción detallada de los prefijos, vea el <xref:System.Net.HttpListener> información general de clases.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListenerContext" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreWriteExceptions">
      <MemberSignature Language="C#" Value="public bool IgnoreWriteExceptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreWriteExceptions" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreWriteExceptions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreWriteExceptions { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreWriteExceptions : bool with get, set" Usage="System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor <see cref="T:System.Boolean" /> que especifica si su aplicación recibe las excepciones que aparecen cuando <see cref="T:System.Net.HttpListener" /> envía la respuesta al cliente.</summary>
        <value><see langword="true" /> Si este <see cref="T:System.Net.HttpListener" /> no debe devolver las excepciones que se producen al enviar la respuesta al cliente; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establezca esta propiedad en `true` si la aplicación no requiere que una respuesta se envía correctamente a cada cliente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo establecer esta propiedad.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsListening">
      <MemberSignature Language="C#" Value="public bool IsListening { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsListening" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsListening" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsListening As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsListening { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsListening : bool" Usage="System.Net.HttpListener.IsListening" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se ha iniciado <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Es <see langword="true" /> si se inició <see cref="T:System.Net.HttpListener" />; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para iniciar un <xref:System.Net.HttpListener>, llame a la <xref:System.Net.HttpListener.Start%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar esta propiedad para determinar el estado de escucha de una instancia.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSupported">
      <MemberSignature Language="C#" Value="public static bool IsSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsSupported" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsSupported { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSupported : bool" Usage="System.Net.HttpListener.IsSupported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Net.HttpListener" /> se puede utilizar con el sistema operativo actual.</summary>
        <value>Es <see langword="true" /> si se admite <see cref="T:System.Net.HttpListener" />; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta clase está disponible solo en equipos que ejecutan los sistemas operativos Windows XP SP2 o Windows Server 2003.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.HttpListener.IsSupported%2A> propiedad para detectar si un <xref:System.Net.HttpListener> objeto puede utilizarse con el sistema operativo actual.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixes">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerPrefixCollection Prefixes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerPrefixCollection Prefixes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Prefixes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Prefixes As HttpListenerPrefixCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerPrefixCollection ^ Prefixes { System::Net::HttpListenerPrefixCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefixes : System.Net.HttpListenerPrefixCollection" Usage="System.Net.HttpListener.Prefixes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerPrefixCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los prefijos de identificador URI controlados por este objeto <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Un objeto <see cref="T:System.Net.HttpListenerPrefixCollection" /> que contiene los prefijos URI que la configuración de este objeto <see cref="T:System.Net.HttpListener" /> le permite controlar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los prefijos son en forma canónica. Para obtener una descripción detallada de los prefijos, vea el <xref:System.Net.HttpListener> información general de clases.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Net.HttpListener.Prefixes%2A> propiedad para obtener e imprimir los prefijos URI que se controlan.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Realm">
      <MemberSignature Language="C#" Value="public string Realm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Realm" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Realm" />
      <MemberSignature Language="VB.NET" Value="Public Property Realm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Realm { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Realm : string with get, set" Usage="System.Net.HttpListener.Realm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el territorio, o partición de recurso, asociado con el objeto <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Un valor <see cref="T:System.String" /> que contiene el nombre del territorio asociado al objeto <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los servidores usan los dominios para particionar recursos protegidos; cada partición puede tener su propia base de datos de autorización o de esquema de autenticación. Los dominios sólo se utilizan para la autenticación básica e implícita. Cuando un cliente se autentica correctamente, la autenticación es válida para todos los recursos de un dominio kerberos determinado. Para obtener una descripción detallada de dominios Kerberos, consulte RFC 2617 en [ https://www.ietf.org/ ](https://www.ietf.org/).  
  
 Una instancia de <xref:System.Net.HttpListener> tiene asociado un solo territorio.  
  
   
  
## Examples  
 El ejemplo de código siguiente se muestra cómo establecer el <xref:System.Net.HttpListener.Realm%2A> propiedad.  
  
 [!code-csharp[Net_Listener_Basic#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="httpListener.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que esta instancia reciba solicitudes de entrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método debe llamarse antes de llamar a la <xref:System.Net.HttpListener.GetContext%2A> o <xref:System.Net.HttpListener.BeginGetContext%2A> método.  
  
 Después de haber iniciado una <xref:System.Net.HttpListener> objeto, puede usar el <xref:System.Net.HttpListener.Stop%2A> método para detenerlo.  
  
> [!NOTE]
>  Si esta instancia de agente de escucha usa https, debe instalar y seleccionar un certificado de servidor. En caso contrario, un <xref:System.Net.HttpWebRequest> consultas de este <xref:System.Net.HttpListener> se producirá un error con el cierre inesperado de la conexión. Puede configurar certificados de servidor y otras opciones de agente de escucha mediante HttpCfg.exe. Consulte [ http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp ](https://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) para obtener más detalles.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Net.HttpListener.Start%2A> método para comenzar a procesar las solicitudes entrantes.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Se ha producido un error en una llamada de función de Win32. Examine la propiedad <see cref="P:System.Net.HttpListenerException.ErrorCode" /> de la excepción para determinar su causa.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto está cerrado.</exception>
        <block subset="none" type="usage"><para>Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="httpListener.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hace que esta instancia deje de recibir solicitudes de entrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si esta instancia se ha detenido, llamar a este método no tiene ningún efecto.  
  
 Después de haber detenido un <xref:System.Net.HttpListener> objeto, puede usar el <xref:System.Net.HttpListener.Start%2A> método reiniciarlo.  
  
   
  
## Examples  
 
En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Net.HttpListener.Stop%2A> método para detener el procesamiento de solicitudes entrantes.  
 
[!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <block subset="none" type="usage"><para>Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos mantenidos por este objeto <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las aplicaciones deben usar el <xref:System.Net.HttpListener.Close%2A> método en lugar de llamar a este método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeoutManager">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerTimeoutManager TimeoutManager" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.TimeoutManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeoutManager As HttpListenerTimeoutManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerTimeoutManager ^ TimeoutManager { System::Net::HttpListenerTimeoutManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TimeoutManager : System.Net.HttpListenerTimeoutManager" Usage="System.Net.HttpListener.TimeoutManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerTimeoutManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>El administrador de tiempo de espera para esta instancia <see cref="T:System.Net.HttpListener" /> .</summary>
        <value>El administrador de tiempo de espera para esta instancia <see cref="T:System.Net.HttpListener" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El Administrador de tiempo de espera define los límites de tiempo de espera de conexión para este <xref:System.Net.HttpListener> instancia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeConnectionNtlmAuthentication">
      <MemberSignature Language="C#" Value="public bool UnsafeConnectionNtlmAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeConnectionNtlmAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeConnectionNtlmAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeConnectionNtlmAuthentication : bool with get, set" Usage="System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Support for NTLM needs some loving.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor <see cref="T:System.Boolean" /> que controla si, cuando se utiliza NTLM, se requieren solicitudes adicionales que utilicen la misma conexión del protocolo TCP (Protocolo de control de transporte) para la autenticación.</summary>
        <value>Es <see langword="true" /> si el objeto <see cref="T:System.Security.Principal.IIdentity" /> de la primera solicitud debe utilizarse para las solicitudes posteriores de la misma conexión; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando esta propiedad se establece en `true` y la primera solicitud a través de una conexión TCP determinada se autentica utilizando NTLM, se procesan las solicitudes posteriores de la misma conexión TCP con la información de autenticación (<xref:System.Security.Principal.IIdentity>) de la inicial solicitud.  
  
 Esta propiedad no tiene ningún efecto si el protocolo de autenticación no es NTLM. Cuando se especifica Negotiate como el protocolo de autenticación, esta propiedad tiene un efecto sólo si NTLM es el protocolo utilizado para la autenticación.  
  
> [!NOTE]
>  Al establecer esta propiedad en `true` aumenta el rendimiento porque el <xref:System.Net.HttpListener> no no envío autenticación NTLM adicionales, hay un riesgo de seguridad no exigir a todas las solicitudes para proporcionar información de autenticación. Estudie si el aumento de rendimiento compensa este riesgo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo establecer esta propiedad.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
