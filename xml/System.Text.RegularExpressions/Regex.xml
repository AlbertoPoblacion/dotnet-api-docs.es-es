<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Regex.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5646ce7ee28b4835a77eed74edc78f5d335dd6320.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">646ce7ee28b4835a77eed74edc78f5d335dd6320</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Represents an immutable regular expression.</source>
          <target state="translated">Representa una expresión regular inmutable.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class represents the .NET Framework's regular expression engine.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> clase representa el motor de expresiones regulares de .NET Framework.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>It can be used to quickly parse large amounts of text to find specific character patterns; to extract, edit, replace, or delete text substrings; and to add the extracted strings to a collection to generate a report.</source>
          <target state="translated">Se puede utilizar para analizar rápidamente grandes cantidades de texto para buscar patrones de caracteres específicos; para extraer, editar, reemplazar o eliminar subcadenas de texto; y para agregar las cadenas extraídas a una colección para generar un informe.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If your primary interest is to validate a string by determining whether it conforms to a particular pattern, you can use the <ph id="ph1">&lt;xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">Si su interés primario es validar una cadena mediante la determinación de si se ajusta a un patrón determinado, puede usar el <ph id="ph1">&lt;xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To use regular expressions, you define the pattern that you want to identify in a text stream by using the syntax documented in <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para usar expresiones regulares, defina el modelo que desea identificar en una secuencia de texto utilizando la sintaxis documentada en <bpt id="p1">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Next, you can optionally instantiate a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">A continuación, puede crear instancias opcionalmente un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Finally, you call a method that performs some operation, such as replacing text that matches the regular expression pattern, or identifying a pattern match.</source>
          <target state="translated">Por último, llamar a un método que realiza alguna operación, como reemplazar texto que coincide con el patrón de expresión regular, o identifique a una coincidencia de patrones.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For some common regular expression patterns, see <bpt id="p1">[</bpt>Regular Expression Examples<ept id="p1">](~/docs/standard/base-types/regular-expression-examples.md)</ept>.</source>
          <target state="translated">Para algunos patrones de expresiones regulares comunes, consulte <bpt id="p1">[</bpt>ejemplos de expresiones regulares<ept id="p1">](~/docs/standard/base-types/regular-expression-examples.md)</ept>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>There are also a number of online libraries of regular expression patterns, such as the one at <bpt id="p1">[</bpt>Regular-Expressions.info<ept id="p1">](http://www.regular-expressions.info/examples.html)</ept>.</source>
          <target state="translated">También hay una serie de las bibliotecas en línea de patrones de expresiones regulares, como al <bpt id="p1">[</bpt>-expresiones regulares<ept id="p1">](http://www.regular-expressions.info/examples.html)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">&lt;a name="remarks"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> For more information about using the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class, see the following sections in this topic:</source>
          <target state="translated"><bpt id="p1">&lt;a name="remarks"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Para obtener más información sobre el uso de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> de clases, consulte las siguientes secciones de este tema:</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Regex vs. String Methods<ept id="p1">](#regex_vs_string)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Frente a Regex. Métodos de cadena<ept id="p1">](#regex_vs_string)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Static vs. Instance Methods<ept id="p1">](#static_vs_instance)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Puertos estáticos frente a Métodos de instancia<ept id="p1">](#static_vs_instance)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Performing Regular Expression Operations<ept id="p1">](#regex_ops)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Realizar operaciones de expresiones regulares<ept id="p1">](#regex_ops)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Defining a Time-Out Value<ept id="p1">](#define_timeout)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Definir un valor de tiempo de espera<ept id="p1">](#define_timeout)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information about the regular expression language, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> or download and print one of these brochures:</source>
          <target state="translated">Para obtener más información acerca del lenguaje de expresiones regulares, consulte <bpt id="p1">[</bpt>Lenguaje de expresiones regulares - Referencia rápida<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> o descargue e imprima uno de estos folletos:</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Quick Reference in Word (.docx) format<ept id="p1">](http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Referencia rápida en formato Word (.docx)<ept id="p1">](http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Quick Reference in PDF (.pdf) format<ept id="p1">](http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Referencia rápida en formato PDF (.pdf)<ept id="p1">](http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Regex vs. String Methods</source>
          <target state="translated">Frente a Regex. Métodos de cadena</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> class includes several search and comparison methods that you can use to perform pattern matching with text.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> clase incluye varios métodos de comparación y de búsqueda que puede usar para realizar la coincidencia de patrones con texto.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Contains%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> methods determine whether a string instance contains a specified substring; and the <ph id="ph4">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOfAny%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph7">&lt;xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType&gt;</ph> methods return the starting position of a specified substring in a string.</source>
          <target state="translated">Por ejemplo, el <ph id="ph1">&lt;xref:System.String.Contains%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A?displayProperty=nameWithType&gt;</ph>, y <ph id="ph3">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> métodos determinan si una instancia de cadena contiene una subcadena especificada; y la <ph id="ph4">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOfAny%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>, y <ph id="ph7">&lt;xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType&gt;</ph> métodos devuelven la posición inicial de una subcadena especificada en una cadena.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Use the methods of the <ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> class when you are searching for a specific string.</source>
          <target state="translated">Use los métodos de la <ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> clase cuando se está buscando una cadena específica.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class when you are searching for a specific pattern in a string.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> clase cuando se está buscando un patrón específico en una cadena.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information and examples, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</source>
          <target state="translated">Para obtener más información y ejemplos, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Volver a comentarios<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Static vs. Instance Methods</source>
          <target state="translated">Puertos estáticos frente a Métodos de instancia</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>After you define a regular expression pattern, you can provide it to the regular expression engine in either of two ways:</source>
          <target state="translated">Después de definir un patrón de expresión regular, puede proporcionar al motor de expresiones regulares en cualquiera de estas dos maneras:</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By instantiating a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object that represents the regular expression.</source>
          <target state="translated">Creando un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto que representa la expresión regular.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To do this, you pass the regular expression pattern to a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">Para ello, pase el patrón de expresión regular a un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%2A&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable; when you instantiate a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with a regular expression, that object's regular expression cannot be changed.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto es inmutable; cuando se crea una instancia una <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto con una expresión regular, que no se puede cambiar la expresión regular del objeto.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By supplying both the regular expression and the text to search to a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> method.</source>
          <target state="translated">Si se suministra la expresión regular y el texto que desea buscar en un <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> en Visual Basic) <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This enables you to use a regular expression without explicitly creating a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">Esto le permite usar una expresión regular sin crear explícitamente un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>All <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> pattern identification methods include both static and instance overloads.</source>
          <target state="translated">Todos los <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> métodos de identificación de modelo son estáticos y de instancia sobrecargas.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The regular expression engine must compile a particular pattern before the pattern can be used.</source>
          <target state="translated">El motor de expresiones regulares debe compilar un modelo determinado antes de que se puede usar el modelo.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Because <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objects are immutable, this is a one-time procedure that occurs when a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructor or a static method is called.</source>
          <target state="translated">Dado que <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objetos son inmutables, se trata de un procedimiento de un solo uso que se produce cuando un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se denomina constructor de clase o un método estático.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To eliminate the need to repeatedly compile a single regular expression, the regular expression engine caches the compiled regular expressions used in static method calls.</source>
          <target state="translated">Para eliminar la necesidad de compilar varias veces una única expresión regular, el motor de expresiones regulares almacena en caché las expresiones regulares compiladas usadas en llamadas a métodos estáticos.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>As a result, regular expression pattern-matching methods offer comparable performance for static and instance methods.</source>
          <target state="translated">Como resultado, los métodos de coincidencia de patrón de expresión regular ofrecen un rendimiento comparable para estático y métodos de instancia.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In the .NET Framework versions 1.0 and 1.1, all compiled regular expressions, whether they were used in instance or static method calls, were cached.</source>
          <target state="translated">En las expresiones regulares de .NET Framework versiones 1.0 y 1.1, todos los compilado, si se usan en la instancia o método estático llama, se almacenaron en caché.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Starting with the .NET Framework 2.0, only regular expressions used in static method calls are cached.</source>
          <target state="translated">A partir de .NET Framework 2.0, solo los expresiones regulares que se utilizan en llamadas a métodos estáticos se almacenan en caché.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>However, caching can adversely affect performance in the following two cases:</source>
          <target state="translated">Sin embargo, el almacenamiento en caché puede afectar negativamente al rendimiento en los dos casos siguientes:</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>When you use static method calls with a large number of regular expressions.</source>
          <target state="translated">Al utilizar llamadas a métodos estáticos con un gran número de expresiones regulares.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By default, the regular expression engine caches the 15 most recently used static regular expressions.</source>
          <target state="translated">De forma predeterminada, el motor de expresiones regulares almacena en caché las 15 expresiones regulares estáticas usadas más recientemente.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If your application uses more than 15 static regular expressions, some regular expressions must be recompiled.</source>
          <target state="translated">Si la aplicación usa más de 15 expresiones regulares estáticas, algunas expresiones regulares deben compilarse.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To prevent this recompilation, you can increase the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para evitar que esta recompilación, puede aumentar la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>When you instantiate new <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objects with regular expressions that have previously been compiled.</source>
          <target state="translated">Cuando se crea una instancia nueva <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objetos con expresiones regulares que se han compilado previamente.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For example, the following code defines a regular expression to locate duplicated words in a text stream.</source>
          <target state="translated">Por ejemplo, el código siguiente define una expresión regular para buscar palabras duplicadas en una secuencia de texto.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Although the example uses a single regular expression, it instantiates a new <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object to process each line of text.</source>
          <target state="translated">Aunque en el ejemplo usa una única expresión regular, crea una instancia de un nuevo <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto para procesar cada línea de texto.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This results in the recompilation of the regular expression with each iteration of the loop.</source>
          <target state="translated">Esto da como resultado la recompilación de la expresión regular con cada iteración del bucle.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To prevent recompilation, you should instantiate a single <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object that is accessible to all code that requires it, as shown in the following rewritten example.</source>
          <target state="translated">Para evitar volver a compilar, debe crear una instancia de una sola <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto que sea accesible a todo el código que lo requiera, como se muestra en el ejemplo siguiente se ha vuelto a escribir.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Volver a comentarios<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Performing Regular Expression Operations</source>
          <target state="translated">Realizar operaciones de expresiones regulares</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Whether you decide to instantiate a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object and call its methods or call static methods, the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class offers the following pattern-matching functionality:</source>
          <target state="translated">Si decide crear una instancia de un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto y llamar a sus métodos o llamar a métodos estáticos, el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> clase ofrece las siguientes funciones de coincidencia de patrón:</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Validation of a match.</source>
          <target state="translated">Validación de una coincidencia.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method to determine whether a match is present.</source>
          <target state="translated">Se llama a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> método para determinar si existe una coincidencia.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Retrieval of a single match.</source>
          <target state="translated">Recuperación de una única coincidencia.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object that represents the first match in a string or in part of a string.</source>
          <target state="translated">Se llama a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> método para recuperar un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objeto que representa la primera coincidencia en una cadena o en parte de una cadena.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Subsequent matches can be retrieved by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se pueden recuperar las coincidencias subsiguientes llamando a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Retrieval of all matches.</source>
          <target state="translated">Recuperación de todas las coincidencias.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType&gt;</ph> object that represents all the matches found in a string or in part of a string.</source>
          <target state="translated">Se llama a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> método para recuperar un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType&gt;</ph> objeto que representa todas las coincidencias encontradas en una cadena o en parte de una cadena.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Replacement of matched text.</source>
          <target state="translated">Sustitución del texto coincidente.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> method to replace matched text.</source>
          <target state="translated">Se llama a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> método para reemplazar el texto coincidente.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The replacement text can also be defined by a regular expression.</source>
          <target state="translated">El texto de reemplazo también puede definirse mediante una expresión regular.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In addition, some of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> methods include a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> parameter that enables you to programmatically define the replacement text.</source>
          <target state="translated">Además, algunos de los <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> métodos incluyen un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> parámetro que le permite definir mediante programación el texto de reemplazo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Creation of a string array that is formed from parts of an input string.</source>
          <target state="translated">Creación de una matriz de cadenas que se compone de partes de una cadena de entrada.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> method to split an input string at positions that are defined by the regular expression.</source>
          <target state="translated">Se llama a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> método para dividir una cadena de entrada en las posiciones definidas por la expresión regular.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In addition to its pattern-matching methods, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class includes several special-purpose methods:</source>
          <target state="translated">Además de sus métodos de coincidencia de patrones, el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> clase incluye varios métodos de propósito especial:</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method escapes any characters that may be interpreted as regular expression operators in a regular expression or input string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> método convierte los caracteres que se pueden interpretar como operadores de expresiones regulares en una expresión regular o una cadena de entrada.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method removes these escape characters.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> método quita estos caracteres de escape.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> method creates an assembly that contains predefined regular expressions.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> método crea un ensamblado que contiene expresiones regulares predefinidas.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The .NET Framework contains examples of these special-purpose assemblies in the <ph id="ph1">&lt;xref:System.Web.RegularExpressions?displayProperty=nameWithType&gt;</ph> namespace.</source>
          <target state="translated">.NET Framework contiene ejemplos de estos ensamblados para fines especiales en el <ph id="ph1">&lt;xref:System.Web.RegularExpressions?displayProperty=nameWithType&gt;</ph> espacio de nombres.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Volver a comentarios<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Defining a Time-Out Value</source>
          <target state="translated">Definir un valor de tiempo de espera</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The .NET Framework supports a full-featured regular expression language that provides substantial power and flexibility in pattern matching.</source>
          <target state="translated">.NET Framework admite un lenguaje de expresión regular completa que proporciona gran potencia y flexibilidad en la coincidencia.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>However, the power and flexibility come at a cost: the risk of poor performance.</source>
          <target state="translated">Sin embargo, la eficacia y flexibilidad se suministran con un costo: el riesgo de un rendimiento bajo.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Regular expressions that perform poorly are surprisingly easy to create.</source>
          <target state="translated">Las expresiones regulares que se ejecutan satisfactoriamente son sorprendentemente fáciles de crear.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In some cases, regular expression operations that rely on excessive backtracking can appear to stop responding when they process text that nearly matches the regular expression pattern.</source>
          <target state="translated">En algunos casos, operaciones de expresiones regulares que se basan en un retroceso excesivo pueden parecer que deje de responder cuando procesa el texto que casi coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information about the .NET Framework regular expression engine, see <bpt id="p1">[</bpt>Details of Regular Expression Behavior<ept id="p1">](~/docs/standard/base-types/details-of-regular-expression-behavior.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre el motor de expresiones regulares de .NET Framework, vea <bpt id="p1">[</bpt>detalles del comportamiento de expresiones regulares<ept id="p1">](~/docs/standard/base-types/details-of-regular-expression-behavior.md)</ept>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information about excessive backtracking, see <bpt id="p1">[</bpt>Backtracking<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre un retroceso excesivo, consulte <bpt id="p1">[</bpt>retroceso<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, you can define a time-out interval for regular expression matches.</source>
          <target state="translated">A partir de la <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, se puede definir un intervalo de tiempo de espera para buscar coincidencias de expresiones regulares.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the regular expression engine cannot identify a match within this time interval, the matching operation throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Si el motor de expresiones regulares no puede identificar una coincidencia dentro de este intervalo de tiempo, la operación de coincidencia produce un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In most cases, this prevents the regular expression engine from wasting processing power by trying to match text that nearly matches the regular expression pattern.</source>
          <target state="translated">En la mayoría de los casos, esto impide que el motor de expresiones regulares desperdiciar potencia de procesamiento cuando se intenta buscar coincidencias con texto que casi coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>It also could indicate, however, that the timeout interval has been set too low, or that the current machine load has caused an overall degradation in performance.</source>
          <target state="translated">También podría indicar, sin embargo, que el intervalo de tiempo de espera se ha establecido demasiado bajo, o que la carga actual de la máquina ha provocado una degradación general del rendimiento.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>How you handle the exception depends on the cause of the exception.</source>
          <target state="translated">Cómo controlar la excepción depende de la causa de la excepción.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the exception occurs because the time-out interval is set too low or because of excessive machine load, you can increase the time-out interval and retry the matching operation.</source>
          <target state="translated">Si la excepción se produce porque el intervalo de tiempo de espera se establece demasiado bajo, o debido a la carga de la máquina excesivo, puede aumentar el intervalo de tiempo de espera y vuelva a intentar la operación de coincidencia.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the exception occurs because the regular expression relies on excessive backtracking, you can assume that a match does not exist, and, optionally, you can log information that will help you modify the regular expression pattern.</source>
          <target state="translated">Si la excepción se produce porque la expresión regular se basa en un retroceso excesivo, puede asumir que no existe una coincidencia y, si lo desea, puede registrar información que le ayudará a modificar el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You can set a time-out interval by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor when you instantiate a regular expression object.</source>
          <target state="translated">Puede establecer un intervalo de tiempo de espera mediante una llamada a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor al crear una instancia de un objeto de expresión regular.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For static methods, you can set a time-out interval by calling an overload of a matching method that has a <ph id="ph1">`matchTimeout`</ph> parameter.</source>
          <target state="translated">Para los métodos estáticos, puede establecer un intervalo de tiempo de espera mediante una llamada a una sobrecarga de un método correspondiente que tiene un <ph id="ph1">`matchTimeout`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If you do not set a time-out value explicitly, the default time-out value  is determined as follows:</source>
          <target state="translated">Si no establece explícitamente un valor de tiempo de espera, el valor de tiempo de espera predeterminado se determina como sigue:</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By using the application-wide time-out value, if one exists.</source>
          <target state="translated">Utilizando el tiempo de espera de toda la aplicación el valor, si existe.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This can be any time-out value that applies to the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is instantiated or the static method call is made.</source>
          <target state="translated">Esto puede ser cualquier valor de tiempo de espera que se aplica al dominio de aplicación en el que el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se realiza la llamada al método estático o se crea una instancia de objeto.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You can set the application-wide time-out value by calling the <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> method to assign the string representation of a <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> value to the "REGEX_DEFAULT_MATCH_TIMEOUT" property.</source>
          <target state="translated">Puede establecer el valor de tiempo de espera de toda la aplicación mediante una llamada a la <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> método para asignar una representación de cadena de un <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> valor a la propiedad "REGEX_DEFAULT_MATCH_TIMEOUT".</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By using the value <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph>, if no application-wide time-out value has been set.</source>
          <target state="translated">Con el valor <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph>, si no se ha establecido ningún valor de tiempo de espera de toda la aplicación.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>We recommend that you set a time-out value in all regular expression pattern-matching operations.</source>
          <target state="translated">Se recomienda que establezca un valor de tiempo de espera en todas las operaciones de coincidencia de patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>prácticas recomendadas para las expresiones regulares<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Volver a comentarios<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The following example uses a regular expression to check for repeated occurrences of words in a string.</source>
          <target state="translated">En el ejemplo siguiente se utiliza una expresión regular para comprobar las apariciones repetidas de palabras en una cadena.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The regular expression <ph id="ph1">`\b(?&lt;word&gt;\w+)\s+(\k&lt;word&gt;)\b`</ph> can be interpreted as shown in the following table.</source>
          <target state="translated">La expresión regular <ph id="ph1">`\b(?&lt;word&gt;\w+)\s+(\k&lt;word&gt;)\b`</ph> puede interpretarse como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Start the match at a word boundary.</source>
          <target state="translated">Iniciar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match one or more word characters up to a word boundary.</source>
          <target state="translated">Buscar coincidencias con uno o más caracteres de palabra hasta un límite de palabras.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Name this captured group <ph id="ph1">`word`</ph>.</source>
          <target state="translated">Este grupo capturado se denomina <ph id="ph1">`word`</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match one or more white-space characters.</source>
          <target state="translated">Coincide con uno o más caracteres de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match the captured group that is named <ph id="ph1">`word`</ph>.</source>
          <target state="translated">Coincide con el grupo capturado denominada <ph id="ph1">`word`</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match a word boundary.</source>
          <target state="translated">Coincide con un límite de palabras.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The following example illustrates the use of a regular expression to check whether a string either represents a currency value or has the correct format to represent a currency value.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de una expresión regular para comprobar si una cadena representa un valor de divisa o tiene el formato correcto para representar un valor de divisa.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In this case, the regular expression is built dynamically from the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> properties for the user's current culture.</source>
          <target state="translated">En este caso, se genera dinámicamente la expresión regular de la <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph>, y <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> propiedades de la referencia cultural actual del usuario.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the system's current culture is en-US, the resulting regular expression is <ph id="ph1">`^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`</ph>.</source>
          <target state="translated">Si el sistema actual de la referencia cultural es en-US, la expresión regular resultante es <ph id="ph1">`^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This regular expression can be interpreted as shown in the following table.</source>
          <target state="translated">Esta expresión regular puede interpretarse como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Start at the beginning of the string.</source>
          <target state="translated">Comience desde el principio de la cadena.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">Busca coincidencias con cero o más caracteres de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one occurrence of either the positive sign or the negative sign.</source>
          <target state="translated">Coincide con cero o una aparición de signo positivo o el signo negativo.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one white-space character.</source>
          <target state="translated">Busca coincidencias con cero o un carácter de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one occurrence of the dollar sign.</source>
          <target state="translated">Cero o una coincidencia con el signo de dólar.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one white-space character.</source>
          <target state="translated">Busca coincidencias con cero o un carácter de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or more decimal digits.</source>
          <target state="translated">Busca cero o más dígitos decimales.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one decimal point symbol.</source>
          <target state="translated">Coincide con cero o un símbolo de separador decimal.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match two decimal digits zero or one time.</source>
          <target state="translated">Coincide con cero o una vez de dos dígitos decimales.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match the pattern of integral and fractional digits separated by a decimal point symbol at least one time.</source>
          <target state="translated">Coincide con el patrón de dígitos enteros y fraccionarios separados por un símbolo de separador decimal al menos una vez.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match the end of the string.</source>
          <target state="translated">Coincide con el final de la cadena.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In this case, the regular expression assumes that a valid currency string does not contain group separator symbols, and that it has either no fractional digits or the number of fractional digits defined by the current culture's <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph> property.</source>
          <target state="translated">En este caso, la expresión regular se da por supuesto que una cadena de divisa válida no contiene símbolos de separador de grupo y que tenga ningún dígito fraccionario o el número de dígitos fraccionarios definido por la referencia cultural actual <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Because the regular expression in this example is built dynamically, we do not know at design time whether the current culture's currency symbol, decimal sign, or positive and negative signs might be misinterpreted by the regular expression engine as regular expression language operators.</source>
          <target state="translated">Dado que la expresión regular en este ejemplo se genera dinámicamente, se desconoce en tiempo de diseño si el símbolo de divisa de la referencia cultural actual, signo decimal o signos positivos y negativos podrían malinterpretarse por el motor de expresiones regulares como operadores de lenguaje de expresiones regulares.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To prevent any misinterpretation, the example passes each dynamically generated string to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method.</source>
          <target state="translated">Para evitar los errores de interpretación, en el ejemplo se pasa cada cadena generada de forma dinámica a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class is immutable (read-only) and thread safe.</source>
          <target state="translated">La <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> clase es inmutable (de solo lectura) y es seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects can be created on any thread and shared between threads.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> los objetos se pueden crearse en cualquier subproceso y compartirse entre varios subprocesos.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information, see <bpt id="p1">[</bpt>Thread Safety<ept id="p1">](~/docs/standard/base-types/thread-safety-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>seguridad para subprocesos<ept id="p1">](~/docs/standard/base-types/thread-safety-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor">
          <source>Note that this constructor is protected; it can only be called by classes derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Tenga en cuenta que este constructor está protegido; solo se puede llamar mediante las clases derivadas de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class for the specified regular expression.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> para la expresión regular especificada.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>For more information about regular expressions, see the <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> topics.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea el <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> temas.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29&gt;</ph> constructor is equivalent to calling the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor with a value of <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.None&gt;</ph> for the <ph id="ph4">`options`</ph> argument.</source>
          <target state="translated">Llamar a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29&gt;</ph> es equivalente a llamar al constructor el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor con un valor de <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.None&gt;</ph> para el <ph id="ph4">`options`</ph> argumento.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable, which means that it can be used only for the match pattern you define when you create it.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto es inmutable, lo que significa que se puede utilizar únicamente para el patrón de coincidencia que defina al crearlo.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>However, it can be used any number of times without being recompiled.</source>
          <target state="translated">Sin embargo, puede usar cualquier número de veces sin que se va a volver a compilar.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>This constructor instantiates a regular expression object that attempts a case-sensitive match of any alphabetical characters defined in <ph id="ph1">`pattern`</ph>.</source>
          <target state="translated">Este constructor crea una instancia de un objeto de expresión regular que intenta obtener una coincidencia entre mayúsculas y minúsculas de cualquier carácter alfabético definido en <ph id="ph1">`pattern`</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>For a case-insensitive match, use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Hay una coincidencia entre mayúsculas y minúsculas, utilice el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>The following example illustrates how to use this constructor to instantiate a regular expression that matches any word that begins with the letters "a" or "t".</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar este constructor para crear una instancia de una expresión regular que coincide con cualquier palabra que comience con las letras "a" o "t".</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>Note that the regular expression pattern cannot match the word "The" at the beginning of the text, because comparisons are case-sensitive by default.</source>
          <target state="translated">Tenga en cuenta que el patrón de expresión regular no puede coincidir con la palabra "The" al principio del texto, dado que las comparaciones distinguen entre mayúsculas y minúsculas de forma predeterminada.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>For an example of case-insensitive comparison, see the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor.</source>
          <target state="translated">Para obtener un ejemplo de comparación entre mayúsculas y minúsculas, consulte el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>This constructor creates a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object that uses the default time-out value of the application domain in which it is created.</source>
          <target state="translated">Este constructor crea un <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objeto que utiliza el valor de tiempo de espera predeterminado del dominio de aplicación en el que se crea.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>If a time-out value has not been defined for the application domain,  the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object uses the value <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the operation from timing out. The recommended constructor for creating a <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object is <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objeto utiliza el valor <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, que impide que la operación ha agotado el tiempo. El constructor recomendado para crear un <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objeto es <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, que permite establecer el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The object that contains a serialized pattern and <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> information.</source>
          <target state="translated">Objeto que contiene un modelo serializado e información de <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The destination for this serialization.</source>
          <target state="translated">Destino de esta serialización.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>(This parameter is not used; specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.)</source>
          <target state="translated">(Este parámetro no se usa; especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class by using serialized data.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> con datos serializados.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The pattern that <ph id="ph1">&lt;paramref name="info" /&gt;</ph> contains is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El modelo que contiene <ph id="ph1">&lt;paramref name="info" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> contains an invalid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> flag.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> contiene una marca <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> no válida.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that modify the regular expression.</source>
          <target state="translated">Combinación bit a bit de los valores de enumeración que modifican la expresión regular.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class for the specified regular expression, with options that modify the pattern.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> para la expresión regular especificada, con opciones que modifican el modelo.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see the <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> topics.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea el <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> temas.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable, which means that it can be used only for the match parameters you define when you create it.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto es inmutable, lo que significa que se puede utilizar únicamente para los parámetros de coincidencia se definen al crearlo.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>However, it can be used any number of times without being recompiled.</source>
          <target state="translated">Sin embargo, puede usar cualquier número de veces sin que se va a volver a compilar.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example illustrates how to use this constructor to instantiate a regular expression that matches any word that begins with the letters "a" or "t".</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar este constructor para crear una instancia de una expresión regular que coincide con cualquier palabra que comience con las letras "a" o "t".</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Note that the match collection includes the word "The" that begins the text because the <ph id="ph1">`options`</ph> parameter has defined case-insensitive comparisons.</source>
          <target state="translated">Tenga en cuenta que la colección de coincidencias incluye la palabra "The" que comienza el texto porque el <ph id="ph1">`options`</ph> parámetro definió las comparaciones entre mayúsculas y minúsculas.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> contains an invalid flag.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> contiene una marca no válida.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This constructor creates a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object that uses the default time-out value of the application domain in which it is created.</source>
          <target state="translated">Este constructor crea un <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objeto que utiliza el valor de tiempo de espera predeterminado del dominio de aplicación en el que se crea.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object uses the value <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the operation from timing out. The recommended constructor for creating a <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object is <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objeto utiliza el valor <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, que impide que la operación ha agotado el tiempo. El constructor recomendado para crear un <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objeto es <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, que permite establecer el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that modify the regular expression.</source>
          <target state="translated">Combinación bit a bit de los valores de enumeración que modifican la expresión regular.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Un intervalo de tiempo de espera, o <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> para indicar que el método no debe agotar el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class for the specified regular expression, with options that modify the pattern and a value that specifies how long a pattern matching method should attempt a match before it times out.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> para la expresión regular especificada, con las opciones que modifican el modelo y un valor que especifica cuánto tiempo debe intentar un método de coincidencia de modelos una coincidencia antes de que se agote el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see the <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> topics.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea el <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> temas.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable, which means that it can be used only for the match pattern that you define when you create it.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto es inmutable, lo que significa que se puede utilizar únicamente para el patrón de coincidencia que se define cuando se crea.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, it can be used any number of times without being recompiled.</source>
          <target state="translated">Sin embargo, puede usar cualquier número de veces sin que se va a volver a compilar.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern-matching method should try to find a match before it times out. If no match is found in that time interval, the pattern-matching method throws a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">El <ph id="ph1">`matchTimeout`</ph> parámetro especifica cuánto tiempo una patrón de coincidencia de método debe intentar encontrar una coincidencia antes de expirar. Si no se encuentra ninguna coincidencia en ese intervalo de tiempo, el método de coincidencia de patrones se produce un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> invalida cualquier tiempo de espera predeterminado definido para el dominio de aplicación en el que el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea el objeto.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The instance pattern-matching methods that observe the <ph id="ph1">`matchTimeout`</ph> time-out interval include the following:</source>
          <target state="translated">Los métodos de coincidencia de patrones de instancia que observan las <ph id="ph1">`matchTimeout`</ph> intervalo de tiempo de espera incluyen lo siguiente:</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated">Establecer un intervalo de tiempo de espera impide que las expresiones regulares que se basan en un retroceso excesivo aparezcan deje de responder cuando procesan datos de entrada que contenga cerca de coincidencias.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>prácticas recomendadas para las expresiones regulares<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> y <bpt id="p2">[</bpt>retroceso<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To set a reasonable time-out interval, consider the following factors:</source>
          <target state="translated">Para establecer un intervalo de tiempo de espera razonable, tenga en cuenta los siguientes factores:</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The length and complexity of the regular expression pattern.</source>
          <target state="translated">La longitud y complejidad del patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Longer and more complex regular expressions require more time than shorter and simpler ones.</source>
          <target state="translated">Las expresiones regulares más largas y complejas requieren más tiempo que las más cortas y más sencillas.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The expected machine load.</source>
          <target state="translated">La carga esperado de la máquina.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Processing takes more time on systems that have high CPU and memory utilization.</source>
          <target state="translated">El proceso tarda más tiempo en sistemas que tienen un uso elevado de CPU y memoria.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with a time-out value of one second.</source>
          <target state="translated">El ejemplo siguiente se llama el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor para crear instancias de un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto con un valor de tiempo de espera de un segundo.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern <ph id="ph1">`(a+)+$`</ph>, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</source>
          <target state="translated">El patrón de expresión regular <ph id="ph1">`(a+)+$`</ph>, que coincide con una o más secuencias de uno o varios caracteres "a" al final de una línea, está sujeto a un retroceso excesivo.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> is thrown, the example increases the time-out value up to the maximum value of three seconds.</source>
          <target state="translated">Si un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> está iniciada, en el ejemplo se aumenta el valor de tiempo de espera hasta el valor máximo de tres segundos.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Otherwise, it abandons the attempt to match the pattern.</source>
          <target state="translated">En caso contrario, abandona el intento de hacer coincidir el patrón.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> no es un valor <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> válido.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> es negativo, cero o mayor que 24 días aproximadamente.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Se recomienda que establezca el <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parámetro en un valor apropiado, como dos segundos.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Si deshabilita los tiempos de espera mediante la especificación de <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones:</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o está formada por texto estático.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Excluye el texto que se ha dinámicamente introducidos por los usuarios.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controle eficazmente coincide con, ausencia de coincidencias y casi coincide con.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Cuando el patrón de expresión regular no contiene ningún elemento de lenguaje que se sabe que causan un retroceso excesivo al procesar a una coincidencia casi.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Gets or sets the maximum number of entries in the current static cache of compiled regular expressions.</source>
          <target state="translated">Obtiene o establece el número máximo de entradas en la memoria caché estática actual de expresiones regulares compiladas.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>The maximum number of entries in the static cache.</source>
          <target state="translated">Número máximo de entradas en la memoria caché estática.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class maintains an internal cache of compiled regular expressions used in static method calls.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> clase mantiene una caché interna de expresiones regulares compiladas usadas en llamadas a métodos estáticos.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>If the value specified in a set operation is less than the current cache size, cache entries are discarded until the cache size is equal to the specified value.</source>
          <target state="translated">Si el valor especificado en una operación set es menor que el tamaño de caché actual, se descartan las entradas de caché hasta que el tamaño de caché es igual que el valor especificado.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>By default, the cache holds 15 compiled static regular expressions.</source>
          <target state="translated">De forma predeterminada, la memoria caché contiene 15 expresiones regulares estáticas compiladas.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Your application typically will not have to modify the size of the cache.</source>
          <target state="translated">La aplicación normalmente no tendrá que modificar el tamaño de la memoria caché.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A&gt;</ph> property only when you want to turn off caching or when you have an unusually large cache.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A&gt;</ph> propiedad solo cuando desee desactivar el almacenamiento en caché o si cuenta con una caché inusualmente grande.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>The value in a set operation is less than zero.</source>
          <target state="translated">El valor de una operación Set es menor que cero.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>In the .NET Framework prior to the <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, regular expressions used in both static and instance method calls were cached.</source>
          <target state="translated">En .NET Framework anteriores a la <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, las expresiones regulares que se usan en estáticos y llamadas de método de instancia se almacenaron en caché.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, only regular expressions used in static method calls are cached.</source>
          <target state="translated">A partir del <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, solo normales se almacenan en caché las expresiones usadas en llamadas a métodos estáticos.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.capnames">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Lo usa un objeto <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> generado por el método <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>Gets or sets a dictionary that maps named capturing groups to their index values.</source>
          <target state="translated">Obtiene o establece un diccionario que asigna grupos de captura denominados con sus valores de índice.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>A dictionary that maps named capturing groups to their index values.</source>
          <target state="translated">Diccionario que asigna grupos de captura denominados con sus valores de índice.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>Note that this property is protected; it can only be accessed from a class derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Tenga en cuenta que esta propiedad está protegida; solo puede obtenerse de una clase derivada de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>A set operation attempts to convert the value assigned to the property to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object; if this conversion fails, it calls the <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Una operación set intenta convertir el valor asignado a la propiedad a una <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> objeto; si se produce un error en esta conversión, llama a la <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>The value assigned to the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.CapNames" /&gt;</ph> property in a set operation is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor asignado a la propiedad <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.CapNames" /&gt;</ph> en una operación set es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.caps">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Lo usa un objeto <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> generado por el método <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>Gets or sets a dictionary that maps numbered capturing groups to their index values.</source>
          <target state="translated">Obtiene o establece un diccionario que asigna grupos de captura numerados con sus valores de índice.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>A dictionary that maps numbered capturing groups to their index values.</source>
          <target state="translated">Diccionario que asigna grupos de captura numerados con sus valores de índice.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>Note that this property is protected; it can only be accessed from a class derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Tenga en cuenta que esta propiedad está protegida; solo puede obtenerse de una clase derivada de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>A set operation attempts to convert the value assigned to the property to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object; if this conversion fails, it calls the <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Una operación set intenta convertir el valor asignado a la propiedad a una <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> objeto; si se produce un error en esta conversión, llama a la <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>The value assigned to the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Caps" /&gt;</ph> property in a set operation is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor asignado a la propiedad <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Caps" /&gt;</ph> en una operación set es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.capsize">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Lo usa un objeto <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> generado por el método <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.capslist">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Lo usa un objeto <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> generado por el método <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Compiles regular expressions and saves them to disk in a single assembly.</source>
          <target state="translated">Compila expresiones regulares y las guarda en disco en un ensamblado único.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>An array that describes the regular expressions to compile.</source>
          <target state="translated">Matriz que describe las expresiones regulares que se van a compilar.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The file name of the assembly.</source>
          <target state="translated">El nombre de archivo del ensamblado.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Compiles one or more specified <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects to a named assembly.</source>
          <target state="translated">Compila uno o varios objetos <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> especificados en un ensamblado con nombre.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph2">`regexinfos`</ph> array is represented by a class.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> método genera un ensamblado de .NET Framework en la que cada expresión regular definida en la <ph id="ph2">`regexinfos`</ph> matriz se representa mediante una clase.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Typically, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> method is called from a separate application that generates an assembly of compiled regular expressions.</source>
          <target state="translated">Normalmente, el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> método se llama desde una aplicación independiente que genera un ensamblado de expresiones regulares compiladas.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Each regular expression included in the assembly has the following characteristics:</source>
          <target state="translated">Cada expresión regular incluida en el ensamblado tiene las siguientes características:</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>It is derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Se deriva de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>It is assigned the fully qualified name that is defined by the <ph id="ph1">`fullnamespace`</ph> and <ph id="ph2">`name`</ph> parameters of its corresponding <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> object.</source>
          <target state="translated">Se asigna el nombre completo que está definido por el <ph id="ph1">`fullnamespace`</ph> y <ph id="ph2">`name`</ph> parámetros correspondiente <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>It has a default (or parameterless) constructor.</source>
          <target state="translated">Tiene un valor predeterminado (o sin parámetros) constructor.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</source>
          <target state="translated">Normalmente, el código que crea instancias y utiliza la expresión regular compilada se encuentra en un ensamblado o una aplicación que es independiente del código que crea el ensamblado.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The following example creates an assembly named RegexLib.dll.</source>
          <target state="translated">En el ejemplo siguiente se crea un ensamblado denominado RegexLib.dll.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The assembly includes two compiled regular expressions.</source>
          <target state="translated">El ensamblado incluye dos expresiones regulares compiladas.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The first, <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, matches two identical contiguous words.</source>
          <target state="translated">La primera, <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, coincide con dos palabras contiguas idénticas.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The second, <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, checks whether a string has the correct format to be an email address.</source>
          <target state="translated">El segundo, <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, comprueba si una cadena tiene el formato correcto es una dirección de correo electrónico.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The regular expression that checks a string for duplicate words is then instantiated and used by the following example.</source>
          <target state="translated">La expresión regular que comprueba las palabras duplicadas en una cadena, a continuación, se crea y se usa en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Successful compilation of this second example requires a reference to RegexLib.dll (the assembly created by the first example) to be added to the project.</source>
          <target state="translated">Compilación correcta de este segundo ejemplo requiere una referencia a RegexLib.dll (el ensamblado creado en el primer ejemplo) va a agregar al proyecto.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The value of the <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> parameter's <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> property is an empty or null string.</source>
          <target state="translated">El valor de la propiedad <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> del parámetro <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> es una cadena vacía o NULL.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The regular expression pattern of one or more objects in <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated">El modelo de expresión regular de uno o varios objetos de <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contiene una sintaxis no válida.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> or <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> o <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>If you are developing on a system that has <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or its point releases installed, you target <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, and you use the <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> method to create an assembly that contains compiled regular expressions.</source>
          <target state="translated">Si está desarrollando en un sistema que tenga <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> o sus versiones secundarias instalados, el destino <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, y usa el <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> método para crear un ensamblado que contiene expresiones regulares compiladas.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Trying to use one of the regular expressions in that assembly on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> throws an exception.</source>
          <target state="translated">Intente usar una de las expresiones regulares en que el ensamblado en un sistema que tiene <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> produce una excepción.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>To work around this problem, you can do either of the following:</source>
          <target state="translated">Para evitar este problema, realice una de las acciones siguientes:</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Build the assembly that contains the compiled regular expressions on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> instead of later versions installed.</source>
          <target state="translated">Compilar el ensamblado que contiene las expresiones regulares compiladas en un sistema que tenga <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> en lugar de las versiones posteriores.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Instead of calling <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> and retrieving the compiled regular expression from an assembly, use either static or instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> methods with the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option when you instantiate a <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object or call a regular expression pattern matching method.</source>
          <target state="translated">En lugar de llamar <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> y recuperar la expresión regular compilada de un ensamblado, utilice estáticas o de instancia <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> métodos con el <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> opción cuando se instancie un <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objeto o llamar a una expresión regular método de coincidencia de patrón.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>An array that describes the regular expressions to compile.</source>
          <target state="translated">Matriz que describe las expresiones regulares que se van a compilar.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The file name of the assembly.</source>
          <target state="translated">El nombre de archivo del ensamblado.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>An array that defines the attributes to apply to the assembly.</source>
          <target state="translated">Matriz que define los atributos que se van a aplicar al ensamblado.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Compiles one or more specified <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects to a named assembly with the specified attributes.</source>
          <target state="translated">Compila uno o varios objetos <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> especificados en un ensamblado con nombre que tiene los atributos especificados.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph2">`regexinfos`</ph> array is represented by a class.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> método genera un ensamblado de .NET Framework en la que cada expresión regular definida en la <ph id="ph2">`regexinfos`</ph> matriz se representa mediante una clase.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Typically, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> method is called from a separate application that generates an assembly of compiled regular expressions.</source>
          <target state="translated">Normalmente, el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> método se llama desde una aplicación independiente que genera un ensamblado de expresiones regulares compiladas.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Each regular expression included in the assembly has the following characteristics:</source>
          <target state="translated">Cada expresión regular incluida en el ensamblado tiene las siguientes características:</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>It is derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Se deriva de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>It is assigned the fully qualified name that is defined by the <ph id="ph1">`fullnamespace`</ph> and <ph id="ph2">`name`</ph> parameters of its corresponding <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> object.</source>
          <target state="translated">Se asigna el nombre completo que está definido por el <ph id="ph1">`fullnamespace`</ph> y <ph id="ph2">`name`</ph> parámetros correspondiente <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>It has a default (or parameterless) constructor.</source>
          <target state="translated">Tiene un valor predeterminado (o sin parámetros) constructor.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</source>
          <target state="translated">Normalmente, el código que crea instancias y utiliza la expresión regular compilada se encuentra en un ensamblado o una aplicación que es independiente del código que crea el ensamblado.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> method generates a .NET Framework assembly from a method call instead of using a particular language's class definition keyword (such as <ph id="ph2">`class`</ph> in C# or <ph id="ph3">`Class`</ph>…<ph id="ph4">`End Class`</ph></source>
          <target state="translated">Dado que la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> método genera un ensamblado de .NET Framework de una llamada de método en lugar de utilizar la palabra clave de definición de clase de un lenguaje determinado (como <ph id="ph2">`class`</ph> en C# o <ph id="ph3">`Class`</ph>...<ph id="ph4">`End Class`</ph></target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>in Visual Basic), it does not allow .NET Framework attributes to be assigned to the assembly by using the development language's standard attribute syntax.</source>
          <target state="translated">en Visual Basic), no permiten atributos de .NET Framework que se asignará al ensamblado mediante la sintaxis de atributo estándar del lenguaje de desarrollo.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The <ph id="ph1">`attributes`</ph> parameter provides an alternative method for defining the attributes that apply to the assembly.</source>
          <target state="translated">El <ph id="ph1">`attributes`</ph> parámetro proporciona un método alternativo para definir los atributos que se aplican al ensamblado.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>For each attribute that you want to apply to the assembly, do the following:</source>
          <target state="translated">Para cada atributo que desea aplicar al ensamblado, haga lo siguiente:</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Create an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects representing the parameter types of the attribute constructor that you want to call.</source>
          <target state="translated">Crear una matriz de <ph id="ph1">&lt;xref:System.Type&gt;</ph> objetos que representan los tipos de parámetro del constructor de atributo que desea llamar.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Retrieve a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing the attribute class that you want to apply to the new assembly.</source>
          <target state="translated">Recuperar un <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto que representa la clase de atributo que desea aplicar al nuevo ensamblado.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method of the attribute <ph id="ph2">&lt;xref:System.Type&gt;</ph> object to retrieve a <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object representing the attribute constructor that you want to call.</source>
          <target state="translated">Llame a la <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> método del atributo <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto que se va a recuperar un <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objeto que representa el constructor de atributo que desea llamar.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Pass the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method the array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects that represents the constructor's parameter types.</source>
          <target state="translated">Pasar el <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> método la matriz de <ph id="ph2">&lt;xref:System.Type&gt;</ph> objetos que representan los tipos de parámetro del constructor.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Create a <ph id="ph1">&lt;xref:System.Object&gt;</ph> array that defines the parameters to pass to the attribute's constructor.</source>
          <target state="translated">Crear un <ph id="ph1">&lt;xref:System.Object&gt;</ph> matriz que define los parámetros para pasar al constructor del atributo.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Instantiate a <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> object by passing its constructor the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object retrieved in step 3 and the <ph id="ph3">&lt;xref:System.Object&gt;</ph> array created in step 4.</source>
          <target state="translated">Crear una instancia de un <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objeto pasando su constructor la <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objeto recuperado en el paso 3 y el <ph id="ph3">&lt;xref:System.Object&gt;</ph> matriz creada en el paso 4.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>You can then pass an array of these <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objects instead of the <ph id="ph2">`attributes`</ph> parameter to the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">A continuación, puede pasar una matriz de estos <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objetos en lugar de la <ph id="ph2">`attributes`</ph> parámetro para el <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The following example creates an assembly named RegexLib.dll and applies the <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attribute to it.</source>
          <target state="translated">En el ejemplo siguiente se crea un ensamblado denominado RegexLib.dll y se aplica el <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The assembly includes two compiled regular expressions.</source>
          <target state="translated">El ensamblado incluye dos expresiones regulares compiladas.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The first, <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, matches two identical contiguous words.</source>
          <target state="translated">La primera, <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, coincide con dos palabras contiguas idénticas.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The second, <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, checks whether a string has the correct format to be an email address.</source>
          <target state="translated">El segundo, <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, comprueba si una cadena tiene el formato correcto es una dirección de correo electrónico.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>You can verify that the <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attribute has been applied to the assembly by examining its manifest with a reflection utility such as ILDasm.</source>
          <target state="translated">Puede comprobar que la <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> se ha aplicado el atributo al ensamblado examinando su manifiesto con una utilidad de reflexión como ILDasm.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The regular expression that checks a string for duplicate words is then instantiated and used by the following example.</source>
          <target state="translated">La expresión regular que comprueba las palabras duplicadas en una cadena, a continuación, se crea y se usa en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Successful compilation of this second example requires a reference to RegexLib.dll (the assembly created by the first example) to be added to the project.</source>
          <target state="translated">Compilación correcta de este segundo ejemplo requiere una referencia a RegexLib.dll (el ensamblado creado en el primer ejemplo) va a agregar al proyecto.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The value of the <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> parameter's <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> property is an empty or null string.</source>
          <target state="translated">El valor de la propiedad <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> del parámetro <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> es una cadena vacía o NULL.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The regular expression pattern of one or more objects in <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated">El modelo de expresión regular de uno o varios objetos de <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contiene una sintaxis no válida.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> or <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> o <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>If you are developing on a system that has <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or its point releases installed, you target <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, and you use the <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> method to create an assembly that contains compiled regular expressions.</source>
          <target state="translated">Si está desarrollando en un sistema que tenga <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> o sus versiones secundarias instalados, el destino <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, y usa el <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> método para crear un ensamblado que contiene expresiones regulares compiladas.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Trying to use one of the regular expressions in that assembly on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> throws an exception.</source>
          <target state="translated">Intente usar una de las expresiones regulares en que el ensamblado en un sistema que tiene <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> produce una excepción.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>To work around this problem, you can do either of the following:</source>
          <target state="translated">Para evitar este problema, realice una de las acciones siguientes:</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Build the assembly that contains the compiled regular expressions on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> instead of later versions installed.</source>
          <target state="translated">Compilar el ensamblado que contiene las expresiones regulares compiladas en un sistema que tenga <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> en lugar de las versiones posteriores.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Instead of calling <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> and retrieving the compiled regular expression from an assembly, use either static or instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> methods with the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option when you instantiate a <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object or call a regular expression pattern matching method.</source>
          <target state="translated">En lugar de llamar <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> y recuperar la expresión regular compilada de un ensamblado, utilice estáticas o de instancia <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> métodos con el <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> opción cuando se instancie un <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objeto o llamar a una expresión regular método de coincidencia de patrón.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>An array that describes the regular expressions to compile.</source>
          <target state="translated">Matriz que describe las expresiones regulares que se van a compilar.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The file name of the assembly.</source>
          <target state="translated">El nombre de archivo del ensamblado.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>An array that defines the attributes to apply to the assembly.</source>
          <target state="translated">Matriz que define los atributos que se van a aplicar al ensamblado.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The name of the Win32 resource file to include in the assembly.</source>
          <target state="translated">Nombre del archivo de recursos Win32 que se va a incluir en el ensamblado.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Compiles one or more specified <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects and a specified resource file to a named assembly with the specified attributes.</source>
          <target state="translated">Compila uno o varios objetos <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> especificados y un archivo de recursos especificado en un ensamblado con nombre que tiene los atributos indicados.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The [<ph id="ph1">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph3">`regexinfos`</ph> array is represented by a class.</source>
          <target state="translated">The [<ph id="ph1">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph3">`regexinfos`</ph> array is represented by a class.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Typically, the [<ph id="ph1">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method is called from a separate application that generates an assembly of compiled regular expressions.</source>
          <target state="translated">Typically, the [<ph id="ph1">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method is called from a separate application that generates an assembly of compiled regular expressions.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Each regular expression included in the assembly has the following characteristics:</source>
          <target state="translated">Cada expresión regular incluida en el ensamblado tiene las siguientes características:</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>It is derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Se deriva de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>It is assigned the fully qualified name that is defined by the <ph id="ph1">`fullnamespace`</ph> and <ph id="ph2">`name`</ph> parameters of its corresponding <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> object.</source>
          <target state="translated">Se asigna el nombre completo que está definido por el <ph id="ph1">`fullnamespace`</ph> y <ph id="ph2">`name`</ph> parámetros correspondiente <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>It has a default (or parameterless) constructor.</source>
          <target state="translated">Tiene un valor predeterminado (o sin parámetros) constructor.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</source>
          <target state="translated">Normalmente, el código que crea instancias y utiliza la expresión regular compilada se encuentra en un ensamblado o una aplicación que es independiente del código que crea el ensamblado.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> method generates a .NET Framework assembly from a method call instead of using a particular language's class definition keyword (such as <ph id="ph2">`class`</ph> in C# or <ph id="ph3">`Class`</ph>…<ph id="ph4">`End Class`</ph></source>
          <target state="translated">Dado que la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> método genera un ensamblado de .NET Framework de una llamada de método en lugar de utilizar la palabra clave de definición de clase de un lenguaje determinado (como <ph id="ph2">`class`</ph> en C# o <ph id="ph3">`Class`</ph>...<ph id="ph4">`End Class`</ph></target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>in Visual Basic), it does not allow .NET Framework attributes to be assigned to the assembly by using the development language's standard attribute syntax.</source>
          <target state="translated">en Visual Basic), no permiten atributos de .NET Framework que se asignará al ensamblado mediante la sintaxis de atributo estándar del lenguaje de desarrollo.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The <ph id="ph1">`attributes`</ph> parameter provides an alternative method for defining the attributes that apply to the assembly.</source>
          <target state="translated">El <ph id="ph1">`attributes`</ph> parámetro proporciona un método alternativo para definir los atributos que se aplican al ensamblado.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>For each attribute that you want to apply to the assembly, do the following:</source>
          <target state="translated">Para cada atributo que desea aplicar al ensamblado, haga lo siguiente:</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Create an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects representing the parameter types of the attribute constructor that you want to call.</source>
          <target state="translated">Crear una matriz de <ph id="ph1">&lt;xref:System.Type&gt;</ph> objetos que representan los tipos de parámetro del constructor de atributo que desea llamar.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Retrieve a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing the attribute class that you want to apply to the new assembly.</source>
          <target state="translated">Recuperar un <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto que representa la clase de atributo que desea aplicar al nuevo ensamblado.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method of the attribute <ph id="ph2">&lt;xref:System.Type&gt;</ph> object to retrieve a <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object representing the attribute constructor that you want to call.</source>
          <target state="translated">Llame a la <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> método del atributo <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto que se va a recuperar un <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objeto que representa el constructor de atributo que desea llamar.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Pass the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method the array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects that represents the constructor's parameter types</source>
          <target state="translated">Pasar el <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> método la matriz de <ph id="ph2">&lt;xref:System.Type&gt;</ph> objetos que representan los tipos de parámetro del constructor</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Create a <ph id="ph1">&lt;xref:System.Object&gt;</ph> array that defines the parameters to pass to the attribute's constructor.</source>
          <target state="translated">Crear un <ph id="ph1">&lt;xref:System.Object&gt;</ph> matriz que define los parámetros para pasar al constructor del atributo.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Instantiate a <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> object by passing its constructor the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object retrieved in step 3 and the <ph id="ph3">&lt;xref:System.Object&gt;</ph> array created in step 4.</source>
          <target state="translated">Crear una instancia de un <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objeto pasando su constructor la <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objeto recuperado en el paso 3 y el <ph id="ph3">&lt;xref:System.Object&gt;</ph> matriz creada en el paso 4.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>You can then pass an array of these <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objects instead of the <ph id="ph2">`attributes`</ph> parameter to the [<ph id="ph3">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph4">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method.</source>
          <target state="translated">You can then pass an array of these <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objects instead of the <ph id="ph2">`attributes`</ph> parameter to the [<ph id="ph3">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph4">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The value of the <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> parameter's <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> property is an empty or null string.</source>
          <target state="translated">El valor de la propiedad <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> del parámetro <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> es una cadena vacía o NULL.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The regular expression pattern of one or more objects in <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated">El modelo de expresión regular de uno o varios objetos de <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contiene una sintaxis no válida.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> or <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> o <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> parameter designates an invalid Win32 resource file.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> designa un archivo de recursos de Win32 no válido.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The file designated by the <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> parameter cannot be found.</source>
          <target state="translated">No se pudo encontrar el archivo designado por el parámetro <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>If you are developing on a system that has <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or its point releases installed, you target <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, and you use the <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> method to create an assembly that contains compiled regular expressions.</source>
          <target state="translated">Si está desarrollando en un sistema que tenga <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> o sus versiones secundarias instalados, el destino <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, y usa el <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> método para crear un ensamblado que contiene expresiones regulares compiladas.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Trying to use one of the regular expressions in that assembly on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> throws an exception.</source>
          <target state="translated">Intente usar una de las expresiones regulares en que el ensamblado en un sistema que tiene <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> produce una excepción.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>To work around this problem, you can do either of the following:</source>
          <target state="translated">Para evitar este problema, realice una de las acciones siguientes:</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Build the assembly that contains the compiled regular expressions on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> instead of later versions installed.</source>
          <target state="translated">Compilar el ensamblado que contiene las expresiones regulares compiladas en un sistema que tenga <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> en lugar de las versiones posteriores.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Instead of calling <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> and retrieving the compiled regular expression from an assembly, use either static or instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> methods with the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option when you instantiate a <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object or call a regular expression pattern matching method.</source>
          <target state="translated">En lugar de llamar <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> y recuperar la expresión regular compilada de un ensamblado, utilice estáticas o de instancia <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> métodos con el <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> opción cuando se instancie un <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objeto o llamar a una expresión regular método de coincidencia de patrón.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>The input string that contains the text to convert.</source>
          <target state="translated">Cadena de entrada que contiene el texto que se va a convertir.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Escapes a minimal set of characters (<ph id="ph1">\\</ph>, *, +, ?, |, {, [, (,), ^, $,., #, and white space) by replacing them with their escape codes.</source>
          <target state="translated">Convierte en caracteres de escape un juego mínimo de caracteres (<ph id="ph1">\\</ph>, *, +, ?, |, {, [, (,), ^, $,., # y espacio en blanco) al reemplazarlos con sus códigos de escape.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>This instructs the regular expression engine to interpret these characters literally rather than as metacharacters.</source>
          <target state="translated">Esto indica al motor de expresiones regulares que interprete los caracteres literalmente en lugar de como metacaracteres.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>A string of characters with metacharacters converted to their escaped form.</source>
          <target state="translated">Cadena de caracteres con metacaracteres convertidos a su forma de escape.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> converts a string so that the regular expression engine will interpret any metacharacters that it may contain as character literals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> Convierte una cadena para que el motor de expresiones regulares interprete los metacaracteres que puede contener como literales de carácter.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>For example, consider a regular expression that is designed to extract comments that are delimited by straight opening and closing brackets ([ and ]) from text.</source>
          <target state="translated">Por ejemplo, considere la posibilidad de una expresión regular que está diseñada para extraer comentarios que están delimitados por recta de apertura y cierre entre corchetes ([y]) del texto.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In the following example, the regular expression "[(.*?)]" is interpreted as a character class.</source>
          <target state="translated">En el ejemplo siguiente, la expresión regular "[(.*?)]" se interpreta como una clase de caracteres.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Rather than matching comments embedded in the input text, the regular expression matches each opening or closing parenthesis, period, asterisk, or question mark.</source>
          <target state="translated">En lugar de búsqueda de coincidencias comentarios incrustados en el texto de entrada, la expresión regular coincide con cada apertura o un paréntesis de cierre, un punto, un asterisco o un signo de interrogación.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>However, if the opening bracket is escaped by passing it to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method, the regular expression succeeds in matching comments that are embedded in the input string.</source>
          <target state="translated">Sin embargo, si el corchete de apertura es la secuencia de escape pasarlo a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> método, la expresión regular logra encontrar coincidencias con los comentarios que se incrustan en la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>The following example illustrates this.</source>
          <target state="translated">Esto se ilustra en el siguiente ejemplo:</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In a regular expression that is defined by using static text, characters that are to be interpreted literally rather than as metacharacters can be escaped by preceding them with a backslash symbol (<ph id="ph1">\\</ph>) as well as by calling the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method.</source>
          <target state="translated">En una expresión regular que se define mediante el uso de texto estático, se pueden escapar caracteres que deben interpretarse literalmente en lugar de como metacaracteres utilizando delante de ellas con un símbolo de barra diagonal inversa (<ph id="ph1">\\</ph>) así como mediante una llamada a la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In a regular expression that is defined dynamically using characters that are not known at design time, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method is particularly important to ensure that the regular expression engine interprets individual characters as literals rather than as metacharacters.</source>
          <target state="translated">En una expresión regular que se define dinámicamente, utilizando caracteres que no se conocen en tiempo de diseño, una llamada a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> método es especialmente importante para asegurarse de que el motor de expresiones regulares interpreta los caracteres individuales como literales en lugar de como metacaracteres.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If a regular expression pattern includes either the number sign (#) or literal white-space characters, they must be escaped if input text is parsed with the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option enabled.</source>
          <target state="translated">Si un patrón de expresión regular incluye el signo de número (#) o caracteres de espacio en blanco literales, deben convertirse si se analiza el texto de entrada con el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> opción habilitada.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>While the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method escapes the straight opening bracket ([) and opening brace ({) characters, it does not escape their corresponding closing characters (] and }).</source>
          <target state="translated">Mientras el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> método antepone la recta abrir corchete ([) y abrir llaves ({}), no escape sus correspondientes caracteres de cierre (] y}).</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In most cases, escaping these is not necessary.</source>
          <target state="translated">En la mayoría de los casos, estos caracteres de escape no es necesario.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If a closing bracket or brace is not preceded by its corresponding opening character, the regular expression engine interprets it literally.</source>
          <target state="translated">Si un corchete o llave no está precedida por el carácter de apertura correspondiente, el motor de expresiones regulares lo interpreta literalmente.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If an opening braket or brace is interpreted as a metacharacter, the regular expression engine interprets the first corresponding closing character as a metacharacter.</source>
          <target state="translated">Si una llave o soporte de apertura se interpreta como un metacarácter, el motor de expresiones regulares interpreta el carácter como un metacarácter de cierre primera correspondiente.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If this is not the desired behavior, the closing bracket or brace should be escaped by explicitly prepending the backslash (<ph id="ph1">\\</ph>) character.</source>
          <target state="translated">Si esto no es el comportamiento deseado, el corchete o llave debe ser caracteres de escape anteponiendo explícitamente la barra diagonal inversa (<ph id="ph1">\\</ph>) caracteres.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>For an illustration, see the Example section.</source>
          <target state="translated">Para ver una ilustración, vea la sección ejemplo.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>The following example extracts comments from text.</source>
          <target state="translated">En el ejemplo siguiente se extrae los comentarios del texto.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>It assumes that the comments are delimited by a begin comment symbol and an end comment symbol that is selected by the user.</source>
          <target state="translated">Se supone que los comentarios se delimitan mediante un símbolo de comentario begin y un símbolo de comentario final seleccionado por el usuario.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Because the comment symbols are to be interpreted literally, they are passed to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method to ensure that they cannot be misinterpreted as metacharacters.</source>
          <target state="translated">Dado que los símbolos de comentario son debe interpretarse literalmente, se pasan a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> método para asegurarse de que no se pueden interpretar como metacaracteres.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In addition, the example explicitly checks whether the end comment symbol entered by the user is a closing bracket (]) or brace (}).</source>
          <target state="translated">Además, el ejemplo comprueba explícitamente si el símbolo de comentario final especificado por el usuario es un corchete de cierre (]) o una llave (}).</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If it is, a backslash character (<ph id="ph1">\\</ph>) is prepended to the bracket or brace so that it is interpreted literally.</source>
          <target state="translated">Si es así, un carácter de barra diagonal inversa (<ph id="ph1">\\</ph>) se antepone al corchete o llave de modo que se interpreta literalmente.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Note that the example also uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> collection to display the comment only, rather than the comment together with its opening and closing comment symbols.</source>
          <target state="translated">Tenga en cuenta que el ejemplo también usa el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> colección para mostrar solo el comentario, en lugar del comentario junto con sus símbolos de comentario de apertura y cierre.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.factory">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Lo usa un objeto <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> generado por el método <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Returns an array of capturing group names for the regular expression.</source>
          <target state="translated">Devuelve una matriz de nombres de grupo de captura para la expresión regular.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>A string array of group names.</source>
          <target state="translated">Matriz de cadenas de nombres de grupo.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The collection of group names contains the set of strings used to name capturing groups in the expression.</source>
          <target state="translated">La colección de nombres de grupo contiene el conjunto de cadenas que se usan en nombres de grupos de captura en la expresión.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Even if capturing groups are not explicitly named, they are automatically assigned numerical names ("0", "1", "2", "3", and so on).</source>
          <target state="translated">Aunque los grupos de captura no se mencionen explícitamente, se asignan automáticamente nombres numéricos ("0", "1", "2", "3" y así sucesivamente).</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The "0" named group represents all text matched by the regular expression pattern.</source>
          <target state="translated">"0" denominado grupo representa todo el texto coincidente con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Numbered groups precede explicitly named groups in the collection, and named groups appear in the order in which they are defined in the regular expression pattern.</source>
          <target state="translated">Los grupos numerados preceden a los grupos con nombre explícitamente en la colección y los grupos con nombre aparecen en el orden en que se definen en el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>You can use the <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> property on the array returned by this method to determine the number of groups in a regular expression.</source>
          <target state="translated">Puede usar el <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> propiedad en la matriz devuelta por este método para determinar el número de grupos en una expresión regular.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The following example defines a general-purpose <ph id="ph1">`ShowMatches`</ph> method that displays the names of regular expression groups and their matched text.</source>
          <target state="translated">En el ejemplo siguiente se define un uso general <ph id="ph1">`ShowMatches`</ph> método que muestra los nombres de grupos de expresión regular y el texto coincidente.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>In this case, the regular expression pattern <ph id="ph1">`\b(?&lt;FirstWord&gt;\w+)\s?((\w+)\s)*(?&lt;LastWord&gt;\w+)?(?&lt;Punctuation&gt;\p{Po})`</ph> is intended to parse a simple sentence, and to identify its first word, last word, and ending punctuation mark.</source>
          <target state="translated">En este caso, el patrón de expresión regular <ph id="ph1">`\b(?&lt;FirstWord&gt;\w+)\s?((\w+)\s)*(?&lt;LastWord&gt;\w+)?(?&lt;Punctuation&gt;\p{Po})`</ph> está diseñada para analizar una frase simple y para identificar su primera palabra, la última palabra y el signo de puntuación de final.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The following table shows how the regular expression pattern is interpreted:</source>
          <target state="translated">En la tabla siguiente se muestra cómo se interpreta el patrón de expresión regular:</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Iniciar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match one or more word characters.</source>
          <target state="translated">Buscar coincidencias con uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the <ph id="ph1">`FirstWord`</ph> named group.</source>
          <target state="translated">Se trata de la <ph id="ph1">`FirstWord`</ph> con el nombre de grupo.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>\s?</source>
          <target state="translated">¿\s?</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match zero or one white-space characters.</source>
          <target state="translated">Busca una coincidencia con cero o un carácter de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>(\w+)</source>
          <target state="translated">(\w+)</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match one or more word characters.</source>
          <target state="translated">Buscar coincidencias con uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the second capturing group.</source>
          <target state="translated">Este es el segundo grupo de captura.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>\s</source>
          <target state="translated">\s</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match a white-space character.</source>
          <target state="translated">Coincide con un carácter de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>((\w+)\s)*</source>
          <target state="translated">((\w+)\s)*</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match zero or more occurrences of one or more word characters followed by a white space.</source>
          <target state="translated">Buscar coincidencias con cero o más apariciones de uno o más caracteres de palabra seguidos por un espacio en blanco.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the first capturing group.</source>
          <target state="translated">Este es el primer grupo de captura.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>(?<ph id="ph1">\&lt;</ph>LastWord&gt;\w+)?</source>
          <target state="translated">(?<ph id="ph1">\&lt;</ph>LastWord&gt;\w+)?</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match zero or one occurrence of one or more word characters.</source>
          <target state="translated">Coincide con cero o una aparición de uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the <ph id="ph1">`LastWord`</ph> named group.</source>
          <target state="translated">Se trata de la <ph id="ph1">`LastWord`</ph> con el nombre de grupo.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>(?<ph id="ph1">\&lt;</ph>Punctuation&gt;\p{Po})</source>
          <target state="translated">(? <ph id="ph1">\&lt;</ph>Puntuación &gt; \p{Po})</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match a character whose Unicode category is Punctuation, Other.</source>
          <target state="translated">Coincide con un carácter cuya categoría Unicode es el signo de puntuación, otro.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the <ph id="ph1">`Punctuation`</ph> named group.</source>
          <target state="translated">Se trata de la <ph id="ph1">`Punctuation`</ph> con el nombre de grupo.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Returns an array of capturing group numbers that correspond to group names in an array.</source>
          <target state="translated">Devuelve una matriz de números de grupo de captura que corresponde a los nombres de grupo en una matriz.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>An integer array of group numbers.</source>
          <target state="translated">Matriz de enteros de números de grupo.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Both unnamed and named capturing groups can be accessed by number.</source>
          <target state="translated">Pueden tener acceso a los grupos de captura con nombre y sin nombre por número.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Unnamed groups are numbered from left to right starting with 1.</source>
          <target state="translated">Grupos sin nombre se numeran de izquierda a derecha, comenzando por 1.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>(The capturing group in index 0 (zero) represents the match as a whole.)  Named groups are then numbered from left to right starting with a number that is one greater than the number of unnamed capturing groups.</source>
          <target state="translated">(El grupo de captura en el índice 0 (cero) representa a la coincidencia como un todo.)  Los grupos con nombre, a continuación, se numeran de izquierda a derecha, comenzando por un número que es una unidad mayor que el número de sin nombre de grupos de captura.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Referencing a group by its number instead of by string name can provide faster access.</source>
          <target state="translated">Referencia a un grupo por su número en lugar de por nombre de la cadena puede proporcionar un acceso más rápido.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The following example defines a regular expression, <ph id="ph1">`\b((?&lt;word&gt;\w+)\s*)+(?&lt;end&gt;[.?!])`</ph>, that matches a sentence.</source>
          <target state="translated">En el ejemplo siguiente se define una expresión regular, <ph id="ph1">`\b((?&lt;word&gt;\w+)\s*)+(?&lt;end&gt;[.?!])`</ph>, que coincide con una frase.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The regular expression includes three capturing groups: an unnamed group that captures an individual word along with a space character that may follow it; a group named <ph id="ph1">`word`</ph> that captures the individual words in the sentence; and a group named <ph id="ph2">`end`</ph> that captures the punctuation that ends the sentence.</source>
          <target state="translated">La expresión regular incluye tres grupos de captura: un grupo sin nombre que captura una sola palabra junto con un carácter de espacio que puede seguir; un grupo denominado <ph id="ph1">`word`</ph> que captura las palabras individuales de la oración; y un grupo denominado <ph id="ph2">`end`</ph> que captura los signos de puntuación que termina la frase.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A&gt;</ph> method to get the numbers of all capturing groups, and then displays their captured string.</source>
          <target state="translated">El ejemplo se llama el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A&gt;</ph> método para obtener los números de captura de todos los grupos y, a continuación, muestra su cadena capturada.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>In addition, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> method is used to indicate whether a particular numbered group corresponds to a named group.</source>
          <target state="translated">Además, la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> método se utiliza para indicar si un determinado grupo numerado corresponde a un grupo con nombre.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">El patrón de la expresión regular se interpreta como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Iniciar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match one or more word characters and assign the matched strings to a group named <ph id="ph1">`word`</ph>.</source>
          <target state="translated">Coincide con uno o más caracteres alfabéticos y asigna las cadenas coincidentes a un grupo denominado <ph id="ph1">`word`</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">Busca coincidencias con cero o más caracteres de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Assign the <ph id="ph1">`word`</ph> captured group followed by any captured white-space characters to the first captured group.</source>
          <target state="translated">Asigne el <ph id="ph1">`word`</ph> grupo capturado seguido de cualquier captura caracteres de espacio en blanco para el primer grupo capturado.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match the pattern of one or more word characters followed by any white-space characters one or more times.</source>
          <target state="translated">Coincide con el patrón de uno o más caracteres de palabra seguido de cualquier carácter de espacio en blanco una o varias veces.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match a period, question mark, or exclamation point.</source>
          <target state="translated">Buscar coincidencias con un punto, un signo de interrogación o un signo de exclamación.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Assign the matched character to the <ph id="ph1">`end`</ph> capturing group.</source>
          <target state="translated">Asigne el carácter coincidente para el <ph id="ph1">`end`</ph> grupo de captura.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The group number to convert to the corresponding group name.</source>
          <target state="translated">Número de grupo para convertir al nombre de grupo correspondiente.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Gets the group name that corresponds to the specified group number.</source>
          <target state="translated">Obtiene el nombre de grupo que corresponde al número de grupo especificado.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>A string that contains the group name associated with the specified group number.</source>
          <target state="translated">Cadena que contiene el nombre de grupo asociado al número de grupo especificado.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If there is no group name that corresponds to <ph id="ph1">&lt;paramref name="i" /&gt;</ph>, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Si no hay un nombre de grupo que se corresponda con <ph id="ph1">&lt;paramref name="i" /&gt;</ph>, el método devuelve <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>A regular expression pattern may contain either named or numbered capturing groups, which delineate subexpressions within a pattern match.</source>
          <target state="translated">Un patrón de expresión regular puede contener grupos de captura con nombre o numerados, que definen subexpresiones de una coincidencia de patrones.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Numbered groups are delimited by the syntax (<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>) and are assigned numbers based on their order in the regular expression.</source>
          <target state="translated">Los grupos numerados están delimitados por la sintaxis (<bpt id="p1">*</bpt>subexpresión<ept id="p1">*</ept>) y se asignan números según su orden en la expresión regular.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Named groups are delimited by the syntax (?<ph id="ph1">`&lt;`</ph><bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>) or (?'<bpt id="p3">*</bpt>name<ept id="p3">*</ept>'<bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>), where <bpt id="p5">*</bpt>name<ept id="p5">*</ept> is the name by which the subexpression will be identified.</source>
          <target state="translated">Los grupos con nombre están delimitados por la sintaxis (?<ph id="ph1">`&lt;`</ph> <bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>) or (?' <bpt id="p3">*</bpt>nombre<ept id="p3">*</ept>'<bpt id="p4">*</bpt>subexpresión<ept id="p4">*</ept>), donde <bpt id="p5">*</bpt>nombre<ept id="p5">*</ept> es el nombre por el que se identificará la subexpresión.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>(For more information, see <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.) The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> method identifies both named groups and numbered groups by their ordinal positions in the regular expression.</source>
          <target state="translated">Para más información, consulte la sección sobre <bpt id="p1">[</bpt>Construcciones de agrupamiento en expresiones regulares<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>. El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> método identifica los grupos con nombre y los grupos numerados mediante sus posiciones ordinales en la expresión regular.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Ordinal position zero always represents the entire regular expression.</source>
          <target state="translated">Posición ordinal cero siempre representa la expresión regular completa.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>All numbered groups are then counted before named groups, regardless of their actual position in the regular expression pattern.</source>
          <target state="translated">Numerados todos los grupos, a continuación, se cuentan antes que los grupos con nombre, independientemente de su posición real en el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If <ph id="ph1">`i`</ph> is the number of a named group, the method returns the name of the group.</source>
          <target state="translated">Si <ph id="ph1">`i`</ph> es el número de un grupo con nombre, el método devuelve el nombre del grupo.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If <ph id="ph1">`i`</ph> is the number of an unnamed group, the method returns the string representation of the number.</source>
          <target state="translated">Si <ph id="ph1">`i`</ph> es el número de un grupo sin nombre, el método devuelve la representación de cadena del número.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>For example, if <ph id="ph1">`i`</ph> is 1, the method returns "1".</source>
          <target state="translated">Por ejemplo, si <ph id="ph1">`i`</ph> es 1, el método devuelve "1".</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If <ph id="ph1">`i`</ph> is not the number of a capturing group, the method returns <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`i`</ph> no es el número de un grupo de captura, el método devuelve <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If a pattern match is found, the value returned by this method can then be used to retrieve the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object that represents the captured group from the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Si se encuentra una coincidencia de patrones, el valor devuelto por este método, a continuación, puede utilizarse para recuperar el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> objeto que representa el grupo capturado desde la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object is returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> objeto devuelto por la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The following example defines a regular expression pattern that matches an address line containing a U.S. city name, state name, and zip code.</source>
          <target state="translated">En el ejemplo siguiente se define un patrón de expresión regular que coincida con una línea de dirección que contiene un nombre de la ciudad de Estados Unidos, el nombre del estado y el código postal.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> method to retrieve the names of capturing groups.</source>
          <target state="translated">El ejemplo se utiliza la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> método para recuperar los nombres de grupos de captura.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>It then uses these names to retrieve the corresponding captured groups for matches.</source>
          <target state="translated">A continuación, utiliza estos nombres para recuperar los grupos capturados correspondientes para buscar coincidencias.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">El patrón de expresión regular se define mediante la siguiente expresión:</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match one or more alphabetic or white-space character.</source>
          <target state="translated">Coincide con uno o más caracteres alfabéticos o de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Assign this captured group the name <ph id="ph1">`city`</ph>.</source>
          <target state="translated">Asignar el nombre de este grupo capturado <ph id="ph1">`city`</ph>.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match a comma (,) followed by a white-space character.</source>
          <target state="translated">Coincide con una coma (,) seguida por un carácter de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match two alphabetic characters.</source>
          <target state="translated">Coincide con dos caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Assign this captured group the name <ph id="ph1">`state`</ph>.</source>
          <target state="translated">Asignar el nombre de este grupo capturado <ph id="ph1">`state`</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>This group should be followed by a white-space character.</source>
          <target state="translated">Este grupo debe ir seguido de un carácter de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match five numeric digits followed by either zero or one occurrence of a hyphen followed by four digits.</source>
          <target state="translated">Coincide con cinco dígitos numéricos seguidos de cero o una aparición de un guión seguido de cuatro dígitos.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Assign this captured group the name <ph id="ph1">`zip`</ph>.</source>
          <target state="translated">Asignar el nombre de este grupo capturado <ph id="ph1">`zip`</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>The group name to convert to the corresponding group number.</source>
          <target state="translated">Nombre de grupo para convertir al número de grupo correspondiente.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Returns the group number that corresponds to the specified group name.</source>
          <target state="translated">Devuelve el número de grupo que corresponde al nombre de grupo especificado.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>The group number that corresponds to the specified group name, or -1 if <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid group name.</source>
          <target state="translated">Número del grupo que corresponde al nombre de grupo especificado o -1 si <ph id="ph1">&lt;paramref name="name" /&gt;</ph> no es un nombre de grupo válido.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>A regular expression pattern may contain either named or numbered capturing groups, which delineate subexpressions within a pattern match.</source>
          <target state="translated">Un patrón de expresión regular puede contener grupos de captura con nombre o numerados, que definen subexpresiones de una coincidencia de patrones.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Numbered groups are delimited by the syntax (<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>) and are assigned numbers based on their order in the regular expression.</source>
          <target state="translated">Los grupos numerados están delimitados por la sintaxis (<bpt id="p1">*</bpt>subexpresión<ept id="p1">*</ept>) y se asignan números según su orden en la expresión regular.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Named groups are delimited by the syntax (?<ph id="ph1">`&lt;`</ph><bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>) or (?'<bpt id="p3">*</bpt>name<ept id="p3">*</ept>'<bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>), where <bpt id="p5">*</bpt>name<ept id="p5">*</ept> is the name by which the subexpression will be identified.</source>
          <target state="translated">Los grupos con nombre están delimitados por la sintaxis (?<ph id="ph1">`&lt;`</ph> <bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>) or (?' <bpt id="p3">*</bpt>nombre<ept id="p3">*</ept>'<bpt id="p4">*</bpt>subexpresión<ept id="p4">*</ept>), donde <bpt id="p5">*</bpt>nombre<ept id="p5">*</ept> es el nombre por el que se identificará la subexpresión.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>(For more information, see <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.) The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A&gt;</ph> method identifies both named groups and numbered groups by their ordinal positions in the regular expression.</source>
          <target state="translated">Para más información, consulte la sección sobre <bpt id="p1">[</bpt>Construcciones de agrupamiento en expresiones regulares<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>. El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A&gt;</ph> método identifica los grupos con nombre y los grupos numerados mediante sus posiciones ordinales en la expresión regular.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Ordinal position zero always represents the entire regular expression.</source>
          <target state="translated">Posición ordinal cero siempre representa la expresión regular completa.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>All numbered groups are then counted before named groups, regardless of their actual position in the regular expression pattern.</source>
          <target state="translated">Numerados todos los grupos, a continuación, se cuentan antes que los grupos con nombre, independientemente de su posición real en el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>If <ph id="ph1">`name`</ph> is the string representation of a group number that is present in the regular expression pattern, the method returns that number.</source>
          <target state="translated">Si <ph id="ph1">`name`</ph> es la representación de cadena de un número de grupo que está presente en el patrón de expresión regular, el método devuelve dicha cantidad.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>If <ph id="ph1">`name`</ph> corresponds to a named capturing group that is present in the regular expression pattern, the method returns its corresponding number.</source>
          <target state="translated">Si <ph id="ph1">`name`</ph> corresponde a un conjunto con nombre captura el grupo que se encuentra en el patrón de expresión regular, el método devuelve el número correspondiente.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>The comparison of <ph id="ph1">`name`</ph> with the group name is case-sensitive.</source>
          <target state="translated">La comparación de <ph id="ph1">`name`</ph> con el grupo nombre distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>If <ph id="ph1">`name`</ph> does not correspond to the name of a capturing group or to the string representation of the number of a capturing group, the method returns -1.</source>
          <target state="translated">Si <ph id="ph1">`name`</ph> no corresponderse con el nombre de un grupo de captura o con la representación de cadena del número de un grupo de captura, el método devuelve -1.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>Specifies that a pattern-matching operation should not time out.</source>
          <target state="translated">Especifica que una operación de coincidencia de patrones no debe superar el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> class constructor and a number of static matching methods use the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> constant to indicate that the attempt to find a pattern match should not time out.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> clase constructor y un número de uso de métodos de coincidencia estática la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> constante para indicar que el intento de encontrar una coincidencia de patrones debe tiempo de espera.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>Setting the regular expression engine's time-out value to <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> can cause regular expressions that rely on excessive backtracking to appear to stop responding when processing text that nearly matches the regular expression pattern.</source>
          <target state="translated">Establecer el valor de tiempo de espera del motor de expresiones regulares en <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> puede hacer que las expresiones regulares que se basan en un retroceso excesivo para que aparezca deje de responder al procesar el texto que casi coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>If you disable time-outs, you should ensure that your regular expression does not rely on excessive backtracking and that it handles text that nearly matches the regular expression pattern.</source>
          <target state="translated">Si deshabilita los tiempos de espera, debe asegurarse de que la expresión regular no se basa en un retroceso excesivo y que controla el texto que casi coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>For more information about handling backtracking, see <bpt id="p1">[</bpt>Backtracking<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre el control de retroceso, consulte <bpt id="p1">[</bpt>retroceso<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> constant can be supplied as the value of the <ph id="ph2">`matchTimeout`</ph> argument of the following members:</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> constante se puede proporcionar como el valor de la <ph id="ph2">`matchTimeout`</ph> argumento de los miembros siguientes:</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.InitializeReferences">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Lo usa un objeto <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> generado por el método <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.InitializeReferences">
          <source>References have already been initialized.</source>
          <target state="translated">Ya se han inicializado las referencias.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.internalMatchTimeout">
          <source>The maximum amount of time that can elapse in a pattern-matching operation before the operation times out.</source>
          <target state="translated">Tiempo máximo que puede transcurrir en una operación de coincidencia de patrones antes de que se agote el tiempo de espera de la operación.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Indicates whether the regular expression finds a match in the input string.</source>
          <target state="translated">Indica si la expresión regular encuentra una coincidencia en la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Indicates whether the regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor finds a match in a specified input string.</source>
          <target state="translated">Indica si la expresión regular especificada en el constructor <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> encuentra una coincidencia en una cadena de entrada indicada.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la expresión regular encuentra una coincidencia; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> método suele usarse para validar una cadena o para asegurarse de que una cadena se ajusta a un patrón determinado sin tener que recuperar esa cadena para una manipulación subsiguientes.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">Si desea determinar si una o varias cadenas coinciden con un patrón de expresión regular y, a continuación, recuperan para su manipulación subsiguientes, llamada la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado por el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea el objeto.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> método para determinar si una cadena es un número de pieza válido.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">La expresión regular se da por supuesto que el número de pieza tiene un formato específico que consta de tres conjuntos de caracteres separados por guiones.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">El primer conjunto, que contiene cuatro caracteres, debe constar de un carácter alfanumérico seguido de dos caracteres numéricos seguidos por un carácter alfanumérico.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">El segundo conjunto, que consta de tres caracteres, debe ser numérico.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">El tercer conjunto, que consta de cuatro caracteres, debe tener tres caracteres numéricos seguidos por un carácter alfanumérico.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The regular expression pattern is:</source>
          <target state="translated">El patrón de la expresión regular es:</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Begin the match at the beginning of the line.</source>
          <target state="translated">Comienza la búsqueda de coincidencias al principio de la línea.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Coincide con un carácter alfabético único (<ph id="ph1">`a`</ph> a través de <ph id="ph2">`z`</ph> o <ph id="ph3">`A`</ph> a través de <ph id="ph4">`Z`</ph>) o carácter numérico.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match two numeric characters.</source>
          <target state="translated">Buscar coincidencias con dos caracteres numéricos.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Coincide con un carácter alfabético único (<ph id="ph1">`a`</ph> a través de <ph id="ph2">`z`</ph> o <ph id="ph3">`A`</ph> a través de <ph id="ph4">`Z`</ph>) o carácter numérico.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a hyphen.</source>
          <target state="translated">Buscar coincidencias con un guion.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">Buscar coincidencias con exactamente tres caracteres numéricos.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">Buscar un guión seguido de tres caracteres numéricos y coincide con dos apariciones de este patrón.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Coincide con un carácter alfabético único (<ph id="ph1">`a`</ph> a través de <ph id="ph2">`z`</ph> o <ph id="ph3">`A`</ph> a través de <ph id="ph4">`Z`</ph>) o carácter numérico.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>End the match at the end of the line.</source>
          <target state="translated">Finalizar la búsqueda de coincidencias al final de la línea.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The character position at which to start the search.</source>
          <target state="translated">Posición de carácter en la que se va a iniciar la búsqueda.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Indicates whether the regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor finds a match in the specified input string, beginning at the specified starting position in the string.</source>
          <target state="translated">Indica si la expresión regular especificada en el constructor <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> encuentra una coincidencia en la cadena de entrada especificada, empezando en la posición inicial indicada en la cadena.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la expresión regular encuentra una coincidencia; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> método suele usarse para validar una cadena o para asegurarse de que una cadena se ajusta a un patrón determinado sin tener que recuperar esa cadena para una manipulación subsiguientes.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">Si desea determinar si una o varias cadenas coinciden con un patrón de expresión regular y, a continuación, recuperan para su manipulación subsiguientes, llamada la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado por el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea el objeto.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> método para determinar si una cadena es un número de pieza válido.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>It searches for a part number that follows a colon (:) character in a string.</source>
          <target state="translated">Busca un número de pieza que sigue a un carácter de dos puntos (:) en una cadena.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> method is used to determine the position of the colon character, which is then passed to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> método se usa para determinar la posición del carácter de dos puntos, que se pasa a continuación el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">La expresión regular se da por supuesto que el número de pieza tiene un formato específico que consta de tres conjuntos de caracteres separados por guiones.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">El primer conjunto, que contiene cuatro caracteres, debe constar de un carácter alfanumérico seguido de dos caracteres numéricos seguidos por un carácter alfanumérico.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">El segundo conjunto, que consta de tres caracteres, debe ser numérico.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">El tercer conjunto, que consta de cuatro caracteres, debe tener tres caracteres numéricos seguidos por un carácter alfanumérico.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The regular expression pattern is:</source>
          <target state="translated">El patrón de la expresión regular es:</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Coincide con un carácter alfabético único (<ph id="ph1">`a`</ph> a través de <ph id="ph2">`z`</ph> o <ph id="ph3">`A`</ph> a través de <ph id="ph4">`Z`</ph>) o carácter numérico.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match two numeric characters.</source>
          <target state="translated">Buscar coincidencias con dos caracteres numéricos.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Coincide con un carácter alfabético único (<ph id="ph1">`a`</ph> a través de <ph id="ph2">`z`</ph> o <ph id="ph3">`A`</ph> a través de <ph id="ph4">`Z`</ph>) o carácter numérico.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a hyphen.</source>
          <target state="translated">Buscar coincidencias con un guion.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">Buscar coincidencias con exactamente tres caracteres numéricos.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">Buscar un guión seguido de tres caracteres numéricos y coincide con dos apariciones de este patrón.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Coincide con un carácter alfabético único (<ph id="ph1">`a`</ph> a través de <ph id="ph2">`z`</ph> o <ph id="ph3">`A`</ph> a través de <ph id="ph4">`Z`</ph>) o carácter numérico.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>End the match at the end of the line.</source>
          <target state="translated">Finalizar la búsqueda de coincidencias al final de la línea.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> es menor que cero o mayor que la longitud de <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Indicates whether the specified regular expression finds a match in the specified input string.</source>
          <target state="translated">Indica si la expresión regular especificada busca una coincidencia en la cadena de entrada indicada.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la expresión regular encuentra una coincidencia; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> método suele usarse para validar una cadena o para asegurarse de que una cadena se ajusta a un patrón determinado sin tener que recuperar esa cadena para una manipulación subsiguientes.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">Si desea determinar si una o varias cadenas coinciden con un patrón de expresión regular y, a continuación, recuperan para su manipulación subsiguientes, llamada la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the regular expression pattern specified by <ph id="ph3">`pattern`</ph> and calling the <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance method.</source>
          <target state="translated">El método estático <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> método es equivalente a construir un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto con el patrón de expresión regular especificado por <ph id="ph3">`pattern`</ph> y llamar a la <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> método de instancia.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>This regular expression pattern is cached for rapid retrieval by the regular expression engine.</source>
          <target state="translated">Este patrón de expresión regular se almacena en caché para la recuperación rápida por el motor de expresiones regulares.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> método para determinar si una cadena es un número de pieza válido.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">La expresión regular se da por supuesto que el número de pieza tiene un formato específico que consta de tres conjuntos de caracteres separados por guiones.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">El primer conjunto, que contiene cuatro caracteres, debe constar de un carácter alfanumérico seguido de dos caracteres numéricos seguidos por un carácter alfanumérico.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">El segundo conjunto, que consta de tres caracteres, debe ser numérico.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">El tercer conjunto, que consta de cuatro caracteres, debe tener tres caracteres numéricos seguidos por un carácter alfanumérico.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The regular expression pattern is:</source>
          <target state="translated">El patrón de la expresión regular es:</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Begin the match at the beginning of the line.</source>
          <target state="translated">Comienza la búsqueda de coincidencias al principio de la línea.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Coincide con un carácter alfabético único (<ph id="ph1">`a`</ph> a través de <ph id="ph2">`z`</ph> o <ph id="ph3">`A`</ph> a través de <ph id="ph4">`Z`</ph>) o carácter numérico.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match two numeric characters.</source>
          <target state="translated">Buscar coincidencias con dos caracteres numéricos.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Coincide con un carácter alfabético único (<ph id="ph1">`a`</ph> a través de <ph id="ph2">`z`</ph> o <ph id="ph3">`A`</ph> a través de <ph id="ph4">`Z`</ph>) o carácter numérico.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a hyphen.</source>
          <target state="translated">Buscar coincidencias con un guion.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">Buscar coincidencias con exactamente tres caracteres numéricos.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">Buscar un guión seguido de tres caracteres numéricos y coincide con dos apariciones de este patrón.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Coincide con un carácter alfabético único (<ph id="ph1">`a`</ph> a través de <ph id="ph2">`z`</ph> o <ph id="ph3">`A`</ph> a través de <ph id="ph4">`Z`</ph>) o carácter numérico.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>End the match at the end of the line.</source>
          <target state="translated">Finalizar la búsqueda de coincidencias al final de la línea.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called.</source>
          <target state="translated">Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama al método.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, que impide que el método de tiempo de espera, se utiliza.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The recommended static method for verifying a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">El método estático recomendado para comprobar una coincidencia de patrones es <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, que permite establecer el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options.</source>
          <target state="translated">Indica si la expresión regular especificada encuentra una coincidencia en la cadena de entrada indicada, utilizando para ello las opciones de coincidencia especificadas.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la expresión regular encuentra una coincidencia; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> método suele usarse para validar una cadena o para asegurarse de que una cadena se ajusta a un patrón determinado sin tener que recuperar esa cadena para una manipulación subsiguientes.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">Si desea determinar si una o varias cadenas coinciden con un patrón de expresión regular y, a continuación, recuperan para su manipulación subsiguientes, llamada la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the regular expression pattern specified by <ph id="ph3">`pattern`</ph> and the regular expression options specified by <ph id="ph4">`options`</ph> and calling the <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance method.</source>
          <target state="translated">El método estático <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> método es equivalente a construir un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto con el patrón de expresión regular especificado por <ph id="ph3">`pattern`</ph> y las opciones de expresión regular especificadas por <ph id="ph4">`options`</ph> y llamar a la <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> método de instancia.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This regular expression pattern is cached for rapid retrieval by the regular expression engine.</source>
          <target state="translated">Este patrón de expresión regular se almacena en caché para la recuperación rápida por el motor de expresiones regulares.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> método para determinar si una cadena es un número de pieza válido.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">La expresión regular se da por supuesto que el número de pieza tiene un formato específico que consta de tres conjuntos de caracteres separados por guiones.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">El primer conjunto, que contiene cuatro caracteres, debe constar de un carácter alfanumérico seguido de dos caracteres numéricos seguidos por un carácter alfanumérico.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">El segundo conjunto, que consta de tres caracteres, debe ser numérico.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">El tercer conjunto, que consta de cuatro caracteres, debe tener tres caracteres numéricos seguidos por un carácter alfanumérico.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern is:</source>
          <target state="translated">El patrón de la expresión regular es:</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Begin the match at the beginning of the string.</source>
          <target state="translated">Empieza la búsqueda de coincidencias en el principio de la cadena.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Coincide con cualquier carácter alfabético único de <ph id="ph1">`A`</ph> a través de <ph id="ph2">`Z`</ph>, o cualquier carácter numérico.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match two numeric characters.</source>
          <target state="translated">Buscar coincidencias con dos caracteres numéricos.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Coincide con cualquier carácter alfabético único de <ph id="ph1">`A`</ph> a través de <ph id="ph2">`Z`</ph>, o cualquier carácter numérico.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match a hyphen.</source>
          <target state="translated">Buscar coincidencias con un guion.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">Buscar coincidencias con exactamente tres caracteres numéricos.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern..</source>
          <target state="translated">Buscar un guión seguido de tres caracteres numéricos y coincide con dos apariciones de este patrón...</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Coincide con cualquier carácter alfabético único de <ph id="ph1">`A`</ph> a través de <ph id="ph2">`Z`</ph>, o cualquier carácter numérico.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>End the match at the end of the string.</source>
          <target state="translated">Finalizar la búsqueda al final de la cadena.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method with the <ph id="ph2">`options`</ph> parameter set to <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> is equivalent to defining the following regular expression:</source>
          <target state="translated">Llamar a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> método con el <ph id="ph2">`options`</ph> parámetro establecido en <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> es equivalente a la definición de la siguiente expresión regular:</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For comparison, see the example for the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method.</source>
          <target state="translated">Para la comparación, vea el ejemplo de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> no es un valor <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> válido.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, que impide que el método de tiempo de espera, se utiliza.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for verifying a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">El método estático recomendado para comprobar una coincidencia de patrones es <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, que permite establecer el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Un intervalo de tiempo de espera, o <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> para indicar que el método no debe agotar el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options and time-out interval.</source>
          <target state="translated">Indica si la expresión regular especificada encuentra una coincidencia en la cadena de entrada indicada, utilizando para ello las opciones de coincidencia y el intervalo de tiempo de espera que se especifiquen.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la expresión regular encuentra una coincidencia; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> método suele usarse para validar una cadena o para asegurarse de que una cadena se ajusta a un patrón determinado sin tener que recuperar esa cadena para una manipulación subsiguientes.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">Si desea determinar si una o varias cadenas coinciden con un patrón de expresión regular y, a continuación, recuperan para su manipulación subsiguientes, llamada la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the regular expression pattern specified by <ph id="ph3">`pattern`</ph> and the regular expression options specified by <ph id="ph4">`options`</ph> and calling the <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance method.</source>
          <target state="translated">El método estático <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> método es equivalente a construir un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto con el patrón de expresión regular especificado por <ph id="ph3">`pattern`</ph> y las opciones de expresión regular especificadas por <ph id="ph4">`options`</ph> y llamar a la <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> método de instancia.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This regular expression pattern is cached for rapid retrieval by the regular expression engine.</source>
          <target state="translated">Este patrón de expresión regular se almacena en caché para la recuperación rápida por el motor de expresiones regulares.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated">El <ph id="ph1">`matchTimeout`</ph> parámetro especifica cómo tiempo una coincidencia de patrones método debe intentar encontrar una coincidencia antes de expirar. Establecer un intervalo de tiempo de espera impide que las expresiones regulares que se basan en un retroceso excesivo aparezcan deje de responder cuando procesan datos de entrada que contenga cerca de coincidencias.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>prácticas recomendadas para las expresiones regulares<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> y <bpt id="p2">[</bpt>retroceso<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Si se encuentra ninguna coincidencia en ese intervalo de tiempo, el método produce una <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> invalida cualquier valor de tiempo de espera predeterminado definido para el dominio de aplicación en el que se ejecuta el método.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> método para determinar si una cadena es un número de pieza válido.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">La expresión regular se da por supuesto que el número de pieza tiene un formato específico que consta de tres conjuntos de caracteres separados por guiones.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">El primer conjunto, que contiene cuatro caracteres, debe constar de un carácter alfanumérico seguido de dos caracteres numéricos seguidos por un carácter alfanumérico.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">El segundo conjunto, que consta de tres caracteres, debe ser numérico.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">El tercer conjunto, que consta de cuatro caracteres, debe tener tres caracteres numéricos seguidos por un carácter alfanumérico.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Matching the regular expression pattern should involve minimal searching through the input string, so the method sets a time-out interval of 500 milliseconds.</source>
          <target state="translated">Que coincidan con el patrón de expresión regular debe implicar buscar mínima a través de la cadena de entrada, por lo que el método establece un intervalo de tiempo de espera de 500 milisegundos.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern is:</source>
          <target state="translated">El patrón de la expresión regular es:</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Begin the match at the beginning of the string.</source>
          <target state="translated">Empieza la búsqueda de coincidencias en el principio de la cadena.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Coincide con cualquier carácter alfabético único de <ph id="ph1">`A`</ph> a través de <ph id="ph2">`Z`</ph>, o cualquier carácter numérico.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match two numeric characters.</source>
          <target state="translated">Buscar coincidencias con dos caracteres numéricos.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Coincide con cualquier carácter alfabético único de <ph id="ph1">`A`</ph> a través de <ph id="ph2">`Z`</ph>, o cualquier carácter numérico.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match a hyphen.</source>
          <target state="translated">Buscar coincidencias con un guion.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">Buscar coincidencias con exactamente tres caracteres numéricos.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">Buscar un guión seguido de tres caracteres numéricos y coincide con dos apariciones de este patrón.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Coincide con cualquier carácter alfabético único de <ph id="ph1">`A`</ph> a través de <ph id="ph2">`Z`</ph>, o cualquier carácter numérico.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>End the match at the end of the string.</source>
          <target state="translated">Finalizar la búsqueda al final de la cadena.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method with the <ph id="ph2">`options`</ph> parameter set to <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> is equivalent to defining the following regular expression:</source>
          <target state="translated">Llamar a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> método con el <ph id="ph2">`options`</ph> parámetro establecido en <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> es equivalente a la definición de la siguiente expresión regular:</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For comparison, see the example for the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method.</source>
          <target state="translated">Para la comparación, vea el ejemplo de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> no es un valor <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> válido.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> es negativo, cero o mayor que 24 días aproximadamente.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Se recomienda que establezca el <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parámetro en un valor apropiado, como dos segundos.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Si deshabilita los tiempos de espera mediante la especificación de <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones:</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o está formada por texto estático.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Excluye el texto que se ha dinámicamente introducidos por los usuarios.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controle eficazmente coincide con, ausencia de coincidencias y casi coincide con.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Cuando el patrón de expresión regular no contiene ningún elemento de lenguaje que se sabe que causan un retroceso excesivo al procesar a una coincidencia casi.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Searches an input string for a substring that matches a regular expression pattern and returns the first occurrence as a single <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> object.</source>
          <target state="translated">Busca en una cadena de entrada una subcadena que coincida con un modelo de expresión regular y devuelve la primera aparición como un único objeto <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Searches the specified input string for the first occurrence of the regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Busca en la cadena de entrada especificada la primera aparición de la expresión regular especificada en el constructor <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Objeto que contiene información sobre la coincidencia.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> método devuelve la primera subcadena que coincide con un patrón de expresión regular en una cadena de entrada.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de los elementos de lenguaje que se utilizan para crear un patrón de expresión regular, vea <bpt id="p1">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada comprobando el valor de devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Si se encuentra una coincidencia, el valor devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> propiedad contiene la subcadena desde <ph id="ph3">`input`</ph> que coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si se encuentra ninguna coincidencia, su valor es <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>This method returns the first substring in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Este método devuelve la primera subcadena en <ph id="ph1">`input`</ph> que coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">También puede recuperar todas las coincidencias en una única llamada al método mediante una llamada a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado por el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea el objeto.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The following example finds regular expression pattern matches in a string, then lists the matched groups, captures, and capture positions.</source>
          <target state="translated">En el ejemplo siguiente se busca el patrón de expresión regular coincide con una cadena, muestra el conjunto de grupos, las capturas y las posiciones de captura.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The regular expression pattern <ph id="ph1">`(\w+)\s+(car)`</ph> matches occurrences of the word "car" along with the word that precedes it.</source>
          <target state="translated">El patrón de expresión regular <ph id="ph1">`(\w+)\s+(car)`</ph> devuelve repeticiones de la palabra "car" junto con la palabra que precede en el código.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>It is interpreted as shown in the following table.</source>
          <target state="translated">Se interpreta como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Match one or more word characters.</source>
          <target state="translated">Buscar coincidencias con uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>This is the first capturing group.</source>
          <target state="translated">Este es el primer grupo de captura.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Match one or more white-space characters.</source>
          <target state="translated">Coincide con uno o más caracteres de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>(car)</source>
          <target state="translated">(car)</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Match the literal string "car".</source>
          <target state="translated">Coincide con la cadena literal "car".</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>This is the second capturing group.</source>
          <target state="translated">Este es el segundo grupo de captura.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The zero-based character position at which to start the search.</source>
          <target state="translated">Posición de carácter basada en cero en la que se va a iniciar la búsqueda.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position in the string.</source>
          <target state="translated">Busca en la cadena de entrada la primera aparición de una expresión regular, empezando en la posición inicial especificada de la cadena.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Objeto que contiene información sobre la coincidencia.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> method returns the first substring that matches a regular expression pattern, starting at or after the <ph id="ph2">`startat`</ph> character position, in an input string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> método devuelve la primera subcadena que coincide con un patrón de expresión regular, empezando en o después de la <ph id="ph2">`startat`</ph> posición de carácter, de una cadena de entrada.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de los elementos de lenguaje que se utilizan para crear un patrón de expresión regular, vea <bpt id="p1">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">El patrón de expresión regular para que la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> búsquedas de método se define mediante la llamada a uno de los <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructores de clase.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de los elementos que pueden formar un patrón de expresión regular, vea <bpt id="p1">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can optionally specify a starting position in the string by using the <ph id="ph1">`startat`</ph> parameter.</source>
          <target state="translated">Opcionalmente, puede especificar una posición inicial de la cadena mediante el <ph id="ph1">`startat`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>When the regular expression engine parses from left to right (the default), the match and the scan move rightward, starting at the character specified in <ph id="ph1">`startat`</ph>.</source>
          <target state="translated">Cuando el motor de expresiones regulares analiza de izquierda a derecha (el valor predeterminado), la coincidencia y la exploración se mueven hacia la derecha, empezando por el carácter especificado en <ph id="ph1">`startat`</ph>.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>When the regular expression engine parses from right to left (when the regular expression pattern is constructed with the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> option), the match and scan move in the opposite direction and begin with the character at <ph id="ph2">`startat`</ph> -1.</source>
          <target state="translated">Cuando el motor de expresiones regulares analiza de derecha a izquierda (cuando se construye el patrón de expresión regular con la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> opción), la coincidencia y la exploración mover en la dirección opuesta y comienzan con el carácter que ocupa <ph id="ph2">`startat`</ph> -1.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If you do not specify a starting position, the search begins at the default <ph id="ph1">`startat`</ph> position.</source>
          <target state="translated">Si no especifica una posición inicial, la búsqueda comienza en el valor predeterminado <ph id="ph1">`startat`</ph> posición.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If the regular expression searches from left to right, the default <ph id="ph1">`startat`</ph> position is at the left end of <ph id="ph2">`input`</ph>; if it searches from right to left, the default <ph id="ph3">`startat`</ph> position is at the right end of <ph id="ph4">`input`</ph>.</source>
          <target state="translated">Si la expresión regular busca de izquierda a derecha, el valor predeterminado <ph id="ph1">`startat`</ph> posición está en el extremo izquierdo de <ph id="ph2">`input`</ph>; si busca de derecha a izquierda, el valor predeterminado <ph id="ph3">`startat`</ph> posición está en el extremo derecho de <ph id="ph4">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If you want to restrict a match so that it begins at a particular character position in the string and the regular expression engine does not scan the remainder of the string for a match, anchor the regular expression with a <ph id="ph1">`\G`</ph> (at the left for a left-to-right pattern, or at the right for a right-to-left pattern).</source>
          <target state="translated">Si desea restringir una coincidencia para que comienza en una posición de caracteres determinada en la cadena y el motor de expresiones regulares no examina el resto de la cadena de una coincidencia, delimite la expresión regular con una <ph id="ph1">`\G`</ph> (a la izquierda para un modelo de izquierda a derecha o a la derecha de un patrón de derecha a izquierda).</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>This restricts the match so it must start exactly at <ph id="ph1">`startat`</ph>.</source>
          <target state="translated">Esto restringe la búsqueda de coincidencias, por lo que debe comenzar exactamente en <ph id="ph1">`startat`</ph>.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada comprobando el valor de devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Si se encuentra una coincidencia, el valor devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> propiedad contiene la subcadena desde <ph id="ph3">`input`</ph> que coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si se encuentra ninguna coincidencia, su valor es <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>This method returns the first substring found at or after the <ph id="ph1">`startat`</ph> character position in <ph id="ph2">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Este método devuelve la primera subcadena encontrada en o después de la <ph id="ph1">`startat`</ph> posición de carácter de <ph id="ph2">`input`</ph> que coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">También puede recuperar todas las coincidencias en una única llamada al método mediante una llamada a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado por el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exeeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación sobrepasa cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea el objeto.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> es menor que cero o mayor que la longitud de <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Searches the specified input string for the first occurrence of the specified regular expression.</source>
          <target state="translated">Busca en la cadena de entrada especificada la primera aparición de la expresión regular indicada.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Objeto que contiene información sobre la coincidencia.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> método devuelve la primera subcadena que coincide con un patrón de expresión regular en una cadena de entrada.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de los elementos de lenguaje que se utilizan para crear un patrón de expresión regular, vea <bpt id="p1">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method.</source>
          <target state="translated">El método estático <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> método es equivalente a construir un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto con el patrón de expresión regular especificado y llamar a la instancia <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>In this case, the regular expression engine caches the regular expression pattern.</source>
          <target state="translated">En este caso, el motor de expresiones regulares almacena en caché el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada comprobando el valor de devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Si se encuentra una coincidencia, el valor devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> propiedad contiene la subcadena desde <ph id="ph3">`input`</ph> que coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si se encuentra ninguna coincidencia, su valor es <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>This method returns the first substring in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Este método devuelve la primera subcadena en <ph id="ph1">`input`</ph> que coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">También puede recuperar todas las coincidencias en una única llamada al método mediante una llamada a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method to find the first word that contains at least one <ph id="ph2">`z`</ph> character, and then calls the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method to find any additional matches.</source>
          <target state="translated">El ejemplo siguiente se llama el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> método para buscar la primera palabra que contiene al menos una <ph id="ph2">`z`</ph> caracteres y, a continuación, llama el <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> método al que se encuentra ninguna coincidencia adicional.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The regular expression pattern <ph id="ph1">`\b\w*z+\w*\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">El patrón de la expresión regular <ph id="ph1">`\b\w*z+\w*\b`</ph> se interpreta como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Iniciar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Match zero, one, or more word characters.</source>
          <target state="translated">Coincide con cero, uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Match one or more occurrences of the <ph id="ph1">`z`</ph> character.</source>
          <target state="translated">Busca coincidencias con uno o varios de los <ph id="ph1">`z`</ph> caracteres.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Match zero, one, or more word characters.</source>
          <target state="translated">Coincide con cero, uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Finalizar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, que impide que el método de tiempo de espera, se utiliza.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The recommended static method for retrieving a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">El método estático recomendado para recuperar una coincidencia de patrones es <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, que permite establecer el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The zero-based character position in the input string that defines the leftmost position to be searched.</source>
          <target state="translated">Posición de caracteres de base cero en la cadena de entrada que define la posición más a la izquierda en la que se buscará.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The number of characters in the substring to include in the search.</source>
          <target state="translated">Número de caracteres de la subcadena que se van a incluir en la búsqueda.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position and searching only the specified number of characters.</source>
          <target state="translated">Busca en la cadena de entrada la primera aparición de una expresión regular, empezando en la posición inicial especificada y buscando solo en el número de caracteres indicado.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Objeto que contiene información sobre la coincidencia.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method returns the first substring that matches a regular expression pattern in a portion of an input string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> método devuelve la primera subcadena que coincide con un patrón de expresión regular en una parte de una cadena de entrada.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de los elementos de lenguaje que se utilizan para crear un patrón de expresión regular, vea <bpt id="p1">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">El patrón de expresión regular para que la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> búsquedas de método se define mediante la llamada a uno de los <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructores de clase.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de los elementos que pueden formar un patrón de expresión regular, vea <bpt id="p1">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method searches the portion of <ph id="ph2">`input`</ph> defined by the <ph id="ph3">`beginning`</ph> and <ph id="ph4">`length`</ph> parameters for the regular expression pattern.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> método busca en la parte de <ph id="ph2">`input`</ph> definido por el <ph id="ph3">`beginning`</ph> y <ph id="ph4">`length`</ph> parámetros para el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">`beginning`</ph> always defines the index of the leftmost character to include in the search, and <ph id="ph2">`length`</ph> defines the maximum number of characters to search.</source>
          <target state="translated"><ph id="ph1">`beginning`</ph> siempre se define el índice del carácter más a la izquierda para incluir en la búsqueda, y <ph id="ph2">`length`</ph> define el número máximo de caracteres que se va a buscar.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>Together, they define the range of the search.</source>
          <target state="translated">Juntos, definen el intervalo de la búsqueda.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If the search proceeds from left to right (the default), the regular expression engine searches from the character at index <ph id="ph1">`beginning`</ph> to the character at index <ph id="ph2">`beginning`</ph><ph id="ph3"> + </ph><ph id="ph4">`length`</ph> – 1.</source>
          <target state="translated">Si la búsqueda se realiza de izquierda a derecha (el valor predeterminado), el motor de expresiones regulares buscará desde el carácter que ocupa el índice <ph id="ph1">`beginning`</ph> hasta el carácter en el índice <ph id="ph2">`beginning`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`length`</ph> – 1.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If the regular expression engine was instantiated by using the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> option so that the search proceeds from right to left, the regular expression engine searches from the character at index <ph id="ph2">`beginning`</ph><ph id="ph3"> + </ph><ph id="ph4">`length`</ph> – 1 to the character at index <ph id="ph5">`beginning`</ph>.</source>
          <target state="translated">Si se crea una instancia del motor de expresiones regulares mediante el uso de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> opción para que la búsqueda continúa de derecha a izquierda, las búsquedas de motor de expresiones regulares en el carácter que ocupa el índice <ph id="ph2">`beginning`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`length`</ph> – 1 para el carácter que ocupa el índice <ph id="ph5">`beginning`</ph>.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>This method returns the first match that it finds within this range.</source>
          <target state="translated">Este método devuelve a la primera coincidencia que encuentra dentro de este intervalo.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada comprobando el valor de devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Si se encuentra una coincidencia, el valor devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> propiedad contiene la subcadena desde <ph id="ph3">`input`</ph> que coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si se encuentra ninguna coincidencia, su valor es <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado por el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If you do not set a time-out value when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si no establece un valor de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea el objeto.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph> es menor que cero o mayor que la longitud de <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> es menor que cero o mayor que la longitud de <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph><ph id="ph2">&lt;see langword="+" /&gt;</ph><ph id="ph3">&lt;paramref name="length" /&gt;</ph><ph id="ph4">&lt;see langword="–1" /&gt;</ph> identifies a position that is outside the range of <ph id="ph5">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph><ph id="ph2">&lt;see langword="+" /&gt;</ph><ph id="ph3">&lt;paramref name="length" /&gt;</ph><ph id="ph4">&lt;see langword="–1" /&gt;</ph> identifica una posición que está fuera del intervalo de <ph id="ph5">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Searches the input string for the first occurrence of the specified regular expression, using the specified matching options.</source>
          <target state="translated">Busca en la cadena de entrada la primera aparición de la expresión regular especificada, utilizando para ello las opciones de coincidencia indicadas.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Objeto que contiene información sobre la coincidencia.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> método devuelve la primera subcadena que coincide con un patrón de expresión regular en una cadena de entrada.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de los elementos de lenguaje que se utilizan para crear un patrón de expresión regular, vea <bpt id="p1">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor and calling the instance <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method.</source>
          <target state="translated">El método estático <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> método es equivalente a construir un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto con el <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor y llamar a la instancia <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> (método).</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada comprobando el valor de devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Si se encuentra una coincidencia, el valor devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> propiedad contiene la subcadena desde <ph id="ph3">`input`</ph> que coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si se encuentra ninguna coincidencia, su valor es <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method returns the first substring found in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Este método devuelve la primera subcadena encontrada en <ph id="ph1">`input`</ph> que coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> method.</source>
          <target state="translated">Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">También puede recuperar todas las coincidencias en una única llamada al método mediante una llamada a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example defines a regular expression that matches words beginning with the letter "a".</source>
          <target state="translated">En el ejemplo siguiente se define una expresión regular que coincide con palabras que empiezan con la letra "a".</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>It uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> option to ensure that the regular expression locates words beginning with both an uppercase "a" and a lowercase "a".</source>
          <target state="translated">Usa el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> opción para asegurarse de que la expresión regular busca palabras que empiezan con ambas en mayúscula en minúscula "a" y "a".</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern <ph id="ph1">`\ba\w*\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">El patrón de la expresión regular <ph id="ph1">`\ba\w*\b`</ph> se interpreta como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Iniciar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the character "a".</source>
          <target state="translated">Coincide con el carácter "a".</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match zero, one, or more word characters.</source>
          <target state="translated">Coincide con cero, uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Finalizar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> no es una combinación bit a bit válida de valores <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, que impide que el método de tiempo de espera, se utiliza.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for retrieving a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">El método estático recomendado para recuperar una coincidencia de patrones es <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, que permite establecer el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Un intervalo de tiempo de espera, o <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> para indicar que el método no debe agotar el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Searches the input string for the first occurrence of the specified regular expression, using the specified matching options and time-out interval.</source>
          <target state="translated">Busca en la cadena de entrada la primera aparición de la expresión regular especificada, utilizando para ello las opciones de coincidencia y el intervalo de tiempo de espera que se indiquen.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Objeto que contiene información sobre la coincidencia.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> método devuelve la primera subcadena que coincide con un patrón de expresión regular en una cadena de entrada.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de los elementos de lenguaje que se utilizan para crear un patrón de expresión regular, vea <bpt id="p1">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor and calling the instance <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method.</source>
          <target state="translated">El método estático <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> método es equivalente a construir un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto con el <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor y llamar a la instancia <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> (método).</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada comprobando el valor de devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Si se encuentra una coincidencia, el valor devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> propiedad contiene la subcadena desde <ph id="ph3">`input`</ph> que coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si se encuentra ninguna coincidencia, su valor es <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This method returns the first substring found in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Este método devuelve la primera subcadena encontrada en <ph id="ph1">`input`</ph> que coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> method.</source>
          <target state="translated">Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">También puede recuperar todas las coincidencias en una única llamada al método mediante una llamada a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated">El <ph id="ph1">`matchTimeout`</ph> parámetro especifica cómo tiempo una coincidencia de patrones método debe intentar encontrar una coincidencia antes de expirar. Establecer un intervalo de tiempo de espera impide que las expresiones regulares que se basan en un retroceso excesivo aparezcan deje de responder cuando procesan datos de entrada que contenga cerca de coincidencias.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>prácticas recomendadas para las expresiones regulares<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> y <bpt id="p2">[</bpt>retroceso<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Si se encuentra ninguna coincidencia en ese intervalo de tiempo, el método produce una <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> invalida cualquier valor de tiempo de espera predeterminado definido para el dominio de aplicación en el que se ejecuta el método.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> no es una combinación bit a bit válida de valores <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> es negativo, cero o mayor que 24 días aproximadamente.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó un tiempo de espera.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Se recomienda que establezca el <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parámetro en un valor apropiado, como dos segundos.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Si deshabilita los tiempos de espera mediante la especificación de <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones:</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o está formada por texto estático.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Excluye el texto que se ha dinámicamente introducidos por los usuarios.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controle eficazmente coincide con, ausencia de coincidencias y casi coincide con.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Cuando el patrón de expresión regular no contiene ningún elemento de lenguaje que se sabe que causan un retroceso excesivo al procesar a una coincidencia casi.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Searches an input string for all occurrences of a regular expression and returns all the matches.</source>
          <target state="translated">Busca en una cadena de entrada todas las apariciones de una expresión regular y devuelve todas las coincidencias.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>When a match attempt is repeated by calling the <ph id="ph1">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /&gt;</ph> method, the regular expression engine gives empty matches special treatment.</source>
          <target state="translated">Cuando se repite un intento de coincidencia mediante una llamada a la <ph id="ph1">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /&gt;</ph> método, el motor de expresiones regulares otorga coincidencias vacías un tratamiento especial.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Usually, the regular expression engine begins the search for the next match exactly where the previous match left off.</source>
          <target state="translated">Normalmente, el motor de expresiones regulares comienza la búsqueda de la siguiente coincidencia la coincidencia anterior exactamente.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>However, after an empty match, the regular expression engine advances by one character before trying the next match.</source>
          <target state="translated">Sin embargo, tras una coincidencia vacía, el motor de expresiones regulares avanza un carácter antes de intentar a buscar la siguiente coincidencia.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This behavior guarantees that the regular expression engine will progress through the string.</source>
          <target state="translated">Este comportamiento garantiza que el motor de expresiones regulares se avanza a través de la cadena.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Otherwise, because an empty match does not result in any forward movement, the next match would start in exactly the same place as the previous match, and it would match the same empty string repeatedly.</source>
          <target state="translated">En caso contrario, porque no se produce una coincidencia vacía en cualquier movimiento hacia adelante, comience la siguiente coincidencia de exactamente el mismo lugar que la coincidencia anterior y coincidiría con varias veces la misma cadena vacía.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In the following example, the regular expression pattern <bpt id="p1">&lt;c&gt;</bpt>a*<ept id="p1">&lt;/c&gt;</ept> searches for zero or more occurrences of the letter "a" in the string "abaabb".</source>
          <target state="translated">En el ejemplo siguiente, el patrón de expresión regular <bpt id="p1">&lt;c&gt;</bpt>un *<ept id="p1">&lt;/c&gt;</ept> Busca cero o más apariciones de la letra "a" en la cadena "abaabb".</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>As the output from the example shows, the resulting <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchCollection" /&gt;</ph> object contains six <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects.</source>
          <target state="translated">Como la salida se muestra en el ejemplo, resultantes <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchCollection" /&gt;</ph> objeto contiene seis <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The first match attempt finds the first "a".</source>
          <target state="translated">El primer intento de coincidencia busca la primera "a".</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The second match starts exactly where the first match ends, before the first b; it finds zero occurrences of "a" and returns an empty string.</source>
          <target state="translated">La segunda búsqueda se inicia exactamente donde el primero coincide con extremos, antes de la primera b; Busca cero apariciones de "a" y devuelve una cadena vacía.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The third match does not begin exactly where the second match ended, because the second match returned an empty string.</source>
          <target state="translated">La tercera búsqueda no comienza exactamente donde terminó la segunda coincidencia, porque la segunda coincidencia devolvió una cadena vacía.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Instead, it begins one character later, after the first "b".</source>
          <target state="translated">En su lugar, inicia un carácter más adelante, después de la primera "b".</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The third match finds two occurrences of "a" and returns "aa".</source>
          <target state="translated">La tercera búsqueda encuentra dos apariciones de "a" y devuelve "aa".</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The fourth match attempt begins where the third match ended, before the second "b", and returns an empty string.</source>
          <target state="translated">El cuarto intento de coincidencia comienza donde finalizó la coincidencia terceros, antes de la segunda "b" y devuelve una cadena vacía.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The fifth match attempt again advances one character so that it begins before the third "b" and returns an empty string.</source>
          <target state="translated">El intento de coincidencia quinto nuevo avanza un carácter para que se inicia antes de que el tercer "b" y devuelve una cadena vacía.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The sixth match begins after the last "b" and returns an empty string again.</source>
          <target state="translated">La búsqueda de coincidencias sexto comienza después de la última "b" y devuelve una cadena vacía de nuevo.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Searches the specified input string for all occurrences of a regular expression.</source>
          <target state="translated">Busca en la cadena de entrada especificada todas las apariciones de una expresión regular.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">Colección de los objetos <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> encontrados en la búsqueda.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">Si no se encuentran coincidencias, el método devuelve un objeto de colección vacía.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> método es similar a la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> método, salvo que devuelva información sobre todas las coincidencias que se encuentra en la cadena de entrada, en lugar de una coincidencia única.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Es equivalente al código siguiente:</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The collection includes only matches and terminates at the first non-match.</source>
          <target state="translated">La colección incluye a solamente las correspondencias y termina en la primera no coincidencia.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">El patrón de expresión regular para que la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> búsquedas de método se define mediante la llamada a uno de los <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructores de clase.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de los elementos que pueden formar un patrón de expresión regular, vea <bpt id="p1">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> método utiliza la evaluación diferida para rellenar el valor devuelto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">Acceso a miembros de esta colección como <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> hace que la colección que se debe rellenar de forma inmediata.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">Para sacar partido de la evaluación diferida, se debe iterar por la colección mediante una construcción como <ph id="ph1">`foreach`</ph> en C# y <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>in Visual Basic.</source>
          <target state="translated">en Visual Basic.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Debido a su evaluación diferida, al llamar a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> método no produce una <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> property is not <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> and a matching operation exceeds the time-out interval.</source>
          <target state="translated">Sin embargo, la excepción se produce cuando se realiza una operación en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objeto devuelto por este método, si la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> propiedad no es <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> y una operación de búsqueda de coincidencias supere el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method to identify any words in a sentence that end in "es".</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> método para identificar todas las palabras de una frase que terminan en "es".</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">El patrón de expresión regular <ph id="ph1">`\b\w+es\b`</ph> se define como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Iniciar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Match one or more word characters.</source>
          <target state="translated">Buscar coincidencias con uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Match the literal string "es".</source>
          <target state="translated">Coincide con la cadena literal "es".</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Finalizar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The character position in the input string at which to start the search.</source>
          <target state="translated">Posición de carácter de la cadena de entrada en la que se va a iniciar la búsqueda.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Searches the specified input string for all occurrences of a regular expression, beginning at the specified starting position in the string.</source>
          <target state="translated">Busca en la cadena de entrada especificada todas las apariciones de una expresión regular, empezando en la posición de inicio especificada de la cadena.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">Colección de los objetos <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> encontrados en la búsqueda.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">Si no se encuentran coincidencias, el método devuelve un objeto de colección vacía.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The  <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method is similar to the  <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> método es similar a la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> método, salvo que devuelva información sobre todas las coincidencias que se encuentra en la cadena de entrada, en lugar de una coincidencia única.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Es equivalente al código siguiente:</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">El patrón de expresión regular para que la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> búsquedas de método se define mediante la llamada a uno de los <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructores de clase.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de los elementos que pueden formar un patrón de expresión regular, vea <bpt id="p1">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> método utiliza la evaluación diferida para rellenar el valor devuelto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">Acceso a miembros de esta colección como <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> hace que la colección que se debe rellenar de forma inmediata.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">Para sacar partido de la evaluación diferida, se debe iterar por la colección mediante una construcción como <ph id="ph1">`foreach`</ph> en C# y <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>in Visual Basic.</source>
          <target state="translated">en Visual Basic.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Debido a su evaluación diferida, al llamar a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> método no produce una <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> property is not <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> and a matching operation exceeds the time-out interval..</source>
          <target state="translated">Sin embargo, la excepción se produce cuando se realiza una operación en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objeto devuelto por este método, si la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> propiedad no es <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> y una operación de búsqueda de coincidencias supere el intervalo de tiempo de espera...</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method to find the first word in a sentence that ends in "es", and then calls the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method to identify any additional words that end in "es".</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> método para buscar la primera palabra de una frase que termina en "es" y, a continuación, llama el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> método para identificar cualquier palabra adicional que terminan en "es".</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">El patrón de expresión regular <ph id="ph1">`\b\w+es\b`</ph> se define como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Iniciar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Match one or more word characters.</source>
          <target state="translated">Buscar coincidencias con uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Match the literal string "es".</source>
          <target state="translated">Coincide con la cadena literal "es".</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Finalizar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> es menor que cero o mayor que la longitud de <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Searches the specified input string for all occurrences of a specified regular expression.</source>
          <target state="translated">Busca en la cadena de entrada especificada todas las apariciones de una expresión regular indicada.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">Colección de los objetos <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> encontrados en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">Si no se encuentran coincidencias, el método devuelve un objeto de colección vacía.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> método es similar a la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> método, salvo que devuelva información sobre todas las coincidencias que se encuentra en la cadena de entrada, en lugar de una coincidencia única.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Es equivalente al código siguiente:</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The static <ph id="ph1">`Matches`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Matches`</ph>.</source>
          <target state="translated">El método estático <ph id="ph1">`Matches`</ph> métodos son equivalentes a construir un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto con el patrón de expresión regular especificado y llamando al método de instancia <ph id="ph3">`Matches`</ph>.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> método utiliza la evaluación diferida para rellenar el valor devuelto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">Acceso a miembros de esta colección como <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> hace que la colección que se debe rellenar de forma inmediata.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">Para sacar partido de la evaluación diferida, se debe iterar por la colección mediante una construcción como <ph id="ph1">`foreach`</ph> en C# y <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>in Visual Basic.</source>
          <target state="translated">en Visual Basic.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Debido a su evaluación diferida, al llamar a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> método no produce una <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if a time-out interval is defined by the "REGEX_DEFAULT_MATCH_TIMEOUT" property of the current application domain and a matching operation exceeds this time-out interval.</source>
          <target state="translated">Sin embargo, la excepción se produce cuando se realiza una operación en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objeto devuelto por este método, si un intervalo de tiempo de espera se define mediante la propiedad "REGEX_DEFAULT_MATCH_TIMEOUT" del dominio de aplicación actual y una operación de búsqueda de coincidencias supera este intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method to identify any word in a sentence that ends in "es".</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> método para identificar cualquier palabra en una frase que termina en "es".</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">El patrón de expresión regular <ph id="ph1">`\b\w+es\b`</ph> se define como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Iniciar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Match one or more word characters.</source>
          <target state="translated">Buscar coincidencias con uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Match the literal string "es".</source>
          <target state="translated">Coincide con la cadena literal "es".</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Finalizar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, que impide que el método de tiempo de espera, se utiliza.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The recommended static method for retrieving multiple pattern matches is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you specify the time-out interval.</source>
          <target state="translated">El método estático recomendado para recuperar varios patrón coincide con es <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, que le permite especificar el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that specify options for matching.</source>
          <target state="translated">Combinación bit a bit de los valores de enumeración que especifican opciones de coincidencia.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options.</source>
          <target state="translated">Busca en la cadena de entrada especificada todas las apariciones de una expresión regular indicada, utilizando para ello las opciones de coincidencia especificadas.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">Colección de los objetos <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> encontrados en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">Si no se encuentran coincidencias, el método devuelve un objeto de colección vacía.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> método es similar a la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> método, salvo que devuelva información sobre todas las coincidencias que se encuentra en la cadena de entrada, en lugar de una coincidencia única.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Es equivalente al código siguiente:</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">`Matches`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Matches`</ph>.</source>
          <target state="translated">El método estático <ph id="ph1">`Matches`</ph> métodos son equivalentes a construir un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto con el patrón de expresión regular especificado y llamando al método de instancia <ph id="ph3">`Matches`</ph>.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> método utiliza la evaluación diferida para rellenar el valor devuelto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">Acceso a miembros de esta colección como <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> hace que la colección que se debe rellenar de forma inmediata.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">Para sacar partido de la evaluación diferida, se debe iterar por la colección mediante una construcción como <ph id="ph1">`foreach`</ph> en C# y <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>in Visual Basic.</source>
          <target state="translated">en Visual Basic.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Debido a su evaluación diferida, al llamar a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> método no produce una <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if a time-out interval is defined by the "REGEX_DEFAULT_MATCH_TIMEOUT" property of the current application domain and a matching operation exceeds this time-out interval.</source>
          <target state="translated">Sin embargo, la excepción se produce cuando se realiza una operación en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objeto devuelto por este método, si un intervalo de tiempo de espera se define mediante la propiedad "REGEX_DEFAULT_MATCH_TIMEOUT" del dominio de aplicación actual y una operación de búsqueda de coincidencias supera este intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method to identify any word in a sentence that ends in "es", and then calls the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method to perform a case-insensitive comparison of the pattern with the input string.</source>
          <target state="translated">El ejemplo siguiente se llama el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> método para identificar cualquier palabra en una frase que termina en "es" y, a continuación, llama a la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> método para realizar una comparación entre mayúsculas y minúsculas del patrón con la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>As the output shows, the two methods return different results.</source>
          <target state="translated">Como muestra el resultado, los dos métodos devuelvan resultados diferentes.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">El patrón de expresión regular <ph id="ph1">`\b\w+es\b`</ph> se define como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Iniciar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match one or more word characters.</source>
          <target state="translated">Buscar coincidencias con uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the literal string "es".</source>
          <target state="translated">Coincide con la cadena literal "es".</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Finalizar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> no es una combinación bit a bit válida de valores <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, que impide que el método de tiempo de espera, se utiliza.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for retrieving multiple pattern matches is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">El método estático recomendado para recuperar varios patrón coincide con es <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, que permite establecer el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that specify options for matching.</source>
          <target state="translated">Combinación bit a bit de los valores de enumeración que especifican opciones de coincidencia.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Un intervalo de tiempo de espera, o <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> para indicar que el método no debe agotar el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options and time-out interval.</source>
          <target state="translated">Busca en la cadena de entrada especificada todas las apariciones de una expresión regular indicada, utilizando para ello las opciones de coincidencia y el intervalo de tiempo de espera que se especifiquen.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">Colección de los objetos <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> encontrados en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">Si no se encuentran coincidencias, el método devuelve un objeto de colección vacía.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> método es similar a la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> método, salvo que devuelva información sobre todas las coincidencias que se encuentra en la cadena de entrada, en lugar de una coincidencia única.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Es equivalente al código siguiente:</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">`Matches`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Matches`</ph>.</source>
          <target state="translated">El método estático <ph id="ph1">`Matches`</ph> métodos son equivalentes a construir un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto con el patrón de expresión regular especificado y llamando al método de instancia <ph id="ph3">`Matches`</ph>.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> método utiliza la evaluación diferida para rellenar el valor devuelto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">Acceso a miembros de esta colección como <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> hace que la colección que se debe rellenar de forma inmediata.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">Para sacar partido de la evaluación diferida, se debe iterar por la colección mediante una construcción como <ph id="ph1">`foreach`</ph> en C# y <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>in Visual Basic.</source>
          <target state="translated">en Visual Basic.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Debido a su evaluación diferida, al llamar a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> método no produce una <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, an exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if a matching operation exceeds this time-out interval specified by the<ph id="ph2">`matchTimeout`</ph> parameter.</source>
          <target state="translated">Sin embargo, se produce una excepción cuando se realiza una operación en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objeto devuelto por este método, si una operación de coincidencia superior a este intervalo de tiempo de espera especificado por el<ph id="ph2">`matchTimeout`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to perform a case-sensitive comparison that matches any word in a sentence that ends in "es".</source>
          <target state="translated">El ejemplo siguiente se llama el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> método para realizar una comparación entre mayúsculas y minúsculas que coincide con cualquier palabra en una frase que termina en "es".</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to perform a case-insensitive comparison of the pattern with the input string.</source>
          <target state="translated">A continuación, llama el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> método para realizar una comparación entre mayúsculas y minúsculas del patrón con la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In both cases, the time-out interval is set to one second.</source>
          <target state="translated">En ambos casos, el intervalo de tiempo de espera se establece en un segundo.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>As the output shows, the two methods return different results.</source>
          <target state="translated">Como muestra el resultado, los dos métodos devuelvan resultados diferentes.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">El patrón de expresión regular <ph id="ph1">`\b\w+es\b`</ph> se define como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Iniciar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match one or more word characters.</source>
          <target state="translated">Buscar coincidencias con uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the literal string "es".</source>
          <target state="translated">Coincide con la cadena literal "es".</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Finalizar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> no es una combinación bit a bit válida de valores <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> es negativo, cero o mayor que 24 días aproximadamente.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Se recomienda que establezca el <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parámetro en un valor apropiado, como dos segundos.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Si deshabilita los tiempos de espera mediante la especificación de <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones:</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o está formada por texto estático.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Excluye el texto que se ha dinámicamente introducidos por los usuarios.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controle eficazmente coincide con, ausencia de coincidencias y casi coincide con.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Cuando el patrón de expresión regular no contiene ningún elemento de lenguaje que se sabe que causan un retroceso excesivo al procesar a una coincidencia casi.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>Gets the time-out interval of the current instance.</source>
          <target state="translated">Obtiene el intervalo de tiempo de espera de la instancia actual.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>The maximum time interval that can elapse in a pattern-matching operation before a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /&gt;</ph> is thrown, or <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> if time-outs are disabled.</source>
          <target state="translated">Intervalo de tiempo máximo que puede transcurrir en una operación de coincidencia de modelos antes de que se produzca una <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /&gt;</ph> o <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> si se deshabilitan los tiempos de espera.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> property defines the approximate maximum time interval for a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instance to execute a single matching operation before the operation times out. The regular expression engine throws a <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception during its next timing check after the time-out interval has elapsed.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> propiedad define el intervalo de tiempo máximo aproximado para un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instancia para ejecutar una única operación coincidente antes agote el tiempo de espera de la operación. El motor de expresiones regulares produce una <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción durante su próxima comprobación de tiempo después de que ha transcurrido el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>This prevents the regular expression engine from processing input strings that require excessive backtracking.</source>
          <target state="translated">Esto evita que el motor de expresiones regulares de procesamiento de cadenas de entrada que requieren un retroceso excesivo.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>For more information, see <bpt id="p1">[</bpt>Backtracking<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Best Practices for Regular Expressions<ept id="p2">](~/docs/standard/base-types/best-practices.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>retroceso<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept> y <bpt id="p2">[</bpt>prácticas recomendadas para las expresiones regulares<ept id="p2">](~/docs/standard/base-types/best-practices.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>This property is read-only.</source>
          <target state="translated">Esta propiedad es de sólo lectura.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>You can set its value explicitly for an individual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object by calling the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor; and you can set its value for all <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> matching operations in an application domain by calling the <ph id="ph4">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> method and providing a <ph id="ph5">&lt;xref:System.TimeSpan&gt;</ph> value for the "REGEX_DEFAULT_MATCH_TIMEOUT" property, as the following example illustrates.</source>
          <target state="translated">Puede establecer su valor explícitamente para las personas <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto mediante una llamada a la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor y se puede establecer su valor para todas las <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> coincidencia operaciones en un dominio de aplicación mediante una llamada a la <ph id="ph4">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> método y proporcionar una <ph id="ph5">&lt;xref:System.TimeSpan&gt;</ph> valor para la propiedad "REGEX_DEFAULT_MATCH_TIMEOUT", como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>If you do not explicitly set a time-out interval, the default value <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> is used, and matching operations do not time out.</source>
          <target state="translated">Si no establece explícitamente un intervalo de tiempo de espera, el valor predeterminado <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> es operaciones utilizadas y búsqueda de coincidencias no caducan.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>Gets the options that were passed into the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Obtiene las opciones que se pasaron en el constructor <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>One or more members of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> enumeration that represent options that were passed to the <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor</source>
          <target state="translated">Uno o más miembros de la enumeración <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> que representan opciones pasadas al constructor de <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>The value of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> property consists of one or more members of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions&gt;</ph> enumeration.</source>
          <target state="translated">El valor de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> propiedad consta de uno o varios miembros de la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>If no options were defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructor, its value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si no se definió ninguna opción en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor de clase, su valor es <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>The available options are discussed in detail in the <bpt id="p1">[</bpt>Regular Expression Options<ept id="p1">](~/docs/standard/base-types/regular-expression-options.md)</ept> topic.</source>
          <target state="translated">Las opciones disponibles se describen en detalle en la <bpt id="p1">[</bpt>opciones de expresiones regulares<ept id="p1">](~/docs/standard/base-types/regular-expression-options.md)</ept> tema.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>Note that the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> property does not reflect inline options defined in the regular expression pattern itself.</source>
          <target state="translated">Tenga en cuenta que el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> propiedad no refleja las opciones insertadas definidas en la expresión regular de sí mismo patrón.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> is the base class of regular expressions created by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> es la clase base de las expresiones regulares creados por el <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>These compiled regular expressions use the base class implementation of the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property.</source>
          <target state="translated">Estas expresiones regulares compiladas que usan la implementación de clase base de la <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>If called from a derived class, the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property returns the options that were passed to the <ph id="ph2">&lt;paramref name="options" /&gt;</ph> parameter of the <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> class constructor that was used to define the regular expression.</source>
          <target state="translated">Si se llama desde una clase derivada, el <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> propiedad devuelve las opciones que se pasaron a la <ph id="ph2">&lt;paramref name="options" /&gt;</ph> parámetro de la <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> constructor de clase que se utiliza para definir la expresión regular.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.pattern">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Lo usa un objeto <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> generado por el método <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>In a specified input string, replaces strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">En una cadena de entrada especificada, reemplaza las cadenas que coinciden con un modelo de expresión regular por una cadena de reemplazo especificada.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The replacement string.</source>
          <target state="translated">La cadena de reemplazo.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>In a specified input string, replaces all strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con un patrón de expresión regular por una cadena de reemplazo especificada.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The search for matches starts at the beginning of the <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">Comienza la búsqueda de coincidencias al principio de la <ph id="ph1">`input`</ph> cadena.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">La expresión regular es el patrón definido por el constructor para el actual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated">El <ph id="ph1">`replacement`</ph> parámetro especifica la cadena que va a reemplazar cada coincidencia en <ph id="ph2">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> puede constar de cualquier combinación de texto literal y <bpt id="p1">[</bpt>sustituciones<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Por ejemplo, el patrón de reemplazo <ph id="ph1">`a*${test}b`</ph> inserta la cadena "un *" seguida de la subcadena que coincide con el <ph id="ph2">`test`</ph> capturas de grupo, si los hay, seguida por la cadena "b".</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">El * caracteres no se reconocen como un metacarácter dentro de un patrón de reemplazo.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Todos los otros elementos de lenguaje de expresiones regulares, incluidos <bpt id="p1">[</bpt>escapes de caracteres<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, se permiten en los patrones de expresión regular solo y no se reconocen en modelos de reemplazo.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea el objeto.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Dado que el método devuelve <ph id="ph1">`input`</ph> sin cambios si no hay ninguna coincidencia, puede usar el <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The following example defines a regular expression, <ph id="ph1">`\s+`</ph>, that matches one or more white-space characters.</source>
          <target state="translated">En el ejemplo siguiente se define una expresión regular, <ph id="ph1">`\s+`</ph>, que coincide con uno o más caracteres de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The replacement string, " ", replaces them with a single space character.</source>
          <target state="translated">La cadena de reemplazo, "", los reemplaza con un carácter de espacio único.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The following example defines a regular expression, <ph id="ph1">`(\p{Sc}\s?)?(\d+\.?((?&lt;=\.)\d+)?)(?(1)|\s?\p{Sc})?`</ph>, and a replacement pattern, <ph id="ph2">`$2`</ph>, that removes either a leading or a trailing currency symbol from a numeric value.</source>
          <target state="translated">En el ejemplo siguiente se define una expresión regular, <ph id="ph1">`(\p{Sc}\s?)?(\d+\.?((?&lt;=\.)\d+)?)(?(1)|\s?\p{Sc})?`</ph>y un patrón de reemplazo, <ph id="ph2">`$2`</ph>, que quita inicial o un símbolo de divisa al final de un valor numérico.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The regular expression is interpreted as shown in the following table.</source>
          <target state="translated">La expresión regular se interpreta como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match a currency symbol.</source>
          <target state="translated">Coincide con un símbolo de moneda.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source><ph id="ph1">`{Sc}`</ph> denotes any character that is a member of the Unicode Symbol, Currency category.</source>
          <target state="translated"><ph id="ph1">`{Sc}`</ph> indica cualquier carácter que sea miembro del símbolo Unicode, categoría de moneda.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match zero or one white-space character.</source>
          <target state="translated">Busca coincidencias con cero o un carácter de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match zero or one occurrence of the combination of a currency symbol followed by zero or one white-space character.</source>
          <target state="translated">Coincide con cero o una aparición de la combinación de un símbolo de moneda seguido de cero o un carácter de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>This is the first capturing group.</source>
          <target state="translated">Este es el primer grupo de captura.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Buscar coincidencias con uno o más dígitos decimales.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match zero or one occurrence of a period (used as a decimal separator character).</source>
          <target state="translated">Coincide con cero o una aparición de un período (usado como un carácter de separador decimal).</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If a period is the previous character, match one or more decimal digits.</source>
          <target state="translated">Si un punto es el carácter anterior, coincide con uno o más dígitos decimales.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>This pattern can be matched either zero or one time.</source>
          <target state="translated">Este patrón puede coincidir cero o una vez.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match the pattern of one or more decimal digits followed by an optional period and additional decimal digits.</source>
          <target state="translated">Coincide con el patrón de uno o más dígitos decimales seguidos por un punto opcional y dígitos decimales adicionales.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>This is the second capturing group.</source>
          <target state="translated">Este es el segundo grupo de captura.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29&gt;</ph> method replaces the entire match with the value of this captured group.</source>
          <target state="translated">La llamada a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29&gt;</ph> método reemplaza toda la coincidencia con el valor de este grupo capturado.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If the first captured group exists, match an empty string.</source>
          <target state="translated">Si el primer grupo capturado existe, coincide con una cadena vacía.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Otherwise, match zero or one white-space character followed by a currency symbol.</source>
          <target state="translated">De lo contrario, coincide con cero o un carácter de espacio en blanco seguido de un símbolo de moneda.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular especificada por una cadena devuelta por un delegado <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">Cadena nueva que es idéntica a la cadena de entrada, salvo que una cadena de reemplazo ocupa el lugar de cada cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> método es útil para reemplazar una coincidencia de expresión regular si se cumple alguna de las condiciones siguientes:</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">La cadena de reemplazo no se puede especificar con facilidad por un patrón de reemplazo de expresión regular.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">Los resultados de la cadena de reemplazo de algunos procesos realizados en la cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">Los resultados de la cadena de reemplazo de un procesamiento condicional.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">El método es equivalente a llamar a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> método y pasar cada <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objeto en el valor devuelto <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> colección a la <ph id="ph4">`evaluator`</ph> delegar.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">La expresión regular es el patrón definido por el constructor para el actual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated">El <ph id="ph1">`evaluator`</ph> parámetro es el delegado de un método personalizado que se define y que examina cada coincidencia.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">El método personalizado debe tener la siguiente firma para que coincida con el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">El método personalizado devuelve una cadena que reemplaza la entrada coincidente.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea el objeto.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Dado que el método devuelve <ph id="ph1">`input`</ph> sin cambios si no hay ninguna coincidencia, puede usar el <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The following code example displays an original string, matches each word in the original string, converts the first character of each match to uppercase, then displays the converted string.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra una cadena original, coincide con cada palabra de la cadena original, convierte el primer carácter de cada coincidencia en mayúsculas, a continuación, muestra la cadena convertida.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The replacement string.</source>
          <target state="translated">La cadena de reemplazo.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The maximum number of times the replacement can occur.</source>
          <target state="translated">Número máximo de veces que puede producirse el reemplazo.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">En una cadena de entrada especificada, reemplaza un número máximo indicado de cadenas que coinciden con un patrón de expresión regular por una cadena de reemplazo especificada.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The search for matches starts at the beginning of the <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">Comienza la búsqueda de coincidencias al principio de la <ph id="ph1">`input`</ph> cadena.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The regular expression is the pattern that is defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">La expresión regular es el patrón definido por el constructor para el actual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is negative, replacements continue to the end of the string.</source>
          <target state="translated">Si <ph id="ph1">`count`</ph> es negativo, los reemplazos continuarán hasta el final de la cadena.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> exceeds the number of matches, all matches are replaced.</source>
          <target state="translated">Si <ph id="ph1">`count`</ph> supera el número de coincidencias, se reemplazan todas las coincidencias.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace the first <ph id="ph2">`count`</ph> matches in <ph id="ph3">`input`</ph>.</source>
          <target state="translated">El <ph id="ph1">`replacement`</ph> parámetro especifica la cadena que va a reemplazar la primera <ph id="ph2">`count`</ph> coincidencias en <ph id="ph3">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> puede constar de cualquier combinación de texto literal y <bpt id="p1">[</bpt>sustituciones<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Por ejemplo, el patrón de reemplazo <ph id="ph1">`a*${test}b`</ph> inserta la cadena "un *" seguida de la subcadena que coincide con el <ph id="ph2">`test`</ph> capturas de grupo, si los hay, seguida por la cadena "b".</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">El * caracteres no se reconocen como un metacarácter dentro de un patrón de reemplazo.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Todos los otros elementos de lenguaje de expresiones regulares, incluidos <bpt id="p1">[</bpt>escapes de caracteres<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, se permiten en los patrones de expresión regular solo y no se reconocen en modelos de reemplazo.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea el objeto.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Dado que el método devuelve <ph id="ph1">`input`</ph> sin cambios si no hay ninguna coincidencia, puede usar el <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The following example replaces the first five occurrences of duplicated characters with a single character.</source>
          <target state="translated">En el ejemplo siguiente se reemplaza las cinco primeras apariciones de caracteres duplicados con un solo carácter.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`(\w)\1`</ph> matches consecutive occurrences of a single character and assigns the first occurrence to the first capturing group.</source>
          <target state="translated">El patrón de expresión regular <ph id="ph1">`(\w)\1`</ph> encuentra apariciones consecutivas de un carácter único y se asigna la primera aparición en el primer grupo de captura.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured group.</source>
          <target state="translated">El patrón de reemplazo <ph id="ph1">`$1`</ph> reemplaza toda la coincidencia con el primer grupo capturado.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The replacement string.</source>
          <target state="translated">La cadena de reemplazo.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</source>
          <target state="translated">En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular concreta por la cadena de reemplazo indicada.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The static <ph id="ph1">`Replace`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Replace`</ph>.</source>
          <target state="translated">El método estático <ph id="ph1">`Replace`</ph> métodos son equivalentes a construir un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto con el patrón de expresión regular especificado y llamando al método de instancia <ph id="ph3">`Replace`</ph>.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The search for matches starts at the beginning of the <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">Comienza la búsqueda de coincidencias al principio de la <ph id="ph1">`input`</ph> cadena.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated">El <ph id="ph1">`replacement`</ph> parámetro especifica la cadena que va a reemplazar cada coincidencia en <ph id="ph2">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> puede constar de cualquier combinación de texto literal y <bpt id="p1">[</bpt>sustituciones<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Por ejemplo, el patrón de reemplazo <ph id="ph1">`a*${test}b`</ph> inserta la cadena "un *" seguida de la subcadena que coincide con el <ph id="ph2">`test`</ph> capturas de grupo, si los hay, seguida por la cadena "b".</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">El * caracteres no se reconocen como un metacarácter dentro de un patrón de reemplazo.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Todos los otros elementos de lenguaje de expresiones regulares, incluidos <bpt id="p1">[</bpt>escapes de caracteres<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, se permiten en los patrones de expresión regular solo y no se reconocen en modelos de reemplazo.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Dado que el método devuelve <ph id="ph1">`input`</ph> sin cambios si no hay ninguna coincidencia, puede usar el <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The following example defines a regular expression, <ph id="ph1">`\s+`</ph>, that matches one or more white-space characters.</source>
          <target state="translated">En el ejemplo siguiente se define una expresión regular, <ph id="ph1">`\s+`</ph>, que coincide con uno o más caracteres de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The replacement string, " ", replaces them with a single space character.</source>
          <target state="translated">La cadena de reemplazo, "", los reemplaza con un carácter de espacio único.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> method to replace the local machine and drive names in a UNC path with a local file path.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> método para reemplazar los nombres de equipo y la unidad locales en una ruta de acceso UNC con una ruta de acceso de archivo local.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The regular expression uses the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property to include the name of the local computer, and the <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> method to include the names of the logical drives.</source>
          <target state="translated">La expresión regular usa el <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> propiedad para incluir el nombre del equipo local y el <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> método para incluir los nombres de las unidades lógicas.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</source>
          <target state="translated">Para ejecutar el ejemplo correctamente, debe reemplazar la cadena literal "MyMachine" con el nombre del equipo local.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">El patrón de expresión regular se define mediante la siguiente expresión:</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match two consecutive backslash (<ph id="ph1">`\`</ph>) characters.</source>
          <target state="translated">Barra diagonal inversa de coincidencia dos consecutivo (<ph id="ph1">`\`</ph>) caracteres.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</source>
          <target state="translated">Dado que el carácter de barra diagonal inversa se interpreta como el carácter de escape, cada barra diagonal inversa debe ser de escape con otra barra diagonal inversa.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Perform a case-insensitive match of the string that is returned by the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Realizar una coincidencia entre mayúsculas y minúsculas de la cadena devuelta por la <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match the period (<ph id="ph1">`.`</ph>) character followed by one or more word characters.</source>
          <target state="translated">Coincide con el punto (<ph id="ph1">`.`</ph>) carácter seguido de uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>This match can occur zero or more times.</source>
          <target state="translated">Esta coincidencia puede producirse cero o más veces.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The matched subexpression is not captured.</source>
          <target state="translated">No se captura la subexpresión coincidente.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match a backslash (<ph id="ph1">`\`</ph>) character.</source>
          <target state="translated">Coincide con una barra diagonal inversa (<ph id="ph1">`\`</ph>) caracteres.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Perform a case-insensitive match of the character class that consists of the individual drive lettters.</source>
          <target state="translated">Realizar a una coincidencia entre mayúsculas y minúsculas de la clase de caracteres que se compone de las letras de unidad individuales.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>This match is the first captured subexpression.</source>
          <target state="translated">Esta coincidencia es la primera subexpresión capturada.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match the literal dollar sign (<ph id="ph1">`$`</ph>) character.</source>
          <target state="translated">Coincide con el signo de dólar literal (<ph id="ph1">`$`</ph>) caracteres.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured subexpression.</source>
          <target state="translated">El patrón de reemplazo <ph id="ph1">`$1`</ph> reemplaza toda la coincidencia con la primera subexpresión capturada.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>That is, it replaces the UNC machine and drive name with the drive letter.</source>
          <target state="translated">Es decir, el nombre de equipo y la unidad UNC reemplaza con la letra de unidad.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> o <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> es <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, que impide que el método de tiempo de espera, se utiliza.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The recommended static method for replacing a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">El método estático recomendado para reemplazar una coincidencia de patrones es <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, que permite establecer el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular especificada por una cadena devuelta por un delegado <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">Cadena nueva que es idéntica a la cadena de entrada, salvo que una cadena de reemplazo ocupa el lugar de cada cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> método es útil para reemplazar una coincidencia de expresión regular si se cumple alguna de las condiciones siguientes:</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">La cadena de reemplazo no se puede especificar con facilidad por un patrón de reemplazo de expresión regular.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">Los resultados de la cadena de reemplazo de algunos procesos realizados en la cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">Los resultados de la cadena de reemplazo de un procesamiento condicional.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">El método es equivalente a llamar a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> método y pasar cada <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objeto en el valor devuelto <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> colección a la <ph id="ph4">`evaluator`</ph> delegar.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated">El <ph id="ph1">`evaluator`</ph> parámetro es el delegado de un método personalizado que se define y que examina cada coincidencia.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">El método personalizado debe tener la siguiente firma para que coincida con el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">El método personalizado devuelve una cadena que reemplaza la entrada coincidente.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Dado que el método devuelve <ph id="ph1">`input`</ph> sin cambios si no hay ninguna coincidencia, puede usar el <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The following example uses a regular expression to extract the individual words from a string, and then uses a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate to call a method named <ph id="ph2">`WordScramble`</ph> that scrambles the individual letters in the word.</source>
          <target state="translated">En el ejemplo siguiente se utiliza una expresión regular para extraer las palabras individuales de una cadena y, a continuación, utiliza un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegado para llamar a un método denominado <ph id="ph2">`WordScramble`</ph> que codifica las letras individuales en la palabra.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>To do this, the <ph id="ph1">`WordScramble`</ph> method creates an array that contains the characters in the match.</source>
          <target state="translated">Para ello, el <ph id="ph1">`WordScramble`</ph> método crea una matriz que contiene los caracteres de la coincidencia.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>It also creates a parallel array that it populates with random floating-point numbers.</source>
          <target state="translated">También se crea una matriz paralela que se rellena con números de punto flotante aleatorios.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The arrays are sorted by calling the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method, and the sorted array is provided as an argument to a <ph id="ph2">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">Las matrices se ordenan mediante una llamada a la <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> método y la matriz ordenada se proporciona como un argumento a un <ph id="ph2">&lt;xref:System.String&gt;</ph> constructor de clase.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>This newly created string is then returned by the <ph id="ph1">`WordScramble`</ph> method.</source>
          <target state="translated">A continuación, se devuelve esta cadena recién creada por el <ph id="ph1">`WordScramble`</ph> método.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The regular expression pattern <ph id="ph1">`\w+`</ph> matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</source>
          <target state="translated">El patrón de expresión regular <ph id="ph1">`\w+`</ph> coincide con uno o más caracteres alfabéticos; continuará el motor de expresiones regulares agregar caracteres a la búsqueda de coincidencias, hasta que encuentra un carácter no sea de palabra, como un carácter de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> o <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> es <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, que impide que el método de tiempo de espera, se utiliza.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The recommended static method for evaluating and replacing a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">El método estático recomendado para evaluar y reemplazar una coincidencia de patrones es <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, que permite establecer el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The maximum number of times the replacement will occur.</source>
          <target state="translated">Número máximo de veces que se llevará a cabo el reemplazo.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">En una cadena de entrada especificada, reemplaza un número máximo especificado de cadenas que coinciden con un modelo de expresión regular por una cadena devuelta por un delegado <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">Cadena nueva que es idéntica a la cadena de entrada, salvo que una cadena de reemplazo ocupa el lugar de cada cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> método es útil para reemplazar una coincidencia de expresión regular si se cumple alguna de las condiciones siguientes:</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">La cadena de reemplazo no se puede especificar con facilidad por un patrón de reemplazo de expresión regular.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">Los resultados de la cadena de reemplazo de algunos procesos realizados en la cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">Los resultados de la cadena de reemplazo de un procesamiento condicional.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> method and passing the first <ph id="ph2">`count`</ph><ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects in the returned <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph5">`evaluator`</ph> delegate.</source>
          <target state="translated">El método es equivalente a llamar a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> método y pasar la primera <ph id="ph2">`count`</ph> <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objetos en el valor devuelto <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> colección a la <ph id="ph5">`evaluator`</ph> delegar.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">La expresión regular es el patrón definido por el constructor para el actual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated">El <ph id="ph1">`evaluator`</ph> parámetro es el delegado de un método personalizado que se define y que examina cada coincidencia.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">El método personalizado debe tener la siguiente firma para que coincida con el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">El método personalizado devuelve una cadena que reemplaza la entrada coincidente.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea el objeto.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Dado que el método devuelve <ph id="ph1">`input`</ph> sin cambios si no hay ninguna coincidencia, puede usar el <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The following example uses a regular expression to deliberately misspell half of the words in a list.</source>
          <target state="translated">En el ejemplo siguiente se usa una expresión regular para deliberadamente escrito incorrectamente la mitad de las palabras en una lista.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>It uses the regular expression <ph id="ph1">`\w*(ie|ei)\w*`</ph> to match words that include the characters "ie" or "ei".</source>
          <target state="translated">Se usa la expresión regular <ph id="ph1">`\w*(ie|ei)\w*`</ph> para buscar palabras que incluyen los caracteres "ie" o "ei".</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>It passes the first half of the matching words to the <ph id="ph1">`ReverseLetter`</ph> method, which, in turn, uses the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method to reverse "i" and "e" in the matched string.</source>
          <target state="translated">Pasa la primera mitad de las palabras de búsqueda de coincidencias para el <ph id="ph1">`ReverseLetter`</ph> método, que a su vez, utiliza el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> método para invertir la "i" y "e" en la cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The remaining words remain unchanged.</source>
          <target state="translated">El resto de las palabras no se modificarán.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The regular expression <ph id="ph1">`\w*(ie|ei)\w*`</ph> is defined as shown in the following table.</source>
          <target state="translated">La expresión regular <ph id="ph1">`\w*(ie|ei)\w*`</ph> se define como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Match zero or more word characters.</source>
          <target state="translated">Buscar una coincidencia con cero o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Match either "ie" or "ei".</source>
          <target state="translated">Coincide con "ie" o "ei".</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Match zero or more word characters.</source>
          <target state="translated">Buscar una coincidencia con cero o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`([ie])([ie])`</ph> in the <ph id="ph2">`ReverseLetter`</ph> method matches the first "i" or "e" in the diphthong "ie" or "ei" and assigns the letter to the first capturing group.</source>
          <target state="translated">El patrón de expresión regular <ph id="ph1">`([ie])([ie])`</ph> en el <ph id="ph2">`ReverseLetter`</ph> método coincide con la primera "i" o "e" en el diphthong "ie" o "ei" y asigna la letra al primer grupo de captura.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>It matches the second "i" or "e" and assigns the letter to the second capturing group.</source>
          <target state="translated">Coincide con la segunda "i" o "e" y asigna la letra al segundo grupo de captura.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The two characters are then reversed by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> method with the replacement pattern <ph id="ph2">`$2$1`</ph>.</source>
          <target state="translated">Los dos caracteres, a continuación, se invierten mediante una llamada a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> método con el patrón de reemplazo <ph id="ph2">`$2$1`</ph>.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The replacement string.</source>
          <target state="translated">La cadena de reemplazo.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Maximum number of times the replacement can occur.</source>
          <target state="translated">Número máximo de veces que puede producirse el reemplazo.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The character position in the input string where the search begins.</source>
          <target state="translated">Posición del carácter en la cadena de entrada donde comienza la búsqueda.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">En una subcadena de entrada especificada, reemplaza un número máximo especificado de cadenas que coinciden con un patrón de expresión regular por una cadena de reemplazo especificada.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The search for matches starts in the <ph id="ph1">`input`</ph> string at the position specified by the <ph id="ph2">`startat`</ph> parameter.</source>
          <target state="translated">Inicia la búsqueda de coincidencias en la <ph id="ph1">`input`</ph> cadena en la posición especificada por el <ph id="ph2">`startat`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">La expresión regular es el patrón definido por el constructor para el actual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is negative, replacements continue to the end of the string.</source>
          <target state="translated">Si <ph id="ph1">`count`</ph> es negativo, los reemplazos continuarán hasta el final de la cadena.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> exceeds the number of matches, all matches are replaced.</source>
          <target state="translated">Si <ph id="ph1">`count`</ph> supera el número de coincidencias, se reemplazan todas las coincidencias.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated">El <ph id="ph1">`replacement`</ph> parámetro especifica la cadena que va a reemplazar cada coincidencia en <ph id="ph2">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> puede constar de cualquier combinación de texto literal y <bpt id="p1">[</bpt>sustituciones<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Por ejemplo, el patrón de reemplazo <ph id="ph1">`a*${test}b`</ph> inserta la cadena "un *" seguida de la subcadena que coincide con el <ph id="ph2">`test`</ph> capturas de grupo, si los hay, seguida por la cadena "b".</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">El * caracteres no se reconocen como un metacarácter dentro de un patrón de reemplazo.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Todos los otros elementos de lenguaje de expresiones regulares, incluidos <bpt id="p1">[</bpt>escapes de caracteres<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, se permiten en los patrones de expresión regular solo y no se reconocen en modelos de reemplazo.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea el objeto.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Dado que el método devuelve <ph id="ph1">`input`</ph> sin cambios si no hay ninguna coincidencia, puede usar el <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The following example double-spaces all but the first line of a string.</source>
          <target state="translated">En el ejemplo siguiente se duplica todas menos la primera línea de una cadena.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>It defines a regular expression pattern, <ph id="ph1">`^.*$`</ph>, that matches a line of text, calls the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method to match the first line of the string, and uses the <ph id="ph3">`Match.Index`</ph> and <ph id="ph4">`Match.Count`</ph> properties to determine the starting position of the second line.</source>
          <target state="translated">Define un patrón de expresión regular, <ph id="ph1">`^.*$`</ph>, que coincide con una línea de texto, llamadas el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> método para que coincida con la primera línea de la cadena y utiliza el <ph id="ph3">`Match.Index`</ph> y <ph id="ph4">`Match.Count`</ph> propiedades para determinar la posición inicial del segundo línea.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`^.*$`</ph> is defined as shown in the following table.</source>
          <target state="translated">El patrón de expresión regular <ph id="ph1">`^.*$`</ph> se define como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Match the start of a line.</source>
          <target state="translated">Coincidir con el principio de una línea.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>(Note that the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object was instantiated by using the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option; otherwise, this character class would only match the beginning of the input string.)</source>
          <target state="translated">(Tenga en cuenta que la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea una instancia de objeto mediante el uso de la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option; en caso contrario, esta clase de caracteres solo coincidiría con el principio de la cadena de entrada.)</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Match any character zero or more times.</source>
          <target state="translated">Coincide con cualquier carácter cero o más veces.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Match the end of a line.</source>
          <target state="translated">Coincide con el final de una línea.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>(Note that the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object was instantiated by using the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option; otherwise, this character class would only match the beginning of the input string.)</source>
          <target state="translated">(Tenga en cuenta que la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea una instancia de objeto mediante el uso de la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option; en caso contrario, esta clase de caracteres solo coincidiría con el principio de la cadena de entrada.)</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The replacement string (<ph id="ph1">`vbCrLf + "$&amp;"`</ph> in Visual Basic, <ph id="ph2">`"\n$&amp;"`</ph> in C#) adds a new line before the matched string.</source>
          <target state="translated">La cadena de reemplazo (<ph id="ph1">`vbCrLf + "$&amp;"`</ph> en Visual Basic, <ph id="ph2">`"\n$&amp;"`</ph> en C#) agrega una nueva línea antes de la cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Note that <ph id="ph1">`\n`</ph> in the C# example is interpreted as the newline character by the C# compiler; it does not represent a regular expression character escape.</source>
          <target state="translated">Tenga en cuenta que <ph id="ph1">`\n`</ph> en C# en el ejemplo se se interpreta como carácter de nueva línea por el compilador de C#; no representa un escape de carácter de expresión regular.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> es menor que cero o mayor que la longitud de <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string.</source>
          <target state="translated">La cadena de reemplazo.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</source>
          <target state="translated">En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular concreta por la cadena de reemplazo indicada.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Specified options modify the matching operation.</source>
          <target state="translated">Las opciones especificadas modifican la operación de coincidencia.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">`Replace`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Replace`</ph>.</source>
          <target state="translated">El método estático <ph id="ph1">`Replace`</ph> métodos son equivalentes a construir un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto con el patrón de expresión regular especificado y llamando al método de instancia <ph id="ph3">`Replace`</ph>.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">Si especifica <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> para el <ph id="ph2">`options`</ph> parámetro, la búsqueda de coincidencias comienza al final de la cadena de entrada y se mueve a izquierda; en caso contrario, la búsqueda comienza al principio de la cadena de entrada y se mueve a la derecha.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated">El <ph id="ph1">`replacement`</ph> parámetro especifica la cadena que va a reemplazar cada coincidencia en <ph id="ph2">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> puede constar de cualquier combinación de texto literal y <bpt id="p1">[</bpt>sustituciones<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Por ejemplo, el patrón de reemplazo <ph id="ph1">`a*${test}b`</ph> inserta la cadena "un *" seguida de la subcadena que coincide con el <ph id="ph2">`test`</ph> capturas de grupo, si los hay, seguida por la cadena "b".</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">El * caracteres no se reconocen como un metacarácter dentro de un patrón de reemplazo.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Todos los otros elementos de lenguaje de expresiones regulares, incluidos <bpt id="p1">[</bpt>escapes de caracteres<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, se permiten en los patrones de expresión regular solo y no se reconocen en modelos de reemplazo.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Dado que el método devuelve <ph id="ph1">`input`</ph> sin cambios si no hay ninguna coincidencia, puede usar el <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method to replace the local machine and drive names in a UNC path with a local file path.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> método para reemplazar los nombres de equipo y la unidad locales en una ruta de acceso UNC con una ruta de acceso de archivo local.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression uses the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property to include the name of the local computer, and the <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> method to include the names of the logical drives.</source>
          <target state="translated">La expresión regular usa el <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> propiedad para incluir el nombre del equipo local y el <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> método para incluir los nombres de las unidades lógicas.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>All regular expression string comparisons are case-insensitive.</source>
          <target state="translated">Todas las comparaciones de cadenas de expresiones regulares distinguen mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</source>
          <target state="translated">Para ejecutar el ejemplo correctamente, debe reemplazar la cadena literal "MyMachine" con el nombre del equipo local.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">El patrón de expresión regular se define mediante la siguiente expresión:</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match two consecutive backslash (<ph id="ph1">`\`</ph>) characters.</source>
          <target state="translated">Barra diagonal inversa de coincidencia dos consecutivo (<ph id="ph1">`\`</ph>) caracteres.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</source>
          <target state="translated">Dado que el carácter de barra diagonal inversa se interpreta como el carácter de escape, cada barra diagonal inversa debe ser de escape con otra barra diagonal inversa.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the string that is returned by the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Coincide con la cadena devuelta por la <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the period (<ph id="ph1">`.`</ph>) character followed by one or more word characters.</source>
          <target state="translated">Coincide con el punto (<ph id="ph1">`.`</ph>) carácter seguido de uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This match can occur zero or more times.</source>
          <target state="translated">Esta coincidencia puede producirse cero o más veces.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The matched subexpression is not captured.</source>
          <target state="translated">No se captura la subexpresión coincidente.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match a backslash (<ph id="ph1">`\`</ph>) character.</source>
          <target state="translated">Coincide con una barra diagonal inversa (<ph id="ph1">`\`</ph>) caracteres.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the character class that consists of the individual drive letters.</source>
          <target state="translated">Coincide con la clase de caracteres que se compone de las letras de unidad individuales.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This match is the first captured subexpression.</source>
          <target state="translated">Esta coincidencia es la primera subexpresión capturada.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the literal dollar sign (<ph id="ph1">`$`</ph>) character.</source>
          <target state="translated">Coincide con el signo de dólar literal (<ph id="ph1">`$`</ph>) caracteres.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured subexpression.</source>
          <target state="translated">El patrón de reemplazo <ph id="ph1">`$1`</ph> reemplaza toda la coincidencia con la primera subexpresión capturada.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>That is, it replaces the UNC machine and drive name with the drive letter.</source>
          <target state="translated">Es decir, el nombre de equipo y la unidad UNC reemplaza con la letra de unidad.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> o <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> es <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> no es una combinación bit a bit válida de valores <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, que impide que el método de tiempo de espera, se utiliza.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for replacing a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">El método estático recomendado para reemplazar una coincidencia de patrones es <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, que permite establecer el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular especificada por una cadena devuelta por un delegado <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>Specified options modify the matching operation.</source>
          <target state="translated">Las opciones especificadas modifican la operación de coincidencia.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">Cadena nueva que es idéntica a la cadena de entrada, salvo que una cadena de reemplazo ocupa el lugar de cada cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match in if any of the following conditions is true:</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> método es útil para reemplazar una coincidencia de expresión regular en si se cumple alguna de las condiciones siguientes:</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">La cadena de reemplazo no se puede especificar con facilidad por un patrón de reemplazo de expresión regular.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">Los resultados de la cadena de reemplazo de algunos procesos realizados en la cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">Los resultados de la cadena de reemplazo de un procesamiento condicional.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">El método es equivalente a llamar a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> método y pasar cada <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objeto en el valor devuelto <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> colección a la <ph id="ph4">`evaluator`</ph> delegar.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated">El <ph id="ph1">`evaluator`</ph> parámetro es el delegado de un método personalizado que se define y que examina cada coincidencia.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">El método personalizado debe tener la siguiente firma para que coincida con el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">El método personalizado devuelve una cadena que reemplaza la entrada coincidente.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">Si especifica <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> para el <ph id="ph2">`options`</ph> parámetro, la búsqueda de coincidencias comienza al final de la cadena de entrada y se mueve a izquierda; en caso contrario, la búsqueda comienza al principio de la cadena de entrada y se mueve a la derecha.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Dado que el método devuelve <ph id="ph1">`input`</ph> sin cambios si no hay ninguna coincidencia, puede usar el <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example uses a regular expression to extract the individual words from a string, and then uses a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate to call a method named <ph id="ph2">`WordScramble`</ph> that scrambles the individual letters in the word.</source>
          <target state="translated">En el ejemplo siguiente se utiliza una expresión regular para extraer las palabras individuales de una cadena y, a continuación, utiliza un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegado para llamar a un método denominado <ph id="ph2">`WordScramble`</ph> que codifica las letras individuales en la palabra.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>To do this, the <ph id="ph1">`WordScramble`</ph> method creates an array that contains the characters in the match.</source>
          <target state="translated">Para ello, el <ph id="ph1">`WordScramble`</ph> método crea una matriz que contiene los caracteres de la coincidencia.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>It also creates a parallel array that it populates with random floating-point numbers.</source>
          <target state="translated">También se crea una matriz paralela que se rellena con números de punto flotante aleatorios.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The arrays are sorted by calling the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method, and the sorted array is provided as an argument to a <ph id="ph2">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">Las matrices se ordenan mediante una llamada a la <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> método y la matriz ordenada se proporciona como un argumento a un <ph id="ph2">&lt;xref:System.String&gt;</ph> constructor de clase.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>This newly created string is then returned by the <ph id="ph1">`WordScramble`</ph> method.</source>
          <target state="translated">A continuación, se devuelve esta cadena recién creada por el <ph id="ph1">`WordScramble`</ph> método.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern <ph id="ph1">`\w+`</ph> matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</source>
          <target state="translated">El patrón de expresión regular <ph id="ph1">`\w+`</ph> coincide con uno o más caracteres alfabéticos; continuará el motor de expresiones regulares agregar caracteres a la búsqueda de coincidencias, hasta que encuentra un carácter no sea de palabra, como un carácter de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method includes the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option so that the comment in the regular expression pattern <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> is ignored by the regular expression engine.</source>
          <target state="translated">La llamada a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> método incluye la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> opción para que el comentario en el patrón de expresión regular <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> omitido por el motor de expresiones regulares.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> o <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> es <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> no es una combinación bit a bit válida de valores <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The maximum number of times the replacement will occur.</source>
          <target state="translated">Número máximo de veces que se llevará a cabo el reemplazo.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The character position in the input string where the search begins.</source>
          <target state="translated">Posición del carácter en la cadena de entrada donde comienza la búsqueda.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">En una subcadena de entrada especificada, reemplaza un número máximo especificado de cadenas que coinciden con un modelo de expresión regular por una cadena devuelta por un delegado <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">Cadena nueva que es idéntica a la cadena de entrada, salvo que una cadena de reemplazo ocupa el lugar de cada cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> método es útil para reemplazar una coincidencia de expresión regular si se cumple alguna de las condiciones siguientes:</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">La cadena de reemplazo no se puede especificar con facilidad por un patrón de reemplazo de expresión regular.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">Los resultados de la cadena de reemplazo de algunos procesos realizados en la cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">Los resultados de la cadena de reemplazo de un procesamiento condicional.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method and passing the first <ph id="ph2">`count`</ph><ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects in the returned <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph5">`evaluator`</ph> delegate.</source>
          <target state="translated">El método es equivalente a llamar a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> método y pasar la primera <ph id="ph2">`count`</ph> <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objetos en el valor devuelto <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> colección a la <ph id="ph5">`evaluator`</ph> delegar.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">La expresión regular es el patrón definido por el constructor para el actual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated">El <ph id="ph1">`evaluator`</ph> parámetro es el delegado de un método personalizado que se define y que examina cada coincidencia.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">El método personalizado debe tener la siguiente firma para que coincida con el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">El método personalizado devuelve una cadena que reemplaza la entrada coincidente.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea el objeto.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Dado que el método devuelve <ph id="ph1">`input`</ph> sin cambios si no hay ninguna coincidencia, puede usar el <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> es menor que cero o mayor que la longitud de <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The replacement string.</source>
          <target state="translated">La cadena de reemplazo.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Un intervalo de tiempo de espera, o <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> para indicar que el método no debe agotar el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</source>
          <target state="translated">En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular concreta por la cadena de reemplazo indicada.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</source>
          <target state="translated">Los parámetros adicionales especifican las opciones que modifican la operación de coincidencia y un intervalo de tiempo de espera si no se encuentra ninguna coincidencia.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">`Replace`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Replace`</ph>.</source>
          <target state="translated">El método estático <ph id="ph1">`Replace`</ph> métodos son equivalentes a construir un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objeto con el patrón de expresión regular especificado y llamando al método de instancia <ph id="ph3">`Replace`</ph>.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">Si especifica <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> para el <ph id="ph2">`options`</ph> parámetro, la búsqueda de coincidencias comienza al final de la cadena de entrada y se mueve a izquierda; en caso contrario, la búsqueda comienza al principio de la cadena de entrada y se mueve a la derecha.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated">El <ph id="ph1">`replacement`</ph> parámetro especifica la cadena que va a reemplazar cada coincidencia en <ph id="ph2">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> puede constar de cualquier combinación de texto literal y <bpt id="p1">[</bpt>sustituciones<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Por ejemplo, el patrón de reemplazo <ph id="ph1">`a*${test}b`</ph> inserta la cadena "un *" seguida de la subcadena que coincide con el <ph id="ph2">`test`</ph> capturas de grupo, si los hay, seguida por la cadena "b".</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">El * caracteres no se reconocen como un metacarácter dentro de un patrón de reemplazo.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Todos los otros elementos de lenguaje de expresiones regulares, incluidos <bpt id="p1">[</bpt>escapes de caracteres<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, se permiten en los patrones de expresión regular solo y no se reconocen en modelos de reemplazo.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated">El <ph id="ph1">`matchTimeout`</ph> parámetro especifica cómo tiempo una coincidencia de patrones método debe intentar encontrar una coincidencia antes de expirar. Establecer un intervalo de tiempo de espera impide que las expresiones regulares que se basan en un retroceso excesivo aparezcan deje de responder cuando procesan datos de entrada que contenga cerca de coincidencias.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>prácticas recomendadas para las expresiones regulares<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> y <bpt id="p2">[</bpt>retroceso<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Si se encuentra ninguna coincidencia en ese intervalo de tiempo, el método produce una <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> invalida cualquier valor de tiempo de espera predeterminado definido para el dominio de aplicación en el que se ejecuta el método.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Dado que el método devuelve <ph id="ph1">`input`</ph> sin cambios si no hay ninguna coincidencia, puede usar el <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to replace the local machine and drive names in a UNC path with a local file path.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> método para reemplazar los nombres de equipo y la unidad locales en una ruta de acceso UNC con una ruta de acceso de archivo local.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression uses the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property to include the name of the local computer and the <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> method to include the names of the logical drives.</source>
          <target state="translated">La expresión regular usa el <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> propiedad para incluir el nombre del equipo local y el <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> método para incluir los nombres de las unidades lógicas.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>All regular expression string comparisons are case-insensitive, and any single replacement operation times out if a match cannot be found in 0.5 second.</source>
          <target state="translated">Todas las comparaciones de cadenas de expresiones regulares distinguen mayúsculas de minúsculas, y cualquier operación de reemplazo único agota el tiempo si no se encuentra una coincidencia en 0,5 segundos.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</source>
          <target state="translated">Para ejecutar el ejemplo correctamente, debe reemplazar la cadena literal "MyMachine" con el nombre del equipo local.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">El patrón de expresión regular se define mediante la siguiente expresión:</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match two consecutive backslash (<ph id="ph1">`\`</ph>) characters.</source>
          <target state="translated">Barra diagonal inversa de coincidencia dos consecutivo (<ph id="ph1">`\`</ph>) caracteres.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</source>
          <target state="translated">Dado que el carácter de barra diagonal inversa se interpreta como el carácter de escape, cada barra diagonal inversa debe ser de escape con otra barra diagonal inversa.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the string that is returned by the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Coincide con la cadena devuelta por la <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the period (<ph id="ph1">`.`</ph>) character followed by one or more word characters.</source>
          <target state="translated">Coincide con el punto (<ph id="ph1">`.`</ph>) carácter seguido de uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This match can occur zero or more times.</source>
          <target state="translated">Esta coincidencia puede producirse cero o más veces.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The matched subexpression is not captured.</source>
          <target state="translated">No se captura la subexpresión coincidente.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match a backslash (<ph id="ph1">`\`</ph>) character.</source>
          <target state="translated">Coincide con una barra diagonal inversa (<ph id="ph1">`\`</ph>) caracteres.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the character class that consists of the individual drive letters.</source>
          <target state="translated">Coincide con la clase de caracteres que se compone de las letras de unidad individuales.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This match is the first captured subexpression.</source>
          <target state="translated">Esta coincidencia es la primera subexpresión capturada.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the literal dollar sign (<ph id="ph1">`$`</ph>) character.</source>
          <target state="translated">Coincide con el signo de dólar literal (<ph id="ph1">`$`</ph>) caracteres.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured subexpression.</source>
          <target state="translated">El patrón de reemplazo <ph id="ph1">`$1`</ph> reemplaza toda la coincidencia con la primera subexpresión capturada.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>That is, it replaces the UNC machine and drive name with the drive letter.</source>
          <target state="translated">Es decir, el nombre de equipo y la unidad UNC reemplaza con la letra de unidad.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> o <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> es <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> no es una combinación bit a bit válida de valores <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> es negativo, cero o mayor que 24 días aproximadamente.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó un tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Se recomienda que establezca el <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parámetro en un valor apropiado, como dos segundos.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Si deshabilita los tiempos de espera mediante la especificación de <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones:</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o está formada por texto estático.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Excluye el texto que se ha dinámicamente introducidos por los usuarios.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controle eficazmente coincide con, ausencia de coincidencias y casi coincide con.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Cuando el patrón de expresión regular no contiene ningún elemento de lenguaje que se sabe que causan un retroceso excesivo al procesar a una coincidencia casi.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">Cadena en la que se va a buscar una coincidencia.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of enumeration values that provide options for matching.</source>
          <target state="translated">Combinación bit a bit de los valores de la enumeración que proporcionan opciones de coincidencia.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Un intervalo de tiempo de espera, o <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> para indicar que el método no debe agotar el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In a specified input string, replaces all substrings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">En una cadena de entrada especificada, reemplaza todas las subcadenas que coinciden con una expresión regular especificada por una cadena devuelta por un delegado <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</source>
          <target state="translated">Los parámetros adicionales especifican las opciones que modifican la operación de coincidencia y un intervalo de tiempo de espera si no se encuentra ninguna coincidencia.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> método es útil para reemplazar una coincidencia de expresión regular si se cumple alguna de las condiciones siguientes:</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">Si la cadena de reemplazo no se puede especificar fácilmente mediante un patrón de reemplazo de expresión regular.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the replacement string results from some processing performed on the matched string.</source>
          <target state="translated">Si la cadena de reemplazo da como resultado de realiza algún procesamiento en la cadena coincidente.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the replacement string results from conditional processing.</source>
          <target state="translated">Si la cadena de reemplazo da como resultado de un procesamiento condicional.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">El método es equivalente a llamar a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> método y pasar cada <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objeto en el valor devuelto <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> colección a la <ph id="ph4">`evaluator`</ph> delegar.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated">El <ph id="ph1">`evaluator`</ph> parámetro es el delegado de un método personalizado que se define y que examina cada coincidencia.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">El método personalizado debe tener la siguiente firma para que coincida con el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">El método personalizado devuelve una cadena que reemplaza la entrada coincidente.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">Si especifica <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> para el <ph id="ph2">`options`</ph> parámetro, la búsqueda de coincidencias comienza al final de la cadena de entrada y se mueve a izquierda; en caso contrario, la búsqueda comienza al principio de la cadena de entrada y se mueve a la derecha.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to "stop responding when they process input that contains near matches.</source>
          <target state="translated">El <ph id="ph1">`matchTimeout`</ph> parámetro especifica cómo tiempo una coincidencia de patrones método debe intentar encontrar una coincidencia antes de expirar. Establecer un intervalo de tiempo de espera impide que las expresiones regulares que se basan en un retroceso excesivo no aparezca en "dejar de responder cuando procesan datos de entrada que contenga cerca de coincidencias.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>prácticas recomendadas para las expresiones regulares<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> y <bpt id="p2">[</bpt>retroceso<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Si se encuentra ninguna coincidencia en ese intervalo de tiempo, el método produce una <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> invalida cualquier valor de tiempo de espera predeterminado definido para el dominio de aplicación en el que se ejecuta el método.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Dado que el método devuelve <ph id="ph1">`input`</ph> sin cambios si no hay ninguna coincidencia, puede usar el <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example uses a regular expression to extract the individual words from a string, and then uses a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate to call a method named <ph id="ph2">`WordScramble`</ph> that scrambles the individual letters in the word.</source>
          <target state="translated">En el ejemplo siguiente se utiliza una expresión regular para extraer las palabras individuales de una cadena y, a continuación, utiliza un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegado para llamar a un método denominado <ph id="ph2">`WordScramble`</ph> que codifica las letras individuales en la palabra.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To do this, the <ph id="ph1">`WordScramble`</ph> method creates an array that contains the characters in the match.</source>
          <target state="translated">Para ello, el <ph id="ph1">`WordScramble`</ph> método crea una matriz que contiene los caracteres de la coincidencia.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>It also creates a parallel array that it populates with random floating-point numbers.</source>
          <target state="translated">También se crea una matriz paralela que se rellena con números de punto flotante aleatorios.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The arrays are sorted by calling the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method, and the sorted array is provided as an argument to a <ph id="ph2">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">Las matrices se ordenan mediante una llamada a la <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> método y la matriz ordenada se proporciona como un argumento a un <ph id="ph2">&lt;xref:System.String&gt;</ph> constructor de clase.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This newly created string is then returned by the <ph id="ph1">`WordScramble`</ph> method.</source>
          <target state="translated">A continuación, se devuelve esta cadena recién creada por el <ph id="ph1">`WordScramble`</ph> método.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern <ph id="ph1">`\w+`</ph> matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</source>
          <target state="translated">El patrón de expresión regular <ph id="ph1">`\w+`</ph> coincide con uno o más caracteres alfabéticos; continuará el motor de expresiones regulares agregar caracteres a la búsqueda de coincidencias, hasta que encuentra un carácter no sea de palabra, como un carácter de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method includes the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option so that the comment in the regular expression pattern <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> is ignored by the regular expression engine.</source>
          <target state="translated">La llamada a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> método incluye la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> opción para que el comentario en el patrón de expresión regular <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> omitido por el motor de expresiones regulares.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> o <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> es <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> no es una combinación bit a bit válida de valores <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> es negativo, cero o mayor que 24 días aproximadamente.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó un tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Se recomienda que establezca el <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parámetro en un valor apropiado, como dos segundos.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Si deshabilita los tiempos de espera mediante la especificación de <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones:</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o está formada por texto estático.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Excluye el texto que se ha dinámicamente introducidos por los usuarios.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controle eficazmente coincide con, ausencia de coincidencias y casi coincide con.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Cuando el patrón de expresión regular no contiene ningún elemento de lenguaje que se sabe que causan un retroceso excesivo al procesar a una coincidencia casi.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.RightToLeft">
          <source>Gets a value that indicates whether the regular expression searches from right to left.</source>
          <target state="translated">Obtiene un valor que indica si la expresión regular busca de derecha a izquierda.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.RightToLeft">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression searches from right to left; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la expresión regular busca de derecha a izquierda; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.RightToLeft">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.RightToLeft%2A&gt;</ph> is <ph id="ph2">`true`</ph> if the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instance was created with the <ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> option.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.RightToLeft%2A&gt;</ph> es <ph id="ph2">`true`</ph> si la <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instancia se creó con la <ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> opción.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.roptions">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Lo usa un objeto <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> generado por el método <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Splits an input string into an array of substrings at the positions defined by a regular expression match.</source>
          <target state="translated">Divide una cadena de entrada en una matriz de subcadenas en las posiciones definidas por una coincidencia de expresión regular.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The string to split.</source>
          <target state="translated">Cadena que se va a dividir.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Splits an input string into an array of substrings at the positions defined by a regular expression pattern specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Divide una cadena de entrada en una matriz de subcadenas en las posiciones definidas por un modelo de expresión regular especificado en el constructor <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>An array of strings.</source>
          <target state="translated">Matriz de cadenas.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> métodos son similares a los <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> método, salvo que <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The string is split as many times as possible.</source>
          <target state="translated">La cadena se divide tantas veces como sea posible.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If no delimiter is found, the return value contains one element whose value is the original input string.</source>
          <target state="translated">Si no se encuentra ningún delimitador, el valor devuelto contiene un elemento cuyo valor es la cadena de entrada original.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">Si varias coincidencias son adyacentes entre sí, se inserta una cadena vacía en la matriz.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found, as the following code shows.</source>
          <target state="translated">Por ejemplo, dividir una cadena en un solo guión hace que la matriz devuelta incluir una cadena vacía en la posición donde se encuentran dos guiones adyacentes, como se muestra en el código siguiente.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">Si se encuentra una coincidencia al principio o al final de la cadena de entrada, una cadena vacía se incluye al principio o al final de la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`\d+`</ph> to split an input string on numeric characters.</source>
          <target state="translated">En el ejemplo siguiente se usa el patrón de expresión regular <ph id="ph1">`\d+`</ph> para dividir una cadena de entrada de caracteres numéricos.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Because the string begins and ends with matching numeric characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Dado que la cadena comienza y termina con la coincidencia de caracteres numéricos, el valor del primer y último elemento de la matriz devuelta es <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">Si se usan paréntesis de captura en un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expresión, cualquier capturada texto se incluye en la matriz de cadenas resultante.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">Por ejemplo, si divide la cadena "ciruela-pera" con un guión colocado entre paréntesis de captura, la matriz devuelta incluye un elemento de cadena que contiene el guión.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">En .NET Framework 1.0 y 1.1, si no se encuentra una coincidencia en el primer conjunto de paréntesis, de captura no se incluye el texto capturado de paréntesis adicionales en la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">Todo el texto capturado a partir de .NET Framework 2.0, también se agrega a la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">Por ejemplo, el código siguiente usa dos conjuntos de paréntesis de captura para extraer los elementos de una fecha, incluidos los delimitadores de fecha, de una cadena de fecha.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">El primer conjunto de paréntesis de captura captura el guión, y el segundo captura la barra diagonal.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">Si el código de ejemplo se compila y se ejecutan en .NET Framework 1.0 o 1.1, excluye los caracteres de barra diagonal; Si se compila y se ejecuta en el .NET Framework 2.0 o versiones posteriores, los incluye.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%29&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Si la expresión regular puede coincidir con la cadena vacía, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%29&gt;</ph> dividirá la cadena en una matriz de cadenas de carácter único porque el delimitador de cadena vacía se puede encontrar en cada ubicación.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Note that the returned array also includes an empty string at the beginning and end of the array.</source>
          <target state="translated">Tenga en cuenta que la matriz devuelta también incluye una cadena vacía al principio y al final de la matriz.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de división supera el intervalo de tiempo de espera especificado por el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea el objeto.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The string to be split.</source>
          <target state="translated">Cadena que se va a dividir.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The maximum number of times the split can occur.</source>
          <target state="translated">Número máximo de veces que puede llevarse a cabo la división.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Divide una cadena de entrada por un número máximo especificado de veces en una matriz de subcadenas, en las posiciones definidas por una expresión regular especificada en el constructor <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>An array of strings.</source>
          <target state="translated">Matriz de cadenas.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> métodos son similares a los <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> método, salvo que <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The <ph id="ph1">`count`</ph> parameter specifies the maximum number of substrings into which the <ph id="ph2">`input`</ph> string can be split; the last string contains the unsplit remainder of the string.</source>
          <target state="translated">El <ph id="ph1">`count`</ph> parámetro especifica el número máximo de subcadenas en la que el <ph id="ph2">`input`</ph> se puede dividir la cadena; la última cadena contiene el resto no dividido de la cadena.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>A <ph id="ph1">`count`</ph> value of zero provides the default behavior of splitting as many times as possible.</source>
          <target state="translated">Un <ph id="ph1">`count`</ph> valor de cero proporciona el comportamiento predeterminado de división tantas veces como sea posible.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If multiple matches are adjacent to one another or if a match is found at the beginning or end of <ph id="ph1">`input`</ph>, and the number of matches found is at least two less than <ph id="ph2">`count`</ph>, an empty string is inserted into the array.</source>
          <target state="translated">Si varias coincidencias son adyacentes entre sí o si se encuentra una coincidencia al principio o al final de <ph id="ph1">`input`</ph>, y el número de coincidencias encontradas es al menos dos inferior a <ph id="ph2">`count`</ph>, se inserta una cadena vacía en la matriz.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>That is, empty strings that result from adjacent matches or from matches at the beginning or end of the input string are counted in determining whether the number of matched substrings equals <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Es decir, se cuentan las cadenas vacías generadas por las coincidencias adyacentes o de coincidencias al principio o al final de la cadena de entrada para determinar si el número de apertura coincide subcadenas es igual a <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>In the following example, the regular expression <ph id="ph1">`/d+`</ph> is used to split an input string that includes one or more decimal digits into a maximum of three substrings.</source>
          <target state="translated">En el ejemplo siguiente, la expresión regular <ph id="ph1">`/d+`</ph> se utiliza para dividir una cadena de entrada que incluye uno o más dígitos decimales en un máximo de tres subcadenas.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Because the beginning of the input string matches the regular expression pattern, the first array element contains <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, the second contains the first set of alphabetic characters in the input string, and the third contains the remainder of the string that follows the third match.</source>
          <target state="translated">Dado que el principio de la cadena de entrada coincide con el patrón de expresión regular, el primer elemento de matriz contiene <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, el segundo contiene el primer conjunto de caracteres alfabéticos en la cadena de entrada y el tercero contiene el resto de la cadena que sigue a la coincidencia terceros.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If capturing parentheses are used in a regular expression, any captured text is included in the array of split strings.</source>
          <target state="translated">Si se usan paréntesis de captura en una expresión regular, se incluye el texto capturado en la matriz de cadenas de división.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>However, any array elements that contain captured text are not counted in determining whether the number of matches has reached <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Sin embargo, los elementos de matriz que contienen texto capturado no cuentan para determinar si se ha alcanzado el número de coincidencias <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>For example, splitting the string "apple-apricot-plum-pear-banana" into a maximum of four substrings results in a seven-element array, as the following code shows.</source>
          <target state="translated">Por ejemplo, dividir la cadena "apple-albaricoque-ciruela-pera-plátano" en un máximo de cuatro subcadenas da lugar a una matriz de siete elementos, como el siguiente código muestra.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>In the .NET Framework 1.0 and 1.1, only captured text from the first set of capturing parentheses is included in the returned array.</source>
          <target state="translated">En .NET Framework 1.0 y 1.1, solo el texto capturado del primer conjunto de paréntesis de captura se incluye en la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Starting with the .NET Framework 2.0, all captured text is added to the returned array.</source>
          <target state="translated">A partir de .NET Framework 2.0, todo el texto capturado se agrega a la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>However, elements in the returned array that contain captured text are not counted in determining whether the number of matched substrings equals <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Sin embargo, los elementos de la matriz devuelta que contienen texto capturado no cuentan para determinar si el número de apertura coincide subcadenas es igual a <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>For example, in the following code, a regular expression uses two sets of capturing parentheses to extract the elements of a date from a date string.</source>
          <target state="translated">Por ejemplo, en el código siguiente, una expresión regular usa dos conjuntos de paréntesis de captura para extraer los elementos de una fecha de una cadena de fecha.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">El primer conjunto de paréntesis de captura captura el guión, y el segundo captura la barra diagonal.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> method then specifies a maximum of two elements in the returned array.</source>
          <target state="translated">La llamada a la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> método, a continuación, especifica un máximo de dos elementos en la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, the method returns a two-element string array.</source>
          <target state="translated">Si el código de ejemplo se compila y se ejecutan en .NET Framework 1.0 o 1.1, el método devuelve una matriz de cadenas de dos elementos.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If it is compiled and run under the .NET Framework 2.0 or later versions, the method returns a three-element string array.</source>
          <target state="translated">Si se compila y se ejecuta en el .NET Framework 2.0 o versiones posteriores, el método devuelve una matriz de cadenas de tres elementos.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Si la expresión regular puede coincidir con la cadena vacía, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> dividirá la cadena en una matriz de cadenas de carácter único porque el delimitador de cadena vacía se puede encontrar en cada ubicación.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The following example splits the string "characters" into as many elements as there are in the input string.</source>
          <target state="translated">En el ejemplo siguiente se divide la cadena de "caracteres de" como porque no hay muchos elementos están en la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Because the null string matches the beginning of the input string, a null string is inserted at the beginning of the returned array.</source>
          <target state="translated">Dado que la cadena nula coincide con el principio de la cadena de entrada, se inserta una cadena nula al principio de la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>This causes the tenth element to consist of the two characters at the end of the input string.</source>
          <target state="translated">Esto hace que el elemento décimo constan de los dos caracteres al final de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de división supera el intervalo de tiempo de espera especificado por el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea el objeto.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The string to split.</source>
          <target state="translated">Cadena que se va a dividir.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Splits an input string into an array of substrings at the positions defined by a regular expression pattern.</source>
          <target state="translated">Divide una cadena de entrada en una matriz de subcadenas en las posiciones definidas por un patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>An array of strings.</source>
          <target state="translated">Matriz de cadenas.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> métodos son similares a los <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> método, salvo que <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">`input`</ph> string is split as many times as possible.</source>
          <target state="translated">El <ph id="ph1">`input`</ph> cadena se divide tantas veces como sea posible.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If <ph id="ph1">`pattern`</ph> is not found in the <ph id="ph2">`input`</ph> string, the return value contains one element whose value is the original <ph id="ph3">`input`</ph> string.</source>
          <target state="translated">Si <ph id="ph1">`pattern`</ph> no se encuentra en la <ph id="ph2">`input`</ph> cadena, el valor devuelto contiene un elemento cuyo valor es la versión original <ph id="ph3">`input`</ph> cadena.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Compiled regular expressions used in calls to static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods are automatically cached.</source>
          <target state="translated">Compila expresiones regulares utilizadas en llamadas a estática <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> métodos automáticamente se almacenan en caché.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>To manage the lifetime of compiled regular expressions yourself, use the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods.</source>
          <target state="translated">Para administrar la duración de las expresiones regulares compiladas, utilice la instancia <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">Si varias coincidencias son adyacentes entre sí, se inserta una cadena vacía en la matriz.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found, as the following code shows.</source>
          <target state="translated">Por ejemplo, dividir una cadena en un solo guión hace que la matriz devuelta incluir una cadena vacía en la posición donde se encuentran dos guiones adyacentes, como se muestra en el código siguiente.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">Si se encuentra una coincidencia al principio o al final de la cadena de entrada, una cadena vacía se incluye al principio o al final de la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`\d+`</ph> to split an input string on numeric characters.</source>
          <target state="translated">En el ejemplo siguiente se usa el patrón de expresión regular <ph id="ph1">`\d+`</ph> para dividir una cadena de entrada de caracteres numéricos.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Because the string begins and ends with matching numeric characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Dado que la cadena comienza y termina con la coincidencia de caracteres numéricos, el valor del primer y último elemento de la matriz devuelta es <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">Si se usan paréntesis de captura en un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expresión, cualquier capturada texto se incluye en la matriz de cadenas resultante.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">Por ejemplo, si divide la cadena "ciruela-pera" con un guión colocado entre paréntesis de captura, la matriz devuelta incluye un elemento de cadena que contiene el guión.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">En .NET Framework 1.0 y 1.1, si no se encuentra una coincidencia en el primer conjunto de paréntesis, de captura no se incluye el texto capturado de paréntesis adicionales en la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">Todo el texto capturado a partir de .NET Framework 2.0, también se agrega a la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">Por ejemplo, el código siguiente usa dos conjuntos de paréntesis de captura para extraer los elementos de una fecha, incluidos los delimitadores de fecha, de una cadena de fecha.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">El primer conjunto de paréntesis de captura captura el guión, y el segundo captura la barra diagonal.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">Si el código de ejemplo se compila y se ejecutan en .NET Framework 1.0 o 1.1, excluye los caracteres de barra diagonal; Si se compila y se ejecuta en el .NET Framework 2.0 o versiones posteriores, los incluye.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Si la expresión regular puede coincidir con la cadena vacía, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> dividirá la cadena en una matriz de cadenas de carácter único porque el delimitador de cadena vacía se puede encontrar en cada ubicación.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Note that the returned array also includes an empty string at the beginning and end of the array.</source>
          <target state="translated">Tenga en cuenta que la matriz devuelta también incluye una cadena vacía al principio y al final de la matriz.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de división supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called.</source>
          <target state="translated">Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama al método.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, que impide que el método de tiempo de espera, se utiliza.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The recommended static method for splitting text on a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">El método estático recomendado para dividir el texto en una coincidencia de patrones es <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, que permite establecer el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The string to be split.</source>
          <target state="translated">Cadena que se va a dividir.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The maximum number of times the split can occur.</source>
          <target state="translated">Número máximo de veces que puede llevarse a cabo la división.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The character position in the input string where the search will begin.</source>
          <target state="translated">Posición de carácter de la cadena de entrada donde comenzará la búsqueda.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Divide una cadena de entrada por un número máximo especificado de veces en una matriz de subcadenas, en las posiciones definidas por una expresión regular especificada en el constructor <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The search for the regular expression pattern starts at a specified character position in the input string.</source>
          <target state="translated">La búsqueda del patrón de expresión regular se inicia en la posición de carácter especificada de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>An array of strings.</source>
          <target state="translated">Matriz de cadenas.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> métodos son similares a los <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> método, salvo que <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`count`</ph> parameter specifies the maximum number of substrings into which the <ph id="ph2">`input`</ph> string is split; the last string contains the unsplit remainder of the string.</source>
          <target state="translated">El <ph id="ph1">`count`</ph> parámetro especifica el número máximo de subcadenas en la que el <ph id="ph2">`input`</ph> se divide la cadena; la última cadena contiene el resto no dividido de la cadena.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>A <ph id="ph1">`count`</ph> value of zero provides the default behavior of splitting as many times as possible.</source>
          <target state="translated">Un <ph id="ph1">`count`</ph> valor de cero proporciona el comportamiento predeterminado de división tantas veces como sea posible.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startat`</ph> parameter defines the point at which the search for the first delimiter begins (this can be used for skipping leading white space).</source>
          <target state="translated">El <ph id="ph1">`startat`</ph> parámetro define el punto en el que comienza la búsqueda del primer delimitador (Esto se puede utilizar para omitir el espacio en blanco inicial).</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If no matches are found from the <ph id="ph1">`count`</ph>+1 position in the string, the method returns a one-element array that contains the <ph id="ph2">`input`</ph> string.</source>
          <target state="translated">Si no se encuentra ninguna coincidencia de la <ph id="ph1">`count`</ph>+ 1 se coloque en la cadena, el método devuelve una matriz de un elemento que contiene el <ph id="ph2">`input`</ph> cadena.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If one or more matches are found, the first element of the returned array contains the first portion of the string from the first character up to one character before the match.</source>
          <target state="translated">Si se encuentran una o varias coincidencias, el primer elemento de la matriz devuelta contiene la primera parte de la cadena desde el primer carácter hasta un carácter antes de la coincidencia.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If multiple matches are adjacent to one another and the number of matches found is at least two less than <ph id="ph1">`count`</ph>, an empty string is inserted into the array.</source>
          <target state="translated">Si varias coincidencias son adyacentes entre sí y el número de coincidencias encontradas es al menos dos inferior a <ph id="ph1">`count`</ph>, se inserta una cadena vacía en la matriz.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Similarly, if a match is found at <ph id="ph1">`startat`</ph>, which is the first character in the string, the first element of the returned array is an empty string.</source>
          <target state="translated">De forma similar, si se encuentra una coincidencia en <ph id="ph1">`startat`</ph>, que es el primer carácter de la cadena, el primer elemento de la matriz devuelta es una cadena vacía.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>That is, empty strings that result from adjacent matches are counted in determining whether the number of matched substrings equals <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Es decir, se cuentan las cadenas vacías generadas por las coincidencias adyacentes para determinar si el número de apertura coincide subcadenas es igual a <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>In the following example, the regular expression <ph id="ph1">`\d+`</ph> is used to find the starting position of the first substring of numeric characters in a string, and then to split the string a maximum of three times starting at that position.</source>
          <target state="translated">En el ejemplo siguiente, la expresión regular <ph id="ph1">`\d+`</ph> se usa para buscar la posición inicial de la primera subcadena de caracteres numéricos en una cadena y, a continuación, para dividir la cadena de un máximo de tres veces inicial en esa posición.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Because the regular expression pattern matches the beginning of the input string, the returned string array consists of an empty string, a five-character alphabetic string, and the remainder of the string,</source>
          <target state="translated">Dado que el patrón de expresión regular coincide con el principio de la cadena de entrada, la matriz de cadena devuelta consta de una cadena vacía, una cadena es un carácter alfabético de cinco caracteres y el resto de la cadena</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If capturing parentheses are used in a regular expression, any captured text is included in the array of split strings.</source>
          <target state="translated">Si se usan paréntesis de captura en una expresión regular, se incluye el texto capturado en la matriz de cadenas de división.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>However, any array elements that contain captured text are not counted in determining whether the number of matches has reached <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Sin embargo, los elementos de matriz que contienen texto capturado no cuentan para determinar si se ha alcanzado el número de coincidencias <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>For example, splitting the string '"apple-apricot-plum-pear-pomegranate-pineapple-peach" into a maximum of four substrings beginning at character 15 in the string results in a seven-element array, as the following code shows.</source>
          <target state="translated">Por ejemplo, dividir la cadena ' "apple-apricot-plum-pear-pomegranate-pineapple-peach" en un máximo de cuatro subcadenas a partir del carácter 15 de los resultados de cadena en una matriz de siete elementos, como se muestra en el código siguiente.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>In .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">En .NET Framework 1.0 y 1.1, si no se encuentra una coincidencia en el primer conjunto de paréntesis, de captura no se incluye el texto capturado de paréntesis adicionales en la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">Todo el texto capturado a partir de .NET Framework 2.0, también se agrega a la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the individual words in a string.</source>
          <target state="translated">Por ejemplo, el código siguiente usa dos conjuntos de paréntesis de captura para extraer las palabras individuales de una cadena.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the vertical bar.</source>
          <target state="translated">El primer conjunto de paréntesis de captura captura el guión, y el segundo captura la barra vertical.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the vertical bar characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">Si el código de ejemplo se compila y se ejecutan en .NET Framework 1.0 o 1.1, excluye vertical barra caracteres; Si se compila y se ejecuta en el .NET Framework 2.0 o versiones posteriores, los incluye.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Si la expresión regular puede coincidir con la cadena vacía, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> dividirá la cadena en una matriz de cadenas de carácter único porque el delimitador de cadena vacía se puede encontrar en cada ubicación.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The following example splits the string "characters" into as many elements as the input string contains, starting with the character "a".</source>
          <target state="translated">En el ejemplo siguiente se divide la cadena "caracteres" en tantos elementos como contiene la cadena de entrada, empezando por el carácter "a".</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Because the null string matches the end of the input string, a null string is inserted at the end of the returned array.</source>
          <target state="translated">Dado que la cadena nula coincide con el final de la cadena de entrada, se inserta una cadena nula al final de la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de división supera el intervalo de tiempo de espera especificado por el <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> se crea el objeto.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> es menor que cero o mayor que la longitud de <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to split.</source>
          <target state="translated">Cadena que se va a dividir.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern.</source>
          <target state="translated">Divide una cadena de entrada en una matriz de subcadenas en las posiciones definidas por un patrón de expresión regular especificado.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Specified options modify the matching operation.</source>
          <target state="translated">Las opciones especificadas modifican la operación de coincidencia.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>An array of strings.</source>
          <target state="translated">Matriz de cadenas.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> métodos son similares a los <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> método, salvo que <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string is split as many times as possible.</source>
          <target state="translated">La cadena se divide tantas veces como sea posible.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no delimiter is found, the return value contains one element whose value is the original <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">Si no se encuentra ningún delimitador, el valor devuelto contiene un elemento cuyo valor es la versión original <ph id="ph1">`input`</ph> cadena.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Compiled regular expressions used in calls to static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods are automatically cached.</source>
          <target state="translated">Compila expresiones regulares utilizadas en llamadas a estática <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> métodos automáticamente se almacenan en caché.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>To manage the lifetime of compiled regular expressions yourself, use the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods.</source>
          <target state="translated">Para administrar la duración de las expresiones regulares compiladas, utilice la instancia <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">Si varias coincidencias son adyacentes entre sí, se inserta una cadena vacía en la matriz.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found.</source>
          <target state="translated">Por ejemplo, dividir una cadena en un solo guión hace que la matriz devuelta incluir una cadena vacía en la posición donde se encuentran dos guiones adyacentes.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">Si se encuentra una coincidencia al principio o al final de la cadena de entrada, una cadena vacía se incluye al principio o al final de la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`[a-z]+`</ph> to split an input string on any uppercase or lowercase alphabetic character.</source>
          <target state="translated">En el ejemplo siguiente se usa el patrón de expresión regular <ph id="ph1">`[a-z]+`</ph> para dividir una cadena de entrada de cualquier carácter alfabético en mayúscula o minúscula.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the string begins and ends with matching alphabetic characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Dado que la cadena comienza y termina con la coincidencia de caracteres alfabéticos, el valor del primer y último elemento de la matriz devuelta es <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">Si se usan paréntesis de captura en un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expresión, cualquier capturada texto se incluye en la matriz de cadenas resultante.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">Por ejemplo, si divide la cadena "ciruela-pera" con un guión colocado entre paréntesis de captura, la matriz devuelta incluye un elemento de cadena que contiene el guión.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">En .NET Framework 1.0 y 1.1, si no se encuentra una coincidencia en el primer conjunto de paréntesis, de captura no se incluye el texto capturado de paréntesis adicionales en la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">Todo el texto capturado a partir de .NET Framework 2.0, también se agrega a la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">Por ejemplo, el código siguiente usa dos conjuntos de paréntesis de captura para extraer los elementos de una fecha, incluidos los delimitadores de fecha, de una cadena de fecha.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">El primer conjunto de paréntesis de captura captura el guión, y el segundo captura la barra diagonal.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">Si el código de ejemplo se compila y se ejecutan en .NET Framework 1.0 o 1.1, excluye los caracteres de barra diagonal; Si se compila y se ejecuta en el .NET Framework 2.0 o versiones posteriores, los incluye.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Si la expresión regular puede coincidir con la cadena vacía, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> dividirá la cadena en una matriz de cadenas de carácter único porque el delimitador de cadena vacía se puede encontrar en cada ubicación.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción se produce si el tiempo de ejecución de la operación de división supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> no es una combinación bit a bit válida de valores <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called.</source>
          <target state="translated">Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama al método.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, que impide que el método de tiempo de espera, se utiliza.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for splitting text on a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">El método estático recomendado para dividir el texto en una coincidencia de patrones es <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, que permite establecer el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to split.</source>
          <target state="translated">Cadena que se va a dividir.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Patrón de expresión regular del que van a buscarse coincidencias.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Un intervalo de tiempo de espera, o <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> para indicar que el método no debe agotar el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern.</source>
          <target state="translated">Divide una cadena de entrada en una matriz de subcadenas en las posiciones definidas por un patrón de expresión regular especificado.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</source>
          <target state="translated">Los parámetros adicionales especifican las opciones que modifican la operación de coincidencia y un intervalo de tiempo de espera si no se encuentra ninguna coincidencia.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A string array.</source>
          <target state="translated">Matriz de cadenas.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> métodos son similares a los <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> método, salvo que <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string is split as many times as possible.</source>
          <target state="translated">La cadena se divide tantas veces como sea posible.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no delimiter is found, the return value contains one element whose value is the original <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">Si no se encuentra ningún delimitador, el valor devuelto contiene un elemento cuyo valor es la versión original <ph id="ph1">`input`</ph> cadena.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Compiled regular expressions used in calls to static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods are automatically cached.</source>
          <target state="translated">Compila expresiones regulares utilizadas en llamadas a estática <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> métodos automáticamente se almacenan en caché.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To manage the lifetime of compiled regular expressions yourself, use the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods.</source>
          <target state="translated">Para administrar la duración de las expresiones regulares compiladas, utilice la instancia <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">Si varias coincidencias son adyacentes entre sí, se inserta una cadena vacía en la matriz.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found.</source>
          <target state="translated">Por ejemplo, dividir una cadena en un solo guión hace que la matriz devuelta incluir una cadena vacía en la posición donde se encuentran dos guiones adyacentes.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">Si se encuentra una coincidencia al principio o al final de la cadena de entrada, una cadena vacía se incluye al principio o al final de la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`[a-z]+`</ph> to split an input string on any uppercase or lowercase alphabetic character.</source>
          <target state="translated">En el ejemplo siguiente se usa el patrón de expresión regular <ph id="ph1">`[a-z]+`</ph> para dividir una cadena de entrada de cualquier carácter alfabético en mayúscula o minúscula.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the string begins and ends with matching alphabetic characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Dado que la cadena comienza y termina con la coincidencia de caracteres alfabéticos, el valor del primer y último elemento de la matriz devuelta es <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">Si se usan paréntesis de captura en un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expresión, cualquier capturada texto se incluye en la matriz de cadenas resultante.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">Por ejemplo, si divide la cadena "ciruela-pera" con un guión colocado entre paréntesis de captura, la matriz devuelta incluye un elemento de cadena que contiene el guión.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">En .NET Framework 1.0 y 1.1, si no se encuentra una coincidencia en el primer conjunto de paréntesis, de captura no se incluye el texto capturado de paréntesis adicionales en la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">Todo el texto capturado a partir de .NET Framework 2.0, también se agrega a la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">Por ejemplo, el código siguiente usa dos conjuntos de paréntesis de captura para extraer los elementos de una fecha, incluidos los delimitadores de fecha, de una cadena de fecha.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">El primer conjunto de paréntesis de captura captura el guión, y el segundo captura la barra diagonal.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">Si el código de ejemplo se compila y se ejecutan en .NET Framework 1.0 o 1.1, excluye los caracteres de barra diagonal; Si se compila y se ejecuta en el .NET Framework 2.0 o versiones posteriores, los incluye.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Si la expresión regular puede coincidir con la cadena vacía, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> dividirá la cadena en una matriz de cadenas de carácter único porque el delimitador de cadena vacía se puede encontrar en cada ubicación.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated">El <ph id="ph1">`matchTimeout`</ph> parámetro especifica cómo tiempo una coincidencia de patrones método debe intentar encontrar una coincidencia antes de expirar. Establecer un intervalo de tiempo de espera impide que las expresiones regulares que se basan en un retroceso excesivo aparezcan deje de responder cuando procesan datos de entrada que contenga cerca de coincidencias.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>prácticas recomendadas para las expresiones regulares<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> y <bpt id="p2">[</bpt>retroceso<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Si se encuentra ninguna coincidencia en ese intervalo de tiempo, el método produce una <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> invalida cualquier valor de tiempo de espera predeterminado definido para el dominio de aplicación en el que se ejecuta el método.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Se produjo un error de análisis de expresión regular.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="input" /&gt;</ph> o <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> no es una combinación bit a bit válida de valores <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> es negativo, cero o mayor que 24 días aproximadamente.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">Se agotó un tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Para más información sobre los tiempos de espera, vea la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Se recomienda que establezca el <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parámetro en un valor apropiado, como dos segundos.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Si deshabilita los tiempos de espera mediante la especificación de <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones:</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o está formada por texto estático.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Excluye el texto que se ha dinámicamente introducidos por los usuarios.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controle eficazmente coincide con, ausencia de coincidencias y casi coincide con.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Cuando el patrón de expresión regular no contiene ningún elemento de lenguaje que se sabe que causan un retroceso excesivo al procesar a una coincidencia casi.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The object to populate with serialization information.</source>
          <target state="translated">Objeto que se va a rellenar con información de serialización.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The place to store and retrieve serialized data.</source>
          <target state="translated">Sitio para almacenar y recuperar los datos serializados.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This parameter is reserved for future use.</source>
          <target state="translated">Este parámetro está reservado para un uso futuro.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Populates a <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object with the data necessary to deserialize the current <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object.</source>
          <target state="translated">Rellena un objeto <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> con los datos necesarios para deserializar el objeto <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>Returns the regular expression pattern that was passed into the <ph id="ph1">&lt;see langword="Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Devuelve el modelo de expresión regular que se pasó al constructor <ph id="ph1">&lt;see langword="Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>The <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> parameter that was passed into the <ph id="ph2">&lt;see langword="Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> que se pasó al constructor <ph id="ph2">&lt;see langword="Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">El <ph id="ph1">`pattern`</ph> parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las expresiones regulares, vea <bpt id="p1">[</bpt>expresiones regulares de .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> y <bpt id="p2">[</bpt>lenguaje de expresiones regulares - referencia rápida<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> is the base class of regular expressions created by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> es la clase base de las expresiones regulares creados por el <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>These compiled regular expressions use the <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> implementation of the base class.</source>
          <target state="translated">Estos compilan expresiones regulares use el <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> implementación de la clase base.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>If called from a derived class, the <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> method returns the string that was passed to the <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> parameter of the <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> class constructor that was used to define the regular expression.</source>
          <target state="translated">Si se llama desde una clase derivada, el <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> método devuelve la cadena que se pasó a la <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> parámetro de la <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> constructor de clase que se utiliza para definir la expresión regular.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>The input string containing the text to convert.</source>
          <target state="translated">Cadena de entrada que contiene el texto que se desea convertir.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>Converts any escaped characters in the input string.</source>
          <target state="translated">Convierte los caracteres de escape de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>A string of characters with any escaped characters converted to their unescaped form.</source>
          <target state="translated">Cadena de caracteres con caracteres de escape convertidos a su forma sin escape.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method performs one of the following two transformations:</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> método realiza una de las siguientes dos transformaciones:</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>It reverses the transformation performed by the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method by removing the escape character ("<ph id="ph2">\\</ph>") from each character escaped by the method.</source>
          <target state="translated">Invierte la transformación realizada por el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> método quitando el carácter de escape ("<ph id="ph2">\\</ph>") de cada carácter de escape por el método.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>These include the <ph id="ph1">\\</ph>, *, +, ?, &amp;#124;, {, [, (,), ^, $,., #, and white space characters.</source>
          <target state="translated">Puede tratarse de la <ph id="ph1">\\</ph>, *, +,?, &amp;#124;, {, [, (,), ^, $,., # y caracteres de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>In addition, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method unescapes the closing bracket (]) and closing brace (}) characters.</source>
          <target state="translated">Además, la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> método convierte el corchete de cierre (]) y cierre (}) dos llaves.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> cannot reverse an escaped string perfectly because it cannot deduce precisely which characters were escaped,</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> no se puede invertir una cadena de escape perfectamente porque no puede deducir con precisión qué caracteres se entre caracteres de escape</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>It replaces the representation of unprintable characters with the characters themselves.</source>
          <target state="translated">Reemplaza la representación de caracteres no imprimibles por los propios caracteres.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>For example, it replaces \a with \x07.</source>
          <target state="translated">Por ejemplo, reemplaza \a por \x07.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>The character representations it replaces are \a, \b, \e, \n, \r, \f, \t, and \v.</source>
          <target state="translated">Las representaciones de caracteres que reemplaza son \a, \b, \e, \n, \r, \f, \t y \v.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>If the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method encounters other escape sequences that it cannot convert, such as \w or \s, it throws an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> método encuentra otras secuencias de escape que no se puede convertir, como \w o \s, produce una <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> includes an unrecognized escape sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> incluye una secuencia de escape desconocida.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionC">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Lo usa un objeto <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> generado por el método <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionC">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property contains the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propiedad <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> contiene la opción <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph>; de lo contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionR">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Lo usa un objeto <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> generado por el método <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionR">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property contains the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /&gt;</ph> option; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propiedad <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> contiene la opción <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /&gt;</ph>; de lo contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)">
          <source>The time-out interval to check.</source>
          <target state="translated">Intervalo de tiempo de espera que se va a comprobar.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)">
          <source>Checks whether a time-out interval is within an acceptable range.</source>
          <target state="translated">Comprueba si un intervalo de tiempo de espera está dentro del intervalo permitido.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>