<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fd2ccb43296a43eb9c1de7114e0d688441835233" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33684363" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa una expresión regular inmutable.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.RegularExpressions.Regex> clase representa el motor de expresiones regulares de .NET Framework. Se puede utilizar para analizar rápidamente grandes cantidades de texto para buscar patrones de caracteres específicos; para extraer, editar, reemplazar o eliminar subcadenas de texto; y para agregar las cadenas extraídas a una colección para generar un informe.  
  
> [!NOTE]
>  Si su interés primario es validar una cadena mediante la determinación de si se ajusta a un patrón determinado, puede usar el <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> clase.  
  
 Para usar expresiones regulares, defina el modelo que desea identificar en una secuencia de texto utilizando la sintaxis documentada en [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md). A continuación, puede crear instancias opcionalmente un <xref:System.Text.RegularExpressions.Regex> objeto. Por último, llamar a un método que realiza alguna operación, como reemplazar texto que coincide con el patrón de expresión regular, o identifique a una coincidencia de patrones.  
  
> [!NOTE]
>  Para algunos patrones de expresiones regulares comunes, consulte [ejemplos de expresiones regulares](~/docs/standard/base-types/regular-expression-examples.md). También hay una serie de las bibliotecas en línea de patrones de expresiones regulares, como al [-expresiones regulares](https://www.regular-expressions.info/examples.html).  
  
<a name="remarks"></a> Para obtener más información sobre el uso de la <xref:System.Text.RegularExpressions.Regex> de clases, consulte las siguientes secciones de este tema:  
  
-   [Frente a Regex. Métodos de cadena](#regex_vs_string)  
  
-   [Puertos estáticos frente a Métodos de instancia](#static_vs_instance)  
  
-   [Realizar operaciones de expresiones regulares](#regex_ops)  
  
-   [Definir un valor de tiempo de espera](#define_timeout)  
  
 Para obtener más información acerca del lenguaje de expresiones regulares, consulte [Lenguaje de expresiones regulares - Referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md) o descargue e imprima uno de estos folletos:  
  
 [Referencia rápida en formato Word (.docx)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [Referencia rápida en formato PDF (.pdf)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Frente a Regex. Métodos de cadena  
 La <xref:System.String?displayProperty=nameWithType> clase incluye varios métodos de comparación y de búsqueda que puede usar para realizar la coincidencia de patrones con texto. Por ejemplo, el <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, y <xref:System.String.StartsWith%2A?displayProperty=nameWithType> métodos determinan si una instancia de cadena contiene una subcadena especificada; y la <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, y <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> métodos devuelven la posición inicial de una subcadena especificada en una cadena. Use los métodos de la <xref:System.String?displayProperty=nameWithType> clase cuando se está buscando una cadena específica. Use la <xref:System.Text.RegularExpressions.Regex> clase cuando se está buscando un patrón específico en una cadena. Para obtener más información y ejemplos, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
 [Volver a comentarios](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>Puertos estáticos frente a Métodos de instancia  
 Después de definir un patrón de expresión regular, puede proporcionar al motor de expresiones regulares en cualquiera de estas dos maneras:  
  
-   Creando un <xref:System.Text.RegularExpressions.Regex> objeto que representa la expresión regular. Para ello, pase el patrón de expresión regular a un <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> constructor. A <xref:System.Text.RegularExpressions.Regex> objeto es inmutable; cuando se crea una instancia una <xref:System.Text.RegularExpressions.Regex> objeto con una expresión regular, que no se puede cambiar la expresión regular del objeto.  
  
-   Si se suministra la expresión regular y el texto que desea buscar en un `static` (`Shared` en Visual Basic) <xref:System.Text.RegularExpressions.Regex> método. Esto le permite usar una expresión regular sin crear explícitamente un <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 Todos los <xref:System.Text.RegularExpressions.Regex> métodos de identificación de modelo son estáticos y de instancia sobrecargas.  
  
 El motor de expresiones regulares debe compilar un modelo determinado antes de que se puede usar el modelo. Dado que <xref:System.Text.RegularExpressions.Regex> objetos son inmutables, se trata de un procedimiento de un solo uso que se produce cuando un <xref:System.Text.RegularExpressions.Regex> se denomina constructor de clase o un método estático. Para eliminar la necesidad de compilar varias veces una única expresión regular, el motor de expresiones regulares almacena en caché las expresiones regulares compiladas usadas en llamadas a métodos estáticos. Como resultado, los métodos de coincidencia de patrón de expresión regular ofrecen un rendimiento comparable para estático y métodos de instancia.  
  
> [!IMPORTANT]
>  En las expresiones regulares de .NET Framework versiones 1.0 y 1.1, todos los compilado, si se usan en la instancia o método estático llama, se almacenaron en caché. A partir de .NET Framework 2.0, solo los expresiones regulares que se utilizan en llamadas a métodos estáticos se almacenan en caché.  
  
 Sin embargo, el almacenamiento en caché puede afectar negativamente al rendimiento en los dos casos siguientes:  
  
-   Al utilizar llamadas a métodos estáticos con un gran número de expresiones regulares. De forma predeterminada, el motor de expresiones regulares almacena en caché las 15 expresiones regulares estáticas usadas más recientemente. Si la aplicación usa más de 15 expresiones regulares estáticas, algunas expresiones regulares deben compilarse. Para evitar que esta recompilación, puede aumentar la <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> propiedad.  
  
-   Cuando se crea una instancia nueva <xref:System.Text.RegularExpressions.Regex> objetos con expresiones regulares que se han compilado previamente. Por ejemplo, el código siguiente define una expresión regular para buscar palabras duplicadas en una secuencia de texto. Aunque en el ejemplo usa una única expresión regular, crea una instancia de un nuevo <xref:System.Text.RegularExpressions.Regex> objeto para procesar cada línea de texto. Esto da como resultado la recompilación de la expresión regular con cada iteración del bucle.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     Para evitar volver a compilar, debe crear una instancia de una sola <xref:System.Text.RegularExpressions.Regex> objeto que sea accesible a todo el código que lo requiera, como se muestra en el ejemplo siguiente se ha vuelto a escribir.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [Volver a comentarios](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>Realizar operaciones de expresiones regulares  
 Si decide crear una instancia de un <xref:System.Text.RegularExpressions.Regex> objeto y llamar a sus métodos o llamar a métodos estáticos, el <xref:System.Text.RegularExpressions.Regex> clase ofrece las siguientes funciones de coincidencia de patrón:  
  
-   Validación de una coincidencia. Se llama a la <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método para determinar si existe una coincidencia.  
  
-   Recuperación de una única coincidencia. Se llama a la <xref:System.Text.RegularExpressions.Regex.Match%2A> método para recuperar un <xref:System.Text.RegularExpressions.Match> objeto que representa la primera coincidencia en una cadena o en parte de una cadena. Se pueden recuperar las coincidencias subsiguientes llamando a la <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método.  
  
-   Recuperación de todas las coincidencias. Se llama a la <xref:System.Text.RegularExpressions.Regex.Matches%2A> método para recuperar un <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> objeto que representa todas las coincidencias encontradas en una cadena o en parte de una cadena.  
  
-   Sustitución del texto coincidente. Se llama a la <xref:System.Text.RegularExpressions.Regex.Replace%2A> método para reemplazar el texto coincidente. El texto de reemplazo también puede definirse mediante una expresión regular. Además, algunos de los <xref:System.Text.RegularExpressions.Regex.Replace%2A> métodos incluyen un <xref:System.Text.RegularExpressions.MatchEvaluator> parámetro que le permite definir mediante programación el texto de reemplazo.  
  
-   Creación de una matriz de cadenas que se compone de partes de una cadena de entrada. Se llama a la <xref:System.Text.RegularExpressions.Regex.Split%2A> método para dividir una cadena de entrada en las posiciones definidas por la expresión regular.  
  
 Además de sus métodos de coincidencia de patrones, el <xref:System.Text.RegularExpressions.Regex> clase incluye varios métodos de propósito especial:  
  
-   El <xref:System.Text.RegularExpressions.Regex.Escape%2A> método convierte los caracteres que se pueden interpretar como operadores de expresiones regulares en una expresión regular o una cadena de entrada.  
  
-   El <xref:System.Text.RegularExpressions.Regex.Unescape%2A> método quita estos caracteres de escape.  
  
-   El <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> método crea un ensamblado que contiene expresiones regulares predefinidas. .NET Framework contiene ejemplos de estos ensamblados para fines especiales en el <xref:System.Web.RegularExpressions?displayProperty=nameWithType> espacio de nombres.  
  
 [Volver a comentarios](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>Definir un valor de tiempo de espera  
 .NET Framework admite un lenguaje de expresión regular completa que proporciona gran potencia y flexibilidad en la coincidencia. Sin embargo, la eficacia y flexibilidad se suministran con un costo: el riesgo de un rendimiento bajo. Las expresiones regulares que se ejecutan satisfactoriamente son sorprendentemente fáciles de crear. En algunos casos, operaciones de expresiones regulares que se basan en un retroceso excesivo pueden parecer que deje de responder cuando procesa el texto que casi coincide con el patrón de expresión regular. Para obtener más información sobre el motor de expresiones regulares de .NET Framework, vea [detalles del comportamiento de expresiones regulares](~/docs/standard/base-types/details-of-regular-expression-behavior.md). Para obtener más información sobre un retroceso excesivo, consulte [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], se puede definir un intervalo de tiempo de espera para buscar coincidencias de expresiones regulares. Si el motor de expresiones regulares no puede identificar una coincidencia dentro de este intervalo de tiempo, la operación de coincidencia produce un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. En la mayoría de los casos, esto impide que el motor de expresiones regulares desperdiciar potencia de procesamiento cuando se intenta buscar coincidencias con texto que casi coincide con el patrón de expresión regular. También podría indicar, sin embargo, que el intervalo de tiempo de espera se ha establecido demasiado bajo, o que la carga actual de la máquina ha provocado una degradación general del rendimiento.  
  
 Cómo controlar la excepción depende de la causa de la excepción. Si la excepción se produce porque el intervalo de tiempo de espera se establece demasiado bajo, o debido a la carga de la máquina excesivo, puede aumentar el intervalo de tiempo de espera y vuelva a intentar la operación de coincidencia. Si la excepción se produce porque la expresión regular se basa en un retroceso excesivo, puede asumir que no existe una coincidencia y, si lo desea, puede registrar información que le ayudará a modificar el patrón de expresión regular.  
  
 Puede establecer un intervalo de tiempo de espera mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor al crear una instancia de un objeto de expresión regular. Para los métodos estáticos, puede establecer un intervalo de tiempo de espera mediante una llamada a una sobrecarga de un método correspondiente que tiene un `matchTimeout` parámetro. Si no establece explícitamente un valor de tiempo de espera, el valor de tiempo de espera predeterminado se determina como sigue:  
  
-   Utilizando el tiempo de espera de toda la aplicación el valor, si existe. Esto puede ser cualquier valor de tiempo de espera que se aplica al dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se realiza la llamada al método estático o se crea una instancia de objeto. Puede establecer el valor de tiempo de espera de toda la aplicación mediante una llamada a la <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> método para asignar una representación de cadena de un <xref:System.TimeSpan> valor a la propiedad "REGEX_DEFAULT_MATCH_TIMEOUT".  
  
-   Con el valor <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, si no se ha establecido ningún valor de tiempo de espera de toda la aplicación.  
  
> [!IMPORTANT]
>  Se recomienda que establezca un valor de tiempo de espera en todas las operaciones de coincidencia de patrón de expresión regular. Para obtener más información, consulte [prácticas recomendadas para las expresiones regulares](~/docs/standard/base-types/best-practices.md).  
  
 [Volver a comentarios](#remarks)  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza una expresión regular para comprobar las apariciones repetidas de palabras en una cadena. La expresión regular `\b(?<word>\w+)\s+(\k<word>)\b` puede interpretarse como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`(?<word>\w+)`|Buscar coincidencias con uno o más caracteres de palabra hasta un límite de palabras. Este grupo capturado se denomina `word`.|  
|`\s+`|Coincide con uno o más caracteres de espacio en blanco.|  
|`(\k<word>)`|Coincide con el grupo capturado denominada `word`.|  
|`\b`|Coincide con un límite de palabras.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 En el ejemplo siguiente se muestra el uso de una expresión regular para comprobar si una cadena representa un valor de divisa o tiene el formato correcto para representar un valor de divisa. En este caso, se genera dinámicamente la expresión regular de la <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, y <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> propiedades de la referencia cultural actual del usuario. Si el sistema actual de la referencia cultural es en-US, la expresión regular resultante es `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`. Esta expresión regular puede interpretarse como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`^`|Comience desde el principio de la cadena.|  
|`\s*`|Busca coincidencias con cero o más caracteres de espacio en blanco.|  
|`[\+-]?`|Coincide con cero o una aparición de signo positivo o el signo negativo.|  
|`\s?`|Busca coincidencias con cero o un carácter de espacio en blanco.|  
|`\$?`|Cero o una coincidencia con el signo de dólar.|  
|`\s?`|Busca coincidencias con cero o un carácter de espacio en blanco.|  
|`\d*`|Busca cero o más dígitos decimales.|  
|`\.?`|Coincide con cero o un símbolo de separador decimal.|  
|`\d{2}?`|Coincide con cero o una vez de dos dígitos decimales.|  
|`(\d*\.?\d{2}?){1}`|Coincide con el patrón de dígitos enteros y fraccionarios separados por un símbolo de separador decimal al menos una vez.|  
|`$`|Coincide con el final de la cadena.|  
  
 En este caso, la expresión regular se da por supuesto que una cadena de divisa válida no contiene símbolos de separador de grupo y que tenga ningún dígito fraccionario o el número de dígitos fraccionarios definido por la referencia cultural actual <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> propiedad.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 Dado que la expresión regular en este ejemplo se genera dinámicamente, se desconoce en tiempo de diseño si el símbolo de divisa de la referencia cultural actual, signo decimal o signos positivos y negativos podrían malinterpretarse por el motor de expresiones regulares como operadores de lenguaje de expresiones regulares. Para evitar los errores de interpretación, en el ejemplo se pasa cada cadena generada de forma dinámica a la <xref:System.Text.RegularExpressions.Regex.Escape%2A> método.  
  
 ]]></format>
    </remarks>
    <threadsafe>La <see cref="T:System.Text.RegularExpressions.Regex" /> clase es inmutable (de solo lectura) y es seguro para subprocesos. <see cref="T:System.Text.RegularExpressions.Regex" /> los objetos se pueden crearse en cualquier subproceso y compartirse entre varios subprocesos. Para obtener más información, consulte [seguridad para subprocesos](~/docs/standard/base-types/thread-safety-in-regular-expressions.md).</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que este constructor está protegido; solo se puede llamar mediante las clases derivadas de la <xref:System.Text.RegularExpressions.Regex> clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.RegularExpressions.Regex" /> para la expresión regular especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea el [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md) temas.  
  
 Llamar a la <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> es equivalente a llamar al constructor el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> constructor con un valor de <xref:System.Text.RegularExpressions.RegexOptions.None> para el `options` argumento.  
  
 Un <xref:System.Text.RegularExpressions.Regex> objeto es inmutable, lo que significa que se puede utilizar únicamente para el patrón de coincidencia que defina al crearlo. Sin embargo, puede usar cualquier número de veces sin que se va a volver a compilar.  
  
 Este constructor crea una instancia de un objeto de expresión regular que intenta obtener una coincidencia entre mayúsculas y minúsculas de cualquier carácter alfabético definido en `pattern`. Hay una coincidencia entre mayúsculas y minúsculas, utilice el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> constructor.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar este constructor para crear una instancia de una expresión regular que coincide con cualquier palabra que comience con las letras "a" o "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 Tenga en cuenta que el patrón de expresión regular no puede coincidir con la palabra "The" al principio del texto, dado que las comparaciones distinguen entre mayúsculas y minúsculas de forma predeterminada. Para obtener un ejemplo de comparación entre mayúsculas y minúsculas, consulte el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> es <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Este constructor crea un <see cref="T:System.Text.RegularExpressions.Regex" /> objeto que utiliza el valor de tiempo de espera predeterminado del dominio de aplicación en el que se crea. Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el <see cref="T:System.Text.RegularExpressions.Regex" /> objeto utiliza el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que la operación ha agotado el tiempo. El constructor recomendado para crear un <see cref="T:System.Text.RegularExpressions.Regex" /> objeto es <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Objeto que contiene un modelo serializado e información de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</param>
        <param name="context">Destino de esta serialización. (Este parámetro no se usa; especifique <see langword="null" />).</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.RegularExpressions.Regex" /> con datos serializados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">El modelo que contiene <paramref name="info" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="info" /> contiene una marca <see cref="T:System.Text.RegularExpressions.RegexOptions" /> no válida.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que modifican la expresión regular.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.RegularExpressions.Regex" /> para la expresión regular especificada, con opciones que modifican el modelo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea el [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md) temas.  
  
 Un <xref:System.Text.RegularExpressions.Regex> objeto es inmutable, lo que significa que se puede utilizar únicamente para los parámetros de coincidencia se definen al crearlo. Sin embargo, puede usar cualquier número de veces sin que se va a volver a compilar.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar este constructor para crear una instancia de una expresión regular que coincide con cualquier palabra que comience con las letras "a" o "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 Tenga en cuenta que la colección de coincidencias incluye la palabra "The" que comienza el texto porque el `options` parámetro definió las comparaciones entre mayúsculas y minúsculas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> contiene una marca no válida.</exception>
        <block subset="none" type="usage">
          <para>Este constructor crea un <see cref="T:System.Text.RegularExpressions.Regex" /> objeto que utiliza el valor de tiempo de espera predeterminado del dominio de aplicación en el que se crea. Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el <see cref="T:System.Text.RegularExpressions.Regex" /> objeto utiliza el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que la operación ha agotado el tiempo. El constructor recomendado para crear un <see cref="T:System.Text.RegularExpressions.Regex" /> objeto es <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que modifican la expresión regular.</param>
        <param name="matchTimeout">Un intervalo de tiempo de espera, o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que el método no debe agotar el tiempo de espera.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.RegularExpressions.Regex" /> para la expresión regular especificada, con las opciones que modifican el modelo y un valor que especifica cuánto tiempo debe intentar un método de coincidencia de modelos una coincidencia antes de que se agote el tiempo de espera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea el [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md) temas.  
  
 Un <xref:System.Text.RegularExpressions.Regex> objeto es inmutable, lo que significa que se puede utilizar únicamente para el patrón de coincidencia que se define cuando se crea. Sin embargo, puede usar cualquier número de veces sin que se va a volver a compilar.  
  
 El `matchTimeout` parámetro especifica cuánto tiempo una patrón de coincidencia de método debe intentar encontrar una coincidencia antes de expirar. Si no se encuentra ninguna coincidencia en ese intervalo de tiempo, el método de coincidencia de patrones se produce un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. `matchTimeout` invalida cualquier tiempo de espera predeterminado definido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Los métodos de coincidencia de patrones de instancia que observan las `matchTimeout` intervalo de tiempo de espera incluyen lo siguiente:  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 Establecer un intervalo de tiempo de espera impide que las expresiones regulares que se basan en un retroceso excesivo aparezcan deje de responder cuando procesan datos de entrada que contenga cerca de coincidencias. Para obtener más información, consulte [prácticas recomendadas para las expresiones regulares](~/docs/standard/base-types/best-practices.md) y [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Para establecer un intervalo de tiempo de espera razonable, tenga en cuenta los siguientes factores:  
  
-   La longitud y complejidad del patrón de expresión regular. Las expresiones regulares más largas y complejas requieren más tiempo que las más cortas y más sencillas.  
  
-   La carga esperado de la máquina. El proceso tarda más tiempo en sistemas que tienen un uso elevado de CPU y memoria.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor para crear instancias de un <xref:System.Text.RegularExpressions.Regex> objeto con un valor de tiempo de espera de un segundo. El patrón de expresión regular `(a+)+$`, que coincide con una o más secuencias de uno o varios caracteres "a" al final de una línea, está sujeto a un retroceso excesivo. Si un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> está iniciada, en el ejemplo se aumenta el valor de tiempo de espera hasta el valor máximo de tres segundos. En caso contrario, abandona el intento de hacer coincidir el patrón.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es un valor <see cref="T:System.Text.RegularExpressions.RegexOptions" /> válido.  
  
 O bien  
  
 <paramref name="matchTimeout" /> es negativo, cero o mayor que 24 días aproximadamente.</exception>
        <block subset="none" type="usage">
          <para>Se recomienda que establezca el <paramref name="matchTimeout" /> parámetro en un valor apropiado, como dos segundos. Si deshabilita los tiempos de espera mediante la especificación de <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor. Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones:  
  
-   Cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o está formada por texto estático. Excluye el texto que se ha dinámicamente introducidos por los usuarios.  
  
-   Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controle eficazmente coincide con, ausencia de coincidencias y casi coincide con.  
  
-   Cuando el patrón de expresión regular no contiene ningún elemento de lenguaje que se sabe que causan un retroceso excesivo al procesar a una coincidencia casi.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número máximo de entradas en la memoria caché estática actual de expresiones regulares compiladas.</summary>
        <value>Número máximo de entradas en la memoria caché estática.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.RegularExpressions.Regex> clase mantiene una caché interna de expresiones regulares compiladas usadas en llamadas a métodos estáticos. Si el valor especificado en una operación set es menor que el tamaño de caché actual, se descartan las entradas de caché hasta que el tamaño de caché es igual que el valor especificado.  
  
 De forma predeterminada, la memoria caché contiene 15 expresiones regulares estáticas compiladas. La aplicación normalmente no tendrá que modificar el tamaño de la memoria caché. Use la <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> propiedad solo cuando desee desactivar el almacenamiento en caché o si cuenta con una caché inusualmente grande.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de una operación Set es menor que cero.</exception>
        <block subset="none" type="usage">
          <para>En .NET Framework anteriores a la [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], las expresiones regulares que se usan en estáticos y llamadas de método de instancia se almacenaron en caché. A partir del [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], solo normales se almacenan en caché las expresiones usadas en llamadas a métodos estáticos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un diccionario que asigna grupos de captura denominados con sus valores de índice.</summary>
        <value>Diccionario que asigna grupos de captura denominados con sus valores de índice.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que esta propiedad está protegida; solo puede obtenerse de una clase derivada de la <xref:System.Text.RegularExpressions.Regex> clase.  
  
 Una operación set intenta convertir el valor asignado a la propiedad a una <xref:System.Collections.Hashtable> objeto; si se produce un error en esta conversión, llama a la <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor asignado a la propiedad <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> en una operación set es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un diccionario que asigna grupos de captura numerados con sus valores de índice.</summary>
        <value>Diccionario que asigna grupos de captura numerados con sus valores de índice.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que esta propiedad está protegida; solo puede obtenerse de una clase derivada de la <xref:System.Text.RegularExpressions.Regex> clase.  
  
 Una operación set intenta convertir el valor asignado a la propiedad a una <xref:System.Collections.Hashtable> objeto; si se produce un error en esta conversión, llama a la <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor asignado a la propiedad <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> en una operación set es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compila expresiones regulares y las guarda en disco en un ensamblado único.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Matriz que describe las expresiones regulares que se van a compilar.</param>
        <param name="assemblyname">El nombre de archivo del ensamblado.</param>
        <summary>Compila uno o varios objetos <see cref="T:System.Text.RegularExpressions.Regex" /> especificados en un ensamblado con nombre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> método genera un ensamblado de .NET Framework en la que cada expresión regular definida en la `regexinfos` matriz se representa mediante una clase. Normalmente, el <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> método se llama desde una aplicación independiente que genera un ensamblado de expresiones regulares compiladas. Cada expresión regular incluida en el ensamblado tiene las siguientes características:  
  
-   Se deriva de la <xref:System.Text.RegularExpressions.Regex> clase.  
  
-   Se asigna el nombre completo que está definido por el `fullnamespace` y `name` parámetros correspondiente <xref:System.Text.RegularExpressions.RegexCompilationInfo> objeto.  
  
-   Tiene un valor predeterminado (o sin parámetros) constructor.  
  
 Normalmente, el código que crea instancias y utiliza la expresión regular compilada se encuentra en un ensamblado o una aplicación que es independiente del código que crea el ensamblado.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un ensamblado denominado RegexLib.dll. El ensamblado incluye dos expresiones regulares compiladas. La primera, `Utilities.RegularExpressions.DuplicatedString`, coincide con dos palabras contiguas idénticas. El segundo, `Utilities.RegularExpressions.EmailAddress`, comprueba si una cadena tiene el formato correcto es una dirección de correo electrónico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 La expresión regular que comprueba las palabras duplicadas en una cadena, a continuación, se crea y se usa en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Compilación correcta de este segundo ejemplo requiere una referencia a RegexLib.dll (el ensamblado creado en el primer ejemplo) va a agregar al proyecto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de la propiedad <see cref="P:System.Reflection.AssemblyName.Name" /> del parámetro <paramref name="assemblyname" /> es una cadena vacía o NULL.  
  
 O bien  
  
 El modelo de expresión regular de uno o varios objetos de <paramref name="regexinfos" /> contiene una sintaxis no válida.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="assemblyname" /> o <paramref name="regexinfos" /> es <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Si está desarrollando en un sistema que tenga [!INCLUDE[net_v45](~/includes/net-v45-md.md)] o sus versiones secundarias instalados, el destino [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], y usa el <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> método para crear un ensamblado que contiene expresiones regulares compiladas. Intente usar una de las expresiones regulares en que el ensamblado en un sistema que tiene [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] produce una excepción. Para evitar este problema, realice una de las acciones siguientes:  
  
-   Compilar el ensamblado que contiene las expresiones regulares compiladas en un sistema que tenga [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] en lugar de las versiones posteriores.  
  
-   En lugar de llamar <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> y recuperar la expresión regular compilada de un ensamblado, utilice estáticas o de instancia <see cref="T:System.Text.RegularExpressions.Regex" /> métodos con el <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opción cuando se instancie un <see cref="T:System.Text.RegularExpressions.Regex" /> objeto o llamar a una expresión regular método de coincidencia de patrón.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Matriz que describe las expresiones regulares que se van a compilar.</param>
        <param name="assemblyname">El nombre de archivo del ensamblado.</param>
        <param name="attributes">Matriz que define los atributos que se van a aplicar al ensamblado.</param>
        <summary>Compila uno o varios objetos <see cref="T:System.Text.RegularExpressions.Regex" /> especificados en un ensamblado con nombre que tiene los atributos especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> método genera un ensamblado de .NET Framework en la que cada expresión regular definida en la `regexinfos` matriz se representa mediante una clase. Normalmente, el <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> método se llama desde una aplicación independiente que genera un ensamblado de expresiones regulares compiladas. Cada expresión regular incluida en el ensamblado tiene las siguientes características:  
  
-   Se deriva de la <xref:System.Text.RegularExpressions.Regex> clase.  
  
-   Se asigna el nombre completo que está definido por el `fullnamespace` y `name` parámetros correspondiente <xref:System.Text.RegularExpressions.RegexCompilationInfo> objeto.  
  
-   Tiene un valor predeterminado (o sin parámetros) constructor.  
  
 Normalmente, el código que crea instancias y utiliza la expresión regular compilada se encuentra en un ensamblado o una aplicación que es independiente del código que crea el ensamblado.  
  
 Dado que la <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> método genera un ensamblado de .NET Framework de una llamada de método en lugar de utilizar la palabra clave de definición de clase de un lenguaje determinado (como `class` en C# o `Class`...`End Class` en Visual Basic), no permiten atributos de .NET Framework que se asignará al ensamblado mediante la sintaxis de atributo estándar del lenguaje de desarrollo. El `attributes` parámetro proporciona un método alternativo para definir los atributos que se aplican al ensamblado. Para cada atributo que desea aplicar al ensamblado, haga lo siguiente:  
  
1.  Crear una matriz de <xref:System.Type> objetos que representan los tipos de parámetro del constructor de atributo que desea llamar.  
  
2.  Recuperar un <xref:System.Type> objeto que representa la clase de atributo que desea aplicar al nuevo ensamblado.  
  
3.  Llame a la <xref:System.Type.GetConstructor%2A> método del atributo <xref:System.Type> objeto que se va a recuperar un <xref:System.Reflection.ConstructorInfo> objeto que representa el constructor de atributo que desea llamar. Pasar el <xref:System.Type.GetConstructor%2A> método la matriz de <xref:System.Type> objetos que representan los tipos de parámetro del constructor.  
  
4.  Crear un <xref:System.Object> matriz que define los parámetros para pasar al constructor del atributo.  
  
5.  Crear una instancia de un <xref:System.Reflection.Emit.CustomAttributeBuilder> objeto pasando su constructor la <xref:System.Reflection.ConstructorInfo> objeto recuperado en el paso 3 y el <xref:System.Object> matriz creada en el paso 4.  
  
 A continuación, puede pasar una matriz de estos <xref:System.Reflection.Emit.CustomAttributeBuilder> objetos en lugar de la `attributes` parámetro para el <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un ensamblado denominado RegexLib.dll y se aplica el <xref:System.Reflection.AssemblyTitleAttribute> atributo. El ensamblado incluye dos expresiones regulares compiladas. La primera, `Utilities.RegularExpressions.DuplicatedString`, coincide con dos palabras contiguas idénticas. El segundo, `Utilities.RegularExpressions.EmailAddress`, comprueba si una cadena tiene el formato correcto es una dirección de correo electrónico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 Puede comprobar que la <xref:System.Reflection.AssemblyTitleAttribute> se ha aplicado el atributo al ensamblado examinando su manifiesto con una utilidad de reflexión como ILDasm.  
  
 La expresión regular que comprueba las palabras duplicadas en una cadena, a continuación, se crea y se usa en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Compilación correcta de este segundo ejemplo requiere una referencia a RegexLib.dll (el ensamblado creado en el primer ejemplo) va a agregar al proyecto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de la propiedad <see cref="P:System.Reflection.AssemblyName.Name" /> del parámetro <paramref name="assemblyname" /> es una cadena vacía o NULL.  
  
 O bien  
  
 El modelo de expresión regular de uno o varios objetos de <paramref name="regexinfos" /> contiene una sintaxis no válida.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="assemblyname" /> o <paramref name="regexinfos" /> es <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Si está desarrollando en un sistema que tenga [!INCLUDE[net_v45](~/includes/net-v45-md.md)] o sus versiones secundarias instalados, el destino [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], y usa el <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> método para crear un ensamblado que contiene expresiones regulares compiladas. Intente usar una de las expresiones regulares en que el ensamblado en un sistema que tiene [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] produce una excepción. Para evitar este problema, realice una de las acciones siguientes:  
  
-   Compilar el ensamblado que contiene las expresiones regulares compiladas en un sistema que tenga [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] en lugar de las versiones posteriores.  
  
-   En lugar de llamar <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> y recuperar la expresión regular compilada de un ensamblado, utilice estáticas o de instancia <see cref="T:System.Text.RegularExpressions.Regex" /> métodos con el <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opción cuando se instancie un <see cref="T:System.Text.RegularExpressions.Regex" /> objeto o llamar a una expresión regular método de coincidencia de patrón.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
        <Parameter Name="resourceFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Matriz que describe las expresiones regulares que se van a compilar.</param>
        <param name="assemblyname">El nombre de archivo del ensamblado.</param>
        <param name="attributes">Matriz que define los atributos que se van a aplicar al ensamblado.</param>
        <param name="resourceFile">Nombre del archivo de recursos Win32 que se va a incluir en el ensamblado.</param>
        <summary>Compila uno o varios objetos <see cref="T:System.Text.RegularExpressions.Regex" /> especificados y un archivo de recursos especificado en un ensamblado con nombre que tiene los atributos indicados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method generates a .NET Framework assembly in which each regular expression defined in the `regexinfos` array is represented by a class. Typically, the [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method is called from a separate application that generates an assembly of compiled regular expressions. Cada expresión regular incluida en el ensamblado tiene las siguientes características:  
  
-   Se deriva de la <xref:System.Text.RegularExpressions.Regex> clase.  
  
-   Se asigna el nombre completo que está definido por el `fullnamespace` y `name` parámetros correspondiente <xref:System.Text.RegularExpressions.RegexCompilationInfo> objeto.  
  
-   Tiene un valor predeterminado (o sin parámetros) constructor.  
  
 Normalmente, el código que crea instancias y utiliza la expresión regular compilada se encuentra en un ensamblado o una aplicación que es independiente del código que crea el ensamblado.  
  
 Dado que la <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> método genera un ensamblado de .NET Framework de una llamada de método en lugar de utilizar la palabra clave de definición de clase de un lenguaje determinado (como `class` en C# o `Class`...`End Class` en Visual Basic), no permiten atributos de .NET Framework que se asignará al ensamblado mediante la sintaxis de atributo estándar del lenguaje de desarrollo. El `attributes` parámetro proporciona un método alternativo para definir los atributos que se aplican al ensamblado. Para cada atributo que desea aplicar al ensamblado, haga lo siguiente:  
  
1.  Crear una matriz de <xref:System.Type> objetos que representan los tipos de parámetro del constructor de atributo que desea llamar.  
  
2.  Recuperar un <xref:System.Type> objeto que representa la clase de atributo que desea aplicar al nuevo ensamblado.  
  
3.  Llame a la <xref:System.Type.GetConstructor%2A> método del atributo <xref:System.Type> objeto que se va a recuperar un <xref:System.Reflection.ConstructorInfo> objeto que representa el constructor de atributo que desea llamar. Pasar el <xref:System.Type.GetConstructor%2A> método la matriz de <xref:System.Type> objetos que representan los tipos de parámetro del constructor  
  
4.  Crear un <xref:System.Object> matriz que define los parámetros para pasar al constructor del atributo.  
  
5.  Crear una instancia de un <xref:System.Reflection.Emit.CustomAttributeBuilder> objeto pasando su constructor la <xref:System.Reflection.ConstructorInfo> objeto recuperado en el paso 3 y el <xref:System.Object> matriz creada en el paso 4.  
  
 You can then pass an array of these <xref:System.Reflection.Emit.CustomAttributeBuilder> objects instead of the `attributes` parameter to the [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de la propiedad <see cref="P:System.Reflection.AssemblyName.Name" /> del parámetro <paramref name="assemblyname" /> es una cadena vacía o NULL.  
  
 O bien  
  
 El modelo de expresión regular de uno o varios objetos de <paramref name="regexinfos" /> contiene una sintaxis no válida.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="assemblyname" /> o <paramref name="regexinfos" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">El parámetro <paramref name="resourceFile" /> designa un archivo de recursos de Win32 no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se pudo encontrar el archivo designado por el parámetro <paramref name="resourceFile" />.</exception>
        <block subset="none" type="usage">
          <para>Si está desarrollando en un sistema que tenga [!INCLUDE[net_v45](~/includes/net-v45-md.md)] o sus versiones secundarias instalados, el destino [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], y usa el <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> método para crear un ensamblado que contiene expresiones regulares compiladas. Intente usar una de las expresiones regulares en que el ensamblado en un sistema que tiene [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] produce una excepción. Para evitar este problema, realice una de las acciones siguientes:  
  
-   Compilar el ensamblado que contiene las expresiones regulares compiladas en un sistema que tenga [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] en lugar de las versiones posteriores.  
  
-   En lugar de llamar <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> y recuperar la expresión regular compilada de un ensamblado, utilice estáticas o de instancia <see cref="T:System.Text.RegularExpressions.Regex" /> métodos con el <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opción cuando se instancie un <see cref="T:System.Text.RegularExpressions.Regex" /> objeto o llamar a una expresión regular método de coincidencia de patrón.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Cadena de entrada que contiene el texto que se va a convertir.</param>
        <summary>Convierte en caracteres de escape un juego mínimo de caracteres (\\, *, +, ?, |, {, [, (,), ^, $,., # y espacio en blanco) al reemplazarlos con sus códigos de escape. Esto indica al motor de expresiones regulares que interprete los caracteres literalmente en lugar de como metacaracteres.</summary>
        <returns>Cadena de caracteres con metacaracteres convertidos a su forma de escape.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> Convierte una cadena para que el motor de expresiones regulares interprete los metacaracteres que puede contener como literales de carácter. Por ejemplo, considere la posibilidad de una expresión regular que está diseñada para extraer comentarios que están delimitados por recta de apertura y cierre entre corchetes ([y]) del texto. En el ejemplo siguiente, la expresión regular "[(.*?)]" se interpreta como una clase de caracteres. En lugar de búsqueda de coincidencias comentarios incrustados en el texto de entrada, la expresión regular coincide con cada apertura o un paréntesis de cierre, un punto, un asterisco o un signo de interrogación.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 Sin embargo, si el corchete de apertura es la secuencia de escape pasarlo a la <xref:System.Text.RegularExpressions.Regex.Escape%2A> método, la expresión regular logra encontrar coincidencias con los comentarios que se incrustan en la cadena de entrada. Esto se ilustra en el siguiente ejemplo:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 En una expresión regular que se define mediante el uso de texto estático, se pueden escapar caracteres que deben interpretarse literalmente en lugar de como metacaracteres utilizando delante de ellas con un símbolo de barra diagonal inversa (\\) así como mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.Escape%2A> método. En una expresión regular que se define dinámicamente, utilizando caracteres que no se conocen en tiempo de diseño, una llamada a la <xref:System.Text.RegularExpressions.Regex.Escape%2A> método es especialmente importante para asegurarse de que el motor de expresiones regulares interpreta los caracteres individuales como literales en lugar de como metacaracteres.  
  
> [!NOTE]
>  Si un patrón de expresión regular incluye el signo de número (#) o caracteres de espacio en blanco literales, deben convertirse si se analiza el texto de entrada con el <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opción habilitada.  
  
 Mientras el <xref:System.Text.RegularExpressions.Regex.Escape%2A> método antepone la recta abrir corchete ([) y abrir llaves ({}), no escape sus correspondientes caracteres de cierre (] y}). En la mayoría de los casos, estos caracteres de escape no es necesario. Si un corchete o llave no está precedida por el carácter de apertura correspondiente, el motor de expresiones regulares lo interpreta literalmente. Si una llave o soporte de apertura se interpreta como un metacarácter, el motor de expresiones regulares interpreta el carácter como un metacarácter de cierre primera correspondiente. Si esto no es el comportamiento deseado, el corchete o llave debe ser caracteres de escape anteponiendo explícitamente la barra diagonal inversa (\\) caracteres. Para ver una ilustración, vea la sección ejemplo.  
  
   
  
## Examples  
 En el ejemplo siguiente se extrae los comentarios del texto. Se supone que los comentarios se delimitan mediante un símbolo de comentario begin y un símbolo de comentario final seleccionado por el usuario. Dado que los símbolos de comentario son debe interpretarse literalmente, se pasan a la <xref:System.Text.RegularExpressions.Regex.Escape%2A> método para asegurarse de que no se pueden interpretar como metacaracteres. Además, el ejemplo comprueba explícitamente si el símbolo de comentario final especificado por el usuario es un corchete de cierre (]) o una llave (}). Si es así, un carácter de barra diagonal inversa (\\) se antepone al corchete o llave de modo que se interpreta literalmente. Tenga en cuenta que el ejemplo también usa el <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> colección para mostrar solo el comentario, en lugar del comentario junto con sus símbolos de comentario de apertura y cierre.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz de nombres de grupo de captura para la expresión regular.</summary>
        <returns>Matriz de cadenas de nombres de grupo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La colección de nombres de grupo contiene el conjunto de cadenas que se usan en nombres de grupos de captura en la expresión. Aunque los grupos de captura no se mencionen explícitamente, se asignan automáticamente nombres numéricos ("0", "1", "2", "3" y así sucesivamente). "0" denominado grupo representa todo el texto coincidente con el patrón de expresión regular. Los grupos numerados preceden a los grupos con nombre explícitamente en la colección y los grupos con nombre aparecen en el orden en que se definen en el patrón de expresión regular.  
  
 Puede usar el <xref:System.Array.Length%2A> propiedad en la matriz devuelta por este método para determinar el número de grupos en una expresión regular.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un uso general `ShowMatches` método que muestra los nombres de grupos de expresión regular y el texto coincidente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 En este caso, el patrón de expresión regular `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` está diseñada para analizar una frase simple y para identificar su primera palabra, la última palabra y el signo de puntuación de final. En la tabla siguiente se muestra cómo se interpreta el patrón de expresión regular:  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`(?<FirstWord>\w+)`|Buscar coincidencias con uno o más caracteres alfabéticos. Se trata de la `FirstWord` con el nombre de grupo.|  
|¿\s?|Busca una coincidencia con cero o un carácter de espacio en blanco.|  
|(\w+)|Buscar coincidencias con uno o más caracteres alfabéticos. Este es el segundo grupo de captura.|  
|\s|Coincide con un carácter de espacio en blanco.|  
|((\w+)\s)*|Buscar coincidencias con cero o más apariciones de uno o más caracteres de palabra seguidos por un espacio en blanco. Este es el primer grupo de captura.|  
|(? ¿\<LastWord > \w+)?|Coincide con cero o una aparición de uno o más caracteres alfabéticos. Se trata de la `LastWord` con el nombre de grupo.|  
|(? \<Puntuación > \p{Po})|Coincide con un carácter cuya categoría Unicode es el signo de puntuación, otro. Se trata de la `Punctuation` con el nombre de grupo.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz de números de grupo de captura que corresponde a los nombres de grupo en una matriz.</summary>
        <returns>Matriz de enteros de números de grupo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pueden tener acceso a los grupos de captura con nombre y sin nombre por número. Grupos sin nombre se numeran de izquierda a derecha, comenzando por 1. (El grupo de captura en el índice 0 (cero) representa a la coincidencia como un todo.)  Los grupos con nombre, a continuación, se numeran de izquierda a derecha, comenzando por un número que es una unidad mayor que el número de sin nombre de grupos de captura.  
  
 Referencia a un grupo por su número en lugar de por nombre de la cadena puede proporcionar un acceso más rápido.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una expresión regular, `\b((?<word>\w+)\s*)+(?<end>[.?!])`, que coincide con una frase. La expresión regular incluye tres grupos de captura: un grupo sin nombre que captura una sola palabra junto con un carácter de espacio que puede seguir; un grupo denominado `word` que captura las palabras individuales de la oración; y un grupo denominado `end` que captura los signos de puntuación que termina la frase. El ejemplo se llama el <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> método para obtener los números de captura de todos los grupos y, a continuación, muestra su cadena capturada. Además, la <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> método se utiliza para indicar si un determinado grupo numerado corresponde a un grupo con nombre.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 El patrón de la expresión regular se interpreta como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`(?<word>\w+)`|Coincide con uno o más caracteres alfabéticos y asigna las cadenas coincidentes a un grupo denominado `word`.|  
|`\s*`|Busca coincidencias con cero o más caracteres de espacio en blanco.|  
|`((?<word>\w+)\s*)`|Asigne el `word` grupo capturado seguido de cualquier captura caracteres de espacio en blanco para el primer grupo capturado.|  
|`((?<word>\w+)\s*)+`|Coincide con el patrón de uno o más caracteres de palabra seguido de cualquier carácter de espacio en blanco una o varias veces.|  
|`(?<end>[.?!])`|Buscar coincidencias con un punto, un signo de interrogación o un signo de exclamación. Asigne el carácter coincidente para el `end` grupo de captura.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Número de grupo para convertir al nombre de grupo correspondiente.</param>
        <summary>Obtiene el nombre de grupo que corresponde al número de grupo especificado.</summary>
        <returns>Cadena que contiene el nombre de grupo asociado al número de grupo especificado. Si no hay un nombre de grupo que se corresponda con <paramref name="i" />, el método devuelve <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un patrón de expresión regular puede contener grupos de captura con nombre o numerados, que definen subexpresiones de una coincidencia de patrones. Los grupos numerados están delimitados por la sintaxis (*subexpresión*) y se asignan números según su orden en la expresión regular. Los grupos con nombre están delimitados por la sintaxis (?`<` *name*`>`*subexpression*) or (?' *nombre*'*subexpresión*), donde *nombre* es el nombre por el que se identificará la subexpresión. Para más información, consulte la sección sobre [Construcciones de agrupamiento en expresiones regulares](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md). El <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> método identifica los grupos con nombre y los grupos numerados mediante sus posiciones ordinales en la expresión regular. Posición ordinal cero siempre representa la expresión regular completa. Numerados todos los grupos, a continuación, se cuentan antes que los grupos con nombre, independientemente de su posición real en el patrón de expresión regular.  
  
 Si `i` es el número de un grupo con nombre, el método devuelve el nombre del grupo. Si `i` es el número de un grupo sin nombre, el método devuelve la representación de cadena del número. Por ejemplo, si `i` es 1, el método devuelve "1". Si `i` no es el número de un grupo de captura, el método devuelve <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Si se encuentra una coincidencia de patrones, el valor devuelto por este método, a continuación, puede utilizarse para recuperar el <xref:System.Text.RegularExpressions.Group> objeto que representa el grupo capturado desde la <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> propiedad. El <xref:System.Text.RegularExpressions.GroupCollection> objeto devuelto por la <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> propiedad.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un patrón de expresión regular que coincida con una línea de dirección que contiene un nombre de la ciudad de Estados Unidos, el nombre del estado y el código postal. El ejemplo se utiliza la <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> método para recuperar los nombres de grupos de captura. A continuación, utiliza estos nombres para recuperar los grupos capturados correspondientes para buscar coincidencias.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 El patrón de expresión regular se define mediante la siguiente expresión:  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|Coincide con uno o más caracteres alfabéticos o de espacio en blanco. Asignar el nombre de este grupo capturado `city`.|  
|`,`|Coincide con una coma (,) seguida por un carácter de espacio en blanco.|  
|`(?<state>[A-Za-z]{2})`|Coincide con dos caracteres alfabéticos. Asignar el nombre de este grupo capturado `state`. Este grupo debe ir seguido de un carácter de espacio en blanco.|  
|`(?<zip>\d{5}(-\d{4})?)`|Coincide con cinco dígitos numéricos seguidos de cero o una aparición de un guión seguido de cuatro dígitos. Asignar el nombre de este grupo capturado `zip`.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de grupo para convertir al número de grupo correspondiente.</param>
        <summary>Devuelve el número de grupo que corresponde al nombre de grupo especificado.</summary>
        <returns>Número del grupo que corresponde al nombre de grupo especificado o -1 si <paramref name="name" /> no es un nombre de grupo válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un patrón de expresión regular puede contener grupos de captura con nombre o numerados, que definen subexpresiones de una coincidencia de patrones. Los grupos numerados están delimitados por la sintaxis (*subexpresión*) y se asignan números según su orden en la expresión regular. Los grupos con nombre están delimitados por la sintaxis (?`<` *name*`>`*subexpression*) or (?' *nombre*'*subexpresión*), donde *nombre* es el nombre por el que se identificará la subexpresión. Para más información, consulte la sección sobre [Construcciones de agrupamiento en expresiones regulares](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md). El <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> método identifica los grupos con nombre y los grupos numerados mediante sus posiciones ordinales en la expresión regular. Posición ordinal cero siempre representa la expresión regular completa. Numerados todos los grupos, a continuación, se cuentan antes que los grupos con nombre, independientemente de su posición real en el patrón de expresión regular.  
  
 Si `name` es la representación de cadena de un número de grupo que está presente en el patrón de expresión regular, el método devuelve dicha cantidad. Si `name` corresponde a un conjunto con nombre captura el grupo que se encuentra en el patrón de expresión regular, el método devuelve el número correspondiente. La comparación de `name` con el grupo nombre distingue mayúsculas de minúsculas. Si `name` no corresponderse con el nombre de un grupo de captura o con la representación de cadena del número de un grupo de captura, el método devuelve -1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que una operación de coincidencia de patrones no debe superar el tiempo de espera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> clase constructor y un número de uso de métodos de coincidencia estática la <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> constante para indicar que el intento de encontrar una coincidencia de patrones debe tiempo de espera.  
  
> [!WARNING]
>  Establecer el valor de tiempo de espera del motor de expresiones regulares en <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> puede hacer que las expresiones regulares que se basan en un retroceso excesivo para que aparezca deje de responder al procesar el texto que casi coincide con el patrón de expresión regular. Si deshabilita los tiempos de espera, debe asegurarse de que la expresión regular no se basa en un retroceso excesivo y que controla el texto que casi coincide con el patrón de expresión regular.  
>   
>  Para obtener más información sobre el control de retroceso, consulte [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 El <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> constante se puede proporcionar como el valor de la `matchTimeout` argumento de los miembros siguientes:  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ya se han inicializado las referencias.</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tiempo máximo que puede transcurrir en una operación de coincidencia de patrones antes de que se agote el tiempo de espera de la operación.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si la expresión regular encuentra una coincidencia en la cadena de entrada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <summary>Indica si la expresión regular especificada en el constructor <see cref="T:System.Text.RegularExpressions.Regex" /> encuentra una coincidencia en una cadena de entrada indicada.</summary>
        <returns>
          <see langword="true" /> si la expresión regular encuentra una coincidencia; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método suele usarse para validar una cadena o para asegurarse de que una cadena se ajusta a un patrón determinado sin tener que recuperar esa cadena para una manipulación subsiguientes. Si desea determinar si una o varias cadenas coinciden con un patrón de expresión regular y, a continuación, recuperan para su manipulación subsiguientes, llamada la <xref:System.Text.RegularExpressions.Regex.Match%2A> o <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no se ha definido ningún tiempo de espera en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> método para determinar si una cadena es un número de pieza válido. La expresión regular se da por supuesto que el número de pieza tiene un formato específico que consta de tres conjuntos de caracteres separados por guiones. El primer conjunto, que contiene cuatro caracteres, debe constar de un carácter alfanumérico seguido de dos caracteres numéricos seguidos por un carácter alfanumérico. El segundo conjunto, que consta de tres caracteres, debe ser numérico. El tercer conjunto, que consta de cuatro caracteres, debe tener tres caracteres numéricos seguidos por un carácter alfanumérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 El patrón de la expresión regular es:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`^`|Comienza la búsqueda de coincidencias al principio de la línea.|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o carácter numérico.|  
|`\d{2}`|Buscar coincidencias con dos caracteres numéricos.|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o carácter numérico.|  
|`-`|Buscar coincidencias con un guion.|  
|`\d{3}`|Buscar coincidencias con exactamente tres caracteres numéricos.|  
|`(-\d{3}){2}`|Buscar un guión seguido de tres caracteres numéricos y coincide con dos apariciones de este patrón.|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o carácter numérico.|  
|`$`|Finalizar la búsqueda de coincidencias al final de la línea.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="startat">Posición de carácter en la que se va a iniciar la búsqueda.</param>
        <summary>Indica si la expresión regular especificada en el constructor <see cref="T:System.Text.RegularExpressions.Regex" /> encuentra una coincidencia en la cadena de entrada especificada, empezando en la posición inicial indicada en la cadena.</summary>
        <returns>
          <see langword="true" /> si la expresión regular encuentra una coincidencia; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método suele usarse para validar una cadena o para asegurarse de que una cadena se ajusta a un patrón determinado sin tener que recuperar esa cadena para una manipulación subsiguientes. Si desea determinar si una o varias cadenas coinciden con un patrón de expresión regular y, a continuación, recuperan para su manipulación subsiguientes, llamada la <xref:System.Text.RegularExpressions.Regex.Match%2A> o <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no se ha definido ningún tiempo de espera en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> método para determinar si una cadena es un número de pieza válido. Busca un número de pieza que sigue a un carácter de dos puntos (:) en una cadena. El <xref:System.String.IndexOf%28System.Char%29> método se usa para determinar la posición del carácter de dos puntos, que se pasa a continuación el <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> método. La expresión regular se da por supuesto que el número de pieza tiene un formato específico que consta de tres conjuntos de caracteres separados por guiones. El primer conjunto, que contiene cuatro caracteres, debe constar de un carácter alfanumérico seguido de dos caracteres numéricos seguidos por un carácter alfanumérico. El segundo conjunto, que consta de tres caracteres, debe ser numérico. El tercer conjunto, que consta de cuatro caracteres, debe tener tres caracteres numéricos seguidos por un carácter alfanumérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 El patrón de la expresión regular es:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o carácter numérico.|  
|`\d{2}`|Buscar coincidencias con dos caracteres numéricos.|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o carácter numérico.|  
|`-`|Buscar coincidencias con un guion.|  
|`\d{3}`|Buscar coincidencias con exactamente tres caracteres numéricos.|  
|`(-\d{3}){2}`|Buscar un guión seguido de tres caracteres numéricos y coincide con dos apariciones de este patrón.|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o carácter numérico.|  
|`$`|Finalizar la búsqueda de coincidencias al final de la línea.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> es menor que cero o mayor que la longitud de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <summary>Indica si la expresión regular especificada busca una coincidencia en la cadena de entrada indicada.</summary>
        <returns>
          <see langword="true" /> si la expresión regular encuentra una coincidencia; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método suele usarse para validar una cadena o para asegurarse de que una cadena se ajusta a un patrón determinado sin tener que recuperar esa cadena para una manipulación subsiguientes. Si desea determinar si una o varias cadenas coinciden con un patrón de expresión regular y, a continuación, recuperan para su manipulación subsiguientes, llamada la <xref:System.Text.RegularExpressions.Regex.Match%2A> o <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 El método estático <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método es equivalente a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el patrón de expresión regular especificado por `pattern` y llamar a la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> método de instancia. Este patrón de expresión regular se almacena en caché para la recuperación rápida por el motor de expresiones regulares.  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método para determinar si una cadena es un número de pieza válido. La expresión regular se da por supuesto que el número de pieza tiene un formato específico que consta de tres conjuntos de caracteres separados por guiones. El primer conjunto, que contiene cuatro caracteres, debe constar de un carácter alfanumérico seguido de dos caracteres numéricos seguidos por un carácter alfanumérico. El segundo conjunto, que consta de tres caracteres, debe ser numérico. El tercer conjunto, que consta de cuatro caracteres, debe tener tres caracteres numéricos seguidos por un carácter alfanumérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 El patrón de la expresión regular es:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`^`|Comienza la búsqueda de coincidencias al principio de la línea.|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o carácter numérico.|  
|`\d{2}`|Buscar coincidencias con dos caracteres numéricos.|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o carácter numérico.|  
|`-`|Buscar coincidencias con un guion.|  
|`\d{3}`|Buscar coincidencias con exactamente tres caracteres numéricos.|  
|`(-\d{3}){2}`|Buscar un guión seguido de tres caracteres numéricos y coincide con dos apariciones de este patrón.|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o carácter numérico.|  
|`$`|Finalizar la búsqueda de coincidencias al final de la línea.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama al método. Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para comprobar una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <summary>Indica si la expresión regular especificada encuentra una coincidencia en la cadena de entrada indicada, utilizando para ello las opciones de coincidencia especificadas.</summary>
        <returns>
          <see langword="true" /> si la expresión regular encuentra una coincidencia; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método suele usarse para validar una cadena o para asegurarse de que una cadena se ajusta a un patrón determinado sin tener que recuperar esa cadena para una manipulación subsiguientes. Si desea determinar si una o varias cadenas coinciden con un patrón de expresión regular y, a continuación, recuperan para su manipulación subsiguientes, llamada la <xref:System.Text.RegularExpressions.Regex.Match%2A> o <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 El método estático <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método es equivalente a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el patrón de expresión regular especificado por `pattern` y las opciones de expresión regular especificadas por `options` y llamar a la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> método de instancia. Este patrón de expresión regular se almacena en caché para la recuperación rápida por el motor de expresiones regulares.  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método para determinar si una cadena es un número de pieza válido. La expresión regular se da por supuesto que el número de pieza tiene un formato específico que consta de tres conjuntos de caracteres separados por guiones. El primer conjunto, que contiene cuatro caracteres, debe constar de un carácter alfanumérico seguido de dos caracteres numéricos seguidos por un carácter alfanumérico. El segundo conjunto, que consta de tres caracteres, debe ser numérico. El tercer conjunto, que consta de cuatro caracteres, debe tener tres caracteres numéricos seguidos por un carácter alfanumérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 El patrón de la expresión regular es:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`^`|Empieza la búsqueda de coincidencias en el principio de la cadena.|  
|`[A-Z0-9]`|Coincide con cualquier carácter alfabético único de `A` a través de `Z`, o cualquier carácter numérico.|  
|`\d{2}`|Buscar coincidencias con dos caracteres numéricos.|  
|`[A-Z0-9]`|Coincide con cualquier carácter alfabético único de `A` a través de `Z`, o cualquier carácter numérico.|  
|`-`|Buscar coincidencias con un guion.|  
|`\d{3}`|Buscar coincidencias con exactamente tres caracteres numéricos.|  
|`(-\d{3}){2}`|Buscar un guión seguido de tres caracteres numéricos y coincide con dos apariciones de este patrón...|  
|`[A-Z0-9]`|Coincide con cualquier carácter alfabético único de `A` a través de `Z`, o cualquier carácter numérico.|  
|`$`|Finalizar la búsqueda al final de la cadena.|  
  
 Llamar a la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método con el `options` parámetro establecido en <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> es equivalente a la definición de la siguiente expresión regular:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Para la comparación, vea el ejemplo de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es un valor <see cref="T:System.Text.RegularExpressions.RegexOptions" /> válido.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama. Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para comprobar una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <param name="matchTimeout">Un intervalo de tiempo de espera, o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que el método no debe agotar el tiempo de espera.</param>
        <summary>Indica si la expresión regular especificada encuentra una coincidencia en la cadena de entrada indicada, utilizando para ello las opciones de coincidencia y el intervalo de tiempo de espera que se especifiquen.</summary>
        <returns>
          <see langword="true" /> si la expresión regular encuentra una coincidencia; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método suele usarse para validar una cadena o para asegurarse de que una cadena se ajusta a un patrón determinado sin tener que recuperar esa cadena para una manipulación subsiguientes. Si desea determinar si una o varias cadenas coinciden con un patrón de expresión regular y, a continuación, recuperan para su manipulación subsiguientes, llamada la <xref:System.Text.RegularExpressions.Regex.Match%2A> o <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 El método estático <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método es equivalente a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el patrón de expresión regular especificado por `pattern` y las opciones de expresión regular especificadas por `options` y llamar a la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> método de instancia. Este patrón de expresión regular se almacena en caché para la recuperación rápida por el motor de expresiones regulares.  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El `matchTimeout` parámetro especifica cómo tiempo una coincidencia de patrones método debe intentar encontrar una coincidencia antes de expirar. Establecer un intervalo de tiempo de espera impide que las expresiones regulares que se basan en un retroceso excesivo aparezcan deje de responder cuando procesan datos de entrada que contenga cerca de coincidencias. Para obtener más información, consulte [prácticas recomendadas para las expresiones regulares](~/docs/standard/base-types/best-practices.md) y [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Si se encuentra ninguna coincidencia en ese intervalo de tiempo, el método produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. `matchTimeout` invalida cualquier valor de tiempo de espera predeterminado definido para el dominio de aplicación en el que se ejecuta el método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método para determinar si una cadena es un número de pieza válido. La expresión regular se da por supuesto que el número de pieza tiene un formato específico que consta de tres conjuntos de caracteres separados por guiones. El primer conjunto, que contiene cuatro caracteres, debe constar de un carácter alfanumérico seguido de dos caracteres numéricos seguidos por un carácter alfanumérico. El segundo conjunto, que consta de tres caracteres, debe ser numérico. El tercer conjunto, que consta de cuatro caracteres, debe tener tres caracteres numéricos seguidos por un carácter alfanumérico. Que coincidan con el patrón de expresión regular debe implicar buscar mínima a través de la cadena de entrada, por lo que el método establece un intervalo de tiempo de espera de 500 milisegundos.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 El patrón de la expresión regular es:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`^`|Empieza la búsqueda de coincidencias en el principio de la cadena.|  
|`[A-Z0-9]`|Coincide con cualquier carácter alfabético único de `A` a través de `Z`, o cualquier carácter numérico.|  
|`\d{2}`|Buscar coincidencias con dos caracteres numéricos.|  
|`[A-Z0-9]`|Coincide con cualquier carácter alfabético único de `A` a través de `Z`, o cualquier carácter numérico.|  
|`-`|Buscar coincidencias con un guion.|  
|`\d{3}`|Buscar coincidencias con exactamente tres caracteres numéricos.|  
|`(-\d{3}){2}`|Buscar un guión seguido de tres caracteres numéricos y coincide con dos apariciones de este patrón.|  
|`[A-Z0-9]`|Coincide con cualquier carácter alfabético único de `A` a través de `Z`, o cualquier carácter numérico.|  
|`$`|Finalizar la búsqueda al final de la cadena.|  
  
 Llamar a la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método con el `options` parámetro establecido en <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> es equivalente a la definición de la siguiente expresión regular:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Para la comparación, vea el ejemplo de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es un valor <see cref="T:System.Text.RegularExpressions.RegexOptions" /> válido.  
  
 O bien  
  
 <paramref name="matchTimeout" /> es negativo, cero o mayor que 24 días aproximadamente.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera.</exception>
        <block subset="none" type="usage">
          <para>Se recomienda que establezca el <paramref name="matchTimeout" /> parámetro en un valor apropiado, como dos segundos. Si deshabilita los tiempos de espera mediante la especificación de <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor. Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones:  
  
-   Cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o está formada por texto estático. Excluye el texto que se ha dinámicamente introducidos por los usuarios.  
  
-   Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controle eficazmente coincide con, ausencia de coincidencias y casi coincide con.  
  
-   Cuando el patrón de expresión regular no contiene ningún elemento de lenguaje que se sabe que causan un retroceso excesivo al procesar a una coincidencia casi.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca en una cadena de entrada una subcadena que coincida con un modelo de expresión regular y devuelve la primera aparición como un único objeto <see cref="T:System.Text.RegularExpressions.Match" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <summary>Busca en la cadena de entrada especificada la primera aparición de la expresión regular especificada en el constructor <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Objeto que contiene información sobre la coincidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método devuelve la primera subcadena que coincide con un patrón de expresión regular en una cadena de entrada. Para obtener información acerca de los elementos de lenguaje que se utilizan para crear un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada comprobando el valor de devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propiedad. Si se encuentra una coincidencia, el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propiedad contiene la subcadena desde `input` que coincide con el patrón de expresión regular. Si se encuentra ninguna coincidencia, su valor es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Este método devuelve la primera subcadena en `input` que coincide con el patrón de expresión regular. Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método. También puede recuperar todas las coincidencias en una única llamada al método mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> método.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no se ha definido ningún tiempo de espera en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se busca el patrón de expresión regular coincide con una cadena, muestra el conjunto de grupos, las capturas y las posiciones de captura.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 El patrón de expresión regular `(\w+)\s+(car)` devuelve repeticiones de la palabra "car" junto con la palabra que precede en el código. Se interpreta como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`(\w+)`|Buscar coincidencias con uno o más caracteres alfabéticos. Este es el primer grupo de captura.|  
|`\s+`|Coincide con uno o más caracteres de espacio en blanco.|  
|(car)|Coincide con la cadena literal "car". Este es el segundo grupo de captura.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="startat">Posición de carácter basada en cero en la que se va a iniciar la búsqueda.</param>
        <summary>Busca en la cadena de entrada la primera aparición de una expresión regular, empezando en la posición inicial especificada de la cadena.</summary>
        <returns>Objeto que contiene información sobre la coincidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> método devuelve la primera subcadena que coincide con un patrón de expresión regular, empezando en o después de la `startat` posición de carácter, de una cadena de entrada. Para obtener información acerca de los elementos de lenguaje que se utilizan para crear un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El patrón de expresión regular para que la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> búsquedas de método se define mediante la llamada a uno de los <xref:System.Text.RegularExpressions.Regex> constructores de clase. Para obtener más información acerca de los elementos que pueden formar un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Opcionalmente, puede especificar una posición inicial de la cadena mediante el `startat` parámetro. Cuando el motor de expresiones regulares analiza de izquierda a derecha (el valor predeterminado), la coincidencia y la exploración se mueven hacia la derecha, empezando por el carácter especificado en `startat`. Cuando el motor de expresiones regulares analiza de derecha a izquierda (cuando se construye el patrón de expresión regular con la <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opción), la coincidencia y la exploración mover en la dirección opuesta y comienzan con el carácter que ocupa `startat` -1. Si no especifica una posición inicial, la búsqueda comienza en el valor predeterminado `startat` posición. Si la expresión regular busca de izquierda a derecha, el valor predeterminado `startat` posición está en el extremo izquierdo de `input`; si busca de derecha a izquierda, el valor predeterminado `startat` posición está en el extremo derecho de `input`.  
  
 Si desea restringir una coincidencia para que comienza en una posición de caracteres determinada en la cadena y el motor de expresiones regulares no examina el resto de la cadena de una coincidencia, delimite la expresión regular con una `\G` (a la izquierda para un modelo de izquierda a derecha o a la derecha de un patrón de derecha a izquierda). Esto restringe la búsqueda de coincidencias, por lo que debe comenzar exactamente en `startat`.  
  
 Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada comprobando el valor de devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propiedad. Si se encuentra una coincidencia, el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propiedad contiene la subcadena desde `input` que coincide con el patrón de expresión regular. Si se encuentra ninguna coincidencia, su valor es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Este método devuelve la primera subcadena encontrada en o después de la `startat` posición de carácter de `input` que coincide con el patrón de expresión regular. Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método. También puede recuperar todas las coincidencias en una única llamada al método mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> método.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación sobrepasa cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no se ha definido ningún tiempo de espera en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> es menor que cero o mayor que la longitud de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <summary>Busca en la cadena de entrada especificada la primera aparición de la expresión regular indicada.</summary>
        <returns>Objeto que contiene información sobre la coincidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> método devuelve la primera subcadena que coincide con un patrón de expresión regular en una cadena de entrada. Para obtener información acerca de los elementos de lenguaje que se utilizan para crear un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El método estático <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> método es equivalente a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el patrón de expresión regular especificado y llamar a la instancia <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método. En este caso, el motor de expresiones regulares almacena en caché el patrón de expresión regular.  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada comprobando el valor de devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propiedad. Si se encuentra una coincidencia, el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propiedad contiene la subcadena desde `input` que coincide con el patrón de expresión regular. Si se encuentra ninguna coincidencia, su valor es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Este método devuelve la primera subcadena en `input` que coincide con el patrón de expresión regular. Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método. También puede recuperar todas las coincidencias en una única llamada al método mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> método.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> método para buscar la primera palabra que contiene al menos una `z` caracteres y, a continuación, llama el <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método al que se encuentra ninguna coincidencia adicional.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 El patrón de la expresión regular `\b\w*z+\w*\b` se interpreta como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`\w*`|Coincide con cero, uno o más caracteres alfabéticos.|  
|`z+`|Busca coincidencias con uno o varios de los `z` caracteres.|  
|`\w*`|Coincide con cero, uno o más caracteres alfabéticos.|  
|`\b`|Finalizar la búsqueda de coincidencias en un límite de palabras.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama. Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para recuperar una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="beginning">Posición de caracteres de base cero en la cadena de entrada que define la posición más a la izquierda en la que se buscará.</param>
        <param name="length">Número de caracteres de la subcadena que se van a incluir en la búsqueda.</param>
        <summary>Busca en la cadena de entrada la primera aparición de una expresión regular, empezando en la posición inicial especificada y buscando solo en el número de caracteres indicado.</summary>
        <returns>Objeto que contiene información sobre la coincidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> método devuelve la primera subcadena que coincide con un patrón de expresión regular en una parte de una cadena de entrada. Para obtener información acerca de los elementos de lenguaje que se utilizan para crear un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El patrón de expresión regular para que la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> búsquedas de método se define mediante la llamada a uno de los <xref:System.Text.RegularExpressions.Regex> constructores de clase. Para obtener más información acerca de los elementos que pueden formar un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> método busca en la parte de `input` definido por el `beginning` y `length` parámetros para el patrón de expresión regular. `beginning` siempre se define el índice del carácter más a la izquierda para incluir en la búsqueda, y `length` define el número máximo de caracteres que se va a buscar. Juntos, definen el intervalo de la búsqueda. Si la búsqueda se realiza de izquierda a derecha (el valor predeterminado), el motor de expresiones regulares buscará desde el carácter que ocupa el índice `beginning` hasta el carácter en el índice `beginning`  +  `length` – 1. Si se crea una instancia del motor de expresiones regulares mediante el uso de la <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opción para que la búsqueda continúa de derecha a izquierda, las búsquedas de motor de expresiones regulares en el carácter que ocupa el índice `beginning`  +  `length` – 1 para el carácter que ocupa el índice `beginning`. Este método devuelve a la primera coincidencia que encuentra dentro de este intervalo. Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método.  
  
 Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada comprobando el valor de devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propiedad. Si se encuentra una coincidencia, el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propiedad contiene la subcadena desde `input` que coincide con el patrón de expresión regular. Si se encuentra ninguna coincidencia, su valor es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un valor de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no se ha definido ningún tiempo de espera en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="beginning" /> es menor que cero o mayor que la longitud de <paramref name="input" />.  
  
 O bien  
  
 <paramref name="length" /> es menor que cero o mayor que la longitud de <paramref name="input" />.  
  
 O bien  
  
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="–1" /> identifica una posición que está fuera del intervalo de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <summary>Busca en la cadena de entrada la primera aparición de la expresión regular especificada, utilizando para ello las opciones de coincidencia indicadas.</summary>
        <returns>Objeto que contiene información sobre la coincidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método devuelve la primera subcadena que coincide con un patrón de expresión regular en una cadena de entrada. Para obtener información acerca de los elementos de lenguaje que se utilizan para crear un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El método estático <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método es equivalente a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> constructor y llamar a la instancia <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> (método).  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada comprobando el valor de devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propiedad. Si se encuentra una coincidencia, el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propiedad contiene la subcadena desde `input` que coincide con el patrón de expresión regular. Si se encuentra ninguna coincidencia, su valor es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Este método devuelve la primera subcadena encontrada en `input` que coincide con el patrón de expresión regular. Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A> método. También puede recuperar todas las coincidencias en una única llamada al método mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una expresión regular que coincide con palabras que empiezan con la letra "a". Usa el <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> opción para asegurarse de que la expresión regular busca palabras que empiezan con ambas en mayúscula en minúscula "a" y "a".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 El patrón de la expresión regular `\ba\w*\b` se interpreta como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`a`|Coincide con el carácter "a".|  
|`\w*`|Coincide con cero, uno o más caracteres alfabéticos.|  
|`\b`|Finalizar la búsqueda de coincidencias en un límite de palabras.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama. Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para recuperar una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <param name="matchTimeout">Un intervalo de tiempo de espera, o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que el método no debe agotar el tiempo de espera.</param>
        <summary>Busca en la cadena de entrada la primera aparición de la expresión regular especificada, utilizando para ello las opciones de coincidencia y el intervalo de tiempo de espera que se indiquen.</summary>
        <returns>Objeto que contiene información sobre la coincidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método devuelve la primera subcadena que coincide con un patrón de expresión regular en una cadena de entrada. Para obtener información acerca de los elementos de lenguaje que se utilizan para crear un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El método estático <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método es equivalente a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor y llamar a la instancia <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> (método).  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada comprobando el valor de devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propiedad. Si se encuentra una coincidencia, el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propiedad contiene la subcadena desde `input` que coincide con el patrón de expresión regular. Si se encuentra ninguna coincidencia, su valor es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Este método devuelve la primera subcadena encontrada en `input` que coincide con el patrón de expresión regular. Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A> método. También puede recuperar todas las coincidencias en una única llamada al método mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método.  
  
 El `matchTimeout` parámetro especifica cómo tiempo una coincidencia de patrones método debe intentar encontrar una coincidencia antes de expirar. Establecer un intervalo de tiempo de espera impide que las expresiones regulares que se basan en un retroceso excesivo aparezcan deje de responder cuando procesan datos de entrada que contenga cerca de coincidencias. Para obtener más información, consulte [prácticas recomendadas para las expresiones regulares](~/docs/standard/base-types/best-practices.md) y [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Si se encuentra ninguna coincidencia en ese intervalo de tiempo, el método produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. `matchTimeout` invalida cualquier valor de tiempo de espera predeterminado definido para el dominio de aplicación en el que se ejecuta el método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
 O bien  
  
 <paramref name="matchTimeout" /> es negativo, cero o mayor que 24 días aproximadamente.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó un tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Se recomienda que establezca el <paramref name="matchTimeout" /> parámetro en un valor apropiado, como dos segundos. Si deshabilita los tiempos de espera mediante la especificación de <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor. Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones:  
  
-   Cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o está formada por texto estático. Excluye el texto que se ha dinámicamente introducidos por los usuarios.  
  
-   Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controle eficazmente coincide con, ausencia de coincidencias y casi coincide con.  
  
-   Cuando el patrón de expresión regular no contiene ningún elemento de lenguaje que se sabe que causan un retroceso excesivo al procesar a una coincidencia casi.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca en una cadena de entrada todas las apariciones de una expresión regular y devuelve todas las coincidencias.</summary>
        <block subset="none" type="usage">
          <para>Cuando se repite un intento de coincidencia mediante una llamada a la <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> método, el motor de expresiones regulares otorga coincidencias vacías un tratamiento especial. Normalmente, el motor de expresiones regulares comienza la búsqueda de la siguiente coincidencia la coincidencia anterior exactamente. Sin embargo, tras una coincidencia vacía, el motor de expresiones regulares avanza un carácter antes de intentar a buscar la siguiente coincidencia. Este comportamiento garantiza que el motor de expresiones regulares se avanza a través de la cadena. En caso contrario, porque no se produce una coincidencia vacía en cualquier movimiento hacia adelante, comience la siguiente coincidencia de exactamente el mismo lugar que la coincidencia anterior y coincidiría con varias veces la misma cadena vacía.  
  
 En el ejemplo siguiente, el patrón de expresión regular <c>un *</c> Busca cero o más apariciones de la letra "a" en la cadena "abaabb". Como la salida se muestra en el ejemplo, resultantes <see cref="T:System.Text.RegularExpressions.MatchCollection" /> objeto contiene seis <see cref="T:System.Text.RegularExpressions.Match" /> objetos. El primer intento de coincidencia busca la primera "a". La segunda búsqueda se inicia exactamente donde el primero coincide con extremos, antes de la primera b; Busca cero apariciones de "a" y devuelve una cadena vacía. La tercera búsqueda no comienza exactamente donde terminó la segunda coincidencia, porque la segunda coincidencia devolvió una cadena vacía. En su lugar, inicia un carácter más adelante, después de la primera "b". La tercera búsqueda encuentra dos apariciones de "a" y devuelve "aa". El cuarto intento de coincidencia comienza donde finalizó la coincidencia terceros, antes de la segunda "b" y devuelve una cadena vacía. El intento de coincidencia quinto nuevo avanza un carácter para que se inicia antes de que el tercer "b" y devuelve una cadena vacía. La búsqueda de coincidencias sexto comienza después de la última "b" y devuelve una cadena vacía de nuevo.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <summary>Busca en la cadena de entrada especificada todas las apariciones de una expresión regular.</summary>
        <returns>Colección de los objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados en la búsqueda. Si no se encuentran coincidencias, el método devuelve un objeto de colección vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> método es similar a la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método, salvo que devuelva información sobre todas las coincidencias que se encuentra en la cadena de entrada, en lugar de una coincidencia única. Es equivalente al código siguiente:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 La colección incluye a solamente las correspondencias y termina en la primera no coincidencia.  
  
 El patrón de expresión regular para que la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> búsquedas de método se define mediante la llamada a uno de los <xref:System.Text.RegularExpressions.Regex> constructores de clase. Para obtener más información acerca de los elementos que pueden formar un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El <xref:System.Text.RegularExpressions.Regex.Matches%2A> método utiliza la evaluación diferida para rellenar el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acceso a miembros de esta colección como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> y <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> hace que la colección que se debe rellenar de forma inmediata. Para sacar partido de la evaluación diferida, se debe iterar por la colección mediante una construcción como `foreach` en C# y `For Each`...`Next` en Visual Basic.  
  
 Debido a su evaluación diferida, al llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> método no produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. Sin embargo, la excepción se produce cuando se realiza una operación en el <xref:System.Text.RegularExpressions.MatchCollection> objeto devuelto por este método, si la <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> propiedad no es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> y una operación de búsqueda de coincidencias supere el intervalo de tiempo de espera.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> método para identificar todas las palabras de una frase que terminan en "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 El patrón de expresión regular `\b\w+es\b` se define como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`\w+`|Buscar coincidencias con uno o más caracteres alfabéticos.|  
|`es`|Coincide con la cadena literal "es".|  
|`\b`|Finalizar la búsqueda de coincidencias en un límite de palabras.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="startat">Posición de carácter de la cadena de entrada en la que se va a iniciar la búsqueda.</param>
        <summary>Busca en la cadena de entrada especificada todas las apariciones de una expresión regular, empezando en la posición de inicio especificada de la cadena.</summary>
        <returns>Colección de los objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados en la búsqueda. Si no se encuentran coincidencias, el método devuelve un objeto de colección vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> método es similar a la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> método, salvo que devuelva información sobre todas las coincidencias que se encuentra en la cadena de entrada, en lugar de una coincidencia única. Es equivalente al código siguiente:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 El patrón de expresión regular para que la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> búsquedas de método se define mediante la llamada a uno de los <xref:System.Text.RegularExpressions.Regex> constructores de clase. Para obtener más información acerca de los elementos que pueden formar un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El <xref:System.Text.RegularExpressions.Regex.Matches%2A> método utiliza la evaluación diferida para rellenar el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acceso a miembros de esta colección como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> y <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> hace que la colección que se debe rellenar de forma inmediata. Para sacar partido de la evaluación diferida, se debe iterar por la colección mediante una construcción como `foreach` en C# y `For Each`...`Next` en Visual Basic.  
  
 Debido a su evaluación diferida, al llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> método no produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. Sin embargo, la excepción se produce cuando se realiza una operación en el <xref:System.Text.RegularExpressions.MatchCollection> objeto devuelto por este método, si la <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> propiedad no es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> y una operación de búsqueda de coincidencias supere el intervalo de tiempo de espera...  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método para buscar la primera palabra de una frase que termina en "es" y, a continuación, llama el <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> método para identificar cualquier palabra adicional que terminan en "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 El patrón de expresión regular `\b\w+es\b` se define como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`\w+`|Buscar coincidencias con uno o más caracteres alfabéticos.|  
|`es`|Coincide con la cadena literal "es".|  
|`\b`|Finalizar la búsqueda de coincidencias en un límite de palabras.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> es menor que cero o mayor que la longitud de <paramref name="input" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <summary>Busca en la cadena de entrada especificada todas las apariciones de una expresión regular indicada.</summary>
        <returns>Colección de los objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados en la búsqueda. Si no se encuentran coincidencias, el método devuelve un objeto de colección vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método es similar a la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> método, salvo que devuelva información sobre todas las coincidencias que se encuentra en la cadena de entrada, en lugar de una coincidencia única. Es equivalente al código siguiente:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 El método estático `Matches` métodos son equivalentes a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el patrón de expresión regular especificado y llamando al método de instancia `Matches`.  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El <xref:System.Text.RegularExpressions.Regex.Matches%2A> método utiliza la evaluación diferida para rellenar el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acceso a miembros de esta colección como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> y <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> hace que la colección que se debe rellenar de forma inmediata. Para sacar partido de la evaluación diferida, se debe iterar por la colección mediante una construcción como `foreach` en C# y `For Each`...`Next` en Visual Basic.  
  
 Debido a su evaluación diferida, al llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método no produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. Sin embargo, la excepción se produce cuando se realiza una operación en el <xref:System.Text.RegularExpressions.MatchCollection> objeto devuelto por este método, si un intervalo de tiempo de espera se define mediante la propiedad "REGEX_DEFAULT_MATCH_TIMEOUT" del dominio de aplicación actual y una operación de búsqueda de coincidencias supera este intervalo de tiempo de espera.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método para identificar cualquier palabra en una frase que termina en "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 El patrón de expresión regular `\b\w+es\b` se define como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`\w+`|Buscar coincidencias con uno o más caracteres alfabéticos.|  
|`es`|Coincide con la cadena literal "es".|  
|`\b`|Finalizar la búsqueda de coincidencias en un límite de palabras.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama. Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para recuperar varios patrón coincide con es <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que le permite especificar el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que especifican opciones de coincidencia.</param>
        <summary>Busca en la cadena de entrada especificada todas las apariciones de una expresión regular indicada, utilizando para ello las opciones de coincidencia especificadas.</summary>
        <returns>Colección de los objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados en la búsqueda. Si no se encuentran coincidencias, el método devuelve un objeto de colección vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método es similar a la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método, salvo que devuelva información sobre todas las coincidencias que se encuentra en la cadena de entrada, en lugar de una coincidencia única. Es equivalente al código siguiente:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 El método estático `Matches` métodos son equivalentes a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el patrón de expresión regular especificado y llamando al método de instancia `Matches`.  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El <xref:System.Text.RegularExpressions.Regex.Matches%2A> método utiliza la evaluación diferida para rellenar el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acceso a miembros de esta colección como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> y <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> hace que la colección que se debe rellenar de forma inmediata. Para sacar partido de la evaluación diferida, se debe iterar por la colección mediante una construcción como `foreach` en C# y `For Each`...`Next` en Visual Basic.  
  
 Debido a su evaluación diferida, al llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método no produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. Sin embargo, la excepción se produce cuando se realiza una operación en el <xref:System.Text.RegularExpressions.MatchCollection> objeto devuelto por este método, si un intervalo de tiempo de espera se define mediante la propiedad "REGEX_DEFAULT_MATCH_TIMEOUT" del dominio de aplicación actual y una operación de búsqueda de coincidencias supera este intervalo de tiempo de espera.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método para identificar cualquier palabra en una frase que termina en "es" y, a continuación, llama a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método para realizar una comparación entre mayúsculas y minúsculas del patrón con la cadena de entrada. Como muestra el resultado, los dos métodos devuelvan resultados diferentes.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 El patrón de expresión regular `\b\w+es\b` se define como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`\w+`|Buscar coincidencias con uno o más caracteres alfabéticos.|  
|`es`|Coincide con la cadena literal "es".|  
|`\b`|Finalizar la búsqueda de coincidencias en un límite de palabras.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama. Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para recuperar varios patrón coincide con es <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que especifican opciones de coincidencia.</param>
        <param name="matchTimeout">Un intervalo de tiempo de espera, o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que el método no debe agotar el tiempo de espera.</param>
        <summary>Busca en la cadena de entrada especificada todas las apariciones de una expresión regular indicada, utilizando para ello las opciones de coincidencia y el intervalo de tiempo de espera que se especifiquen.</summary>
        <returns>Colección de los objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados en la búsqueda. Si no se encuentran coincidencias, el método devuelve un objeto de colección vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método es similar a la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método, salvo que devuelva información sobre todas las coincidencias que se encuentra en la cadena de entrada, en lugar de una coincidencia única. Es equivalente al código siguiente:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 El método estático `Matches` métodos son equivalentes a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el patrón de expresión regular especificado y llamando al método de instancia `Matches`.  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El <xref:System.Text.RegularExpressions.Regex.Matches%2A> método utiliza la evaluación diferida para rellenar el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acceso a miembros de esta colección como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> y <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> hace que la colección que se debe rellenar de forma inmediata. Para sacar partido de la evaluación diferida, se debe iterar por la colección mediante una construcción como `foreach` en C# y `For Each`...`Next` en Visual Basic.  
  
 Debido a su evaluación diferida, al llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%2A> método no produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. Sin embargo, se produce una excepción cuando se realiza una operación en el <xref:System.Text.RegularExpressions.MatchCollection> objeto devuelto por este método, si una operación de coincidencia superior a este intervalo de tiempo de espera especificado por el`matchTimeout` parámetro.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método para realizar una comparación entre mayúsculas y minúsculas que coincide con cualquier palabra en una frase que termina en "es". A continuación, llama el <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método para realizar una comparación entre mayúsculas y minúsculas del patrón con la cadena de entrada. En ambos casos, el intervalo de tiempo de espera se establece en un segundo. Como muestra el resultado, los dos métodos devuelvan resultados diferentes.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 El patrón de expresión regular `\b\w+es\b` se define como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`\w+`|Buscar coincidencias con uno o más caracteres alfabéticos.|  
|`es`|Coincide con la cadena literal "es".|  
|`\b`|Finalizar la búsqueda de coincidencias en un límite de palabras.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
 O bien  
  
 <paramref name="matchTimeout" /> es negativo, cero o mayor que 24 días aproximadamente.</exception>
        <block subset="none" type="usage">
          <para>Se recomienda que establezca el <paramref name="matchTimeout" /> parámetro en un valor apropiado, como dos segundos. Si deshabilita los tiempos de espera mediante la especificación de <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor. Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones:  
  
-   Cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o está formada por texto estático. Excluye el texto que se ha dinámicamente introducidos por los usuarios.  
  
-   Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controle eficazmente coincide con, ausencia de coincidencias y casi coincide con.  
  
-   Cuando el patrón de expresión regular no contiene ningún elemento de lenguaje que se sabe que causan un retroceso excesivo al procesar a una coincidencia casi.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el intervalo de tiempo de espera de la instancia actual.</summary>
        <value>Intervalo de tiempo máximo que puede transcurrir en una operación de coincidencia de modelos antes de que se produzca una <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /> o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> si se deshabilitan los tiempos de espera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> propiedad define el intervalo de tiempo máximo aproximado para un <xref:System.Text.RegularExpressions.Regex> instancia para ejecutar una única operación coincidente antes agote el tiempo de espera de la operación. El motor de expresiones regulares produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción durante su próxima comprobación de tiempo después de que ha transcurrido el intervalo de tiempo de espera. Esto evita que el motor de expresiones regulares de procesamiento de cadenas de entrada que requieren un retroceso excesivo. Para obtener más información, consulte [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md) y [prácticas recomendadas para las expresiones regulares](~/docs/standard/base-types/best-practices.md).  
  
 Esta propiedad es de sólo lectura. Puede establecer su valor explícitamente para las personas <xref:System.Text.RegularExpressions.Regex> objeto mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor y se puede establecer su valor para todas las <xref:System.Text.RegularExpressions.Regex> coincidencia operaciones en un dominio de aplicación mediante una llamada a la <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> método y proporcionar una <xref:System.TimeSpan> valor para la propiedad "REGEX_DEFAULT_MATCH_TIMEOUT", como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 Si no establece explícitamente un intervalo de tiempo de espera, el valor predeterminado <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> es operaciones utilizadas y búsqueda de coincidencias no caducan.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene las opciones que se pasaron en el constructor <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <value>Uno o más miembros de la enumeración <see cref="T:System.Text.RegularExpressions.RegexOptions" /> que representan opciones pasadas al constructor de <see cref="T:System.Text.RegularExpressions.Regex" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de la <xref:System.Text.RegularExpressions.Regex.Options%2A> propiedad consta de uno o varios miembros de la <xref:System.Text.RegularExpressions.RegexOptions> enumeración. Si no se definió ninguna opción en el <xref:System.Text.RegularExpressions.Regex> constructor de clase, su valor es <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>. Las opciones disponibles se describen en detalle en la [opciones de expresiones regulares](~/docs/standard/base-types/regular-expression-options.md) tema.  
  
 Tenga en cuenta que el <xref:System.Text.RegularExpressions.Regex.Options%2A> propiedad no refleja las opciones insertadas definidas en la expresión regular de sí mismo patrón.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> es la clase base de las expresiones regulares creados por el <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> método. Estas expresiones regulares compiladas que usan la implementación de clase base de la <see cref="P:System.Text.RegularExpressions.Regex.Options" /> propiedad. Si se llama desde una clase derivada, el <see cref="P:System.Text.RegularExpressions.Regex.Options" /> propiedad devuelve las opciones que se pasaron a la <paramref name="options" /> parámetro de la <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> constructor de clase que se utiliza para definir la expresión regular.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En una cadena de entrada especificada, reemplaza las cadenas que coinciden con un modelo de expresión regular por una cadena de reemplazo especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="replacement">La cadena de reemplazo.</param>
        <summary>En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con un patrón de expresión regular por una cadena de reemplazo especificada.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comienza la búsqueda de coincidencias al principio de la `input` cadena. La expresión regular es el patrón definido por el constructor para el actual <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 El `replacement` parámetro especifica la cadena que va a reemplazar cada coincidencia en `input`. `replacement` puede constar de cualquier combinación de texto literal y [sustituciones](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por ejemplo, el patrón de reemplazo `a*${test}b` inserta la cadena "un *" seguida de la subcadena que coincide con el `test` capturas de grupo, si los hay, seguida por la cadena "b". El * caracteres no se reconocen como un metacarácter dentro de un patrón de reemplazo.  
  
> [!NOTE]
>  Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo. Todos los otros elementos de lenguaje de expresiones regulares, incluidos [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), se permiten en los patrones de expresión regular solo y no se reconocen en modelos de reemplazo.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no se ha definido ningún tiempo de espera en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una expresión regular, `\s+`, que coincide con uno o más caracteres de espacio en blanco. La cadena de reemplazo, "", los reemplaza con un carácter de espacio único.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 En el ejemplo siguiente se define una expresión regular, `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`y un patrón de reemplazo, `$2`, que quita inicial o un símbolo de divisa al final de un valor numérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 La expresión regular se interpreta como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\p{Sc}`|Coincide con un símbolo de moneda. `{Sc}` indica cualquier carácter que sea miembro del símbolo Unicode, categoría de moneda.|  
|`\s?`|Busca coincidencias con cero o un carácter de espacio en blanco.|  
|`(\p{Sc}\s?)?`|Coincide con cero o una aparición de la combinación de un símbolo de moneda seguido de cero o un carácter de espacio en blanco. Este es el primer grupo de captura.|  
|`\d+`|Buscar coincidencias con uno o más dígitos decimales.|  
|`\.?`|Coincide con cero o una aparición de un período (usado como un carácter de separador decimal).|  
|`((?<=\.)\d+)?`|Si un punto es el carácter anterior, coincide con uno o más dígitos decimales. Este patrón puede coincidir cero o una vez.|  
|`(\d+\.?((?<=\.)\d+)?)`|Coincide con el patrón de uno o más dígitos decimales seguidos por un punto opcional y dígitos decimales adicionales. Este es el segundo grupo de captura. La llamada a la <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> método reemplaza toda la coincidencia con el valor de este grupo capturado.|  
|`(?(1)&#124;\s?\p{Sc})?`|Si el primer grupo capturado existe, coincide con una cadena vacía. De lo contrario, coincide con cero o un carácter de espacio en blanco seguido de un símbolo de moneda.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="replacement" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="evaluator">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</param>
        <summary>En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular especificada por una cadena devuelta por un delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que una cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> método es útil para reemplazar una coincidencia de expresión regular si se cumple alguna de las condiciones siguientes:  
  
-   La cadena de reemplazo no se puede especificar con facilidad por un patrón de reemplazo de expresión regular.  
  
-   Los resultados de la cadena de reemplazo de algunos procesos realizados en la cadena coincidente.  
  
-   Los resultados de la cadena de reemplazo de un procesamiento condicional.  
  
 El método es equivalente a llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> método y pasar cada <xref:System.Text.RegularExpressions.Match> objeto en el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> colección a la `evaluator` delegar.  
  
 La expresión regular es el patrón definido por el constructor para el actual <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 El `evaluator` parámetro es el delegado de un método personalizado que se define y que examina cada coincidencia. El método personalizado debe tener la siguiente firma para que coincida con el <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 El método personalizado devuelve una cadena que reemplaza la entrada coincidente.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no se ha definido ningún tiempo de espera en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra una cadena original, coincide con cada palabra de la cadena original, convierte el primer carácter de cada coincidencia en mayúsculas, a continuación, muestra la cadena convertida.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="evaluator" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="replacement">La cadena de reemplazo.</param>
        <param name="count">Número máximo de veces que puede producirse el reemplazo.</param>
        <summary>En una cadena de entrada especificada, reemplaza un número máximo indicado de cadenas que coinciden con un patrón de expresión regular por una cadena de reemplazo especificada.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comienza la búsqueda de coincidencias al principio de la `input` cadena. La expresión regular es el patrón definido por el constructor para el actual <xref:System.Text.RegularExpressions.Regex> objeto. Si `count` es negativo, los reemplazos continuarán hasta el final de la cadena. Si `count` supera el número de coincidencias, se reemplazan todas las coincidencias.  
  
 El `replacement` parámetro especifica la cadena que va a reemplazar la primera `count` coincidencias en `input`. `replacement` puede constar de cualquier combinación de texto literal y [sustituciones](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por ejemplo, el patrón de reemplazo `a*${test}b` inserta la cadena "un *" seguida de la subcadena que coincide con el `test` capturas de grupo, si los hay, seguida por la cadena "b". El * caracteres no se reconocen como un metacarácter dentro de un patrón de reemplazo.  
  
> [!NOTE]
>  Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo. Todos los otros elementos de lenguaje de expresiones regulares, incluidos [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), se permiten en los patrones de expresión regular solo y no se reconocen en modelos de reemplazo.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no se ha definido ningún tiempo de espera en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.  
  
   
  
## Examples  
 En el ejemplo siguiente se reemplaza las cinco primeras apariciones de caracteres duplicados con un solo carácter. El patrón de expresión regular `(\w)\1` encuentra apariciones consecutivas de un carácter único y se asigna la primera aparición en el primer grupo de captura. El patrón de reemplazo `$1` reemplaza toda la coincidencia con el primer grupo capturado.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="replacement" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="replacement">La cadena de reemplazo.</param>
        <summary>En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular concreta por la cadena de reemplazo indicada.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si <paramref name="pattern" /> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método estático `Replace` métodos son equivalentes a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el patrón de expresión regular especificado y llamando al método de instancia `Replace`.  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Comienza la búsqueda de coincidencias al principio de la `input` cadena.  
  
 El `replacement` parámetro especifica la cadena que va a reemplazar cada coincidencia en `input`. `replacement` puede constar de cualquier combinación de texto literal y [sustituciones](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por ejemplo, el patrón de reemplazo `a*${test}b` inserta la cadena "un *" seguida de la subcadena que coincide con el `test` capturas de grupo, si los hay, seguida por la cadena "b". El * caracteres no se reconocen como un metacarácter dentro de un patrón de reemplazo.  
  
> [!NOTE]
>  Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo. Todos los otros elementos de lenguaje de expresiones regulares, incluidos [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), se permiten en los patrones de expresión regular solo y no se reconocen en modelos de reemplazo.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción.  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una expresión regular, `\s+`, que coincide con uno o más caracteres de espacio en blanco. La cadena de reemplazo, "", los reemplaza con un carácter de espacio único.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 En el ejemplo siguiente se usa el <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> método para reemplazar los nombres de equipo y la unidad locales en una ruta de acceso UNC con una ruta de acceso de archivo local. La expresión regular usa el <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propiedad para incluir el nombre del equipo local y el <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> método para incluir los nombres de las unidades lógicas. Para ejecutar el ejemplo correctamente, debe reemplazar la cadena literal "MyMachine" con el nombre del equipo local.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 El patrón de expresión regular se define mediante la siguiente expresión:  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\\\\`|Barra diagonal inversa de coincidencia dos consecutivo (`\`) caracteres. Dado que el carácter de barra diagonal inversa se interpreta como el carácter de escape, cada barra diagonal inversa debe ser de escape con otra barra diagonal inversa.|  
|`(?i:" + Environment.MachineName + ")`|Realizar una coincidencia entre mayúsculas y minúsculas de la cadena devuelta por la <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propiedad.|  
|`(?:\.\w+)*`|Coincide con el punto (`.`) carácter seguido de uno o más caracteres alfabéticos. Esta coincidencia puede producirse cero o más veces. No se captura la subexpresión coincidente.|  
|`\\`|Coincide con una barra diagonal inversa (`\`) caracteres.|  
|`((?i:[" + driveNames + "]))`|Realizar a una coincidencia entre mayúsculas y minúsculas de la clase de caracteres que se compone de las letras de unidad individuales. Esta coincidencia es la primera subexpresión capturada.|  
|`\$`|Coincide con el signo de dólar literal (`$`) caracteres.|  
  
 El patrón de reemplazo `$1` reemplaza toda la coincidencia con la primera subexpresión capturada. Es decir, el nombre de equipo y la unidad UNC reemplaza con la letra de unidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="replacement" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama. Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para reemplazar una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="evaluator">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</param>
        <summary>En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular especificada por una cadena devuelta por un delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que una cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si <paramref name="pattern" /> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> método es útil para reemplazar una coincidencia de expresión regular si se cumple alguna de las condiciones siguientes:  
  
-   La cadena de reemplazo no se puede especificar con facilidad por un patrón de reemplazo de expresión regular.  
  
-   Los resultados de la cadena de reemplazo de algunos procesos realizados en la cadena coincidente.  
  
-   Los resultados de la cadena de reemplazo de un procesamiento condicional.  
  
 El método es equivalente a llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> método y pasar cada <xref:System.Text.RegularExpressions.Match> objeto en el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> colección a la `evaluator` delegar.  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El `evaluator` parámetro es el delegado de un método personalizado que se define y que examina cada coincidencia. El método personalizado debe tener la siguiente firma para que coincida con el <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 El método personalizado devuelve una cadena que reemplaza la entrada coincidente.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción.  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza una expresión regular para extraer las palabras individuales de una cadena y, a continuación, utiliza un <xref:System.Text.RegularExpressions.MatchEvaluator> delegado para llamar a un método denominado `WordScramble` que codifica las letras individuales en la palabra. Para ello, el `WordScramble` método crea una matriz que contiene los caracteres de la coincidencia. También se crea una matriz paralela que se rellena con números de punto flotante aleatorios. Las matrices se ordenan mediante una llamada a la <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método y la matriz ordenada se proporciona como un argumento a un <xref:System.String> constructor de clase. A continuación, se devuelve esta cadena recién creada por el `WordScramble` método. El patrón de expresión regular `\w+` coincide con uno o más caracteres alfabéticos; continuará el motor de expresiones regulares agregar caracteres a la búsqueda de coincidencias, hasta que encuentra un carácter no sea de palabra, como un carácter de espacio en blanco.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="evaluator" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama. Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para evaluar y reemplazar una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="evaluator">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</param>
        <param name="count">Número máximo de veces que se llevará a cabo el reemplazo.</param>
        <summary>En una cadena de entrada especificada, reemplaza un número máximo especificado de cadenas que coinciden con un modelo de expresión regular por una cadena devuelta por un delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que una cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> método es útil para reemplazar una coincidencia de expresión regular si se cumple alguna de las condiciones siguientes:  
  
-   La cadena de reemplazo no se puede especificar con facilidad por un patrón de reemplazo de expresión regular.  
  
-   Los resultados de la cadena de reemplazo de algunos procesos realizados en la cadena coincidente.  
  
-   Los resultados de la cadena de reemplazo de un procesamiento condicional.  
  
 El método es equivalente a llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> método y pasar la primera `count` <xref:System.Text.RegularExpressions.Match> objetos en el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> colección a la `evaluator` delegar.  
  
 La expresión regular es el patrón definido por el constructor para el actual <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 El `evaluator` parámetro es el delegado de un método personalizado que se define y que examina cada coincidencia. El método personalizado debe tener la siguiente firma para que coincida con el <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 El método personalizado devuelve una cadena que reemplaza la entrada coincidente.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no se ha definido ningún tiempo de espera en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa una expresión regular para deliberadamente escrito incorrectamente la mitad de las palabras en una lista. Se usa la expresión regular `\w*(ie|ei)\w*` para buscar palabras que incluyen los caracteres "ie" o "ei". Pasa la primera mitad de las palabras de búsqueda de coincidencias para el `ReverseLetter` método, que a su vez, utiliza el <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método para invertir la "i" y "e" en la cadena coincidente. El resto de las palabras no se modificarán.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 La expresión regular `\w*(ie|ei)\w*` se define como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\w*`|Buscar una coincidencia con cero o más caracteres alfabéticos.|  
|`(ie&#124;ei)`|Coincide con "ie" o "ei".|  
|`\w*`|Buscar una coincidencia con cero o más caracteres alfabéticos.|  
  
 El patrón de expresión regular `([ie])([ie])` en el `ReverseLetter` método coincide con la primera "i" o "e" en el diphthong "ie" o "ei" y asigna la letra al primer grupo de captura. Coincide con la segunda "i" o "e" y asigna la letra al segundo grupo de captura. Los dos caracteres, a continuación, se invierten mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> método con el patrón de reemplazo `$2$1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="evaluator" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="replacement">La cadena de reemplazo.</param>
        <param name="count">Número máximo de veces que puede producirse el reemplazo.</param>
        <param name="startat">Posición del carácter en la cadena de entrada donde comienza la búsqueda.</param>
        <summary>En una subcadena de entrada especificada, reemplaza un número máximo especificado de cadenas que coinciden con un patrón de expresión regular por una cadena de reemplazo especificada.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inicia la búsqueda de coincidencias en la `input` cadena en la posición especificada por el `startat` parámetro. La expresión regular es el patrón definido por el constructor para el actual <xref:System.Text.RegularExpressions.Regex> objeto. Si `count` es negativo, los reemplazos continuarán hasta el final de la cadena. Si `count` supera el número de coincidencias, se reemplazan todas las coincidencias.  
  
 El `replacement` parámetro especifica la cadena que va a reemplazar cada coincidencia en `input`. `replacement` puede constar de cualquier combinación de texto literal y [sustituciones](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por ejemplo, el patrón de reemplazo `a*${test}b` inserta la cadena "un *" seguida de la subcadena que coincide con el `test` capturas de grupo, si los hay, seguida por la cadena "b". El * caracteres no se reconocen como un metacarácter dentro de un patrón de reemplazo.  
  
> [!NOTE]
>  Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo. Todos los otros elementos de lenguaje de expresiones regulares, incluidos [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), se permiten en los patrones de expresión regular solo y no se reconocen en modelos de reemplazo.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no se ha definido ningún tiempo de espera en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.  
  
   
  
## Examples  
 En el ejemplo siguiente se duplica todas menos la primera línea de una cadena. Define un patrón de expresión regular, `^.*$`, que coincide con una línea de texto, llamadas el <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método para que coincida con la primera línea de la cadena y utiliza el `Match.Index` y `Match.Count` propiedades para determinar la posición inicial del segundo línea.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 El patrón de expresión regular `^.*$` se define como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`^`|Coincidir con el principio de una línea. (Tenga en cuenta que la <xref:System.Text.RegularExpressions.Regex> se crea una instancia de objeto mediante el uso de la <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option; en caso contrario, esta clase de caracteres solo coincidiría con el principio de la cadena de entrada.)|  
|`.*`|Coincide con cualquier carácter cero o más veces.|  
|`$`|Coincide con el final de una línea. (Tenga en cuenta que la <xref:System.Text.RegularExpressions.Regex> se crea una instancia de objeto mediante el uso de la <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option; en caso contrario, esta clase de caracteres solo coincidiría con el principio de la cadena de entrada.)|  
  
 La cadena de reemplazo (`vbCrLf + "$&"` en Visual Basic, `"\n$&"` en C#) agrega una nueva línea antes de la cadena coincidente. Tenga en cuenta que `\n` en C# en el ejemplo se se interpreta como carácter de nueva línea por el compilador de C#; no representa un escape de carácter de expresión regular.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="replacement" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> es menor que cero o mayor que la longitud de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="replacement">La cadena de reemplazo.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <summary>En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular concreta por la cadena de reemplazo indicada. Las opciones especificadas modifican la operación de coincidencia.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si <paramref name="pattern" /> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método estático `Replace` métodos son equivalentes a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el patrón de expresión regular especificado y llamando al método de instancia `Replace`.  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Si especifica <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> para el `options` parámetro, la búsqueda de coincidencias comienza al final de la cadena de entrada y se mueve a izquierda; en caso contrario, la búsqueda comienza al principio de la cadena de entrada y se mueve a la derecha.  
  
 El `replacement` parámetro especifica la cadena que va a reemplazar cada coincidencia en `input`. `replacement` puede constar de cualquier combinación de texto literal y [sustituciones](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por ejemplo, el patrón de reemplazo `a*${test}b` inserta la cadena "un *" seguida de la subcadena que coincide con el `test` capturas de grupo, si los hay, seguida por la cadena "b". El * caracteres no se reconocen como un metacarácter dentro de un patrón de reemplazo.  
  
> [!NOTE]
>  Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo. Todos los otros elementos de lenguaje de expresiones regulares, incluidos [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), se permiten en los patrones de expresión regular solo y no se reconocen en modelos de reemplazo.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción.  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método para reemplazar los nombres de equipo y la unidad locales en una ruta de acceso UNC con una ruta de acceso de archivo local. La expresión regular usa el <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propiedad para incluir el nombre del equipo local y el <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> método para incluir los nombres de las unidades lógicas. Todas las comparaciones de cadenas de expresiones regulares distinguen mayúsculas de minúsculas. Para ejecutar el ejemplo correctamente, debe reemplazar la cadena literal "MyMachine" con el nombre del equipo local.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 El patrón de expresión regular se define mediante la siguiente expresión:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\\\\`|Barra diagonal inversa de coincidencia dos consecutivo (`\`) caracteres. Dado que el carácter de barra diagonal inversa se interpreta como el carácter de escape, cada barra diagonal inversa debe ser de escape con otra barra diagonal inversa.|  
|`+ Environment.MachineName +`|Coincide con la cadena devuelta por la <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propiedad.|  
|`(?:\.\w+)*`|Coincide con el punto (`.`) carácter seguido de uno o más caracteres alfabéticos. Esta coincidencia puede producirse cero o más veces. No se captura la subexpresión coincidente.|  
|`\\`|Coincide con una barra diagonal inversa (`\`) caracteres.|  
|`([" + driveNames + "])`|Coincide con la clase de caracteres que se compone de las letras de unidad individuales. Esta coincidencia es la primera subexpresión capturada.|  
|`\$`|Coincide con el signo de dólar literal (`$`) caracteres.|  
  
 El patrón de reemplazo `$1` reemplaza toda la coincidencia con la primera subexpresión capturada. Es decir, el nombre de equipo y la unidad UNC reemplaza con la letra de unidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="replacement" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama. Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para reemplazar una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="evaluator">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <summary>En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular especificada por una cadena devuelta por un delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Las opciones especificadas modifican la operación de coincidencia.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que una cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si <paramref name="pattern" /> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método es útil para reemplazar una coincidencia de expresión regular en si se cumple alguna de las condiciones siguientes:  
  
-   La cadena de reemplazo no se puede especificar con facilidad por un patrón de reemplazo de expresión regular.  
  
-   Los resultados de la cadena de reemplazo de algunos procesos realizados en la cadena coincidente.  
  
-   Los resultados de la cadena de reemplazo de un procesamiento condicional.  
  
 El método es equivalente a llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método y pasar cada <xref:System.Text.RegularExpressions.Match> objeto en el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> colección a la `evaluator` delegar.  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El `evaluator` parámetro es el delegado de un método personalizado que se define y que examina cada coincidencia. El método personalizado debe tener la siguiente firma para que coincida con el <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 El método personalizado devuelve una cadena que reemplaza la entrada coincidente.  
  
 Si especifica <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> para el `options` parámetro, la búsqueda de coincidencias comienza al final de la cadena de entrada y se mueve a izquierda; en caso contrario, la búsqueda comienza al principio de la cadena de entrada y se mueve a la derecha.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción.  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza una expresión regular para extraer las palabras individuales de una cadena y, a continuación, utiliza un <xref:System.Text.RegularExpressions.MatchEvaluator> delegado para llamar a un método denominado `WordScramble` que codifica las letras individuales en la palabra. Para ello, el `WordScramble` método crea una matriz que contiene los caracteres de la coincidencia. También se crea una matriz paralela que se rellena con números de punto flotante aleatorios. Las matrices se ordenan mediante una llamada a la <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método y la matriz ordenada se proporciona como un argumento a un <xref:System.String> constructor de clase. A continuación, se devuelve esta cadena recién creada por el `WordScramble` método. El patrón de expresión regular `\w+` coincide con uno o más caracteres alfabéticos; continuará el motor de expresiones regulares agregar caracteres a la búsqueda de coincidencias, hasta que encuentra un carácter no sea de palabra, como un carácter de espacio en blanco. La llamada a la <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> método incluye la <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opción para que el comentario en el patrón de expresión regular `\w+  # Matches all the characters in a word.` omitido por el motor de expresiones regulares.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="evaluator" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="evaluator">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</param>
        <param name="count">Número máximo de veces que se llevará a cabo el reemplazo.</param>
        <param name="startat">Posición del carácter en la cadena de entrada donde comienza la búsqueda.</param>
        <summary>En una subcadena de entrada especificada, reemplaza un número máximo especificado de cadenas que coinciden con un modelo de expresión regular por una cadena devuelta por un delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que una cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método es útil para reemplazar una coincidencia de expresión regular si se cumple alguna de las condiciones siguientes:  
  
-   La cadena de reemplazo no se puede especificar con facilidad por un patrón de reemplazo de expresión regular.  
  
-   Los resultados de la cadena de reemplazo de algunos procesos realizados en la cadena coincidente.  
  
-   Los resultados de la cadena de reemplazo de un procesamiento condicional.  
  
 El método es equivalente a llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> método y pasar la primera `count` <xref:System.Text.RegularExpressions.Match> objetos en el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> colección a la `evaluator` delegar.  
  
 La expresión regular es el patrón definido por el constructor para el actual <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 El `evaluator` parámetro es el delegado de un método personalizado que se define y que examina cada coincidencia. El método personalizado debe tener la siguiente firma para que coincida con el <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 El método personalizado devuelve una cadena que reemplaza la entrada coincidente.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no se ha definido ningún tiempo de espera en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="evaluator" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> es menor que cero o mayor que la longitud de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="replacement">La cadena de reemplazo.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <param name="matchTimeout">Un intervalo de tiempo de espera, o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que el método no debe agotar el tiempo de espera.</param>
        <summary>En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular concreta por la cadena de reemplazo indicada. Los parámetros adicionales especifican las opciones que modifican la operación de coincidencia y un intervalo de tiempo de espera si no se encuentra ninguna coincidencia.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si <paramref name="pattern" /> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método estático `Replace` métodos son equivalentes a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el patrón de expresión regular especificado y llamando al método de instancia `Replace`.  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Si especifica <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> para el `options` parámetro, la búsqueda de coincidencias comienza al final de la cadena de entrada y se mueve a izquierda; en caso contrario, la búsqueda comienza al principio de la cadena de entrada y se mueve a la derecha.  
  
 El `replacement` parámetro especifica la cadena que va a reemplazar cada coincidencia en `input`. `replacement` puede constar de cualquier combinación de texto literal y [sustituciones](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por ejemplo, el patrón de reemplazo `a*${test}b` inserta la cadena "un *" seguida de la subcadena que coincide con el `test` capturas de grupo, si los hay, seguida por la cadena "b". El * caracteres no se reconocen como un metacarácter dentro de un patrón de reemplazo.  
  
> [!NOTE]
>  Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo. Todos los otros elementos de lenguaje de expresiones regulares, incluidos [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), se permiten en los patrones de expresión regular solo y no se reconocen en modelos de reemplazo.  
  
 El `matchTimeout` parámetro especifica cómo tiempo una coincidencia de patrones método debe intentar encontrar una coincidencia antes de expirar. Establecer un intervalo de tiempo de espera impide que las expresiones regulares que se basan en un retroceso excesivo aparezcan deje de responder cuando procesan datos de entrada que contenga cerca de coincidencias. Para obtener más información, consulte [prácticas recomendadas para las expresiones regulares](~/docs/standard/base-types/best-practices.md) y [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Si se encuentra ninguna coincidencia en ese intervalo de tiempo, el método produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. `matchTimeout` invalida cualquier valor de tiempo de espera predeterminado definido para el dominio de aplicación en el que se ejecuta el método.  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método para reemplazar los nombres de equipo y la unidad locales en una ruta de acceso UNC con una ruta de acceso de archivo local. La expresión regular usa el <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propiedad para incluir el nombre del equipo local y el <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> método para incluir los nombres de las unidades lógicas. Todas las comparaciones de cadenas de expresiones regulares distinguen mayúsculas de minúsculas, y cualquier operación de reemplazo único agota el tiempo si no se encuentra una coincidencia en 0,5 segundos. Para ejecutar el ejemplo correctamente, debe reemplazar la cadena literal "MyMachine" con el nombre del equipo local.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 El patrón de expresión regular se define mediante la siguiente expresión:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\\\\`|Barra diagonal inversa de coincidencia dos consecutivo (`\`) caracteres. Dado que el carácter de barra diagonal inversa se interpreta como el carácter de escape, cada barra diagonal inversa debe ser de escape con otra barra diagonal inversa.|  
|`+ Environment.MachineName +`|Coincide con la cadena devuelta por la <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propiedad.|  
|`(?:\.\w+)*`|Coincide con el punto (`.`) carácter seguido de uno o más caracteres alfabéticos. Esta coincidencia puede producirse cero o más veces. No se captura la subexpresión coincidente.|  
|`\\`|Coincide con una barra diagonal inversa (`\`) caracteres.|  
|`([" + driveNames + "])`|Coincide con la clase de caracteres que se compone de las letras de unidad individuales. Esta coincidencia es la primera subexpresión capturada.|  
|`\$`|Coincide con el signo de dólar literal (`$`) caracteres.|  
  
 El patrón de reemplazo `$1` reemplaza toda la coincidencia con la primera subexpresión capturada. Es decir, el nombre de equipo y la unidad UNC reemplaza con la letra de unidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="replacement" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
 O bien  
  
 <paramref name="matchTimeout" /> es negativo, cero o mayor que 24 días aproximadamente.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó un tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Se recomienda que establezca el <paramref name="matchTimeout" /> parámetro en un valor apropiado, como dos segundos. Si deshabilita los tiempos de espera mediante la especificación de <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor. Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones:  
  
-   Cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o está formada por texto estático. Excluye el texto que se ha dinámicamente introducidos por los usuarios.  
  
-   Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controle eficazmente coincide con, ausencia de coincidencias y casi coincide con.  
  
-   Cuando el patrón de expresión regular no contiene ningún elemento de lenguaje que se sabe que causan un retroceso excesivo al procesar a una coincidencia casi.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="evaluator">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</param>
        <param name="options">Combinación bit a bit de los valores de la enumeración que proporcionan opciones de coincidencia.</param>
        <param name="matchTimeout">Un intervalo de tiempo de espera, o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que el método no debe agotar el tiempo de espera.</param>
        <summary>En una cadena de entrada especificada, reemplaza todas las subcadenas que coinciden con una expresión regular especificada por una cadena devuelta por un delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Los parámetros adicionales especifican las opciones que modifican la operación de coincidencia y un intervalo de tiempo de espera si no se encuentra ninguna coincidencia.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si <paramref name="pattern" /> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método es útil para reemplazar una coincidencia de expresión regular si se cumple alguna de las condiciones siguientes:  
  
-   Si la cadena de reemplazo no se puede especificar fácilmente mediante un patrón de reemplazo de expresión regular.  
  
-   Si la cadena de reemplazo da como resultado de realiza algún procesamiento en la cadena coincidente.  
  
-   Si la cadena de reemplazo da como resultado de un procesamiento condicional.  
  
 El método es equivalente a llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método y pasar cada <xref:System.Text.RegularExpressions.Match> objeto en el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> colección a la `evaluator` delegar.  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El `evaluator` parámetro es el delegado de un método personalizado que se define y que examina cada coincidencia. El método personalizado debe tener la siguiente firma para que coincida con el <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 El método personalizado devuelve una cadena que reemplaza la entrada coincidente.  
  
 Si especifica <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> para el `options` parámetro, la búsqueda de coincidencias comienza al final de la cadena de entrada y se mueve a izquierda; en caso contrario, la búsqueda comienza al principio de la cadena de entrada y se mueve a la derecha.  
  
 El `matchTimeout` parámetro especifica cómo tiempo una coincidencia de patrones método debe intentar encontrar una coincidencia antes de expirar. Establecer un intervalo de tiempo de espera impide que las expresiones regulares que se basan en un retroceso excesivo no aparezca en "dejar de responder cuando procesan datos de entrada que contenga cerca de coincidencias. Para obtener más información, consulte [prácticas recomendadas para las expresiones regulares](~/docs/standard/base-types/best-practices.md) y [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Si se encuentra ninguna coincidencia en ese intervalo de tiempo, el método produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. `matchTimeout` invalida cualquier valor de tiempo de espera predeterminado definido para el dominio de aplicación en el que se ejecuta el método.  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado los reemplazos de la cadena de entrada.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza una expresión regular para extraer las palabras individuales de una cadena y, a continuación, utiliza un <xref:System.Text.RegularExpressions.MatchEvaluator> delegado para llamar a un método denominado `WordScramble` que codifica las letras individuales en la palabra. Para ello, el `WordScramble` método crea una matriz que contiene los caracteres de la coincidencia. También se crea una matriz paralela que se rellena con números de punto flotante aleatorios. Las matrices se ordenan mediante una llamada a la <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método y la matriz ordenada se proporciona como un argumento a un <xref:System.String> constructor de clase. A continuación, se devuelve esta cadena recién creada por el `WordScramble` método. El patrón de expresión regular `\w+` coincide con uno o más caracteres alfabéticos; continuará el motor de expresiones regulares agregar caracteres a la búsqueda de coincidencias, hasta que encuentra un carácter no sea de palabra, como un carácter de espacio en blanco. La llamada a la <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> método incluye la <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opción para que el comentario en el patrón de expresión regular `\w+  # Matches all the characters in a word.` omitido por el motor de expresiones regulares.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="evaluator" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
 O bien  
  
 <paramref name="matchTimeout" /> es negativo, cero o mayor que 24 días aproximadamente.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó un tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Se recomienda que establezca el <paramref name="matchTimeout" /> parámetro en un valor apropiado, como dos segundos. Si deshabilita los tiempos de espera mediante la especificación de <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor. Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones:  
  
-   Cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o está formada por texto estático. Excluye el texto que se ha dinámicamente introducidos por los usuarios.  
  
-   Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controle eficazmente coincide con, ausencia de coincidencias y casi coincide con.  
  
-   Cuando el patrón de expresión regular no contiene ningún elemento de lenguaje que se sabe que causan un retroceso excesivo al procesar a una coincidencia casi.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la expresión regular busca de derecha a izquierda.</summary>
        <value>
          <see langword="true" /> si la expresión regular busca de derecha a izquierda; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> es `true` si la <xref:System.Text.RegularExpressions.Regex> instancia se creó con la <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> opción.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Divide una cadena de entrada en una matriz de subcadenas en las posiciones definidas por una coincidencia de expresión regular.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena que se va a dividir.</param>
        <summary>Divide una cadena de entrada en una matriz de subcadenas en las posiciones definidas por un modelo de expresión regular especificado en el constructor <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Matriz de cadenas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos son similares a los <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> método, salvo que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres. La cadena se divide tantas veces como sea posible. Si no se encuentra ningún delimitador, el valor devuelto contiene un elemento cuyo valor es la cadena de entrada original.  
  
 Si varias coincidencias son adyacentes entre sí, se inserta una cadena vacía en la matriz. Por ejemplo, dividir una cadena en un solo guión hace que la matriz devuelta incluir una cadena vacía en la posición donde se encuentran dos guiones adyacentes, como se muestra en el código siguiente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 Si se encuentra una coincidencia al principio o al final de la cadena de entrada, una cadena vacía se incluye al principio o al final de la matriz devuelta. En el ejemplo siguiente se usa el patrón de expresión regular `\d+` para dividir una cadena de entrada de caracteres numéricos. Dado que la cadena comienza y termina con la coincidencia de caracteres numéricos, el valor del primer y último elemento de la matriz devuelta es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 Si se usan paréntesis de captura en un <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expresión, cualquier capturada texto se incluye en la matriz de cadenas resultante. Por ejemplo, si divide la cadena "ciruela-pera" con un guión colocado entre paréntesis de captura, la matriz devuelta incluye un elemento de cadena que contiene el guión.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework. En .NET Framework 1.0 y 1.1, si no se encuentra una coincidencia en el primer conjunto de paréntesis, de captura no se incluye el texto capturado de paréntesis adicionales en la matriz devuelta. Todo el texto capturado a partir de .NET Framework 2.0, también se agrega a la matriz devuelta. Por ejemplo, el código siguiente usa dos conjuntos de paréntesis de captura para extraer los elementos de una fecha, incluidos los delimitadores de fecha, de una cadena de fecha. El primer conjunto de paréntesis de captura captura el guión, y el segundo captura la barra diagonal. Si el código de ejemplo se compila y se ejecutan en .NET Framework 1.0 o 1.1, excluye los caracteres de barra diagonal; Si se compila y se ejecuta en el .NET Framework 2.0 o versiones posteriores, los incluye.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 Si la expresión regular puede coincidir con la cadena vacía, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> dividirá la cadena en una matriz de cadenas de carácter único porque el delimitador de cadena vacía se puede encontrar en cada ubicación. Por ejemplo:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 Tenga en cuenta que la matriz devuelta también incluye una cadena vacía al principio y al final de la matriz.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de división supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no se ha definido ningún tiempo de espera en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena que se va a dividir.</param>
        <param name="count">Número máximo de veces que puede llevarse a cabo la división.</param>
        <summary>Divide una cadena de entrada por un número máximo especificado de veces en una matriz de subcadenas, en las posiciones definidas por una expresión regular especificada en el constructor <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Matriz de cadenas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos son similares a los <xref:System.String.Split%2A?displayProperty=nameWithType> método, salvo que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres. El `count` parámetro especifica el número máximo de subcadenas en la que el `input` se puede dividir la cadena; la última cadena contiene el resto no dividido de la cadena. Un `count` valor de cero proporciona el comportamiento predeterminado de división tantas veces como sea posible.  
  
 Si varias coincidencias son adyacentes entre sí o si se encuentra una coincidencia al principio o al final de `input`, y el número de coincidencias encontradas es al menos dos inferior a `count`, se inserta una cadena vacía en la matriz. Es decir, se cuentan las cadenas vacías generadas por las coincidencias adyacentes o de coincidencias al principio o al final de la cadena de entrada para determinar si el número de apertura coincide subcadenas es igual a `count`. En el ejemplo siguiente, la expresión regular `/d+` se utiliza para dividir una cadena de entrada que incluye uno o más dígitos decimales en un máximo de tres subcadenas. Dado que el principio de la cadena de entrada coincide con el patrón de expresión regular, el primer elemento de matriz contiene <xref:System.String.Empty?displayProperty=nameWithType>, el segundo contiene el primer conjunto de caracteres alfabéticos en la cadena de entrada y el tercero contiene el resto de la cadena que sigue a la coincidencia terceros.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 Si se usan paréntesis de captura en una expresión regular, se incluye el texto capturado en la matriz de cadenas de división. Sin embargo, los elementos de matriz que contienen texto capturado no cuentan para determinar si se ha alcanzado el número de coincidencias `count`. Por ejemplo, dividir la cadena "apple-albaricoque-ciruela-pera-plátano" en un máximo de cuatro subcadenas da lugar a una matriz de siete elementos, como el siguiente código muestra.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework. En .NET Framework 1.0 y 1.1, solo el texto capturado del primer conjunto de paréntesis de captura se incluye en la matriz devuelta. A partir de .NET Framework 2.0, todo el texto capturado se agrega a la matriz devuelta. Sin embargo, los elementos de la matriz devuelta que contienen texto capturado no cuentan para determinar si el número de apertura coincide subcadenas es igual a `count`. Por ejemplo, en el código siguiente, una expresión regular usa dos conjuntos de paréntesis de captura para extraer los elementos de una fecha de una cadena de fecha. El primer conjunto de paréntesis de captura captura el guión, y el segundo captura la barra diagonal. La llamada a la <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> método, a continuación, especifica un máximo de dos elementos en la matriz devuelta. Si el código de ejemplo se compila y se ejecutan en .NET Framework 1.0 o 1.1, el método devuelve una matriz de cadenas de dos elementos. Si se compila y se ejecuta en el .NET Framework 2.0 o versiones posteriores, el método devuelve una matriz de cadenas de tres elementos.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 Si la expresión regular puede coincidir con la cadena vacía, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> dividirá la cadena en una matriz de cadenas de carácter único porque el delimitador de cadena vacía se puede encontrar en cada ubicación. En el ejemplo siguiente se divide la cadena de "caracteres de" como porque no hay muchos elementos están en la cadena de entrada. Dado que la cadena nula coincide con el principio de la cadena de entrada, se inserta una cadena nula al principio de la matriz devuelta. Esto hace que el elemento décimo constan de los dos caracteres al final de la cadena de entrada.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de división supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no se ha definido ningún tiempo de espera en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena que se va a dividir.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <summary>Divide una cadena de entrada en una matriz de subcadenas en las posiciones definidas por un patrón de expresión regular.</summary>
        <returns>Matriz de cadenas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos son similares a los <xref:System.String.Split%2A?displayProperty=nameWithType> método, salvo que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres. El `input` cadena se divide tantas veces como sea posible. Si `pattern` no se encuentra en la `input` cadena, el valor devuelto contiene un elemento cuyo valor es la versión original `input` cadena.  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Compila expresiones regulares utilizadas en llamadas a estática <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos automáticamente se almacenan en caché. Para administrar la duración de las expresiones regulares compiladas, utilice la instancia <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos.  
  
 Si varias coincidencias son adyacentes entre sí, se inserta una cadena vacía en la matriz. Por ejemplo, dividir una cadena en un solo guión hace que la matriz devuelta incluir una cadena vacía en la posición donde se encuentran dos guiones adyacentes, como se muestra en el código siguiente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 Si se encuentra una coincidencia al principio o al final de la cadena de entrada, una cadena vacía se incluye al principio o al final de la matriz devuelta. En el ejemplo siguiente se usa el patrón de expresión regular `\d+` para dividir una cadena de entrada de caracteres numéricos. Dado que la cadena comienza y termina con la coincidencia de caracteres numéricos, el valor del primer y último elemento de la matriz devuelta es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 Si se usan paréntesis de captura en un <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expresión, cualquier capturada texto se incluye en la matriz de cadenas resultante. Por ejemplo, si divide la cadena "ciruela-pera" con un guión colocado entre paréntesis de captura, la matriz devuelta incluye un elemento de cadena que contiene el guión.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework. En .NET Framework 1.0 y 1.1, si no se encuentra una coincidencia en el primer conjunto de paréntesis, de captura no se incluye el texto capturado de paréntesis adicionales en la matriz devuelta. Todo el texto capturado a partir de .NET Framework 2.0, también se agrega a la matriz devuelta. Por ejemplo, el código siguiente usa dos conjuntos de paréntesis de captura para extraer los elementos de una fecha, incluidos los delimitadores de fecha, de una cadena de fecha. El primer conjunto de paréntesis de captura captura el guión, y el segundo captura la barra diagonal. Si el código de ejemplo se compila y se ejecutan en .NET Framework 1.0 o 1.1, excluye los caracteres de barra diagonal; Si se compila y se ejecuta en el .NET Framework 2.0 o versiones posteriores, los incluye.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Si la expresión regular puede coincidir con la cadena vacía, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividirá la cadena en una matriz de cadenas de carácter único porque el delimitador de cadena vacía se puede encontrar en cada ubicación. Por ejemplo:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 Tenga en cuenta que la matriz devuelta también incluye una cadena vacía al principio y al final de la matriz.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de división supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama al método. Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para dividir el texto en una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena que se va a dividir.</param>
        <param name="count">Número máximo de veces que puede llevarse a cabo la división.</param>
        <param name="startat">Posición de carácter de la cadena de entrada donde comenzará la búsqueda.</param>
        <summary>Divide una cadena de entrada por un número máximo especificado de veces en una matriz de subcadenas, en las posiciones definidas por una expresión regular especificada en el constructor <see cref="T:System.Text.RegularExpressions.Regex" />. La búsqueda del patrón de expresión regular se inicia en la posición de carácter especificada de la cadena de entrada.</summary>
        <returns>Matriz de cadenas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos son similares a los <xref:System.String.Split%2A?displayProperty=nameWithType> método, salvo que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres. El `count` parámetro especifica el número máximo de subcadenas en la que el `input` se divide la cadena; la última cadena contiene el resto no dividido de la cadena. Un `count` valor de cero proporciona el comportamiento predeterminado de división tantas veces como sea posible. El `startat` parámetro define el punto en el que comienza la búsqueda del primer delimitador (Esto se puede utilizar para omitir el espacio en blanco inicial).  
  
 Si no se encuentra ninguna coincidencia de la `count`+ 1 se coloque en la cadena, el método devuelve una matriz de un elemento que contiene el `input` cadena. Si se encuentran una o varias coincidencias, el primer elemento de la matriz devuelta contiene la primera parte de la cadena desde el primer carácter hasta un carácter antes de la coincidencia.  
  
 Si varias coincidencias son adyacentes entre sí y el número de coincidencias encontradas es al menos dos inferior a `count`, se inserta una cadena vacía en la matriz. De forma similar, si se encuentra una coincidencia en `startat`, que es el primer carácter de la cadena, el primer elemento de la matriz devuelta es una cadena vacía. Es decir, se cuentan las cadenas vacías generadas por las coincidencias adyacentes para determinar si el número de apertura coincide subcadenas es igual a `count`. En el ejemplo siguiente, la expresión regular `\d+` se usa para buscar la posición inicial de la primera subcadena de caracteres numéricos en una cadena y, a continuación, para dividir la cadena de un máximo de tres veces inicial en esa posición. Dado que el patrón de expresión regular coincide con el principio de la cadena de entrada, la matriz de cadena devuelta consta de una cadena vacía, una cadena es un carácter alfabético de cinco caracteres y el resto de la cadena  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 Si se usan paréntesis de captura en una expresión regular, se incluye el texto capturado en la matriz de cadenas de división. Sin embargo, los elementos de matriz que contienen texto capturado no cuentan para determinar si se ha alcanzado el número de coincidencias `count`. Por ejemplo, dividir la cadena ' "apple-apricot-plum-pear-pomegranate-pineapple-peach" en un máximo de cuatro subcadenas a partir del carácter 15 de los resultados de cadena en una matriz de siete elementos, como se muestra en el código siguiente.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework. En .NET Framework 1.0 y 1.1, si no se encuentra una coincidencia en el primer conjunto de paréntesis, de captura no se incluye el texto capturado de paréntesis adicionales en la matriz devuelta. Todo el texto capturado a partir de .NET Framework 2.0, también se agrega a la matriz devuelta. Por ejemplo, el código siguiente usa dos conjuntos de paréntesis de captura para extraer las palabras individuales de una cadena. El primer conjunto de paréntesis de captura captura el guión, y el segundo captura la barra vertical. Si el código de ejemplo se compila y se ejecutan en .NET Framework 1.0 o 1.1, excluye vertical barra caracteres; Si se compila y se ejecuta en el .NET Framework 2.0 o versiones posteriores, los incluye.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 Si la expresión regular puede coincidir con la cadena vacía, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividirá la cadena en una matriz de cadenas de carácter único porque el delimitador de cadena vacía se puede encontrar en cada ubicación. En el ejemplo siguiente se divide la cadena "caracteres" en tantos elementos como contiene la cadena de entrada, empezando por el carácter "a". Dado que la cadena nula coincide con el final de la cadena de entrada, se inserta una cadena nula al final de la matriz devuelta.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de división supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no se ha definido ningún tiempo de espera en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> es menor que cero o mayor que la longitud de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Cadena que se va a dividir.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <summary>Divide una cadena de entrada en una matriz de subcadenas en las posiciones definidas por un patrón de expresión regular especificado. Las opciones especificadas modifican la operación de coincidencia.</summary>
        <returns>Matriz de cadenas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos son similares a los <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> método, salvo que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres. La cadena se divide tantas veces como sea posible. Si no se encuentra ningún delimitador, el valor devuelto contiene un elemento cuyo valor es la versión original `input` cadena.  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Compila expresiones regulares utilizadas en llamadas a estática <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos automáticamente se almacenan en caché. Para administrar la duración de las expresiones regulares compiladas, utilice la instancia <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos.  
  
 Si varias coincidencias son adyacentes entre sí, se inserta una cadena vacía en la matriz. Por ejemplo, dividir una cadena en un solo guión hace que la matriz devuelta incluir una cadena vacía en la posición donde se encuentran dos guiones adyacentes.  
  
 Si se encuentra una coincidencia al principio o al final de la cadena de entrada, una cadena vacía se incluye al principio o al final de la matriz devuelta. En el ejemplo siguiente se usa el patrón de expresión regular `[a-z]+` para dividir una cadena de entrada de cualquier carácter alfabético en mayúscula o minúscula. Dado que la cadena comienza y termina con la coincidencia de caracteres alfabéticos, el valor del primer y último elemento de la matriz devuelta es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 Si se usan paréntesis de captura en un <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expresión, cualquier capturada texto se incluye en la matriz de cadenas resultante. Por ejemplo, si divide la cadena "ciruela-pera" con un guión colocado entre paréntesis de captura, la matriz devuelta incluye un elemento de cadena que contiene el guión.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework. En .NET Framework 1.0 y 1.1, si no se encuentra una coincidencia en el primer conjunto de paréntesis, de captura no se incluye el texto capturado de paréntesis adicionales en la matriz devuelta. Todo el texto capturado a partir de .NET Framework 2.0, también se agrega a la matriz devuelta. Por ejemplo, el código siguiente usa dos conjuntos de paréntesis de captura para extraer los elementos de una fecha, incluidos los delimitadores de fecha, de una cadena de fecha. El primer conjunto de paréntesis de captura captura el guión, y el segundo captura la barra diagonal. Si el código de ejemplo se compila y se ejecutan en .NET Framework 1.0 o 1.1, excluye los caracteres de barra diagonal; Si se compila y se ejecuta en el .NET Framework 2.0 o versiones posteriores, los incluye.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Si la expresión regular puede coincidir con la cadena vacía, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividirá la cadena en una matriz de cadenas de carácter único porque el delimitador de cadena vacía se puede encontrar en cada ubicación.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción se produce si el tiempo de ejecución de la operación de división supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no se ha definido ningún tiempo de espera en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se inicia ninguna excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método agote el tiempo de espera después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama al método. Si un valor de tiempo de espera no se ha definido para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para dividir el texto en una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Cadena que se va a dividir.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <param name="matchTimeout">Un intervalo de tiempo de espera, o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que el método no debe agotar el tiempo de espera.</param>
        <summary>Divide una cadena de entrada en una matriz de subcadenas en las posiciones definidas por un patrón de expresión regular especificado. Los parámetros adicionales especifican las opciones que modifican la operación de coincidencia y un intervalo de tiempo de espera si no se encuentra ninguna coincidencia.</summary>
        <returns>Matriz de cadenas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos son similares a los <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> método, salvo que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres. La cadena se divide tantas veces como sea posible. Si no se encuentra ningún delimitador, el valor devuelto contiene un elemento cuyo valor es la versión original `input` cadena.  
  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Compila expresiones regulares utilizadas en llamadas a estática <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos automáticamente se almacenan en caché. Para administrar la duración de las expresiones regulares compiladas, utilice la instancia <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos.  
  
 Si varias coincidencias son adyacentes entre sí, se inserta una cadena vacía en la matriz. Por ejemplo, dividir una cadena en un solo guión hace que la matriz devuelta incluir una cadena vacía en la posición donde se encuentran dos guiones adyacentes.  
  
 Si se encuentra una coincidencia al principio o al final de la cadena de entrada, una cadena vacía se incluye al principio o al final de la matriz devuelta. En el ejemplo siguiente se usa el patrón de expresión regular `[a-z]+` para dividir una cadena de entrada de cualquier carácter alfabético en mayúscula o minúscula. Dado que la cadena comienza y termina con la coincidencia de caracteres alfabéticos, el valor del primer y último elemento de la matriz devuelta es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 Si se usan paréntesis de captura en un <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expresión, cualquier capturada texto se incluye en la matriz de cadenas resultante. Por ejemplo, si divide la cadena "ciruela-pera" con un guión colocado entre paréntesis de captura, la matriz devuelta incluye un elemento de cadena que contiene el guión.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework. En .NET Framework 1.0 y 1.1, si no se encuentra una coincidencia en el primer conjunto de paréntesis, de captura no se incluye el texto capturado de paréntesis adicionales en la matriz devuelta. Todo el texto capturado a partir de .NET Framework 2.0, también se agrega a la matriz devuelta. Por ejemplo, el código siguiente usa dos conjuntos de paréntesis de captura para extraer los elementos de una fecha, incluidos los delimitadores de fecha, de una cadena de fecha. El primer conjunto de paréntesis de captura captura el guión, y el segundo captura la barra diagonal. Si el código de ejemplo se compila y se ejecutan en .NET Framework 1.0 o 1.1, excluye los caracteres de barra diagonal; Si se compila y se ejecuta en el .NET Framework 2.0 o versiones posteriores, los incluye.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Si la expresión regular puede coincidir con la cadena vacía, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividirá la cadena en una matriz de cadenas de carácter único porque el delimitador de cadena vacía se puede encontrar en cada ubicación.  
  
 El `matchTimeout` parámetro especifica cómo tiempo una coincidencia de patrones método debe intentar encontrar una coincidencia antes de expirar. Establecer un intervalo de tiempo de espera impide que las expresiones regulares que se basan en un retroceso excesivo aparezcan deje de responder cuando procesan datos de entrada que contenga cerca de coincidencias. Para obtener más información, consulte [prácticas recomendadas para las expresiones regulares](~/docs/standard/base-types/best-practices.md) y [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Si se encuentra ninguna coincidencia en ese intervalo de tiempo, el método produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. `matchTimeout` invalida cualquier valor de tiempo de espera predeterminado definido para el dominio de aplicación en el que se ejecuta el método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
 O bien  
  
 <paramref name="matchTimeout" /> es negativo, cero o mayor que 24 días aproximadamente.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó un tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Se recomienda que establezca el <paramref name="matchTimeout" /> parámetro en un valor apropiado, como dos segundos. Si deshabilita los tiempos de espera mediante la especificación de <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor. Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones:  
  
-   Cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o está formada por texto estático. Excluye el texto que se ha dinámicamente introducidos por los usuarios.  
  
-   Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controle eficazmente coincide con, ausencia de coincidencias y casi coincide con.  
  
-   Cuando el patrón de expresión regular no contiene ningún elemento de lenguaje que se sabe que causan un retroceso excesivo al procesar a una coincidencia casi.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">Objeto que se va a rellenar con información de serialización.</param>
        <param name="context">Sitio para almacenar y recuperar los datos serializados. Este parámetro está reservado para un uso futuro.</param>
        <summary>Rellena un objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> con los datos necesarios para deserializar el objeto <see cref="T:System.Text.RegularExpressions.Regex" /> actual.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el modelo de expresión regular que se pasó al constructor <see langword="Regex" />.</summary>
        <returns>Parámetro <paramref name="pattern" /> que se pasó al constructor <see langword="Regex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `pattern` parámetro consta de los elementos de lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> es la clase base de las expresiones regulares creados por el <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> método. Estos compilan expresiones regulares use el <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> implementación de la clase base. Si se llama desde una clase derivada, el <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> método devuelve la cadena que se pasó a la <paramref name="pattern" /> parámetro de la <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> constructor de clase que se utiliza para definir la expresión regular.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Cadena de entrada que contiene el texto que se desea convertir.</param>
        <summary>Convierte los caracteres de escape de la cadena de entrada.</summary>
        <returns>Cadena de caracteres con caracteres de escape convertidos a su forma sin escape.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Unescape%2A> método realiza una de las siguientes dos transformaciones:  
  
-   Invierte la transformación realizada por el <xref:System.Text.RegularExpressions.Regex.Escape%2A> método quitando el carácter de escape ("\\") de cada carácter de escape por el método. Puede tratarse de la \\, *, +,?, &#124;, {, [, (,), ^, $,., # y caracteres de espacio en blanco. Además, la <xref:System.Text.RegularExpressions.Regex.Unescape%2A> método convierte el corchete de cierre (]) y cierre (}) dos llaves.  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> no se puede invertir una cadena de escape perfectamente porque no puede deducir con precisión qué caracteres se entre caracteres de escape  
  
-   Reemplaza la representación de caracteres no imprimibles por los propios caracteres. Por ejemplo, reemplaza \a por \x07. Las representaciones de caracteres que reemplaza son \a, \b, \e, \n, \r, \f, \t y \v.  
  
 Si el <xref:System.Text.RegularExpressions.Regex.Unescape%2A> método encuentra otras secuencias de escape que no se puede convertir, como \w o \s, produce una <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="str" /> incluye una secuencia de escape desconocida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns>
          Es <see langword="true" /> si la propiedad <see cref="P:System.Text.RegularExpressions.Regex.Options" /> contiene la opción <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns>
          Es <see langword="true" /> si la propiedad <see cref="P:System.Text.RegularExpressions.Regex.Options" /> contiene la opción <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">Intervalo de tiempo de espera que se va a comprobar.</param>
        <summary>Comprueba si un intervalo de tiempo de espera está dentro del intervalo permitido.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>