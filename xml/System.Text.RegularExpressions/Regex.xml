<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="67e7f6049333b12bfe1d234f9c97a4c28d6d4845" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39999299" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa una expresión regular inmutable.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.RegularExpressions.Regex> clase representa el motor de expresiones regulares de .NET Framework. Se puede usar para analizar rápidamente grandes cantidades de texto para buscar patrones de caracteres específicos; para extraer, editar, reemplazar o eliminar subcadenas de texto; y para agregar las cadenas extraídas a una colección para generar un informe.  
  
> [!NOTE]
>  Si su interés principal consiste en validar una cadena mediante la determinación de si se ajusta a un patrón determinado, puede usar el <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> clase.  
  
 Para usar expresiones regulares, defina el modelo que desea identificar en una secuencia de texto utilizando la sintaxis documentada en [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md). A continuación, puede, opcionalmente, crear instancias de un <xref:System.Text.RegularExpressions.Regex> objeto. Por último, llamar a un método que realiza alguna operación, como reemplazar texto que coincide con el patrón de expresión regular, o que identifica a una coincidencia de patrones.  
  
> [!NOTE]
>  Para algunos patrones de expresiones regulares comunes, consulte [ejemplos de expresiones regulares](~/docs/standard/base-types/regular-expression-examples.md). También hay una serie de bibliotecas en línea de patrones de expresiones regulares, como el de uno en [-expresiones regulares](https://www.regular-expressions.info/examples.html).  
  
<a name="remarks"></a> Para obtener más información sobre el uso de la <xref:System.Text.RegularExpressions.Regex> de clases, vea las secciones siguientes de este tema:  
  
-   [Regex de vs. Métodos String](#regex_vs_string)  
  
-   [Puertos estáticos frente a. Métodos de instancia](#static_vs_instance)  
  
-   [Realizar operaciones de expresiones regulares](#regex_ops)  
  
-   [Definir un valor de tiempo de espera](#define_timeout)  
  
 Para obtener más información acerca del lenguaje de expresiones regulares, consulte [Lenguaje de expresiones regulares - Referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md) o descargue e imprima uno de estos folletos:  
  
 [Referencia rápida en formato Word (.docx)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [Referencia rápida en formato PDF (.pdf)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Regex de vs. Métodos String  
 La <xref:System.String?displayProperty=nameWithType> clase incluye varios métodos de búsqueda y comparación que puede usar para realizar la coincidencia de patrones con texto. Por ejemplo, el <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, y <xref:System.String.StartsWith%2A?displayProperty=nameWithType> métodos determinan si una instancia de la cadena contiene una subcadena especificada; y la <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, y <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> métodos devuelven la fecha inicial posición de una subcadena especificada en una cadena. Utilice los métodos de la <xref:System.String?displayProperty=nameWithType> al buscar una cadena específica de la clase. Use la <xref:System.Text.RegularExpressions.Regex> clase cuando se está buscando un patrón específico en una cadena. Para obtener más información y ejemplos, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
 [Volver a comentarios](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>Puertos estáticos frente a. Métodos de instancia  
 Después de definir un patrón de expresión regular, se puede proporcionar al motor de expresiones regulares de dos maneras:  
  
-   Creando un <xref:System.Text.RegularExpressions.Regex> objeto que representa la expresión regular. Para ello, pase el patrón de expresión regular a una <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> constructor. Un <xref:System.Text.RegularExpressions.Regex> objeto es inmutable; al crear una instancia un <xref:System.Text.RegularExpressions.Regex> objeto con una expresión regular, que no se puede cambiar la expresión regular del objeto.  
  
-   Si se suministra la expresión regular y el texto que desea buscar en un `static` (`Shared` en Visual Basic) <xref:System.Text.RegularExpressions.Regex> método. Esto le permite usar una expresión regular sin crear explícitamente un <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 Todos los <xref:System.Text.RegularExpressions.Regex> métodos de identificación de modelo son estáticos y de instancia de sobrecargas.  
  
 El motor de expresiones regulares debe compilar un modelo determinado antes de que se puede usar el patrón. Dado que <xref:System.Text.RegularExpressions.Regex> los objetos son inmutables, se trata de un procedimiento único que se produce cuando un <xref:System.Text.RegularExpressions.Regex> se denomina constructor de clase o un método estático. Para eliminar la necesidad de compilar varias veces una única expresión regular, el motor de expresiones regulares almacena en caché las expresiones regulares compiladas que se utilizan en llamadas a métodos estáticos. Como resultado, los métodos de coincidencia de patrón de expresión regular ofrecen un rendimiento comparable para estáticos y métodos de instancia.  
  
> [!IMPORTANT]
>  Si se usaron en la instancia o método estático en las expresiones regulares de .NET Framework versiones 1.0 y 1.1, todos los compilados, llama a, se almacenaron en caché. A partir de .NET Framework 2.0, solo las expresiones regulares usadas en llamadas a métodos estáticos se almacenan en caché.  
  
 Sin embargo, el almacenamiento en caché puede afectar negativamente al rendimiento en los dos casos siguientes:  
  
-   Al utilizar llamadas a métodos estáticos con un gran número de expresiones regulares. De forma predeterminada, el motor de expresiones regulares almacena en caché las 15 expresiones regulares estáticas usadas más recientemente. Si la aplicación usa más de 15 expresiones regulares estáticas, se deben volver a compilar algunas expresiones regulares. Para evitar que esta recompilación, puede aumentar el <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> propiedad.  
  
-   Cuando se crea una instancia nueva <xref:System.Text.RegularExpressions.Regex> objetos con expresiones regulares que se han compilado previamente. Por ejemplo, el código siguiente define una expresión regular para buscar palabras duplicadas en una secuencia de texto. Aunque el ejemplo utiliza una expresión regular única, crea una instancia de un nuevo <xref:System.Text.RegularExpressions.Regex> objeto para procesar cada línea de texto. Esto da como resultado la recompilación de la expresión regular con cada iteración del bucle.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     Para evitar volver a compilar, debe crear una instancia de una sola <xref:System.Text.RegularExpressions.Regex> objeto que es accesible a todo el código que lo requiera, como se muestra en el ejemplo siguiente se ha vuelto a escribir.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [Volver a comentarios](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>Realizar operaciones de expresiones regulares  
 Si decide crear una instancia de un <xref:System.Text.RegularExpressions.Regex> de objeto y llamar a sus métodos o llamar a métodos estáticos, el <xref:System.Text.RegularExpressions.Regex> clase ofrece las siguientes funciones de coincidencia de patrones:  
  
-   Validación de una coincidencia. Se llama a la <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método para determinar si se encuentra una coincidencia.  
  
-   Recuperación de una coincidencia única. Se llama a la <xref:System.Text.RegularExpressions.Regex.Match%2A> método para recuperar un <xref:System.Text.RegularExpressions.Match> objeto que representa la primera coincidencia en una cadena o en parte de una cadena. Se pueden recuperar las coincidencias subsiguientes llamando el <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método.  
  
-   Recuperación de todas las coincidencias. Se llama a la <xref:System.Text.RegularExpressions.Regex.Matches%2A> método para recuperar un <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> objeto que representa todas las coincidencias encontradas en una cadena o en parte de una cadena.  
  
-   Sustitución del texto coincidente. Se llama a la <xref:System.Text.RegularExpressions.Regex.Replace%2A> método para reemplazar el texto coincidente. El texto de reemplazo también puede definirse mediante una expresión regular. Además, algunos de los <xref:System.Text.RegularExpressions.Regex.Replace%2A> métodos incluyen un <xref:System.Text.RegularExpressions.MatchEvaluator> parámetro que le permite definir mediante programación el texto de reemplazo.  
  
-   Creación de una matriz de cadenas que se forma a partir de partes de una cadena de entrada. Se llama a la <xref:System.Text.RegularExpressions.Regex.Split%2A> método dividir una cadena de entrada en las posiciones definidas por la expresión regular.  
  
 Además de sus métodos de coincidencia de patrones, el <xref:System.Text.RegularExpressions.Regex> clase incluye varios métodos de propósito especial:  
  
-   El <xref:System.Text.RegularExpressions.Regex.Escape%2A> método escapes de caracteres que se pueden interpretar como operadores de expresión regular en una expresión regular o una cadena de entrada.  
  
-   El <xref:System.Text.RegularExpressions.Regex.Unescape%2A> método quita estos caracteres de escape.  
  
-   El <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> método crea un ensamblado que contiene expresiones regulares predefinidas. .NET Framework contiene ejemplos de estos ensamblados de propósito especial en el <xref:System.Web.RegularExpressions?displayProperty=nameWithType> espacio de nombres.  
  
 [Volver a comentarios](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>Definir un valor de tiempo de espera  
 .NET Framework admite un lenguaje de expresión regular completa que proporciona sustancial eficacia y flexibilidad en la coincidencia de patrones. Sin embargo, la eficacia y flexibilidad vienen con cierto costo: el riesgo de un rendimiento deficiente. Las expresiones regulares que un rendimiento deficiente son sorprendentemente fáciles de crear. En algunos casos, las operaciones de expresión regular que se basan en el retroceso excesivo pueden aparecer deje de responder cuando procesa el texto que casi coincide con el patrón de expresión regular. Para obtener más información sobre el motor de expresiones regulares de .NET Framework, vea [detalles del comportamiento de expresiones regulares](~/docs/standard/base-types/details-of-regular-expression-behavior.md). Para obtener más información sobre el retroceso excesivo, consulte [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], puede definir un intervalo de tiempo de espera para las coincidencias de expresiones regulares. Si el motor de expresiones regulares no puede identificar una coincidencia dentro de este intervalo de tiempo, la operación de coincidencia produce un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. En la mayoría de los casos, esto impide que el motor de expresiones regulares desperdiciar potencia de procesamiento al tratar de coincidir con el texto que casi coincide con el patrón de expresión regular. También podría indicar, sin embargo, que el intervalo de tiempo de espera se ha establecido demasiado bajo, o que la carga actual de la máquina ha causado una degradación general del rendimiento.  
  
 Cómo controlar la excepción depende de la causa de la excepción. Si la excepción se produce porque el intervalo de tiempo de espera se establece demasiado bajo, o debido a la carga de la máquina excesivo, puede aumentar el intervalo de tiempo de espera y vuelva a intentar la operación de coincidencia. Si la excepción se produce porque la expresión regular se basa en un retroceso excesivo, puede suponer que no existe una coincidencia, y, opcionalmente, puede registrar información que le ayudarán a modificar el patrón de expresión regular.  
  
 Puede establecer un intervalo de tiempo de espera mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor al crear instancias de un objeto de expresión regular. Para los métodos estáticos, puede establecer un intervalo de tiempo de espera mediante una llamada a una sobrecarga de un método coincidente que tenga un `matchTimeout` parámetro. Si no establece explícitamente un valor de tiempo de espera, el valor de tiempo de espera predeterminado se determina como sigue:  
  
-   Utilizando el tiempo de espera de toda la aplicación el valor, si existe. Esto puede ser cualquier valor de tiempo de espera que se aplica al dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea una instancia de objeto o se realiza la llamada al método estático. Puede establecer el valor de tiempo de espera de toda la aplicación mediante una llamada a la <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> método para asignar una representación de cadena de un <xref:System.TimeSpan> valor a la propiedad "REGEX_DEFAULT_MATCH_TIMEOUT".  
  
-   Con el valor <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, si no se ha establecido ningún valor de tiempo de espera de toda la aplicación.  
  
> [!IMPORTANT]
>  Se recomienda que establezca un valor de tiempo de espera en todas las operaciones de coincidencia de patrones de expresiones regulares. Para obtener más información, consulte [procedimientos recomendados con expresiones regulares](~/docs/standard/base-types/best-practices.md).  
  
 [Volver a comentarios](#remarks)  
  
   
  
## Examples  
 En el ejemplo siguiente se usa una expresión regular para comprobar las apariciones repetidas de palabras en una cadena. La expresión regular `\b(?<word>\w+)\s+(\k<word>)\b` puede interpretarse como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Comenzar la búsqueda de coincidencias en un límite de palabras.|  
|`(?<word>\w+)`|Coincide con uno o más caracteres de palabra hasta un límite de palabras. Nombre de este grupo capturado `word`.|  
|`\s+`|Coincide con uno o más caracteres de espacio en blanco.|  
|`(\k<word>)`|Coincide con el grupo capturado denominada `word`.|  
|`\b`|Coincide con un límite de palabras.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 El ejemplo siguiente muestra el uso de una expresión regular para comprobar si una cadena representa un valor de divisa o tiene el formato correcto para representar un valor de moneda. En este caso, se genera dinámicamente la expresión regular de la <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, y <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> las propiedades de la referencia cultural del usuario. Si el sistema actual de la referencia cultural es en-US, la expresión regular resultante es `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`. Esta expresión regular puede interpretarse como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`^`|Comience desde el principio de la cadena.|  
|`\s*`|Busca coincidencias con cero o más caracteres de espacio en blanco.|  
|`[\+-]?`|Coincide con cero o una aparición del signo positivo o el signo negativo.|  
|`\s?`|Busca coincidencias con cero o un carácter de espacio en blanco.|  
|`\$?`|Coincide con cero o una aparición del signo de dólar.|  
|`\s?`|Busca coincidencias con cero o un carácter de espacio en blanco.|  
|`\d*`|Busca cero o más dígitos decimales.|  
|`\.?`|Coincide con cero o un símbolo de separador decimal.|  
|`\d{2}?`|Coincide con cero o una vez de dos dígitos decimales.|  
|`(\d*\.?\d{2}?){1}`|Coincide con el patrón de dígitos enteros y fraccionarios, separados por un símbolo de separador decimal al menos una vez.|  
|`$`|Coincide con el final de la cadena.|  
  
 En este caso, la expresión regular se da por supuesto que una cadena de divisa válida no contiene símbolos de separador de grupo y que tiene ningún dígito fraccionario o el número de dígitos fraccionarios definido por la referencia cultural actual <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> propiedad.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 Dado que la expresión regular en este ejemplo se genera dinámicamente, no sabemos en tiempo de diseño si el símbolo de divisa de la referencia cultural actual, signo decimal o signos positivos y negativos se pueden malinterpretar por el motor de expresiones regulares como normales operadores de lenguaje de expresión. Para evitar los errores de interpretación, el ejemplo pasa cada cadena generada dinámicamente a la <xref:System.Text.RegularExpressions.Regex.Escape%2A> método.  
  
 ]]></format>
    </remarks>
    <threadsafe>La <see cref="T:System.Text.RegularExpressions.Regex" /> clase es inmutable (de solo lectura) y es seguro para subprocesos. <see cref="T:System.Text.RegularExpressions.Regex" /> los objetos se pueden crear en cualquier subproceso y compartirlos entre varios subprocesos. Para obtener más información, consulte [Thread Safety](~/docs/standard/base-types/thread-safety-in-regular-expressions.md).</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que este constructor está protegido; solo se puede llamar mediante las clases derivadas de la <xref:System.Text.RegularExpressions.Regex> clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.RegularExpressions.Regex" /> para la expresión regular especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea el [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md) temas.  
  
 Una llamada a la <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> es equivalente a llamar al constructor el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> constructor con un valor de <xref:System.Text.RegularExpressions.RegexOptions.None> para el `options` argumento.  
  
 Un <xref:System.Text.RegularExpressions.Regex> objeto es inmutable, lo que significa que puede usarse solo para el patrón de coincidencia definen al crearla. Sin embargo, puede usar cualquier número de veces sin que se vuelven a compilar.  
  
 Este constructor crea una instancia de un objeto de expresión regular que se trata de una coincidencia entre mayúsculas y minúsculas de cualquier carácter alfabético definido en `pattern`. Para una coincidencia de mayúsculas y minúsculas, utilice el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> constructor.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo utilizar este constructor para crear una instancia de una expresión regular que coincide con cualquier palabra que comience con las letras "a" o "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 Tenga en cuenta que el patrón de expresión regular no coincide con la palabra "The" al principio del texto, dado que las comparaciones distinguen entre mayúsculas y minúsculas de forma predeterminada. Para obtener un ejemplo de comparación entre mayúsculas y minúsculas, consulte el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> es <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Este constructor crea un <see cref="T:System.Text.RegularExpressions.Regex" /> objeto que utiliza el valor de tiempo de espera predeterminado del dominio de aplicación en el que se crea. Si no se ha definido un valor de tiempo de espera para el dominio de aplicación, el <see cref="T:System.Text.RegularExpressions.Regex" /> objeto usa el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, lo que impide que la operación de tiempo de espera. El constructor recomendados para la creación de un <see cref="T:System.Text.RegularExpressions.Regex" /> objeto es <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Objeto que contiene un modelo serializado e información de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</param>
        <param name="context">Destino de esta serialización. (Este parámetro no se usa; especifique <see langword="null" />).</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.RegularExpressions.Regex" /> con datos serializados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">El modelo que contiene <paramref name="info" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="info" /> contiene una marca <see cref="T:System.Text.RegularExpressions.RegexOptions" /> no válida.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que modifican la expresión regular.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.RegularExpressions.Regex" /> para la expresión regular especificada, con opciones que modifican el modelo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea el [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md) temas.  
  
 Un <xref:System.Text.RegularExpressions.Regex> objeto es inmutable, lo que significa que puede usarse solo para los parámetros de coincidencia definen al crearla. Sin embargo, puede usar cualquier número de veces sin que se vuelven a compilar.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo utilizar este constructor para crear una instancia de una expresión regular que coincide con cualquier palabra que comience con las letras "a" o "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 Tenga en cuenta que la colección de coincidencias incluye la palabra "The" que comienza el texto dado el `options` parámetro definió las comparaciones entre mayúsculas y minúsculas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> contiene una marca no válida.</exception>
        <block subset="none" type="usage">
          <para>Este constructor crea un <see cref="T:System.Text.RegularExpressions.Regex" /> objeto que utiliza el valor de tiempo de espera predeterminado del dominio de aplicación en el que se crea. Si no se ha definido un valor de tiempo de espera para el dominio de aplicación, el <see cref="T:System.Text.RegularExpressions.Regex" /> objeto usa el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, lo que impide que la operación de tiempo de espera. El constructor recomendados para la creación de un <see cref="T:System.Text.RegularExpressions.Regex" /> objeto es <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que modifican la expresión regular.</param>
        <param name="matchTimeout">Un intervalo de tiempo de espera, o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que el método no debe agotar el tiempo de espera.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.RegularExpressions.Regex" /> para la expresión regular especificada, con las opciones que modifican el modelo y un valor que especifica cuánto tiempo debe intentar un método de coincidencia de modelos una coincidencia antes de que se agote el tiempo de espera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea el [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md) temas.  
  
 Un <xref:System.Text.RegularExpressions.Regex> objeto es inmutable, lo que significa que puede usarse solo para el patrón de coincidencia que se define cuando se crea. Sin embargo, puede usar cualquier número de veces sin que se vuelven a compilar.  
  
 El `matchTimeout` parámetro especifica cuánto tiempo un patrón de coincidencia de método debe intentar buscar una coincidencia antes de expirar. Si no se encuentra ninguna coincidencia en ese intervalo de tiempo, el método de coincidencia de patrones se produce un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. `matchTimeout` invalida cualquier valor de tiempo de espera predeterminado definido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Los métodos de coincidencia de patrones de instancia que observarán el `matchTimeout` intervalo de tiempo de espera incluyen lo siguiente:  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 Establecer un intervalo de tiempo de espera evita que las expresiones regulares que se basan en un retroceso excesivo aparezcan deje de responder al procesar la entrada que contenga cerca de coincidencias. Para obtener más información, consulte [procedimientos recomendados con expresiones regulares](~/docs/standard/base-types/best-practices.md) y [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Para establecer un intervalo de tiempo de espera razonable, tenga en cuenta los siguientes factores:  
  
-   La longitud y complejidad del patrón de expresión regular. Las expresiones regulares más largas y complejas requieren más tiempo que las más cortas y sencillas.  
  
-   La carga esperado de la máquina. Procesamiento tarda más tiempo en sistemas que tienen un uso alto de CPU y memoria.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor para crear instancias de un <xref:System.Text.RegularExpressions.Regex> objeto con un valor de tiempo de espera de un segundo. El patrón de expresión regular `(a+)+$`, que coincide con una o más secuencias de uno o varios caracteres "a" al final de una línea, está sujeto a un retroceso excesivo. Si un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es produce, el ejemplo incrementa el valor de tiempo de espera hasta el valor máximo de tres segundos. En caso contrario, abandona el intento de hacer coincidir el patrón.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es un valor <see cref="T:System.Text.RegularExpressions.RegexOptions" /> válido.  
  
O bien 
 <paramref name="matchTimeout" /> es negativo, cero o mayor que 24 días aproximadamente.</exception>
        <block subset="none" type="usage">
          <para>Se recomienda que establezca el <paramref name="matchTimeout" /> parámetro a un valor apropiado, como dos segundos. Si deshabilita los tiempos de espera mediante la especificación de <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor. Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones: - cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o formado por texto estático. Excluye el texto que ha sido dinámicamente por usuarios.  -Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controla con gran eficacia coincide, la ausencia de coincidencias y próximo coincide con.  -Cuando el patrón de expresión regular contiene ningún elemento de lenguaje que causan un retroceso excesivo al procesar a una coincidencia casi.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número máximo de entradas en la memoria caché estática actual de expresiones regulares compiladas.</summary>
        <value>Número máximo de entradas en la memoria caché estática.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.RegularExpressions.Regex> clase mantiene una memoria caché interna de expresiones regulares compiladas que se utilizan en llamadas a métodos estáticos. Si el valor especificado en una operación set es menor que el tamaño de caché actual, se descartan las entradas de caché hasta que el tamaño de caché es igual al valor especificado.  
  
 De forma predeterminada, la memoria caché contiene 15 expresiones regulares estáticas compiladas. La aplicación normalmente no tendrá que modificar el tamaño de la memoria caché. Use el <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> propiedad solo cuando desee desactivar el almacenamiento en caché o cuando tiene una caché inusualmente grande.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de una operación Set es menor que cero.</exception>
        <block subset="none" type="usage">
          <para>En .NET Framework anteriores a la [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], utilizar expresiones regulares en estáticos y llamadas a métodos de instancia se almacenaron en caché. A partir del [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], sólo normales se almacenan en caché las expresiones usadas en llamadas a métodos estáticos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un diccionario que asigna grupos de captura denominados con sus valores de índice.</summary>
        <value>Diccionario que asigna grupos de captura denominados con sus valores de índice.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que esta propiedad está protegida; solo se puede acceder desde una clase derivada de la <xref:System.Text.RegularExpressions.Regex> clase.  
  
 Una operación de establecimiento intenta convertir el valor asignado a la propiedad a un <xref:System.Collections.Hashtable> objeto; si se produce un error en esta conversión, llama a la <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor asignado a la propiedad <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> en una operación set es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un diccionario que asigna grupos de captura numerados con sus valores de índice.</summary>
        <value>Diccionario que asigna grupos de captura numerados con sus valores de índice.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que esta propiedad está protegida; solo se puede acceder desde una clase derivada de la <xref:System.Text.RegularExpressions.Regex> clase.  
  
 Una operación de establecimiento intenta convertir el valor asignado a la propiedad a un <xref:System.Collections.Hashtable> objeto; si se produce un error en esta conversión, llama a la <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor asignado a la propiedad <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> en una operación set es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compila expresiones regulares y las guarda en disco en un ensamblado único.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

En .NET Core, las llamadas a la `Regex.CompileToAssembly` método throw un <xref:System.PlatformNotSupportedException>; no se admite la escritura de un ensamblado.
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Matriz que describe las expresiones regulares que se van a compilar.</param>
        <param name="assemblyname">El nombre de archivo del ensamblado.</param>
        <summary>Compila uno o varios objetos <see cref="T:System.Text.RegularExpressions.Regex" /> especificados en un ensamblado con nombre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> método genera un ensamblado de .NET Framework en la que cada expresión regular definida en la `regexinfos` matriz representada por una clase. Normalmente, el <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> se llama al método desde una aplicación independiente que genera un ensamblado de expresiones regulares compiladas. Las expresiones regulares que se incluyen en el ensamblado tiene las siguientes características:  
  
-   Se deriva el <xref:System.Text.RegularExpressions.Regex> clase.  
  
-   Se asigna el nombre completo que está definido por el `fullnamespace` y `name` parámetros correspondiente <xref:System.Text.RegularExpressions.RegexCompilationInfo> objeto.  
  
-   Tiene un valor predeterminado (o sin parámetros) constructor.  
  
 Normalmente, el código que crea una instancia y usa la expresión regular compilada se encuentra en un ensamblado o una aplicación que es independiente del código que crea el ensamblado.  
  
   
  
## Examples  
 El ejemplo siguiente crea un ensamblado denominado RegexLib.dll. El ensamblado incluye dos expresiones regulares compiladas. La primera, `Utilities.RegularExpressions.DuplicatedString`, coincide con dos palabras contiguas idénticas. El segundo, `Utilities.RegularExpressions.EmailAddress`, comprueba si una cadena tiene el formato correcto para una dirección de correo electrónico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 La expresión regular que comprueba las palabras duplicadas en una cadena, a continuación, se crea y se usa en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Compilación correcta de este segundo ejemplo requiere una referencia a RegexLib.dll (el ensamblado creado por el primer ejemplo) que se agrega al proyecto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de la propiedad <see cref="P:System.Reflection.AssemblyName.Name" /> del parámetro <paramref name="assemblyname" /> es una cadena vacía o NULL.  
  
O bien 
El modelo de expresión regular de uno o varios objetos de <paramref name="regexinfos" /> contiene una sintaxis no válida.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="assemblyname" /> o <paramref name="regexinfos" /> es <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: no se admite la creación de un ensamblado de expresiones regulares compiladas.</exception>
        <block subset="none" type="usage">
          <para>Si está desarrollando en un sistema que tiene [!INCLUDE[net_v45](~/includes/net-v45-md.md)] o sus versiones secundarias instalados, tener como destino [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], y usar el <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> método para crear un ensamblado que contiene expresiones regulares compiladas. Intentando usar una de las expresiones regulares de ese ensamblado en un sistema que tiene [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] produce una excepción. Para solucionar este problema, puede realizar una de las siguientes opciones:-compilar el ensamblado que contiene las expresiones regulares compiladas en un sistema que tiene [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] en lugar de una versión posterior.  -En lugar de llamar a <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> y recuperar la expresión regular compilada de un ensamblado, utilice sea estático o de instancia <see cref="T:System.Text.RegularExpressions.Regex" /> métodos con el <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opción al crear instancias de un <see cref="T:System.Text.RegularExpressions.Regex" /> de objeto o llamar a una expresión regular método de coincidencia de patrón.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Matriz que describe las expresiones regulares que se van a compilar.</param>
        <param name="assemblyname">El nombre de archivo del ensamblado.</param>
        <param name="attributes">Matriz que define los atributos que se van a aplicar al ensamblado.</param>
        <summary>Compila uno o varios objetos <see cref="T:System.Text.RegularExpressions.Regex" /> especificados en un ensamblado con nombre que tiene los atributos especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> método genera un ensamblado de .NET Framework en la que cada expresión regular definida en la `regexinfos` matriz representada por una clase. Normalmente, el <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> se llama al método desde una aplicación independiente que genera un ensamblado de expresiones regulares compiladas. Las expresiones regulares que se incluyen en el ensamblado tiene las siguientes características:  
  
-   Se deriva el <xref:System.Text.RegularExpressions.Regex> clase.  
  
-   Se asigna el nombre completo que está definido por el `fullnamespace` y `name` parámetros correspondiente <xref:System.Text.RegularExpressions.RegexCompilationInfo> objeto.  
  
-   Tiene un valor predeterminado (o sin parámetros) constructor.  
  
 Normalmente, el código que crea una instancia y usa la expresión regular compilada se encuentra en un ensamblado o una aplicación que es independiente del código que crea el ensamblado.  
  
 Dado que el <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> método genera un ensamblado de .NET Framework desde una llamada de método en lugar de usar la palabra clave de definición de clase de un lenguaje determinado (como `class` en C# o `Class`...`End Class` en Visual Basic), no permiten atributos de .NET Framework que se asignará al ensamblado mediante la sintaxis de atributo estándar del lenguaje de desarrollo. El `attributes` parámetro proporciona un método alternativo para definir los atributos que se aplican al ensamblado. Para cada atributo que desea aplicar al ensamblado, haga lo siguiente:  
  
1.  Crear una matriz de <xref:System.Type> objetos que representan los tipos de parámetro del constructor del atributo que desea llamar.  
  
2.  Recuperar un <xref:System.Type> objeto que representa la clase de atributo que desea aplicar al nuevo ensamblado.  
  
3.  Llame a la <xref:System.Type.GetConstructor%2A> método del atributo <xref:System.Type> objeto para recuperar un <xref:System.Reflection.ConstructorInfo> objeto que representa el constructor de atributo que desea llamar. Pase el <xref:System.Type.GetConstructor%2A> método la matriz de <xref:System.Type> objetos que representan tipos de parámetro del constructor.  
  
4.  Crear un <xref:System.Object> matriz que define los parámetros que se pasan al constructor del atributo.  
  
5.  Crear una instancia de un <xref:System.Reflection.Emit.CustomAttributeBuilder> pasando su constructor la <xref:System.Reflection.ConstructorInfo> objeto recuperado en el paso 3 y el <xref:System.Object> matriz creada en el paso 4.  
  
 A continuación, puede pasar una matriz de estos <xref:System.Reflection.Emit.CustomAttributeBuilder> objetos en lugar de la `attributes` parámetro para el <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 El ejemplo siguiente se crea un ensamblado denominado RegexLib.dll y aplica la <xref:System.Reflection.AssemblyTitleAttribute> atributo. El ensamblado incluye dos expresiones regulares compiladas. La primera, `Utilities.RegularExpressions.DuplicatedString`, coincide con dos palabras contiguas idénticas. El segundo, `Utilities.RegularExpressions.EmailAddress`, comprueba si una cadena tiene el formato correcto para una dirección de correo electrónico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 Puede comprobar que la <xref:System.Reflection.AssemblyTitleAttribute> se ha aplicado el atributo al ensamblado examinando su manifiesto con una utilidad de reflexión como ILDasm.  
  
 La expresión regular que comprueba las palabras duplicadas en una cadena, a continuación, se crea y se usa en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Compilación correcta de este segundo ejemplo requiere una referencia a RegexLib.dll (el ensamblado creado por el primer ejemplo) que se agrega al proyecto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de la propiedad <see cref="P:System.Reflection.AssemblyName.Name" /> del parámetro <paramref name="assemblyname" /> es una cadena vacía o NULL.  
  
O bien 
El modelo de expresión regular de uno o varios objetos de <paramref name="regexinfos" /> contiene una sintaxis no válida.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="assemblyname" /> o <paramref name="regexinfos" /> es <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: no se admite la creación de un ensamblado de expresiones regulares compiladas.</exception>
        <block subset="none" type="usage">
          <para>Si está desarrollando en un sistema que tiene [!INCLUDE[net_v45](~/includes/net-v45-md.md)] o sus versiones secundarias instalados, tener como destino [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], y usar el <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> método para crear un ensamblado que contiene expresiones regulares compiladas. Intentando usar una de las expresiones regulares de ese ensamblado en un sistema que tiene [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] produce una excepción. Para solucionar este problema, puede realizar una de las siguientes opciones:-compilar el ensamblado que contiene las expresiones regulares compiladas en un sistema que tiene [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] en lugar de una versión posterior.  -En lugar de llamar a <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> y recuperar la expresión regular compilada de un ensamblado, utilice sea estático o de instancia <see cref="T:System.Text.RegularExpressions.Regex" /> métodos con el <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opción al crear instancias de un <see cref="T:System.Text.RegularExpressions.Regex" /> de objeto o llamar a una expresión regular método de coincidencia de patrón.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
        <Parameter Name="resourceFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Matriz que describe las expresiones regulares que se van a compilar.</param>
        <param name="assemblyname">El nombre de archivo del ensamblado.</param>
        <param name="attributes">Matriz que define los atributos que se van a aplicar al ensamblado.</param>
        <param name="resourceFile">Nombre del archivo de recursos Win32 que se va a incluir en el ensamblado.</param>
        <summary>Compila uno o varios objetos <see cref="T:System.Text.RegularExpressions.Regex" /> especificados y un archivo de recursos especificado en un ensamblado con nombre que tiene los atributos indicados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName% 2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 > método genera un ensamblado de .NET Framework en la que cada expresión regular definida en la `regexinfos` matriz representada por una clase. Normalmente, el [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D% 2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 > se llama al método desde una aplicación independiente que genera un ensamblado de expresiones regulares compiladas. Las expresiones regulares que se incluyen en el ensamblado tiene las siguientes características:  
  
-   Se deriva el <xref:System.Text.RegularExpressions.Regex> clase.  
  
-   Se asigna el nombre completo que está definido por el `fullnamespace` y `name` parámetros correspondiente <xref:System.Text.RegularExpressions.RegexCompilationInfo> objeto.  
  
-   Tiene un valor predeterminado (o sin parámetros) constructor.  
  
 Normalmente, el código que crea una instancia y usa la expresión regular compilada se encuentra en un ensamblado o una aplicación que es independiente del código que crea el ensamblado.  
  
 Dado que el <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> método genera un ensamblado de .NET Framework desde una llamada de método en lugar de usar la palabra clave de definición de clase de un lenguaje determinado (como `class` en C# o `Class`...`End Class` en Visual Basic), no permiten atributos de .NET Framework que se asignará al ensamblado mediante la sintaxis de atributo estándar del lenguaje de desarrollo. El `attributes` parámetro proporciona un método alternativo para definir los atributos que se aplican al ensamblado. Para cada atributo que desea aplicar al ensamblado, haga lo siguiente:  
  
1.  Crear una matriz de <xref:System.Type> objetos que representan los tipos de parámetro del constructor del atributo que desea llamar.  
  
2.  Recuperar un <xref:System.Type> objeto que representa la clase de atributo que desea aplicar al nuevo ensamblado.  
  
3.  Llame a la <xref:System.Type.GetConstructor%2A> método del atributo <xref:System.Type> objeto para recuperar un <xref:System.Reflection.ConstructorInfo> objeto que representa el constructor de atributo que desea llamar. Pase el <xref:System.Type.GetConstructor%2A> método la matriz de <xref:System.Type> objetos que representan tipos de parámetro del constructor  
  
4.  Crear un <xref:System.Object> matriz que define los parámetros que se pasan al constructor del atributo.  
  
5.  Crear una instancia de un <xref:System.Reflection.Emit.CustomAttributeBuilder> pasando su constructor la <xref:System.Reflection.ConstructorInfo> objeto recuperado en el paso 3 y el <xref:System.Object> matriz creada en el paso 4.  
  
 A continuación, puede pasar una matriz de estos <xref:System.Reflection.Emit.CustomAttributeBuilder> objetos en lugar de la `attributes` parámetro para el [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly% 28System.Text.RegularExpressions.RegexCompilationInfo%5b%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 > método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de la propiedad <see cref="P:System.Reflection.AssemblyName.Name" /> del parámetro <paramref name="assemblyname" /> es una cadena vacía o NULL.  
  
O bien 
El modelo de expresión regular de uno o varios objetos de <paramref name="regexinfos" /> contiene una sintaxis no válida.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="assemblyname" /> o <paramref name="regexinfos" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">El parámetro <paramref name="resourceFile" /> designa un archivo de recursos de Win32 no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se pudo encontrar el archivo designado por el parámetro <paramref name="resourceFile" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: no se admite la creación de un ensamblado de expresiones regulares compiladas.</exception>
        <block subset="none" type="usage">
          <para>Si está desarrollando en un sistema que tiene [!INCLUDE[net_v45](~/includes/net-v45-md.md)] o sus versiones secundarias instalados, tener como destino [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], y usar el <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> método para crear un ensamblado que contiene expresiones regulares compiladas. Intentando usar una de las expresiones regulares de ese ensamblado en un sistema que tiene [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] produce una excepción. Para solucionar este problema, puede realizar una de las siguientes opciones:-compilar el ensamblado que contiene las expresiones regulares compiladas en un sistema que tiene [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] en lugar de una versión posterior.  -En lugar de llamar a <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> y recuperar la expresión regular compilada de un ensamblado, utilice sea estático o de instancia <see cref="T:System.Text.RegularExpressions.Regex" /> métodos con el <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opción al crear instancias de un <see cref="T:System.Text.RegularExpressions.Regex" /> de objeto o llamar a una expresión regular método de coincidencia de patrón.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Cadena de entrada que contiene el texto que se va a convertir.</param>
        <summary>Convierte en caracteres de escape un juego mínimo de caracteres (\\, *, +, ?, |, {, [, (,), ^, $,., # y espacio en blanco) al reemplazarlos con sus códigos de escape. Esto indica al motor de expresiones regulares que interprete los caracteres literalmente en lugar de como metacaracteres.</summary>
        <returns>Cadena de caracteres con metacaracteres convertidos a su forma de escape.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> Convierte una cadena para que el motor de expresiones regulares interprete los metacaracteres que pueda contener como literales de carácter. Por ejemplo, considere la posibilidad de una expresión regular que se ha diseñado para extraer comentarios que están delimitados por la recta de apertura y cierre entre corchetes ([y]) del texto. En el ejemplo siguiente, la expresión regular "[(.*?)]" se interpreta como una clase de caracteres. En lugar de la coincidencia con comentarios insertados en el texto de entrada, la expresión regular coincide con cada apertura o paréntesis de cierre, período, un asterisco o signo de interrogación.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 Sin embargo, si el corchete de apertura se escape pasándolo a la <xref:System.Text.RegularExpressions.Regex.Escape%2A> método, la expresión regular logre en la coincidencia de los comentarios que se incrustan en la cadena de entrada. Esto se ilustra en el siguiente ejemplo:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 En una expresión regular que se define mediante el uso de texto estático, se pueden escapar los caracteres que tienen que interpretarse literalmente en lugar de como metacaracteres precediéndolas con un símbolo de barra diagonal inversa (\\), así como mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.Escape%2A> método. En una expresión regular que se define dinámicamente utilizando caracteres que no se conocen en tiempo de diseño, una llamada a la <xref:System.Text.RegularExpressions.Regex.Escape%2A> método es especialmente importante para asegurarse de que el motor de expresiones regulares interpreta los caracteres individuales como literales en su lugar de como metacaracteres.  
  
> [!NOTE]
>  Si un patrón de expresión regular incluye el signo de número (#) o caracteres de espacio en blanco literales, deben convertirse si se analiza el texto de entrada con el <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opción habilitada.  
  
 Mientras el <xref:System.Text.RegularExpressions.Regex.Escape%2A> método antepone la recta abrir corchete ([) y abrir llaves ({}), no escape sus correspondientes caracteres de cierre (] y}). En la mayoría de los casos, estas secuencias de escape no es necesario. Si un corchete o llave no está precedido por el carácter de apertura correspondiente, el motor de expresiones regulares lo interpreta literalmente. Si una llave o soporte de apertura se interpreta como un metacarácter, el motor de expresiones regulares interpreta la correspondiente primer carácter como un metacarácter de cierre. Si esto no es el comportamiento deseado, el corchete o llave debe convertirse en escape anteponiendo explícitamente la barra diagonal inversa (\\) caracteres. Para obtener un ejemplo, vea la sección ejemplo.  
  
   
  
## Examples  
 El ejemplo siguiente extrae los comentarios de texto. Se supone que los comentarios se delimitan mediante un símbolo de comentario begin y un símbolo de comentario de final seleccionado por el usuario. Dado que son los símbolos de comentario debe interpretarse literalmente, se pasan a la <xref:System.Text.RegularExpressions.Regex.Escape%2A> método para asegurarse de que no se puede malinterpretarse como metacaracteres. Además, el ejemplo comprueba explícitamente si el símbolo de comentario de final escrito por el usuario es un corchete de cierre (]) o una llave (}). Si es así, un carácter de barra diagonal inversa (\\) se antepone al corchete o llave de modo que se interpreta literalmente. Tenga en cuenta que el ejemplo también usa el <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> colección para mostrar solo el comentario, en lugar del comentario junto con sus símbolos de comentario de apertura y cierre.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Regex ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="regex.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz de nombres de grupo de captura para la expresión regular.</summary>
        <returns>Matriz de cadenas de nombres de grupo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La colección de nombres de grupo contiene el conjunto de cadenas que se usan para los nombres de grupos de captura en la expresión. Incluso si los grupos de captura no se mencionen explícitamente, se asigna automáticamente nombres numéricos ("0", "1", "2", "3" y así sucesivamente). "0" denominada grupo representa todo el texto coincide con el patrón de expresión regular. Los grupos numerados preceden a los grupos con nombre explícito en la colección y los grupos con nombre aparecen en el orden en que se definen en el patrón de expresión regular.  
  
 Puede usar el <xref:System.Array.Length%2A> propiedad en la matriz devuelta por este método para determinar el número de grupos en una expresión regular.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un uso general `ShowMatches` método que muestra los nombres de grupos de expresión regular y su texto coincidente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 En este caso, el patrón de expresión regular `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` está pensado para analizar una frase simple y para identificar su primera palabra, por último y puntuación final. En la tabla siguiente se muestra cómo se interpreta el patrón de expresión regular:  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`(?<FirstWord>\w+)`|Buscar coincidencias con uno o más caracteres alfabéticos. Se trata de la `FirstWord` con el nombre de grupo.|  
|¿\s?|Busca una coincidencia con cero o un carácter de espacio en blanco.|  
|(\w+)|Buscar coincidencias con uno o más caracteres alfabéticos. Este es el segundo grupo de captura.|  
|\s|Coincide con un carácter de espacio en blanco.|  
|((\w+)\s)*|Coincide con cero o más apariciones de uno o más caracteres de palabra seguidos de un espacio en blanco. Este es el primer grupo de captura.|  
|(? ¿\<LastWord > \w+)?|Coincide con cero o una aparición de uno o más caracteres alfabéticos. Se trata de la `LastWord` con el nombre de grupo.|  
|(? \<Puntuación > \p{Po})|Coincide con un carácter cuya categoría Unicode es el signo de puntuación, otro. Se trata de la `Punctuation` con el nombre de grupo.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz de números de grupo de captura que corresponde a los nombres de grupo en una matriz.</summary>
        <returns>Matriz de enteros de números de grupo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Número pueden tener acceso a los grupos de captura con nombre y sin nombre. Grupos sin nombre se numeran de izquierda a derecha, comenzando por 1. (El grupo de captura en el índice 0 (cero) representa a la coincidencia como un todo).  Grupos con nombre, a continuación, se numeran de izquierda a derecha, comenzando con un número que es una unidad mayor que el número de sin nombre los grupos de captura.  
  
 Hacer referencia a un grupo por su número en lugar de por nombre de la cadena puede proporcionar un acceso más rápido.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una expresión regular, `\b((?<word>\w+)\s*)+(?<end>[.?!])`, que coincide con una frase. La expresión regular incluye tres grupos de captura: un grupo sin nombre que captura una sola palabra, junto con un carácter de espacio que puede seguir; un grupo denominado `word` que captura las palabras individuales de la oración; y un grupo denominado `end` que captura los signos de puntuación que termina la oración. El ejemplo llama a la <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> método para obtener los números de la captura de todos los grupos y, a continuación, muestra su cadena capturada. Además, el <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> método se utiliza para indicar si un grupo numerado concreto corresponde a un grupo con nombre.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 El patrón de la expresión regular se interpreta como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`(?<word>\w+)`|Coincide con uno o más caracteres alfabéticos y asigna las cadenas asociadas a un grupo denominado `word`.|  
|`\s*`|Busca coincidencias con cero o más caracteres de espacio en blanco.|  
|`((?<word>\w+)\s*)`|Asignar el `word` grupo capturado seguido de cualquier captura los caracteres de espacio en blanco para el primer grupo capturado.|  
|`((?<word>\w+)\s*)+`|Coincide con el patrón de uno o más caracteres de palabra seguido de cualquier carácter de espacio en blanco una o varias veces.|  
|`(?<end>[.?!])`|Buscar coincidencias con un punto, un signo de interrogación o un signo de exclamación. Asigne el carácter coincidente para el `end` grupo de captura.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Número de grupo para convertir al nombre de grupo correspondiente.</param>
        <summary>Obtiene el nombre de grupo que corresponde al número de grupo especificado.</summary>
        <returns>Cadena que contiene el nombre de grupo asociado al número de grupo especificado. Si no hay un nombre de grupo que se corresponda con <paramref name="i" />, el método devuelve <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un patrón de expresión regular puede contener grupos de captura con nombre o numerados, que definen subexpresiones dentro de una coincidencia de patrones. Los grupos numerados están delimitados por la sintaxis (*subexpresión*) y se asignan números según su orden en la expresión regular. Grupos con nombre están delimitados por la sintaxis (?`<` *nombre*`>`*subexpresión*) o (? " *nombre*'*subexpresión*), donde *nombre* es el nombre por el que se identificará la subexpresión. Para más información, consulte la sección sobre [Construcciones de agrupamiento en expresiones regulares](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md). El <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> método identifica grupos con nombre y los grupos numerados por su posición ordinal en la expresión regular. Posición ordinal cero siempre representa la expresión regular completa. Numerados todos los grupos, a continuación, se cuentan antes de grupos con nombre, independientemente de su posición actual en el patrón de expresión regular.  
  
 Si `i` es el número de un grupo con nombre, el método devuelve el nombre del grupo. Si `i` es el número de un grupo sin nombre, el método devuelve la representación de cadena del número. Por ejemplo, si `i` es 1, el método devuelve "1". Si `i` no es el número de un grupo de captura, el método devuelve <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Si se encuentra una coincidencia de patrones, el valor devuelto por este método, a continuación, puede usarse para recuperar el <xref:System.Text.RegularExpressions.Group> objeto que representa el grupo capturado desde el <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> propiedad. El <xref:System.Text.RegularExpressions.GroupCollection> objeto devuelto por la <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> propiedad.  
  
   
  
## Examples  
 El ejemplo siguiente define un patrón de expresión regular que coincida con una línea de dirección que contiene un nombre de la ciudad de EE. UU., nombre del estado y código postal. El ejemplo se usa el <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> método para recuperar los nombres de grupos de captura. A continuación, utiliza estos nombres para recuperar los grupos capturados correspondientes para las coincidencias.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 El patrón de expresión regular se define mediante la siguiente expresión:  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|Coincide con uno o más caracteres alfabéticos o de espacio en blanco. Asigne el nombre de este grupo capturado `city`.|  
|`,`|Coincide con una coma (,) seguida por un carácter de espacio en blanco.|  
|`(?<state>[A-Za-z]{2})`|Coincide con dos caracteres alfabéticos. Asigne el nombre de este grupo capturado `state`. Este grupo debe ir seguido por un carácter de espacio en blanco.|  
|`(?<zip>\d{5}(-\d{4})?)`|Coincide con cinco dígitos numéricos, seguidos de cero o una aparición de un guión seguido de cuatro dígitos. Asigne el nombre de este grupo capturado `zip`.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de grupo para convertir al número de grupo correspondiente.</param>
        <summary>Devuelve el número de grupo que corresponde al nombre de grupo especificado.</summary>
        <returns>Número del grupo que corresponde al nombre de grupo especificado o -1 si <paramref name="name" /> no es un nombre de grupo válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un patrón de expresión regular puede contener grupos de captura con nombre o numerados, que definen subexpresiones dentro de una coincidencia de patrones. Los grupos numerados están delimitados por la sintaxis (*subexpresión*) y se asignan números según su orden en la expresión regular. Grupos con nombre están delimitados por la sintaxis (?`<` *nombre*`>`*subexpresión*) o (? " *nombre*'*subexpresión*), donde *nombre* es el nombre por el que se identificará la subexpresión. Para más información, consulte la sección sobre [Construcciones de agrupamiento en expresiones regulares](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md). El <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> método identifica grupos con nombre y los grupos numerados por su posición ordinal en la expresión regular. Posición ordinal cero siempre representa la expresión regular completa. Numerados todos los grupos, a continuación, se cuentan antes de grupos con nombre, independientemente de su posición actual en el patrón de expresión regular.  
  
 Si `name` es la representación de cadena de un número de grupo que se encuentra en el patrón de expresión regular, el método devuelve dicha cantidad. Si `name` corresponde a una con nombre de grupo que se encuentra en el patrón de expresión regular de captura, el método devuelve el número correspondiente. La comparación de `name` con el grupo nombre distingue mayúsculas de minúsculas. Si `name` no corresponde al nombre de un grupo de captura o a la representación de cadena del número de un grupo de captura, el método devuelve -1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que una operación de coincidencia de patrones no debe superar el tiempo de espera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> clase constructor y un número de uso de métodos de coincidencia estática la <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> constante para indicar que el intento de buscar una coincidencia de patrones debe tiempo de espera.  
  
> [!WARNING]
>  Establecer el valor de tiempo de espera del motor de expresiones regulares en <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> puede hacer que las expresiones regulares que se basan en un retroceso excesivo para parecer que deja de responder cuando se procesa el texto que casi coincide con el patrón de expresión regular. Si deshabilita los tiempos de espera, debe asegurarse de que la expresión regular no se basa en un retroceso excesivo y que lo controla el texto que casi coincide con el patrón de expresión regular.  
>   
>  Para obtener más información sobre cómo controlar el retroceso, consulte [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 El <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> constante puede proporcionarse como el valor de la `matchTimeout` argumento de los miembros siguientes:  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ya se han inicializado las referencias.</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tiempo máximo que puede transcurrir en una operación de coincidencia de patrones antes de que se agote el tiempo de espera de la operación.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si la expresión regular encuentra una coincidencia en la cadena de entrada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <summary>Indica si la expresión regular especificada en el constructor <see cref="T:System.Text.RegularExpressions.Regex" /> encuentra una coincidencia en una cadena de entrada indicada.</summary>
        <returns>
          <see langword="true" /> si la expresión regular encuentra una coincidencia; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método normalmente se utiliza para validar una cadena o para asegurarse de que una cadena se ajusta a un patrón determinado sin tener que recuperar esa cadena para la manipulación subsiguientes. Si desea determinar si una o más cadenas coinciden con un patrón de expresión regular y, a continuación, recuperan para la manipulación subsiguientes, llamada la <xref:System.Text.RegularExpressions.Regex.Match%2A> o <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no hay tiempo de espera se define en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> método para determinar si una cadena es un número de pieza válido. La expresión regular se da por supuesto que el número de pieza tiene un formato específico que consta de tres conjuntos de caracteres separados por guiones. El primer conjunto, que contiene cuatro caracteres, debe constar de un carácter alfanumérico seguido de dos caracteres numéricos seguidos por un carácter alfanumérico. El segundo conjunto, que consta de tres caracteres, debe ser numérico. El tercer conjunto, que consta de cuatro caracteres, debe tener tres caracteres numéricos seguidos por un carácter alfanumérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 El patrón de la expresión regular es:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`^`|Comienza la búsqueda de coincidencias al principio de la línea.|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o un carácter numérico.|  
|`\d{2}`|Coincide con dos caracteres numéricos.|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o un carácter numérico.|  
|`-`|Buscar coincidencias con un guion.|  
|`\d{3}`|Coincidir con exactamente tres caracteres numéricos.|  
|`(-\d{3}){2}`|Buscar un guión seguido de tres caracteres numéricos y coincide con dos apariciones de este patrón.|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o un carácter numérico.|  
|`$`|Finalizar la búsqueda de coincidencias al final de la línea.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="startat">Posición de carácter en la que se va a iniciar la búsqueda.</param>
        <summary>Indica si la expresión regular especificada en el constructor <see cref="T:System.Text.RegularExpressions.Regex" /> encuentra una coincidencia en la cadena de entrada especificada, empezando en la posición inicial indicada en la cadena.</summary>
        <returns>
          <see langword="true" /> si la expresión regular encuentra una coincidencia; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método normalmente se utiliza para validar una cadena o para asegurarse de que una cadena se ajusta a un patrón determinado sin tener que recuperar esa cadena para la manipulación subsiguientes. Si desea determinar si una o más cadenas coinciden con un patrón de expresión regular y, a continuación, recuperan para la manipulación subsiguientes, llamada la <xref:System.Text.RegularExpressions.Regex.Match%2A> o <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no hay tiempo de espera se define en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> método para determinar si una cadena es un número de pieza válido. Busca un número de pieza que sigue a un carácter de dos puntos (:) en una cadena. El <xref:System.String.IndexOf%28System.Char%29> método se utiliza para determinar la posición del carácter de dos puntos, que, a continuación, se pasa a la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> método. La expresión regular se da por supuesto que el número de pieza tiene un formato específico que consta de tres conjuntos de caracteres separados por guiones. El primer conjunto, que contiene cuatro caracteres, debe constar de un carácter alfanumérico seguido de dos caracteres numéricos seguidos por un carácter alfanumérico. El segundo conjunto, que consta de tres caracteres, debe ser numérico. El tercer conjunto, que consta de cuatro caracteres, debe tener tres caracteres numéricos seguidos por un carácter alfanumérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 El patrón de la expresión regular es:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o un carácter numérico.|  
|`\d{2}`|Coincide con dos caracteres numéricos.|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o un carácter numérico.|  
|`-`|Buscar coincidencias con un guion.|  
|`\d{3}`|Coincidir con exactamente tres caracteres numéricos.|  
|`(-\d{3}){2}`|Buscar un guión seguido de tres caracteres numéricos y coincide con dos apariciones de este patrón.|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o un carácter numérico.|  
|`$`|Finalizar la búsqueda de coincidencias al final de la línea.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> es menor que cero o mayor que la longitud de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <summary>Indica si la expresión regular especificada busca una coincidencia en la cadena de entrada indicada.</summary>
        <returns>
          <see langword="true" /> si la expresión regular encuentra una coincidencia; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método normalmente se utiliza para validar una cadena o para asegurarse de que una cadena se ajusta a un patrón determinado sin tener que recuperar esa cadena para la manipulación subsiguientes. Si desea determinar si una o más cadenas coinciden con un patrón de expresión regular y, a continuación, recuperan para la manipulación subsiguientes, llamada la <xref:System.Text.RegularExpressions.Regex.Match%2A> o <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 Estático <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método es equivalente a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el patrón de expresión regular especificado por `pattern` y llamar a la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> método de instancia. Este patrón de expresión regular se almacena en caché para una recuperación rápida mediante el motor de expresiones regulares.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no hay tiempo de espera se define en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método para determinar si una cadena es un número de pieza válido. La expresión regular se da por supuesto que el número de pieza tiene un formato específico que consta de tres conjuntos de caracteres separados por guiones. El primer conjunto, que contiene cuatro caracteres, debe constar de un carácter alfanumérico seguido de dos caracteres numéricos seguidos por un carácter alfanumérico. El segundo conjunto, que consta de tres caracteres, debe ser numérico. El tercer conjunto, que consta de cuatro caracteres, debe tener tres caracteres numéricos seguidos por un carácter alfanumérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 El patrón de la expresión regular es:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`^`|Comienza la búsqueda de coincidencias al principio de la línea.|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o un carácter numérico.|  
|`\d{2}`|Coincide con dos caracteres numéricos.|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o un carácter numérico.|  
|`-`|Buscar coincidencias con un guion.|  
|`\d{3}`|Coincidir con exactamente tres caracteres numéricos.|  
|`(-\d{3}){2}`|Buscar un guión seguido de tres caracteres numéricos y coincide con dos apariciones de este patrón.|  
|`[a-zA-Z0-9]`|Coincide con un carácter alfabético único (`a` a través de `z` o `A` a través de `Z`) o un carácter numérico.|  
|`$`|Finalizar la búsqueda de coincidencias al final de la línea.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método se agota después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama al método. Si no se ha definido un valor de tiempo de espera para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para comprobar una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <summary>Indica si la expresión regular especificada encuentra una coincidencia en la cadena de entrada indicada, utilizando para ello las opciones de coincidencia especificadas.</summary>
        <returns>
          <see langword="true" /> si la expresión regular encuentra una coincidencia; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método normalmente se utiliza para validar una cadena o para asegurarse de que una cadena se ajusta a un patrón determinado sin tener que recuperar esa cadena para la manipulación subsiguientes. Si desea determinar si una o más cadenas coinciden con un patrón de expresión regular y, a continuación, recuperan para la manipulación subsiguientes, llamada la <xref:System.Text.RegularExpressions.Regex.Match%2A> o <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 Estático <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método es equivalente a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el patrón de expresión regular especificado por `pattern` y las opciones de expresión regular especificadas por `options` y llamar a la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> instancia método. Este patrón de expresión regular se almacena en caché para una recuperación rápida mediante el motor de expresiones regulares.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no hay tiempo de espera se define en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método para determinar si una cadena es un número de pieza válido. La expresión regular se da por supuesto que el número de pieza tiene un formato específico que consta de tres conjuntos de caracteres separados por guiones. El primer conjunto, que contiene cuatro caracteres, debe constar de un carácter alfanumérico seguido de dos caracteres numéricos seguidos por un carácter alfanumérico. El segundo conjunto, que consta de tres caracteres, debe ser numérico. El tercer conjunto, que consta de cuatro caracteres, debe tener tres caracteres numéricos seguidos por un carácter alfanumérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 El patrón de la expresión regular es:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`^`|Empieza la búsqueda de coincidencias en el principio de la cadena.|  
|`[A-Z0-9]`|Coincide con cualquier carácter alfabético único de `A` a través de `Z`, o cualquier carácter numérico.|  
|`\d{2}`|Coincide con dos caracteres numéricos.|  
|`[A-Z0-9]`|Coincide con cualquier carácter alfabético único de `A` a través de `Z`, o cualquier carácter numérico.|  
|`-`|Buscar coincidencias con un guion.|  
|`\d{3}`|Coincidir con exactamente tres caracteres numéricos.|  
|`(-\d{3}){2}`|Buscar un guión seguido de tres caracteres numéricos y coincide con dos apariciones de este patrón...|  
|`[A-Z0-9]`|Coincide con cualquier carácter alfabético único de `A` a través de `Z`, o cualquier carácter numérico.|  
|`$`|Finalizar la búsqueda al final de la cadena.|  
  
 Una llamada a la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método con el `options` parámetro establecido en <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> es equivalente a definir la siguiente expresión regular:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Para la comparación, vea el ejemplo de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es un valor <see cref="T:System.Text.RegularExpressions.RegexOptions" /> válido.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método se agota después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama. Si no se ha definido un valor de tiempo de espera para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para comprobar una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <param name="matchTimeout">Un intervalo de tiempo de espera, o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que el método no debe agotar el tiempo de espera.</param>
        <summary>Indica si la expresión regular especificada encuentra una coincidencia en la cadena de entrada indicada, utilizando para ello las opciones de coincidencia y el intervalo de tiempo de espera que se especifiquen.</summary>
        <returns>
          <see langword="true" /> si la expresión regular encuentra una coincidencia; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método normalmente se utiliza para validar una cadena o para asegurarse de que una cadena se ajusta a un patrón determinado sin tener que recuperar esa cadena para la manipulación subsiguientes. Si desea determinar si una o más cadenas coinciden con un patrón de expresión regular y, a continuación, recuperan para la manipulación subsiguientes, llamada la <xref:System.Text.RegularExpressions.Regex.Match%2A> o <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 Estático <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método es equivalente a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el patrón de expresión regular especificado por `pattern` y las opciones de expresión regular especificadas por `options` y llamar a la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> instancia método. Este patrón de expresión regular se almacena en caché para una recuperación rápida mediante el motor de expresiones regulares.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El `matchTimeout` parámetro especifica cómo larga una coincidencia de método debe intentar buscar una coincidencia antes de expirar. Establecer un intervalo de tiempo de espera evita que las expresiones regulares que se basan en un retroceso excesivo aparezcan deje de responder al procesar la entrada que contenga cerca de coincidencias. Para obtener más información, consulte [procedimientos recomendados con expresiones regulares](~/docs/standard/base-types/best-practices.md) y [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Si no se encuentra ninguna coincidencia en ese intervalo de tiempo, el método produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. `matchTimeout` invalida cualquier valor de tiempo de espera predeterminado definido para el dominio de aplicación en el que se ejecuta el método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método para determinar si una cadena es un número de pieza válido. La expresión regular se da por supuesto que el número de pieza tiene un formato específico que consta de tres conjuntos de caracteres separados por guiones. El primer conjunto, que contiene cuatro caracteres, debe constar de un carácter alfanumérico seguido de dos caracteres numéricos seguidos por un carácter alfanumérico. El segundo conjunto, que consta de tres caracteres, debe ser numérico. El tercer conjunto, que consta de cuatro caracteres, debe tener tres caracteres numéricos seguidos por un carácter alfanumérico. Coincidencia de patrón de expresión regular debe implicar buscar mínima a través de la cadena de entrada, por lo que el método establece un intervalo de tiempo de espera de 500 milisegundos.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 El patrón de la expresión regular es:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`^`|Empieza la búsqueda de coincidencias en el principio de la cadena.|  
|`[A-Z0-9]`|Coincide con cualquier carácter alfabético único de `A` a través de `Z`, o cualquier carácter numérico.|  
|`\d{2}`|Coincide con dos caracteres numéricos.|  
|`[A-Z0-9]`|Coincide con cualquier carácter alfabético único de `A` a través de `Z`, o cualquier carácter numérico.|  
|`-`|Buscar coincidencias con un guion.|  
|`\d{3}`|Coincidir con exactamente tres caracteres numéricos.|  
|`(-\d{3}){2}`|Buscar un guión seguido de tres caracteres numéricos y coincide con dos apariciones de este patrón.|  
|`[A-Z0-9]`|Coincide con cualquier carácter alfabético único de `A` a través de `Z`, o cualquier carácter numérico.|  
|`$`|Finalizar la búsqueda al final de la cadena.|  
  
 Una llamada a la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método con el `options` parámetro establecido en <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> es equivalente a definir la siguiente expresión regular:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Para la comparación, vea el ejemplo de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es un valor <see cref="T:System.Text.RegularExpressions.RegexOptions" /> válido.  
  
O bien 
 <paramref name="matchTimeout" /> es negativo, cero o mayor que 24 días aproximadamente.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera.</exception>
        <block subset="none" type="usage">
          <para>Se recomienda que establezca el <paramref name="matchTimeout" /> parámetro a un valor apropiado, como dos segundos. Si deshabilita los tiempos de espera mediante la especificación de <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor. Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones: - cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o formado por texto estático. Excluye el texto que ha sido dinámicamente por usuarios.  -Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controla con gran eficacia coincide, la ausencia de coincidencias y próximo coincide con.  -Cuando el patrón de expresión regular contiene ningún elemento de lenguaje que causan un retroceso excesivo al procesar a una coincidencia casi.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca en una cadena de entrada una subcadena que coincida con un modelo de expresión regular y devuelve la primera aparición como un único objeto <see cref="T:System.Text.RegularExpressions.Match" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <summary>Busca en la cadena de entrada especificada la primera aparición de la expresión regular especificada en el constructor <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Objeto que contiene información sobre la coincidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método devuelve la primera subcadena que coincide con un patrón de expresión regular en una cadena de entrada. Para obtener información acerca de los elementos del lenguaje utilizado para generar un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada, compruebe el valor devuelto del <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propiedad. Si se encuentra una coincidencia, el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propiedad contiene la subcadena de `input` que coincide con el patrón de expresión regular. Si no se encuentra ninguna coincidencia, su valor es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Este método devuelve la primera subcadena en `input` que coincide con el patrón de expresión regular. Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método. También puede recuperar todas las coincidencias en una única llamada al método mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> método.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no hay tiempo de espera se define en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción.  
  
   
  
## Examples  
 El ejemplo siguiente busca el patrón de expresión regular coincide con una cadena, muestra el texto coincidente grupos, las capturas y las posiciones de captura.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 El patrón de expresión regular `(\w+)\s+(car)` devuelve las repeticiones de la palabra "car" junto con la palabra que precede. Se interpreta como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`(\w+)`|Buscar coincidencias con uno o más caracteres alfabéticos. Este es el primer grupo de captura.|  
|`\s+`|Coincide con uno o más caracteres de espacio en blanco.|  
|(car)|Coincide con la cadena literal "car". Este es el segundo grupo de captura.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="startat">Posición de carácter basada en cero en la que se va a iniciar la búsqueda.</param>
        <summary>Busca en la cadena de entrada la primera aparición de una expresión regular, empezando en la posición inicial especificada de la cadena.</summary>
        <returns>Objeto que contiene información sobre la coincidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> método devuelve la primera subcadena que coincide con un patrón de expresión regular, empezando en o después de la `startat` posición de carácter, de una cadena de entrada. Para obtener información acerca de los elementos del lenguaje utilizado para generar un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El patrón de expresión regular para que el <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> búsquedas de los métodos se define mediante la llamada a uno de los <xref:System.Text.RegularExpressions.Regex> los constructores de clase. Para obtener más información acerca de los elementos que pueden formar un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 También puede especificar una posición inicial en la cadena mediante el uso de la `startat` parámetro. Cuando el motor de expresiones regulares se analiza de izquierda a derecha (el valor predeterminado), la coincidencia y el examen se mueven hacia la derecha, comenzando en el carácter especificado en `startat`. Cuando el motor de expresiones regulares se analiza de derecha a izquierda (cuando se construye el patrón de expresión regular con la <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opción), la coincidencia y el examen mover en la dirección opuesta y comienzan con el carácter que ocupa `startat` -1. Si no especifica una posición inicial, la búsqueda comienza en el valor predeterminado `startat` posición. Si la expresión regular busca de izquierda a derecha, el valor predeterminado `startat` posición está en el extremo izquierdo de `input`; si busca de derecha a izquierda, el valor predeterminado `startat` posición está en el extremo derecho de `input`.  
  
 Si desea restringir una coincidencia de forma que empieza en una posición de caracteres determinada en la cadena y el motor de expresiones regulares no examina el resto de la cadena para una coincidencia, delimite la expresión regular con un `\G` (a la izquierda de izquierda a derecha patrón, o a la derecha de un patrón de derecha a izquierda). Esto restringe la coincidencia por lo que debe comenzar exactamente en `startat`.  
  
 Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada, compruebe el valor devuelto del <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propiedad. Si se encuentra una coincidencia, el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propiedad contiene la subcadena de `input` que coincide con el patrón de expresión regular. Si no se encuentra ninguna coincidencia, su valor es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Este método devuelve la primera subcadena encontrada en o después de la `startat` posición de carácter de `input` que coincide con el patrón de expresión regular. Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método. También puede recuperar todas las coincidencias en una única llamada al método mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> método.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación de sobrepasa cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no hay tiempo de espera se define en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> es menor que cero o mayor que la longitud de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <summary>Busca en la cadena de entrada especificada la primera aparición de la expresión regular indicada.</summary>
        <returns>Objeto que contiene información sobre la coincidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> método devuelve la primera subcadena que coincide con un patrón de expresión regular en una cadena de entrada. Para obtener información acerca de los elementos del lenguaje utilizado para generar un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Estático <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> método es equivalente a construir un <xref:System.Text.RegularExpressions.Regex> con el patrón de expresión regular especificada de objetos y llamar a la instancia <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método. En este caso, el motor de expresiones regulares almacena en caché el patrón de expresión regular.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada, compruebe el valor devuelto del <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propiedad. Si se encuentra una coincidencia, el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propiedad contiene la subcadena de `input` que coincide con el patrón de expresión regular. Si no se encuentra ninguna coincidencia, su valor es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Este método devuelve la primera subcadena en `input` que coincide con el patrón de expresión regular. Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método. También puede recuperar todas las coincidencias en una única llamada al método mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> método.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no hay tiempo de espera se define en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> método para buscar la primera palabra que contiene al menos uno `z` caracteres y, a continuación, llama a la <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método para buscar las coincidencias adicionales.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 El patrón de la expresión regular `\b\w*z+\w*\b` se interpreta como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`\w*`|Coincide con cero, uno o más caracteres alfabéticos.|  
|`z+`|Coincide con uno o más apariciones de la `z` caracteres.|  
|`\w*`|Coincide con cero, uno o más caracteres alfabéticos.|  
|`\b`|Finalizar la búsqueda de coincidencias en un límite de palabras.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método se agota después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama. Si no se ha definido un valor de tiempo de espera para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para recuperar una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="beginning">Posición de caracteres de base cero en la cadena de entrada que define la posición más a la izquierda en la que se buscará.</param>
        <param name="length">Número de caracteres de la subcadena que se van a incluir en la búsqueda.</param>
        <summary>Busca en la cadena de entrada la primera aparición de una expresión regular, empezando en la posición inicial especificada y buscando solo en el número de caracteres indicado.</summary>
        <returns>Objeto que contiene información sobre la coincidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> método devuelve la primera subcadena que coincide con un patrón de expresión regular en una parte de una cadena de entrada. Para obtener información acerca de los elementos del lenguaje utilizado para generar un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El patrón de expresión regular para que el <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> búsquedas de los métodos se define mediante la llamada a uno de los <xref:System.Text.RegularExpressions.Regex> los constructores de clase. Para obtener más información acerca de los elementos que pueden formar un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> método busca en la parte de `input` definido por el `beginning` y `length` parámetros para el patrón de expresión regular. `beginning` siempre se define el índice del carácter más a la izquierda para incluir en la búsqueda, y `length` define el número máximo de caracteres que se va a buscar. Juntos, definen el intervalo de la búsqueda. Si la búsqueda se realiza de izquierda a derecha (el valor predeterminado), el motor de expresiones regulares buscará desde el carácter situado en índice `beginning` para el carácter situado en índice `beginning`  +  `length` – 1. Si se crea una instancia del motor de expresiones regulares mediante la <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opción para que la búsqueda se realiza de derecha a izquierda, las búsquedas de motor de expresiones regulares desde el carácter situado en índice `beginning`  +  `length` – 1 para el carácter en el índice `beginning`. Este método devuelve a la primera coincidencia que encuentra dentro de este intervalo. Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método.  
  
 Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada, compruebe el valor devuelto del <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propiedad. Si se encuentra una coincidencia, el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propiedad contiene la subcadena de `input` que coincide con el patrón de expresión regular. Si no se encuentra ninguna coincidencia, su valor es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un valor de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no hay tiempo de espera se define en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="beginning" /> es menor que cero o mayor que la longitud de <paramref name="input" />.  
  
O bien 
 <paramref name="length" /> es menor que cero o mayor que la longitud de <paramref name="input" />.  
  
O bien 
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="–1" /> identifica una posición que está fuera del intervalo de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <summary>Busca en la cadena de entrada la primera aparición de la expresión regular especificada, utilizando para ello las opciones de coincidencia indicadas.</summary>
        <returns>Objeto que contiene información sobre la coincidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método devuelve la primera subcadena que coincide con un patrón de expresión regular en una cadena de entrada. Para obtener información acerca de los elementos del lenguaje utilizado para generar un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Estático <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método es equivalente a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> constructor y llamar a la instancia <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada, compruebe el valor devuelto del <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propiedad. Si se encuentra una coincidencia, el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propiedad contiene la subcadena de `input` que coincide con el patrón de expresión regular. Si no se encuentra ninguna coincidencia, su valor es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Este método devuelve la primera subcadena encontrada en `input` que coincide con el patrón de expresión regular. Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A> método. También puede recuperar todas las coincidencias en una única llamada al método mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de coincidencia supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no hay tiempo de espera se define en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una expresión regular que coincida con las palabras que empiezan por la letra "a". Usa el <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> opción para asegurarse de que la expresión regular busca palabras que empiezan con ambas en mayúscula "a" y una minúscula "a".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 El patrón de la expresión regular `\ba\w*\b` se interpreta como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`a`|Coincide con el carácter "a".|  
|`\w*`|Coincide con cero, uno o más caracteres alfabéticos.|  
|`\b`|Finalizar la búsqueda de coincidencias en un límite de palabras.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método se agota después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama. Si no se ha definido un valor de tiempo de espera para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para recuperar una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <param name="matchTimeout">Un intervalo de tiempo de espera, o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que el método no debe agotar el tiempo de espera.</param>
        <summary>Busca en la cadena de entrada la primera aparición de la expresión regular especificada, utilizando para ello las opciones de coincidencia y el intervalo de tiempo de espera que se indiquen.</summary>
        <returns>Objeto que contiene información sobre la coincidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método devuelve la primera subcadena que coincide con un patrón de expresión regular en una cadena de entrada. Para obtener información acerca de los elementos del lenguaje utilizado para generar un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Estático <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método es equivalente a construir un <xref:System.Text.RegularExpressions.Regex> objeto con el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor y llamar a la instancia <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Puede determinar si se ha encontrado el patrón de expresión regular en la cadena de entrada, compruebe el valor devuelto del <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propiedad. Si se encuentra una coincidencia, el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propiedad contiene la subcadena de `input` que coincide con el patrón de expresión regular. Si no se encuentra ninguna coincidencia, su valor es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Este método devuelve la primera subcadena encontrada en `input` que coincide con el patrón de expresión regular. Puede recuperar las coincidencias subsiguientes llamando repetidamente el valor devuelto <xref:System.Text.RegularExpressions.Match> del objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A> método. También puede recuperar todas las coincidencias en una única llamada al método mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método.  
  
 El `matchTimeout` parámetro especifica cómo larga una coincidencia de método debe intentar buscar una coincidencia antes de expirar. Establecer un intervalo de tiempo de espera evita que las expresiones regulares que se basan en un retroceso excesivo aparezcan deje de responder al procesar la entrada que contenga cerca de coincidencias. Para obtener más información, consulte [procedimientos recomendados con expresiones regulares](~/docs/standard/base-types/best-practices.md) y [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Si no se encuentra ninguna coincidencia en ese intervalo de tiempo, el método produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. `matchTimeout` invalida cualquier valor de tiempo de espera predeterminado definido para el dominio de aplicación en el que se ejecuta el método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
O bien 
 <paramref name="matchTimeout" /> es negativo, cero o mayor que 24 días aproximadamente.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó un tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Se recomienda que establezca el <paramref name="matchTimeout" /> parámetro a un valor apropiado, como dos segundos. Si deshabilita los tiempos de espera mediante la especificación de <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor. Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones: - cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o formado por texto estático. Excluye el texto que ha sido dinámicamente por usuarios.  -Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controla con gran eficacia coincide, la ausencia de coincidencias y próximo coincide con.  -Cuando el patrón de expresión regular contiene ningún elemento de lenguaje que causan un retroceso excesivo al procesar a una coincidencia casi.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca en una cadena de entrada todas las apariciones de una expresión regular y devuelve todas las coincidencias.</summary>
        <block subset="none" type="usage">
          <para>Cuando un intento de coincidencia que se repite mediante una llamada a la <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> método, el motor de expresiones regulares otorga coincidencias vacías un tratamiento especial. Normalmente, el motor de expresiones regulares comienza la búsqueda de la siguiente coincidencia, la coincidencia anterior exactamente. Sin embargo, tras una coincidencia vacía, el motor de expresiones regulares avanza un carácter antes de intentar a la siguiente coincidencia. Este comportamiento garantiza que el motor de expresiones regulares progresan a través de la cadena. En caso contrario, dado que una coincidencia vacía no produce ningún movimiento hacia delante, empezaría la siguiente coincidencia de exactamente el mismo lugar que la coincidencia anterior y coincidiría con repetidamente la misma cadena vacía.  En el ejemplo siguiente, el patrón de expresión regular <c>un *</c> Busca cero o más apariciones de la letra "a" en la cadena "abaabb". Como la salida muestra el ejemplo, el resultado <see cref="T:System.Text.RegularExpressions.MatchCollection" /> objeto contiene seis <see cref="T:System.Text.RegularExpressions.Match" /> objetos. El primer intento de coincidencia busca el primer "a". La segunda búsqueda se inicia exactamente donde el primero coincide con extremos, antes de la primera b; Busca cero repeticiones de "a" y devuelve una cadena vacía. La coincidencia terceros no empieza exactamente donde terminó la segunda coincidencia, porque la segunda coincidencia devolvió una cadena vacía. En su lugar, inicia un carácter más adelante, después de la primera "b". La tercera coincidencia busca dos apariciones de "a" y devuelve "aa". El cuarto intento de coincidencia comienza donde finalizó la coincidencia terceros, antes de la segunda "b" y devuelve una cadena vacía. El quinto intento de coincidencia nuevo avanza un carácter para que se inicia antes de que el tercer "b" y devuelve una cadena vacía. El sexta coincidencia comienza después de la última "b" y devuelve una cadena vacía de nuevo.  [! código csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [! código vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <summary>Busca en la cadena de entrada especificada todas las apariciones de una expresión regular.</summary>
        <returns>Colección de los objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados en la búsqueda. Si no se encuentran coincidencias, el método devuelve un objeto de colección vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> método es similar a la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método, salvo que devuelva información sobre todas las coincidencias que se encuentra en la cadena de entrada, en lugar de una coincidencia única. Es equivalente al código siguiente:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 La colección incluye a solo las coincidencias y termina en la primera no coincide.  
  
 El patrón de expresión regular para que el <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> búsquedas de los métodos se define mediante la llamada a uno de los <xref:System.Text.RegularExpressions.Regex> los constructores de clase. Para obtener más información acerca de los elementos que pueden formar un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El <xref:System.Text.RegularExpressions.Regex.Matches%2A> método usa la evaluación diferida para rellenar el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acceso a miembros de esta colección, como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> y <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> hace que la colección que se debe rellenar inmediatamente. Para aprovechar las ventajas de la evaluación diferida, debe iterar la colección mediante una construcción como `foreach` en C# y `For Each`...`Next` en Visual Basic.  
  
 Debido a su evaluación diferida, llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> método no produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. Sin embargo, la excepción se produce cuando se realiza una operación en el <xref:System.Text.RegularExpressions.MatchCollection> objeto devuelto por este método, si la <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> propiedad no es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> y una operación de coincidencia supera el intervalo de tiempo de espera.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> método para identificar las palabras en una oración que terminan en "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 El patrón de expresión regular `\b\w+es\b` se define como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`\w+`|Buscar coincidencias con uno o más caracteres alfabéticos.|  
|`es`|Coincide con la cadena literal "es".|  
|`\b`|Finalizar la búsqueda de coincidencias en un límite de palabras.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="startat">Posición de carácter de la cadena de entrada en la que se va a iniciar la búsqueda.</param>
        <summary>Busca en la cadena de entrada especificada todas las apariciones de una expresión regular, empezando en la posición de inicio especificada de la cadena.</summary>
        <returns>Colección de los objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados en la búsqueda. Si no se encuentran coincidencias, el método devuelve un objeto de colección vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> método es similar a la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> método, salvo que devuelva información sobre todas las coincidencias que se encuentra en la cadena de entrada, en lugar de una coincidencia única. Es equivalente al código siguiente:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 El patrón de expresión regular para que el <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> búsquedas de los métodos se define mediante la llamada a uno de los <xref:System.Text.RegularExpressions.Regex> los constructores de clase. Para obtener más información acerca de los elementos que pueden formar un patrón de expresión regular, vea [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El <xref:System.Text.RegularExpressions.Regex.Matches%2A> método usa la evaluación diferida para rellenar el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acceso a miembros de esta colección, como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> y <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> hace que la colección que se debe rellenar inmediatamente. Para aprovechar las ventajas de la evaluación diferida, debe iterar la colección mediante una construcción como `foreach` en C# y `For Each`...`Next` en Visual Basic.  
  
 Debido a su evaluación diferida, llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> método no produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. Sin embargo, la excepción se produce cuando se realiza una operación en el <xref:System.Text.RegularExpressions.MatchCollection> objeto devuelto por este método, si la <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> propiedad no es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> y una operación de coincidencia supera el intervalo de tiempo de espera...  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método para buscar la primera palabra en una oración que termina en "es" y, a continuación, llama a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> método para identificar cualquier palabra adicional que terminan en "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 El patrón de expresión regular `\b\w+es\b` se define como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`\w+`|Buscar coincidencias con uno o más caracteres alfabéticos.|  
|`es`|Coincide con la cadena literal "es".|  
|`\b`|Finalizar la búsqueda de coincidencias en un límite de palabras.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> es menor que cero o mayor que la longitud de <paramref name="input" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <summary>Busca en la cadena de entrada especificada todas las apariciones de una expresión regular indicada.</summary>
        <returns>Colección de los objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados en la búsqueda. Si no se encuentran coincidencias, el método devuelve un objeto de colección vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método es similar a la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> método, salvo que devuelva información sobre todas las coincidencias que se encuentra en la cadena de entrada, en lugar de una coincidencia única. Es equivalente al código siguiente:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 Estático `Matches` métodos son equivalentes a construir un <xref:System.Text.RegularExpressions.Regex> con el patrón de expresión regular especificada de objetos y llamar al método de instancia `Matches`.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El <xref:System.Text.RegularExpressions.Regex.Matches%2A> método usa la evaluación diferida para rellenar el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acceso a miembros de esta colección, como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> y <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> hace que la colección que se debe rellenar inmediatamente. Para aprovechar las ventajas de la evaluación diferida, debe iterar la colección mediante una construcción como `foreach` en C# y `For Each`...`Next` en Visual Basic.  
  
 Debido a su evaluación diferida, llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método no produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. Sin embargo, la excepción se produce cuando se realiza una operación en el <xref:System.Text.RegularExpressions.MatchCollection> objeto devuelto por este método, si un intervalo de tiempo de espera es definido por la propiedad "REGEX_DEFAULT_MATCH_TIMEOUT" del dominio de aplicación actual y una operación de coincidencia supera este intervalo de tiempo de espera.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método para identificar cualquier palabra en una oración que termina en "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 El patrón de expresión regular `\b\w+es\b` se define como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`\w+`|Buscar coincidencias con uno o más caracteres alfabéticos.|  
|`es`|Coincide con la cadena literal "es".|  
|`\b`|Finalizar la búsqueda de coincidencias en un límite de palabras.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Este método se agota después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama. Si no se ha definido un valor de tiempo de espera para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. Es el método estático recomendado para recuperar varios patrón coincide con <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que le permite especificar el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que especifican opciones de coincidencia.</param>
        <summary>Busca en la cadena de entrada especificada todas las apariciones de una expresión regular indicada, utilizando para ello las opciones de coincidencia especificadas.</summary>
        <returns>Colección de los objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados en la búsqueda. Si no se encuentran coincidencias, el método devuelve un objeto de colección vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método es similar a la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método, salvo que devuelva información sobre todas las coincidencias que se encuentra en la cadena de entrada, en lugar de una coincidencia única. Es equivalente al código siguiente:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 Estático `Matches` métodos son equivalentes a construir un <xref:System.Text.RegularExpressions.Regex> con el patrón de expresión regular especificada de objetos y llamar al método de instancia `Matches`.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El <xref:System.Text.RegularExpressions.Regex.Matches%2A> método usa la evaluación diferida para rellenar el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acceso a miembros de esta colección, como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> y <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> hace que la colección que se debe rellenar inmediatamente. Para aprovechar las ventajas de la evaluación diferida, debe iterar la colección mediante una construcción como `foreach` en C# y `For Each`...`Next` en Visual Basic.  
  
 Debido a su evaluación diferida, llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método no produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. Sin embargo, la excepción se produce cuando se realiza una operación en el <xref:System.Text.RegularExpressions.MatchCollection> objeto devuelto por este método, si un intervalo de tiempo de espera es definido por la propiedad "REGEX_DEFAULT_MATCH_TIMEOUT" del dominio de aplicación actual y una operación de coincidencia supera este intervalo de tiempo de espera.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método para identificar cualquier palabra en una oración que termina en "es" y, a continuación, llama a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método para realizar una comparación entre mayúsculas y minúsculas del patrón con la cadena de entrada. Como se muestra el resultado, los dos métodos devuelven resultados diferentes.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 El patrón de expresión regular `\b\w+es\b` se define como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`\w+`|Buscar coincidencias con uno o más caracteres alfabéticos.|  
|`es`|Coincide con la cadena literal "es".|  
|`\b`|Finalizar la búsqueda de coincidencias en un límite de palabras.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Este método se agota después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama. Si no se ha definido un valor de tiempo de espera para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. Es el método estático recomendado para recuperar varios patrón coincide con <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que especifican opciones de coincidencia.</param>
        <param name="matchTimeout">Un intervalo de tiempo de espera, o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que el método no debe agotar el tiempo de espera.</param>
        <summary>Busca en la cadena de entrada especificada todas las apariciones de una expresión regular indicada, utilizando para ello las opciones de coincidencia y el intervalo de tiempo de espera que se especifiquen.</summary>
        <returns>Colección de los objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados en la búsqueda. Si no se encuentran coincidencias, el método devuelve un objeto de colección vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método es similar a la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método, salvo que devuelva información sobre todas las coincidencias que se encuentra en la cadena de entrada, en lugar de una coincidencia única. Es equivalente al código siguiente:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 Estático `Matches` métodos son equivalentes a construir un <xref:System.Text.RegularExpressions.Regex> con el patrón de expresión regular especificada de objetos y llamar al método de instancia `Matches`.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El <xref:System.Text.RegularExpressions.Regex.Matches%2A> método usa la evaluación diferida para rellenar el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acceso a miembros de esta colección, como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> y <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> hace que la colección que se debe rellenar inmediatamente. Para aprovechar las ventajas de la evaluación diferida, debe iterar la colección mediante una construcción como `foreach` en C# y `For Each`...`Next` en Visual Basic.  
  
 Debido a su evaluación diferida, llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%2A> método no produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. Sin embargo, se produce una excepción cuando se realiza una operación en el <xref:System.Text.RegularExpressions.MatchCollection> objeto devuelto por este método, si una operación de coincidencia excede este intervalo de tiempo de espera especificado por el`matchTimeout` parámetro.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método para realizar una comparación entre mayúsculas y minúsculas que coincide con cualquier palabra en una oración que termina en "es". A continuación, llama el <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método para realizar una comparación entre mayúsculas y minúsculas del patrón con la cadena de entrada. En ambos casos, el intervalo de tiempo de espera se establece en un segundo. Como se muestra el resultado, los dos métodos devuelven resultados diferentes.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 El patrón de expresión regular `\b\w+es\b` se define como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\b`|Iniciar la búsqueda de coincidencias en un límite de palabras.|  
|`\w+`|Buscar coincidencias con uno o más caracteres alfabéticos.|  
|`es`|Coincide con la cadena literal "es".|  
|`\b`|Finalizar la búsqueda de coincidencias en un límite de palabras.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
O bien 
 <paramref name="matchTimeout" /> es negativo, cero o mayor que 24 días aproximadamente.</exception>
        <block subset="none" type="usage">
          <para>Se recomienda que establezca el <paramref name="matchTimeout" /> parámetro a un valor apropiado, como dos segundos. Si deshabilita los tiempos de espera mediante la especificación de <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor. Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones: - cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o formado por texto estático. Excluye el texto que ha sido dinámicamente por usuarios.  -Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controla con gran eficacia coincide, la ausencia de coincidencias y próximo coincide con.  -Cuando el patrón de expresión regular contiene ningún elemento de lenguaje que causan un retroceso excesivo al procesar a una coincidencia casi.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el intervalo de tiempo de espera de la instancia actual.</summary>
        <value>Intervalo de tiempo máximo que puede transcurrir en una operación de coincidencia de modelos antes de que se produzca una <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /> o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> si se deshabilitan los tiempos de espera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> propiedad define el intervalo de tiempo máximo aproximado para un <xref:System.Text.RegularExpressions.Regex> instancia para ejecutar una única operación coincidente antes de la operación agota el tiempo. El motor de expresiones regulares produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción durante su siguiente comprobación de tiempo después de que ha transcurrido el intervalo de tiempo de espera. Esto impide que el motor de expresiones regulares procesar cadenas de entrada que requieren un retroceso excesivo. Para obtener más información, consulte [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md) y [procedimientos recomendados con expresiones regulares](~/docs/standard/base-types/best-practices.md).  
  
 Esta propiedad es de sólo lectura. Puede establecer su valor explícitamente para un usuario individual <xref:System.Text.RegularExpressions.Regex> objeto mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor; y se puede establecer su valor para todos los <xref:System.Text.RegularExpressions.Regex> coincidentes de las operaciones en un dominio de aplicación mediante una llamada a la <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> método y proporcionar un <xref:System.TimeSpan> valor para la propiedad "REGEX_DEFAULT_MATCH_TIMEOUT", como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 Si no establece explícitamente un intervalo de tiempo de espera, el valor predeterminado <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> es operaciones utilizadas y búsqueda de coincidencias no tiempo de espera.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene las opciones que se pasaron en el constructor <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <value>Uno o más miembros de la enumeración <see cref="T:System.Text.RegularExpressions.RegexOptions" /> que representan opciones pasadas al constructor de <see cref="T:System.Text.RegularExpressions.Regex" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de la <xref:System.Text.RegularExpressions.Regex.Options%2A> propiedad consta de uno o varios miembros de la <xref:System.Text.RegularExpressions.RegexOptions> enumeración. Si no hay opciones se han definido en el <xref:System.Text.RegularExpressions.Regex> constructor de clase, su valor es <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>. Las opciones disponibles se describen en detalle en la [opciones de expresiones regulares](~/docs/standard/base-types/regular-expression-options.md) tema.  
  
 Tenga en cuenta que el <xref:System.Text.RegularExpressions.Regex.Options%2A> propiedad no refleja las opciones alineadas definidas en la expresión regular de patrones propio.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> es la clase base de las expresiones regulares creados por el <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> método. Estas expresiones regulares compiladas usan la implementación de clase base la <see cref="P:System.Text.RegularExpressions.Regex.Options" /> propiedad. Si se llama desde una clase derivada, el <see cref="P:System.Text.RegularExpressions.Regex.Options" /> propiedad devuelve las opciones que se pasaron a la <paramref name="options" /> parámetro de la <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> constructor de clase que se usó para definir la expresión regular.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En una cadena de entrada especificada, reemplaza las cadenas que coinciden con un modelo de expresión regular por una cadena de reemplazo especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="replacement">La cadena de reemplazo.</param>
        <summary>En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con un patrón de expresión regular por una cadena de reemplazo especificada.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comienza la búsqueda de coincidencias al principio de la `input` cadena. La expresión regular es el patrón definido por el constructor actual <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 El `replacement` parámetro especifica la cadena que va a reemplazar cada coincidencia en `input`. `replacement` puede constar de cualquier combinación de texto literal y [sustituciones](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por ejemplo, el patrón de reemplazo `a*${test}b` inserta la cadena "un *" seguida de la subcadena que coincide con el `test` captura grupo, si los hay, seguida por la cadena "b". El * no se reconoce el carácter como un metacarácter dentro de un patrón de reemplazo.  
  
> [!NOTE]
>  Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo. Todos los demás elementos de lenguaje de expresiones regulares, incluidos [escapes de carácter](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), se permiten en los patrones de expresión regular solo y no se reconocen en los patrones de reemplazo.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no hay tiempo de espera se define en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado ningún reemplazo para la cadena de entrada.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una expresión regular, `\s+`, que coincide con uno o varios caracteres de espacio en blanco. La cadena de reemplazo, "", los reemplaza con un carácter de espacio único.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 En el ejemplo siguiente se define una expresión regular, `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`y un patrón de reemplazo, `$2`, que quita caracteres iniciales o un símbolo de divisa al final de un valor numérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 La expresión regular se interpreta como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\p{Sc}`|Coincide con un símbolo de moneda. `{Sc}` denota cualquier carácter que sea miembro del símbolo Unicode, categoría de moneda.|  
|`\s?`|Busca coincidencias con cero o un carácter de espacio en blanco.|  
|`(\p{Sc}\s?)?`|Coincide con cero o una aparición de la combinación de un símbolo de moneda seguido de cero o un carácter de espacio en blanco. Este es el primer grupo de captura.|  
|`\d+`|Buscar coincidencias con uno o más dígitos decimales.|  
|`\.?`|Coincide con cero o una aparición de un período (que se usa como un carácter de separador decimal).|  
|`((?<=\.)\d+)?`|Si un punto es el carácter anterior, coincide con uno o más dígitos decimales. Este patrón puede coincidir cero o una vez.|  
|`(\d+\.?((?<=\.)\d+)?)`|Coincide con el patrón de uno o más dígitos decimales, seguido de un punto opcional y los dígitos decimales adicionales. Este es el segundo grupo de captura. La llamada a la <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> método reemplaza toda la coincidencia con el valor de este grupo capturado.|  
|`(?(1)&#124;\s?\p{Sc})?`|Si el primer grupo capturado existe, coincide con una cadena vacía. En caso contrario, coincide con cero o un carácter de espacio en blanco seguido de un símbolo de moneda.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="replacement" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="evaluator">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</param>
        <summary>En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular especificada por una cadena devuelta por un delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que una cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> método es útil para reemplazar una coincidencia de expresión regular si se cumple alguna de las condiciones siguientes:  
  
-   La cadena de reemplazo no se puede especificar fácilmente mediante un patrón de reemplazo de expresión regular.  
  
-   Los resultados de la cadena de reemplazo de algunos procesos realizados en la cadena coincidente.  
  
-   Los resultados de la cadena de reemplazo de un procesamiento condicional.  
  
 El método es equivalente a llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> método y pasar cada <xref:System.Text.RegularExpressions.Match> objeto en el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> colección a la `evaluator` delegar.  
  
 La expresión regular es el patrón definido por el constructor actual <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 El `evaluator` parámetro es el delegado de un método personalizado que define y que examina cada coincidencia. El método personalizado debe tener la siguiente firma para que coincida con el <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 El método personalizado devuelve una cadena que reemplaza la entrada coincidente.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no hay tiempo de espera se define en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado ningún reemplazo para la cadena de entrada.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra una cadena original, coincide con cada palabra en la cadena original, convierte el primer carácter de cada coincidencia en mayúsculas, a continuación, muestra la cadena convertida.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="evaluator" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="replacement">La cadena de reemplazo.</param>
        <param name="count">Número máximo de veces que puede producirse el reemplazo.</param>
        <summary>En una cadena de entrada especificada, reemplaza un número máximo indicado de cadenas que coinciden con un patrón de expresión regular por una cadena de reemplazo especificada.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comienza la búsqueda de coincidencias al principio de la `input` cadena. La expresión regular es el patrón que se define mediante el constructor actual <xref:System.Text.RegularExpressions.Regex> objeto. Si `count` es negativo, los reemplazos continuarán hasta el final de la cadena. Si `count` supera el número de coincidencias, se reemplazan todas las coincidencias.  
  
 El `replacement` parámetro especifica la cadena que va a reemplazar la primera `count` coincidencias en `input`. `replacement` puede constar de cualquier combinación de texto literal y [sustituciones](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por ejemplo, el patrón de reemplazo `a*${test}b` inserta la cadena "un *" seguida de la subcadena que coincide con el `test` captura grupo, si los hay, seguida por la cadena "b". El * no se reconoce el carácter como un metacarácter dentro de un patrón de reemplazo.  
  
> [!NOTE]
>  Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo. Todos los demás elementos de lenguaje de expresiones regulares, incluidos [escapes de carácter](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), se permiten en los patrones de expresión regular solo y no se reconocen en los patrones de reemplazo.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no hay tiempo de espera se define en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado ningún reemplazo para la cadena de entrada.  
  
   
  
## Examples  
 El siguiente ejemplo reemplaza las cinco primeras apariciones de caracteres duplicados con un solo carácter. El patrón de expresión regular `(\w)\1` detecta instancias consecutivas de un solo carácter y asigna la primera aparición en el primer grupo de captura. El patrón de reemplazo `$1` reemplaza toda la coincidencia con el primer grupo capturado.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="replacement" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="replacement">La cadena de reemplazo.</param>
        <summary>En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular concreta por la cadena de reemplazo indicada.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si <paramref name="pattern" /> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estático `Replace` métodos son equivalentes a construir un <xref:System.Text.RegularExpressions.Regex> con el patrón de expresión regular especificada de objetos y llamar al método de instancia `Replace`.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Comienza la búsqueda de coincidencias al principio de la `input` cadena.  
  
 El `replacement` parámetro especifica la cadena que va a reemplazar cada coincidencia en `input`. `replacement` puede constar de cualquier combinación de texto literal y [sustituciones](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por ejemplo, el patrón de reemplazo `a*${test}b` inserta la cadena "un *" seguida de la subcadena que coincide con el `test` captura grupo, si los hay, seguida por la cadena "b". El * no se reconoce el carácter como un metacarácter dentro de un patrón de reemplazo.  
  
> [!NOTE]
>  Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo. Todos los demás elementos de lenguaje de expresiones regulares, incluidos [escapes de carácter](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), se permiten en los patrones de expresión regular solo y no se reconocen en los patrones de reemplazo.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no hay tiempo de espera se define en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción.  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado ningún reemplazo para la cadena de entrada.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una expresión regular, `\s+`, que coincide con uno o varios caracteres de espacio en blanco. La cadena de reemplazo, "", los reemplaza con un carácter de espacio único.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 En el ejemplo siguiente se usa el <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> método para reemplazar los nombres de equipo y la unidad locales en una ruta de acceso UNC con una ruta de acceso de archivo local. La expresión regular usa el <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propiedad para incluir el nombre del equipo local y el <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> método para incluir los nombres de las unidades lógicas. Para ejecutar el ejemplo correctamente, debe reemplazar la cadena literal "MyMachine" con el nombre del equipo local.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 El patrón de expresión regular se define mediante la siguiente expresión:  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\\\\`|Barra diagonal inversa de coincidencia dos consecutivo (`\`) caracteres. Dado que el carácter de barra diagonal inversa se interpreta como carácter de escape, cada barra diagonal inversa debe ser de escape con otra barra diagonal inversa.|  
|`(?i:" + Environment.MachineName + ")`|Realizar una coincidencia de mayúsculas y minúsculas de la cadena devuelta por la <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propiedad.|  
|`(?:\.\w+)*`|Coincide con el período (`.`) carácter seguido de uno o más caracteres alfabéticos. Esta coincidencia puede aparecer cero o más veces. No se captura la subexpresión coincidente.|  
|`\\`|Coincide con una barra diagonal inversa (`\`) caracteres.|  
|`((?i:[" + driveNames + "]))`|Realizar a una coincidencia de mayúsculas y minúsculas de la clase de caracteres que se compone de la comparación de unidad individual. Esta coincidencia es la primera subexpresión capturada.|  
|`\$`|Coincide con el signo de dólar literal (`$`) caracteres.|  
  
 El patrón de reemplazo `$1` reemplaza toda la coincidencia con la primera subexpresión capturada. Es decir, reemplaza el nombre de equipo y la unidad UNC con la letra de unidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="replacement" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método se agota después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama. Si no se ha definido un valor de tiempo de espera para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para reemplazar una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="evaluator">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</param>
        <summary>En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular especificada por una cadena devuelta por un delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que una cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si <paramref name="pattern" /> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> método es útil para reemplazar una coincidencia de expresión regular si se cumple alguna de las condiciones siguientes:  
  
-   La cadena de reemplazo no se puede especificar fácilmente mediante un patrón de reemplazo de expresión regular.  
  
-   Los resultados de la cadena de reemplazo de algunos procesos realizados en la cadena coincidente.  
  
-   Los resultados de la cadena de reemplazo de un procesamiento condicional.  
  
 El método es equivalente a llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> método y pasar cada <xref:System.Text.RegularExpressions.Match> objeto en el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> colección a la `evaluator` delegar.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El `evaluator` parámetro es el delegado de un método personalizado que define y que examina cada coincidencia. El método personalizado debe tener la siguiente firma para que coincida con el <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 El método personalizado devuelve una cadena que reemplaza la entrada coincidente.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no hay tiempo de espera se define en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción.  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado ningún reemplazo para la cadena de entrada.  
  
   
  
## Examples  
 El ejemplo siguiente se usa una expresión regular para extraer las palabras individuales de una cadena y, a continuación, usa un <xref:System.Text.RegularExpressions.MatchEvaluator> delegado para llamar a un método denominado `WordScramble` que codifica las letras individuales de la palabra. Para ello, el `WordScramble` método crea una matriz que contiene los caracteres de la coincidencia. También se crea una matriz paralela que se rellena con números de punto flotante aleatorios. Las matrices se ordenan mediante una llamada a la <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método y la matriz ordenada se proporciona como argumento a un <xref:System.String> constructor de clase. A continuación, se devuelve esta cadena recién creada por el `WordScramble` método. El patrón de expresión regular `\w+` coincide con uno o más caracteres alfabéticos; el motor de expresiones regulares continuará agregando caracteres a la coincidencia hasta que encuentra un carácter que no sea de palabra, como un carácter de espacio en blanco.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="evaluator" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método se agota después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama. Si no se ha definido un valor de tiempo de espera para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para evaluar y reemplazar una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="evaluator">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</param>
        <param name="count">Número máximo de veces que se llevará a cabo el reemplazo.</param>
        <summary>En una cadena de entrada especificada, reemplaza un número máximo especificado de cadenas que coinciden con un modelo de expresión regular por una cadena devuelta por un delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que una cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> método es útil para reemplazar una coincidencia de expresión regular si se cumple alguna de las condiciones siguientes:  
  
-   La cadena de reemplazo no se puede especificar fácilmente mediante un patrón de reemplazo de expresión regular.  
  
-   Los resultados de la cadena de reemplazo de algunos procesos realizados en la cadena coincidente.  
  
-   Los resultados de la cadena de reemplazo de un procesamiento condicional.  
  
 El método es equivalente a llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> método y pasando la primera `count` <xref:System.Text.RegularExpressions.Match> objetos en el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> colección a la `evaluator` delegar.  
  
 La expresión regular es el patrón definido por el constructor actual <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 El `evaluator` parámetro es el delegado de un método personalizado que define y que examina cada coincidencia. El método personalizado debe tener la siguiente firma para que coincida con el <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 El método personalizado devuelve una cadena que reemplaza la entrada coincidente.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no hay tiempo de espera se define en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado ningún reemplazo para la cadena de entrada.  
  
   
  
## Examples  
 El ejemplo siguiente usa una expresión regular para escribir mal deliberadamente a mitad de las palabras de una lista. Se usa la expresión regular `\w*(ie|ei)\w*` para buscar palabras que incluyen los caracteres "ie" o "ei". Pasa la primera mitad de las palabras coincidentes del `ReverseLetter` método, que, a su vez, se usa el <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> para invertir la "i" y "e" en la cadena coincidente. El resto de las palabras permanecen sin cambios.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 La expresión regular `\w*(ie|ei)\w*` se define como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\w*`|Buscar una coincidencia con cero o más caracteres alfabéticos.|  
|`(ie&#124;ei)`|Coincide con "ie" o "ei".|  
|`\w*`|Buscar una coincidencia con cero o más caracteres alfabéticos.|  
  
 El patrón de expresión regular `([ie])([ie])` en el `ReverseLetter` método coincide con la primera "i" o "e" en el diphthong "ie" o "ei" y asigna la letra al primer grupo de captura. Coincide con la segunda "i" o "e" y asigna la letra al segundo grupo de captura. Los dos caracteres, a continuación, se invierten mediante una llamada a la <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> método con el patrón de reemplazo `$2$1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="evaluator" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="replacement">La cadena de reemplazo.</param>
        <param name="count">Número máximo de veces que puede producirse el reemplazo.</param>
        <param name="startat">Posición del carácter en la cadena de entrada donde comienza la búsqueda.</param>
        <summary>En una subcadena de entrada especificada, reemplaza un número máximo especificado de cadenas que coinciden con un patrón de expresión regular por una cadena de reemplazo especificada.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se inicia la búsqueda de coincidencias en el `input` cadena en la posición especificada por el `startat` parámetro. La expresión regular es el patrón definido por el constructor actual <xref:System.Text.RegularExpressions.Regex> objeto. Si `count` es negativo, los reemplazos continuarán hasta el final de la cadena. Si `count` supera el número de coincidencias, se reemplazan todas las coincidencias.  
  
 El `replacement` parámetro especifica la cadena que va a reemplazar cada coincidencia en `input`. `replacement` puede constar de cualquier combinación de texto literal y [sustituciones](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por ejemplo, el patrón de reemplazo `a*${test}b` inserta la cadena "un *" seguida de la subcadena que coincide con el `test` captura grupo, si los hay, seguida por la cadena "b". El * no se reconoce el carácter como un metacarácter dentro de un patrón de reemplazo.  
  
> [!NOTE]
>  Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo. Todos los demás elementos de lenguaje de expresiones regulares, incluidos [escapes de carácter](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), se permiten en los patrones de expresión regular solo y no se reconocen en los patrones de reemplazo.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no hay tiempo de espera se define en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado ningún reemplazo para la cadena de entrada.  
  
   
  
## Examples  
 El ejemplo siguiente se duplica todas excepto la primera línea de una cadena. Define un patrón de expresión regular, `^.*$`, que coincide con una línea de texto, las llamadas del <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método para que coincida con la primera línea de la cadena y usa el `Match.Index` y `Match.Count` propiedades para determinar la posición inicial del segundo línea.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 El patrón de expresión regular `^.*$` se define como se muestra en la tabla siguiente.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`^`|Coincide con el inicio de una línea. (Tenga en cuenta que el <xref:System.Text.RegularExpressions.Regex> se crea una instancia del objeto utilizando el <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option; en caso contrario, esta clase de caracteres solo coincidiría con el principio de la cadena de entrada.)|  
|`.*`|Coincide con cualquier carácter cero o más veces.|  
|`$`|Coincidir con el final de una línea. (Tenga en cuenta que el <xref:System.Text.RegularExpressions.Regex> se crea una instancia del objeto utilizando el <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option; en caso contrario, esta clase de caracteres solo coincidiría con el principio de la cadena de entrada.)|  
  
 La cadena de reemplazo (`vbCrLf + "$&"` en Visual Basic, `"\n$&"` en C#) agrega una nueva línea antes de la cadena coincidente. Tenga en cuenta que `\n` en C# en el ejemplo se se interpreta como carácter de nueva línea por el compilador de C#; no representa un carácter de escape de expresión regular.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="replacement" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> es menor que cero o mayor que la longitud de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="replacement">La cadena de reemplazo.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <summary>En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular concreta por la cadena de reemplazo indicada. Las opciones especificadas modifican la operación de coincidencia.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si <paramref name="pattern" /> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estático `Replace` métodos son equivalentes a construir un <xref:System.Text.RegularExpressions.Regex> con el patrón de expresión regular especificada de objetos y llamar al método de instancia `Replace`.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Si especifica <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> para el `options` parámetro, la búsqueda de coincidencias empieza al final de la cadena de entrada y se mueve a la izquierda; en caso contrario, la búsqueda comienza al principio de la cadena de entrada y se desplaza hacia la derecha.  
  
 El `replacement` parámetro especifica la cadena que va a reemplazar cada coincidencia en `input`. `replacement` puede constar de cualquier combinación de texto literal y [sustituciones](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por ejemplo, el patrón de reemplazo `a*${test}b` inserta la cadena "un *" seguida de la subcadena que coincide con el `test` captura grupo, si los hay, seguida por la cadena "b". El * no se reconoce el carácter como un metacarácter dentro de un patrón de reemplazo.  
  
> [!NOTE]
>  Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo. Todos los demás elementos de lenguaje de expresiones regulares, incluidos [escapes de carácter](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), se permiten en los patrones de expresión regular solo y no se reconocen en los patrones de reemplazo.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no hay tiempo de espera se define en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción.  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado ningún reemplazo para la cadena de entrada.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método para reemplazar los nombres de equipo y la unidad locales en una ruta de acceso UNC con una ruta de acceso de archivo local. La expresión regular usa el <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propiedad para incluir el nombre del equipo local y el <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> método para incluir los nombres de las unidades lógicas. Todas las comparaciones de cadenas de expresiones regulares distinguen mayúsculas de minúsculas. Para ejecutar el ejemplo correctamente, debe reemplazar la cadena literal "MyMachine" con el nombre del equipo local.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 El patrón de expresión regular se define mediante la siguiente expresión:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\\\\`|Barra diagonal inversa de coincidencia dos consecutivo (`\`) caracteres. Dado que el carácter de barra diagonal inversa se interpreta como carácter de escape, cada barra diagonal inversa debe ser de escape con otra barra diagonal inversa.|  
|`+ Environment.MachineName +`|Coincide con la cadena devuelta por la <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propiedad.|  
|`(?:\.\w+)*`|Coincide con el período (`.`) carácter seguido de uno o más caracteres alfabéticos. Esta coincidencia puede aparecer cero o más veces. No se captura la subexpresión coincidente.|  
|`\\`|Coincide con una barra diagonal inversa (`\`) caracteres.|  
|`([" + driveNames + "])`|Coincide con la clase de caracteres formado por las letras de unidad individuales. Esta coincidencia es la primera subexpresión capturada.|  
|`\$`|Coincide con el signo de dólar literal (`$`) caracteres.|  
  
 El patrón de reemplazo `$1` reemplaza toda la coincidencia con la primera subexpresión capturada. Es decir, reemplaza el nombre de equipo y la unidad UNC con la letra de unidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="replacement" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método se agota después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama. Si no se ha definido un valor de tiempo de espera para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para reemplazar una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="evaluator">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <summary>En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular especificada por una cadena devuelta por un delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Las opciones especificadas modifican la operación de coincidencia.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que una cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si <paramref name="pattern" /> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método es útil para reemplazar una coincidencia de expresión regular en si se cumple alguna de las condiciones siguientes:  
  
-   La cadena de reemplazo no se puede especificar fácilmente mediante un patrón de reemplazo de expresión regular.  
  
-   Los resultados de la cadena de reemplazo de algunos procesos realizados en la cadena coincidente.  
  
-   Los resultados de la cadena de reemplazo de un procesamiento condicional.  
  
 El método es equivalente a llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método y pasar cada <xref:System.Text.RegularExpressions.Match> objeto en el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> colección a la `evaluator` delegar.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El `evaluator` parámetro es el delegado de un método personalizado que define y que examina cada coincidencia. El método personalizado debe tener la siguiente firma para que coincida con el <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 El método personalizado devuelve una cadena que reemplaza la entrada coincidente.  
  
 Si especifica <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> para el `options` parámetro, la búsqueda de coincidencias empieza al final de la cadena de entrada y se mueve a la izquierda; en caso contrario, la búsqueda comienza al principio de la cadena de entrada y se desplaza hacia la derecha.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no hay tiempo de espera se define en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción.  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado ningún reemplazo para la cadena de entrada.  
  
   
  
## Examples  
 El ejemplo siguiente se usa una expresión regular para extraer las palabras individuales de una cadena y, a continuación, usa un <xref:System.Text.RegularExpressions.MatchEvaluator> delegado para llamar a un método denominado `WordScramble` que codifica las letras individuales de la palabra. Para ello, el `WordScramble` método crea una matriz que contiene los caracteres de la coincidencia. También se crea una matriz paralela que se rellena con números de punto flotante aleatorios. Las matrices se ordenan mediante una llamada a la <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método y la matriz ordenada se proporciona como argumento a un <xref:System.String> constructor de clase. A continuación, se devuelve esta cadena recién creada por el `WordScramble` método. El patrón de expresión regular `\w+` coincide con uno o más caracteres alfabéticos; el motor de expresiones regulares continuará agregando caracteres a la coincidencia hasta que encuentra un carácter que no sea de palabra, como un carácter de espacio en blanco. La llamada a la <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> método incluye el <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opción para que el comentario en el patrón de expresión regular `\w+  # Matches all the characters in a word.` omitido por el motor de expresiones regulares.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="evaluator" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="evaluator">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</param>
        <param name="count">Número máximo de veces que se llevará a cabo el reemplazo.</param>
        <param name="startat">Posición del carácter en la cadena de entrada donde comienza la búsqueda.</param>
        <summary>En una subcadena de entrada especificada, reemplaza un número máximo especificado de cadenas que coinciden con un modelo de expresión regular por una cadena devuelta por un delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que una cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si no se encuentran coincidencias del patrón de expresión regular en la instancia actual, el método devuelve la instancia sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método es útil para reemplazar una coincidencia de expresión regular si se cumple alguna de las condiciones siguientes:  
  
-   La cadena de reemplazo no se puede especificar fácilmente mediante un patrón de reemplazo de expresión regular.  
  
-   Los resultados de la cadena de reemplazo de algunos procesos realizados en la cadena coincidente.  
  
-   Los resultados de la cadena de reemplazo de un procesamiento condicional.  
  
 El método es equivalente a llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> método y pasando la primera `count` <xref:System.Text.RegularExpressions.Match> objetos en el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> colección a la `evaluator` delegar.  
  
 La expresión regular es el patrón definido por el constructor actual <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 El `evaluator` parámetro es el delegado de un método personalizado que define y que examina cada coincidencia. El método personalizado debe tener la siguiente firma para que coincida con el <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 El método personalizado devuelve una cadena que reemplaza la entrada coincidente.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de reemplazo supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no hay tiempo de espera se define en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado ningún reemplazo para la cadena de entrada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="evaluator" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> es menor que cero o mayor que la longitud de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="replacement">La cadena de reemplazo.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <param name="matchTimeout">Un intervalo de tiempo de espera, o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que el método no debe agotar el tiempo de espera.</param>
        <summary>En una cadena de entrada especificada, reemplaza todas las cadenas que coinciden con una expresión regular concreta por la cadena de reemplazo indicada. Los parámetros adicionales especifican las opciones que modifican la operación de coincidencia y un intervalo de tiempo de espera si no se encuentra ninguna coincidencia.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si <paramref name="pattern" /> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estático `Replace` métodos son equivalentes a construir un <xref:System.Text.RegularExpressions.Regex> con el patrón de expresión regular especificada de objetos y llamar al método de instancia `Replace`.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Si especifica <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> para el `options` parámetro, la búsqueda de coincidencias empieza al final de la cadena de entrada y se mueve a la izquierda; en caso contrario, la búsqueda comienza al principio de la cadena de entrada y se desplaza hacia la derecha.  
  
 El `replacement` parámetro especifica la cadena que va a reemplazar cada coincidencia en `input`. `replacement` puede constar de cualquier combinación de texto literal y [sustituciones](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por ejemplo, el patrón de reemplazo `a*${test}b` inserta la cadena "un *" seguida de la subcadena que coincide con el `test` captura grupo, si los hay, seguida por la cadena "b". El * no se reconoce el carácter como un metacarácter dentro de un patrón de reemplazo.  
  
> [!NOTE]
>  Las sustituciones son los elementos del lenguaje de expresión regular solo se reconocen en un patrón de reemplazo. Todos los demás elementos de lenguaje de expresiones regulares, incluidos [escapes de carácter](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), se permiten en los patrones de expresión regular solo y no se reconocen en los patrones de reemplazo.  
  
 El `matchTimeout` parámetro especifica cómo larga una coincidencia de método debe intentar buscar una coincidencia antes de expirar. Establecer un intervalo de tiempo de espera evita que las expresiones regulares que se basan en un retroceso excesivo aparezcan deje de responder al procesar la entrada que contenga cerca de coincidencias. Para obtener más información, consulte [procedimientos recomendados con expresiones regulares](~/docs/standard/base-types/best-practices.md) y [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Si no se encuentra ninguna coincidencia en ese intervalo de tiempo, el método produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. `matchTimeout` invalida cualquier valor de tiempo de espera predeterminado definido para el dominio de aplicación en el que se ejecuta el método.  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado ningún reemplazo para la cadena de entrada.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método para reemplazar los nombres de equipo y la unidad locales en una ruta de acceso UNC con una ruta de acceso de archivo local. La expresión regular usa el <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propiedad para incluir el nombre del equipo local y el <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> método para incluir los nombres de las unidades lógicas. Todas las comparaciones de cadenas de expresiones regulares distinguen mayúsculas de minúsculas, y cualquier operación de reemplazo único tiempo de espera si no se encuentra una coincidencia en 0,5 segundos. Para ejecutar el ejemplo correctamente, debe reemplazar la cadena literal "MyMachine" con el nombre del equipo local.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 El patrón de expresión regular se define mediante la siguiente expresión:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\\\\`|Barra diagonal inversa de coincidencia dos consecutivo (`\`) caracteres. Dado que el carácter de barra diagonal inversa se interpreta como carácter de escape, cada barra diagonal inversa debe ser de escape con otra barra diagonal inversa.|  
|`+ Environment.MachineName +`|Coincide con la cadena devuelta por la <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propiedad.|  
|`(?:\.\w+)*`|Coincide con el período (`.`) carácter seguido de uno o más caracteres alfabéticos. Esta coincidencia puede aparecer cero o más veces. No se captura la subexpresión coincidente.|  
|`\\`|Coincide con una barra diagonal inversa (`\`) caracteres.|  
|`([" + driveNames + "])`|Coincide con la clase de caracteres formado por las letras de unidad individuales. Esta coincidencia es la primera subexpresión capturada.|  
|`\$`|Coincide con el signo de dólar literal (`$`) caracteres.|  
  
 El patrón de reemplazo `$1` reemplaza toda la coincidencia con la primera subexpresión capturada. Es decir, reemplaza el nombre de equipo y la unidad UNC con la letra de unidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="replacement" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
O bien 
 <paramref name="matchTimeout" /> es negativo, cero o mayor que 24 días aproximadamente.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó un tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Se recomienda que establezca el <paramref name="matchTimeout" /> parámetro a un valor apropiado, como dos segundos. Si deshabilita los tiempos de espera mediante la especificación de <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor. Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones: - cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o formado por texto estático. Excluye el texto que ha sido dinámicamente por usuarios.  -Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controla con gran eficacia coincide, la ausencia de coincidencias y próximo coincide con.  -Cuando el patrón de expresión regular contiene ningún elemento de lenguaje que causan un retroceso excesivo al procesar a una coincidencia casi.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Cadena en la que se va a buscar una coincidencia.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="evaluator">Un método personalizado que examina cada coincidencia y devuelve la cadena coincidente original o una cadena de reemplazo.</param>
        <param name="options">Combinación bit a bit de los valores de la enumeración que proporcionan opciones de coincidencia.</param>
        <param name="matchTimeout">Un intervalo de tiempo de espera, o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que el método no debe agotar el tiempo de espera.</param>
        <summary>En una cadena de entrada especificada, reemplaza todas las subcadenas que coinciden con una expresión regular especificada por una cadena devuelta por un delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Los parámetros adicionales especifican las opciones que modifican la operación de coincidencia y un intervalo de tiempo de espera si no se encuentra ninguna coincidencia.</summary>
        <returns>Cadena nueva que es idéntica a la cadena de entrada, salvo que la cadena de reemplazo ocupa el lugar de cada cadena coincidente. Si <paramref name="pattern" /> no coincide con la instancia actual, el método devuelve la instancia actual sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método es útil para reemplazar una coincidencia de expresión regular si se cumple alguna de las condiciones siguientes:  
  
-   Si la cadena de reemplazo no se puede especificar fácilmente mediante un patrón de reemplazo de expresión regular.  
  
-   Si la cadena de reemplazo que da como resultado de realiza algún procesamiento en la cadena coincidente.  
  
-   Si da como resultado de la cadena de reemplazo de un procesamiento condicional.  
  
 El método es equivalente a llamar a la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método y pasar cada <xref:System.Text.RegularExpressions.Match> objeto en el valor devuelto <xref:System.Text.RegularExpressions.MatchCollection> colección a la `evaluator` delegar.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 El `evaluator` parámetro es el delegado de un método personalizado que define y que examina cada coincidencia. El método personalizado debe tener la siguiente firma para que coincida con el <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 El método personalizado devuelve una cadena que reemplaza la entrada coincidente.  
  
 Si especifica <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> para el `options` parámetro, la búsqueda de coincidencias empieza al final de la cadena de entrada y se mueve a la izquierda; en caso contrario, la búsqueda comienza al principio de la cadena de entrada y se desplaza hacia la derecha.  
  
 El `matchTimeout` parámetro especifica cómo larga una coincidencia de método debe intentar buscar una coincidencia antes de expirar. Establecer un intervalo de tiempo de espera evita que las expresiones regulares que se basan en un retroceso excesivo que aparezca en "dejar de responder al procesar la entrada que contenga cerca de coincidencias. Para obtener más información, consulte [procedimientos recomendados con expresiones regulares](~/docs/standard/base-types/best-practices.md) y [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Si no se encuentra ninguna coincidencia en ese intervalo de tiempo, el método produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. `matchTimeout` invalida cualquier valor de tiempo de espera predeterminado definido para el dominio de aplicación en el que se ejecuta el método.  
  
 Dado que el método devuelve `input` sin cambios si no hay ninguna coincidencia, puede usar el <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar si el método ha realizado ningún reemplazo para la cadena de entrada.  
  
   
  
## Examples  
 El ejemplo siguiente se usa una expresión regular para extraer las palabras individuales de una cadena y, a continuación, usa un <xref:System.Text.RegularExpressions.MatchEvaluator> delegado para llamar a un método denominado `WordScramble` que codifica las letras individuales de la palabra. Para ello, el `WordScramble` método crea una matriz que contiene los caracteres de la coincidencia. También se crea una matriz paralela que se rellena con números de punto flotante aleatorios. Las matrices se ordenan mediante una llamada a la <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método y la matriz ordenada se proporciona como argumento a un <xref:System.String> constructor de clase. A continuación, se devuelve esta cadena recién creada por el `WordScramble` método. El patrón de expresión regular `\w+` coincide con uno o más caracteres alfabéticos; el motor de expresiones regulares continuará agregando caracteres a la coincidencia hasta que encuentra un carácter que no sea de palabra, como un carácter de espacio en blanco. La llamada a la <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> método incluye el <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opción para que el comentario en el patrón de expresión regular `\w+  # Matches all the characters in a word.` omitido por el motor de expresiones regulares.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="evaluator" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
O bien 
 <paramref name="matchTimeout" /> es negativo, cero o mayor que 24 días aproximadamente.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó un tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Se recomienda que establezca el <paramref name="matchTimeout" /> parámetro a un valor apropiado, como dos segundos. Si deshabilita los tiempos de espera mediante la especificación de <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor. Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones: - cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o formado por texto estático. Excluye el texto que ha sido dinámicamente por usuarios.  -Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controla con gran eficacia coincide, la ausencia de coincidencias y próximo coincide con.  -Cuando el patrón de expresión regular contiene ningún elemento de lenguaje que causan un retroceso excesivo al procesar a una coincidencia casi.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la expresión regular busca de derecha a izquierda.</summary>
        <value>
          <see langword="true" /> si la expresión regular busca de derecha a izquierda; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> es `true` si el <xref:System.Text.RegularExpressions.Regex> instancia se creó con la <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> opción.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Divide una cadena de entrada en una matriz de subcadenas en las posiciones definidas por una coincidencia de expresión regular.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena que se va a dividir.</param>
        <summary>Divide una cadena de entrada en una matriz de subcadenas en las posiciones definidas por un modelo de expresión regular especificado en el constructor <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Matriz de cadenas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos son similares a los <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> método, salvo que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres. Se divide la cadena tantas veces como sea posible. Si no se encuentra ningún delimitador, el valor devuelto contiene un elemento cuyo valor es la cadena de entrada original.  
  
 Si varias coincidencias son adyacentes entre sí, se inserta una cadena vacía en la matriz. Por ejemplo, dividir una cadena en un solo guión hace que la matriz devuelta debe incluir una cadena vacía en la posición donde se encuentran dos guiones adyacentes, como se muestra en el código siguiente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 Si se encuentra una coincidencia al principio o al final de la cadena de entrada, una cadena vacía se incluye al principio o al final de la matriz devuelta. En el ejemplo siguiente se usa el patrón de expresión regular `\d+` para dividir una cadena en caracteres numéricos de entrada. Dado que la cadena empieza y termina con la coincidencia de caracteres numéricos, el valor del primer y último elemento de la matriz devuelta es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 Si se usan paréntesis de captura en un <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expresión, cualquier capturada se incluye el texto de la matriz de cadena resultante. Por ejemplo, si divide la cadena "plum-pear" en un guión colocado entre paréntesis de captura, la matriz devuelta incluye un elemento de cadena que contiene el guión.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework. En .NET Framework 1.0 y 1.1, si no se encuentra una coincidencia en el primer conjunto de paréntesis, de captura no se incluye el texto capturado de paréntesis adicionales en la matriz devuelta. Todo el texto capturado a partir de .NET Framework 2.0, también se agrega a la matriz devuelta. Por ejemplo, el código siguiente utiliza dos conjuntos de paréntesis de captura para extraer los elementos de una fecha, incluidos los delimitadores de fecha, de una cadena de fecha. El primer conjunto de paréntesis de captura captura el guión y el segundo captura la barra diagonal. Si el código de ejemplo se compila y ejecuta en .NET Framework 1.0 o 1.1, excluye los caracteres de barra diagonal; Si se compila y se ejecutan en el .NET Framework 2.0 o versiones posteriores, los incluye.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 Si la expresión regular puede coincidir con la cadena vacía, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> dividirá la cadena en una matriz de cadenas de carácter único porque se puede encontrar el delimitador de cadena vacía en todas las ubicaciones. Por ejemplo:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 Tenga en cuenta que la matriz devuelta también incluye una cadena vacía al principio y al final de la matriz.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de división supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no hay tiempo de espera se define en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena que se va a dividir.</param>
        <param name="count">Número máximo de veces que puede llevarse a cabo la división.</param>
        <summary>Divide una cadena de entrada por un número máximo especificado de veces en una matriz de subcadenas, en las posiciones definidas por una expresión regular especificada en el constructor <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Matriz de cadenas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos son similares a los <xref:System.String.Split%2A?displayProperty=nameWithType> método, salvo que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres. El `count` parámetro especifica el número máximo de subcadenas en la que el `input` se puede dividir la cadena; la última cadena contiene el resto no dividido de la cadena. Un `count` valor cero proporciona el comportamiento predeterminado de división tantas veces como sea posible.  
  
 Si varias coincidencias son adyacentes entre sí o si se encuentra una coincidencia al principio o al final de `input`, y el número de coincidencias encontradas al menos dos es menor que `count`, se inserta una cadena vacía en la matriz. Es decir, se cuentan las cadenas vacías que resultan de las coincidencias adyacentes o de coincidencias al principio o al final de la cadena de entrada para determinar si el número de coincide con subcadenas equals `count`. En el ejemplo siguiente, la expresión regular `/d+` se utiliza para dividir una cadena de entrada que incluye uno o más dígitos decimales en un máximo de tres subcadenas. Dado que el principio de la cadena de entrada coincide con el patrón de expresión regular, el primer elemento de matriz contiene <xref:System.String.Empty?displayProperty=nameWithType>, el segundo contiene el primer conjunto de caracteres alfabéticos en la cadena de entrada y el tercero contiene el resto de la cadena sigue a la coincidencia terceros.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 Si se usan paréntesis de captura en una expresión regular, se incluye el texto capturado en la matriz de cadenas de división. Sin embargo, los elementos de matriz que contienen texto capturado no se cuentan en determinar si se ha alcanzado el número de coincidencias `count`. Por ejemplo, dividir la cadena "apple-albaricoque-plum-pear-banana" en un máximo de cuatro resultados de subcadenas en una matriz de siete elementos, como el siguiente código muestra.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework. En .NET Framework 1.0 y 1.1, sólo el texto capturado desde el primer conjunto de paréntesis de captura se incluye en la matriz devuelta. A partir de .NET Framework 2.0, todo el texto capturado se agrega a la matriz devuelta. Sin embargo, los elementos de la matriz devuelta que contienen texto capturado no se cuentan en determinar si el número de coincide con subcadenas equals `count`. Por ejemplo, en el código siguiente, una expresión regular usa dos conjuntos de paréntesis de captura para extraer los elementos de una fecha de una cadena de fecha. El primer conjunto de paréntesis de captura captura el guión y el segundo captura la barra diagonal. La llamada a la <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> método, a continuación, especifica un máximo de dos elementos en la matriz devuelta. Si el código de ejemplo se compila y ejecuta en .NET Framework 1.0 o 1.1, el método devuelve una matriz de cadenas de dos elementos. Si se compila y se ejecutan en el .NET Framework 2.0 o versiones posteriores, el método devuelve una matriz de cadenas de tres elementos.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 Si la expresión regular puede coincidir con la cadena vacía, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> dividirá la cadena en una matriz de cadenas de carácter único porque se puede encontrar el delimitador de cadena vacía en todas las ubicaciones. El ejemplo siguiente divide la cadena "caracteres" en sea porque no hay muchos elementos en la cadena de entrada. Dado que la cadena null coincide con el principio de la cadena de entrada, se inserta una cadena nula al principio de la matriz devuelta. Esto hace que el décimo elemento constan de dos caracteres al final de la cadena de entrada.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de división supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no hay tiempo de espera se define en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Cadena que se va a dividir.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <summary>Divide una cadena de entrada en una matriz de subcadenas en las posiciones definidas por un patrón de expresión regular.</summary>
        <returns>Matriz de cadenas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos son similares a los <xref:System.String.Split%2A?displayProperty=nameWithType> método, salvo que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres. El `input` se divide la cadena tantas veces como sea posible. Si `pattern` no se encuentra en la `input` cadena, el valor devuelto contiene un elemento cuyo valor es original `input` cadena.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Compila expresiones regulares usadas en las llamadas a estática <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos automáticamente se almacenan en caché. Para administrar la duración de las expresiones regulares compiladas, utilice la instancia <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos.  
  
 Si varias coincidencias son adyacentes entre sí, se inserta una cadena vacía en la matriz. Por ejemplo, dividir una cadena en un solo guión hace que la matriz devuelta debe incluir una cadena vacía en la posición donde se encuentran dos guiones adyacentes, como se muestra en el código siguiente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 Si se encuentra una coincidencia al principio o al final de la cadena de entrada, una cadena vacía se incluye al principio o al final de la matriz devuelta. En el ejemplo siguiente se usa el patrón de expresión regular `\d+` para dividir una cadena en caracteres numéricos de entrada. Dado que la cadena empieza y termina con la coincidencia de caracteres numéricos, el valor del primer y último elemento de la matriz devuelta es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 Si se usan paréntesis de captura en un <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expresión, cualquier capturada se incluye el texto de la matriz de cadena resultante. Por ejemplo, si divide la cadena "plum-pear" en un guión colocado entre paréntesis de captura, la matriz devuelta incluye un elemento de cadena que contiene el guión.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework. En .NET Framework 1.0 y 1.1, si no se encuentra una coincidencia en el primer conjunto de paréntesis, de captura no se incluye el texto capturado de paréntesis adicionales en la matriz devuelta. Todo el texto capturado a partir de .NET Framework 2.0, también se agrega a la matriz devuelta. Por ejemplo, el código siguiente utiliza dos conjuntos de paréntesis de captura para extraer los elementos de una fecha, incluidos los delimitadores de fecha, de una cadena de fecha. El primer conjunto de paréntesis de captura captura el guión y el segundo captura la barra diagonal. Si el código de ejemplo se compila y ejecuta en .NET Framework 1.0 o 1.1, excluye los caracteres de barra diagonal; Si se compila y se ejecutan en el .NET Framework 2.0 o versiones posteriores, los incluye.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Si la expresión regular puede coincidir con la cadena vacía, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividirá la cadena en una matriz de cadenas de carácter único porque se puede encontrar el delimitador de cadena vacía en todas las ubicaciones. Por ejemplo:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 Tenga en cuenta que la matriz devuelta también incluye una cadena vacía al principio y al final de la matriz.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de división supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no hay tiempo de espera se define en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método se agota después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama al método. Si no se ha definido un valor de tiempo de espera para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para dividir el texto en una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Cadena que se va a dividir.</param>
        <param name="count">Número máximo de veces que puede llevarse a cabo la división.</param>
        <param name="startat">Posición de carácter de la cadena de entrada donde comenzará la búsqueda.</param>
        <summary>Divide una cadena de entrada por un número máximo especificado de veces en una matriz de subcadenas, en las posiciones definidas por una expresión regular especificada en el constructor <see cref="T:System.Text.RegularExpressions.Regex" />. La búsqueda del patrón de expresión regular se inicia en la posición de carácter especificada de la cadena de entrada.</summary>
        <returns>Matriz de cadenas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos son similares a los <xref:System.String.Split%2A?displayProperty=nameWithType> método, salvo que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres. El `count` parámetro especifica el número máximo de subcadenas en la que el `input` se divide la cadena; la última cadena contiene el resto no dividido de la cadena. Un `count` valor cero proporciona el comportamiento predeterminado de división tantas veces como sea posible. El `startat` parámetro define el punto en el que comienza la búsqueda del primer delimitador (Esto se puede utilizar para omitir el espacio en blanco inicial).  
  
 Si se encuentra ninguna coincidencia de la `count`+ 1 se coloque en la cadena, el método devuelve una matriz de un elemento que contiene el `input` cadena. Si se encuentran una o varias coincidencias, el primer elemento de la matriz devuelta contiene la primera parte de la cadena desde el primer carácter hasta un carácter delante de la coincidencia.  
  
 Si varias coincidencias son adyacentes entre sí y el número de coincidencias encontradas al menos dos es menor que `count`, se inserta una cadena vacía en la matriz. De forma similar, si se encuentra una coincidencia en `startat`, que es el primer carácter de la cadena, el primer elemento de la matriz devuelta es una cadena vacía. Es decir, se cuentan las cadenas vacías que se derivan de las coincidencias adyacentes para determinar si el número de coincide con subcadenas es igual a `count`. En el ejemplo siguiente, la expresión regular `\d+` se utiliza para buscar la posición inicial de la primera subcadena de caracteres numéricos en una cadena y, a continuación, dividir la cadena de un máximo de tres veces a partir de esa posición. Dado que el patrón de expresión regular coincide con el principio de la cadena de entrada, la matriz de cadena devuelta consta de una cadena vacía, una cadena de cinco caracteres alfabética y el resto de la cadena,  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 Si se usan paréntesis de captura en una expresión regular, se incluye el texto capturado en la matriz de cadenas de división. Sin embargo, los elementos de matriz que contienen texto capturado no se cuentan en determinar si se ha alcanzado el número de coincidencias `count`. Por ejemplo, dividir la cadena ' "apple-apricot-plum-pear-pomegranate-pineapple-peach" en un máximo de cuatro subcadenas a partir del carácter 15 de los resultados de la cadena en una matriz de siete elementos, como se muestra en el código siguiente.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework. En .NET Framework 1.0 y 1.1, si no se encuentra una coincidencia en el primer conjunto de paréntesis, de captura no se incluye el texto capturado de paréntesis adicionales en la matriz devuelta. Todo el texto capturado a partir de .NET Framework 2.0, también se agrega a la matriz devuelta. Por ejemplo, el código siguiente utiliza dos conjuntos de paréntesis de captura para extraer las palabras individuales en una cadena. El primer conjunto de paréntesis de captura captura el guión y el segundo captura la barra vertical. Si el código de ejemplo se compila y ejecuta en .NET Framework 1.0 o 1.1, excluye la vertical de la barra caracteres; Si se compila y se ejecutan en el .NET Framework 2.0 o versiones posteriores, los incluye.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 Si la expresión regular puede coincidir con la cadena vacía, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividirá la cadena en una matriz de cadenas de carácter único porque se puede encontrar el delimitador de cadena vacía en todas las ubicaciones. En el ejemplo siguiente se divide la cadena "caracteres" en tantos elementos como que contiene la cadena de entrada, empezando por el carácter "a". Dado que la cadena null coincide con el final de la cadena de entrada, se inserta una cadena nula al final de la matriz devuelta.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de división supera el intervalo de tiempo de espera especificado por el <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor. Si no establece un intervalo de tiempo de espera al llamar al constructor, la excepción se produce si la operación supera cualquier valor de tiempo de espera establecido para el dominio de aplicación en el que el <xref:System.Text.RegularExpressions.Regex> se crea el objeto. Si no hay tiempo de espera se define en el <xref:System.Text.RegularExpressions.Regex> llamada al constructor o en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> es menor que cero o mayor que la longitud de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Cadena que se va a dividir.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <summary>Divide una cadena de entrada en una matriz de subcadenas en las posiciones definidas por un patrón de expresión regular especificado. Las opciones especificadas modifican la operación de coincidencia.</summary>
        <returns>Matriz de cadenas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos son similares a los <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> método, salvo que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres. Se divide la cadena tantas veces como sea posible. Si no se encuentra ningún delimitador, el valor devuelto contiene un elemento cuyo valor es original `input` cadena.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Compila expresiones regulares usadas en las llamadas a estática <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos automáticamente se almacenan en caché. Para administrar la duración de las expresiones regulares compiladas, utilice la instancia <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos.  
  
 Si varias coincidencias son adyacentes entre sí, se inserta una cadena vacía en la matriz. Por ejemplo, la división de una cadena en un solo guión hace que la matriz devuelta debe incluir una cadena vacía en la posición donde se encuentran dos guiones adyacentes.  
  
 Si se encuentra una coincidencia al principio o al final de la cadena de entrada, una cadena vacía se incluye al principio o al final de la matriz devuelta. En el ejemplo siguiente se usa el patrón de expresión regular `[a-z]+` para dividir una cadena de entrada en cualquier carácter alfabético en mayúscula o minúscula. Dado que la cadena empieza y termina con la coincidencia de caracteres alfabéticos, el valor del primer y último elemento de la matriz devuelta es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 Si se usan paréntesis de captura en un <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expresión, cualquier capturada se incluye el texto de la matriz de cadena resultante. Por ejemplo, si divide la cadena "plum-pear" en un guión colocado entre paréntesis de captura, la matriz devuelta incluye un elemento de cadena que contiene el guión.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework. En .NET Framework 1.0 y 1.1, si no se encuentra una coincidencia en el primer conjunto de paréntesis, de captura no se incluye el texto capturado de paréntesis adicionales en la matriz devuelta. Todo el texto capturado a partir de .NET Framework 2.0, también se agrega a la matriz devuelta. Por ejemplo, el código siguiente utiliza dos conjuntos de paréntesis de captura para extraer los elementos de una fecha, incluidos los delimitadores de fecha, de una cadena de fecha. El primer conjunto de paréntesis de captura captura el guión y el segundo captura la barra diagonal. Si el código de ejemplo se compila y ejecuta en .NET Framework 1.0 o 1.1, excluye los caracteres de barra diagonal; Si se compila y se ejecutan en el .NET Framework 2.0 o versiones posteriores, los incluye.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Si la expresión regular puede coincidir con la cadena vacía, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividirá la cadena en una matriz de cadenas de carácter único porque se puede encontrar el delimitador de cadena vacía en todas las ubicaciones.  
  
 El <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> es una excepción si el tiempo de ejecución de la operación de división supera el intervalo de tiempo de espera especificado para el dominio de aplicación en el que se llama al método. Si no hay tiempo de espera se define en las propiedades del dominio de aplicación, o si el valor de tiempo de espera es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, se produce ninguna excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó el tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Este método se agota después de un intervalo que es igual que el valor de tiempo de espera predeterminado del dominio de aplicación en el que se llama al método. Si no se ha definido un valor de tiempo de espera para el dominio de aplicación, el valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impide que el método de tiempo de espera, se utiliza. El método estático recomendado para dividir el texto en una coincidencia de patrones es <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite establecer el intervalo de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Cadena que se va a dividir.</param>
        <param name="pattern">Patrón de expresión regular del que van a buscarse coincidencias.</param>
        <param name="options">Combinación bit a bit de los valores de enumeración que proporcionan opciones de coincidencia.</param>
        <param name="matchTimeout">Un intervalo de tiempo de espera, o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que el método no debe agotar el tiempo de espera.</param>
        <summary>Divide una cadena de entrada en una matriz de subcadenas en las posiciones definidas por un patrón de expresión regular especificado. Los parámetros adicionales especifican las opciones que modifican la operación de coincidencia y un intervalo de tiempo de espera si no se encuentra ninguna coincidencia.</summary>
        <returns>Matriz de cadenas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos son similares a los <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> método, salvo que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide la cadena en un delimitador determinado por una expresión regular en lugar de un juego de caracteres. Se divide la cadena tantas veces como sea posible. Si no se encuentra ningún delimitador, el valor devuelto contiene un elemento cuyo valor es original `input` cadena.  
  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Compila expresiones regulares usadas en las llamadas a estática <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos automáticamente se almacenan en caché. Para administrar la duración de las expresiones regulares compiladas, utilice la instancia <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos.  
  
 Si varias coincidencias son adyacentes entre sí, se inserta una cadena vacía en la matriz. Por ejemplo, la división de una cadena en un solo guión hace que la matriz devuelta debe incluir una cadena vacía en la posición donde se encuentran dos guiones adyacentes.  
  
 Si se encuentra una coincidencia al principio o al final de la cadena de entrada, una cadena vacía se incluye al principio o al final de la matriz devuelta. En el ejemplo siguiente se usa el patrón de expresión regular `[a-z]+` para dividir una cadena de entrada en cualquier carácter alfabético en mayúscula o minúscula. Dado que la cadena empieza y termina con la coincidencia de caracteres alfabéticos, el valor del primer y último elemento de la matriz devuelta es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 Si se usan paréntesis de captura en un <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expresión, cualquier capturada se incluye el texto de la matriz de cadena resultante. Por ejemplo, si divide la cadena "plum-pear" en un guión colocado entre paréntesis de captura, la matriz devuelta incluye un elemento de cadena que contiene el guión.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Sin embargo, cuando el patrón de expresión regular incluye varios conjuntos de paréntesis de captura, el comportamiento de este método depende de la versión de .NET Framework. En .NET Framework 1.0 y 1.1, si no se encuentra una coincidencia en el primer conjunto de paréntesis, de captura no se incluye el texto capturado de paréntesis adicionales en la matriz devuelta. Todo el texto capturado a partir de .NET Framework 2.0, también se agrega a la matriz devuelta. Por ejemplo, el código siguiente utiliza dos conjuntos de paréntesis de captura para extraer los elementos de una fecha, incluidos los delimitadores de fecha, de una cadena de fecha. El primer conjunto de paréntesis de captura captura el guión y el segundo captura la barra diagonal. Si el código de ejemplo se compila y ejecuta en .NET Framework 1.0 o 1.1, excluye los caracteres de barra diagonal; Si se compila y se ejecutan en el .NET Framework 2.0 o versiones posteriores, los incluye.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Si la expresión regular puede coincidir con la cadena vacía, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividirá la cadena en una matriz de cadenas de carácter único porque se puede encontrar el delimitador de cadena vacía en todas las ubicaciones.  
  
 El `matchTimeout` parámetro especifica cómo larga una coincidencia de método debe intentar buscar una coincidencia antes de expirar. Establecer un intervalo de tiempo de espera evita que las expresiones regulares que se basan en un retroceso excesivo aparezcan deje de responder al procesar la entrada que contenga cerca de coincidencias. Para obtener más información, consulte [procedimientos recomendados con expresiones regulares](~/docs/standard/base-types/best-practices.md) y [retroceso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Si no se encuentra ninguna coincidencia en ese intervalo de tiempo, el método produce una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> excepción. `matchTimeout` invalida cualquier valor de tiempo de espera predeterminado definido para el dominio de aplicación en el que se ejecuta el método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produjo un error de análisis de expresión regular.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="input" /> o <paramref name="pattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> no es una combinación bit a bit válida de valores <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
O bien 
 <paramref name="matchTimeout" /> es negativo, cero o mayor que 24 días aproximadamente.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Se agotó un tiempo de espera. Para más información sobre los tiempos de espera, vea la sección Comentarios.</exception>
        <block subset="none" type="usage">
          <para>Se recomienda que establezca el <paramref name="matchTimeout" /> parámetro a un valor apropiado, como dos segundos. Si deshabilita los tiempos de espera mediante la especificación de <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, el motor de expresiones regulares ofrece un rendimiento ligeramente mejor. Sin embargo, debe deshabilitar los tiempos de espera solo en las siguientes condiciones: - cuando la entrada procesada por una expresión regular se deriva de una fuente conocida y de confianza o formado por texto estático. Excluye el texto que ha sido dinámicamente por usuarios.  -Cuando el patrón de expresión regular se ha probado exhaustivamente para asegurarse de que controla con gran eficacia coincide, la ausencia de coincidencias y próximo coincide con.  -Cuando el patrón de expresión regular contiene ningún elemento de lenguaje que causan un retroceso excesivo al procesar a una coincidencia casi.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">Objeto que se va a rellenar con información de serialización.</param>
        <param name="context">Sitio para almacenar y recuperar los datos serializados. Este parámetro está reservado para un uso futuro.</param>
        <summary>Rellena un objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> con los datos necesarios para deserializar el objeto <see cref="T:System.Text.RegularExpressions.Regex" /> actual.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el modelo de expresión regular que se pasó al constructor <see langword="Regex" />.</summary>
        <returns>Parámetro <paramref name="pattern" /> que se pasó al constructor <see langword="Regex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `pattern` parámetro consta de los elementos del lenguaje de expresiones regulares que describen simbólicamente la cadena que debe coincidir. Para obtener más información sobre las expresiones regulares, vea [expresiones regulares de .NET Framework](~/docs/standard/base-types/regular-expressions.md) y [lenguaje de expresiones regulares - referencia rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> es la clase base de las expresiones regulares creados por el <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> método. Estos compilan expresiones regulares use el <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> implementación de la clase base. Si se llama desde una clase derivada, el <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> método devuelve la cadena que se pasó a la <paramref name="pattern" /> parámetro de la <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> constructor de clase que se usó para definir la expresión regular.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Cadena de entrada que contiene el texto que se desea convertir.</param>
        <summary>Convierte los caracteres de escape de la cadena de entrada.</summary>
        <returns>Cadena de caracteres con caracteres de escape convertidos a su forma sin escape.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.RegularExpressions.Regex.Unescape%2A> método realiza una de las dos transformaciones siguientes:  
  
-   Invierte la transformación realizada por el <xref:System.Text.RegularExpressions.Regex.Escape%2A> método quitando el carácter de escape ("\\") de cada carácter de escape mediante el método. Estos incluyen el \\, *, +,?, &#124;, {, [, (,), ^, $,., # y caracteres de espacio en blanco. Además, el <xref:System.Text.RegularExpressions.Regex.Unescape%2A> método convierte el corchete de cierre (]) y caracteres de cierre (}) de cierre.  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> no se puede invertir una cadena de escape perfectamente porque no se puede deducir exactamente qué caracteres se escaparon,  
  
-   Reemplaza la representación de caracteres no imprimibles con los propios caracteres. Por ejemplo, reemplaza \a por \x07. Las representaciones de caracteres que reemplaza son \a, \b, \e, \n, \r, \f, \t y \v.  
  
 Si el <xref:System.Text.RegularExpressions.Regex.Unescape%2A> método encuentra otras secuencias de escape que no se puede convertir, como \w o \s, produce un <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="str" /> incluye una secuencia de escape desconocida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns>Es <see langword="true" /> si la propiedad <see cref="P:System.Text.RegularExpressions.Regex.Options" /> contiene la opción <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lo usa un objeto <see cref="T:System.Text.RegularExpressions.Regex" /> generado por el método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns>Es <see langword="true" /> si la propiedad <see cref="P:System.Text.RegularExpressions.Regex.Options" /> contiene la opción <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">Intervalo de tiempo de espera que se va a comprobar.</param>
        <summary>Comprueba si un intervalo de tiempo de espera está dentro del intervalo permitido.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>