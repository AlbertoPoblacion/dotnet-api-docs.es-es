<Type Name="TemplateParser" FullName="System.Web.UI.TemplateParser">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0f5455211b2016ca7450cca5d5a176484a8b06d7" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30606729" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TemplateParser : System.Web.UI.BaseParser" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TemplateParser extends System.Web.UI.BaseParser" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.TemplateParser" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TemplateParser&#xA;Inherits BaseParser" />
  <TypeSignature Language="C++ CLI" Value="public ref class TemplateParser abstract : System::Web::UI::BaseParser" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.BaseParser</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Actúa como clase base abstracta para los analizadores de archivos de ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Web.UI.TemplateParser> clase proporciona la funcionalidad común para las clases de analizador. Dado que la <xref:System.Web.UI.TemplateParser> clase es abstracta, no se crea directamente una instancia de esta clase.  
  
 ]]></format>
    </remarks>
    <forInternalUseOnly />
    <altmember cref="T:System.Web.UI.BaseTemplateParser" />
  </Docs>
  <Members>
    <Member MemberName="ParseFile">
      <MemberSignature Language="C#" Value="protected void ParseFile (string physicalPath, string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ParseFile(string physicalPath, string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateParser.ParseFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ParseFile (physicalPath As String, virtualPath As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ParseFile(System::String ^ physicalPath, System::String ^ virtualPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="physicalPath" Type="System.String" />
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="physicalPath">Ruta de acceso física del archivo que se va a analizar. <c>physicalPath</c> tiene precedencia sobre <c>virtualPath</c>.</param>
        <param name="virtualPath">Ruta de acceso virtual del archivo que se va a analizar.</param>
        <summary>Analiza el contenido del archivo especificado por su ruta de acceso virtual o física.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se especifica una ruta de acceso física, se utiliza en la ruta de acceso virtual para buscar el archivo para analizar.  
  
 Si la ruta de acceso al archivo que se va a analizar es una referencia circular; es decir, hace referencia en el mismo archivo que actualmente está analizando el analizador, un <xref:System.Web.HttpException> se produce la excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          El parámetro <paramref name="physicalPath" /> o <paramref name="virtualPath" /> hace referencia al archivo que se está analizando.</exception>
        <forInternalUseOnly />
        <altmember cref="M:System.Web.UI.TemplateParser.ProcessError(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ParseTemplate">
      <MemberSignature Language="C#" Value="public static System.Web.UI.ITemplate ParseTemplate (string content, string virtualPath, bool ignoreFilter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.ITemplate ParseTemplate(string content, string virtualPath, bool ignoreFilter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateParser.ParseTemplate(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseTemplate (content As String, virtualPath As String, ignoreFilter As Boolean) As ITemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::ITemplate ^ ParseTemplate(System::String ^ content, System::String ^ virtualPath, bool ignoreFilter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ITemplate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.String" />
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="ignoreFilter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="content">Contenido.</param>
        <param name="virtualPath">Ruta de acceso virtual.</param>
        <param name="ignoreFilter">
          Es <see langword="true" /> para omitir el filtro; en caso contrario, es <see langword="false" />.</param>
        <summary>Analiza la plantilla.</summary>
        <returns>Devuelve la plantilla.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="ProcessError">
      <MemberSignature Language="C#" Value="protected void ProcessError (string message);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProcessError(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateParser.ProcessError(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProcessError (message As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProcessError(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Texto del mensaje de error utilizado para crear un nuevo objeto <see cref="T:System.Web.ParserError" />.</param>
        <summary>Notifica un error de proceso mediante la creación de un nuevo objeto <see cref="T:System.Web.ParserError" /> con el mensaje especificado y su inclusión en una colección <see cref="T:System.Web.ParserErrorCollection" />.</summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
        <altmember cref="M:System.Web.UI.TemplateParser.ProcessException(System.Exception)" />
        <altmember cref="T:System.Web.ParserError" />
        <altmember cref="T:System.Web.ParserErrorCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProcessException">
      <MemberSignature Language="C#" Value="protected void ProcessException (Exception ex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProcessException(class System.Exception ex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateParser.ProcessException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProcessException (ex As Exception)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProcessException(Exception ^ ex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ex" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="ex">Objeto <see cref="T:System.Exception" /> utilizado para crear un nuevo objeto <see cref="T:System.Web.ParserError" />.</param>
        <summary>Notifica una excepción de analizador mediante la creación de un nuevo objeto <see cref="T:System.Web.ParserError" /> como excepción <see cref="T:System.Exception" /> especificada y su inclusión en una colección <see cref="T:System.Web.ParserErrorCollection" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpCompileException">El objeto <see cref="T:System.Exception" /> que se va a procesar es un error de compilador.</exception>
        <forInternalUseOnly />
        <altmember cref="M:System.Web.UI.TemplateParser.ProcessError(System.String)" />
        <altmember cref="T:System.Web.HttpCompileException" />
        <altmember cref="T:System.Web.ParserError" />
        <altmember cref="T:System.Web.ParserErrorCollection" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.TemplateParser.Text" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cadena que contiene los datos que se analizarán.</summary>
        <value>Datos que se van a analizar.</value>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
  </Members>
</Type>