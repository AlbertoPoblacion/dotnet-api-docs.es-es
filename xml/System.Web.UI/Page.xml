<Type Name="Page" FullName="System.Web.UI.Page">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e5ea609f3230467a783e8274e9539582d81b1f64" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37531390" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Page : System.Web.UI.TemplateControl, System.Web.IHttpHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Web.UI.TemplateControl implements class System.Web.IHttpHandler" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Page" />
  <TypeSignature Language="VB.NET" Value="Public Class Page&#xA;Inherits TemplateControl&#xA;Implements IHttpHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class Page : System::Web::UI::TemplateControl, System::Web::IHttpHandler" />
  <TypeSignature Language="F#" Value="type Page = class&#xA;    inherit TemplateControl&#xA;    interface IHttpHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.TemplateControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.IHttpHandler</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.WebFormCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.TypeCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Web.WebForms.WebFormDesigner, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("ASPXCodeBehind")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un archivo .aspx, también conocido como una página de formularios Web Forms, solicitado desde un servidor que hospeda una aplicación web ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Web.UI.Page> clase está asociada a los archivos que tienen una extensión de aspx. Estos archivos se compilan en tiempo de ejecución como <xref:System.Web.UI.Page> objetos y almacena en caché en memoria del servidor.  
  
 Si desea crear una página de formularios Web Forms mediante la técnica de código subyacente, que se derivan de esta clase. Los diseñadores rápido de aplicaciones (RAD) de desarrollo, como Microsoft Visual Studio, utilizan automáticamente este modelo para crear páginas de formularios Web Forms.  
  
 El <xref:System.Web.UI.Page> objeto actúa como contenedor de nomenclatura para todos los controles de servidor en una página, excepto los que implementan el <xref:System.Web.UI.INamingContainer> interfaz o elementos secundarios de controles que implementan esta interfaz.  
  
 La <xref:System.Web.UI.Page> clase es un control que actúa como la interfaz de usuario para la aplicación Web y, por lo tanto, se debe estudiar para hacer que los procedimientos recomendados para escribir código seguro y proteger las aplicaciones se siguen. Para obtener información general sobre estos temas, consulte [Overview of Web Application Security Threats](http://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a), [NIB: procedimientos recomendados de directiva de seguridad](http://msdn.microsoft.com/library/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05), y [conceptos clave de seguridad](~/docs/standard/security/key-security-concepts.md). Para obtener información más específica, consulte [protección de los controles estándar](http://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8), [Cómo: mostrar mensajes de Error seguros](http://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa), [Cómo: proteger frente a ataques mediante secuencias de una aplicación Web mediante la aplicación HTML Codificación en cadenas](http://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b), y [Introducción a los controles de validación](http://msdn.microsoft.com/library/3c0e7514-cff2-4bed-936d-ee3f7b740190).  
  
   
  
## Examples  
 Un proyecto de sitio Web de Visual Studio con código fuente está disponible como acompañamiento de este tema: [descargar](http://go.microsoft.com/fwlink/?LinkId=192425).  
  
 En el ejemplo de código siguiente se muestra cómo el <xref:System.Web.UI.Page> clase se utiliza en el modelo de página de código subyacente. Tenga en cuenta que el archivo de código subyacente de origen declara una clase parcial que hereda de una clase de página base. La clase base puede ser <xref:System.Web.UI.Page>, o puede ser otra clase que derive de <xref:System.Web.UI.Page>. Además, tenga en cuenta que la clase parcial permite que el archivo de código subyacente usar los controles definidos en la página sin necesidad de definirlos como miembros de campo.  
  
 [!code-csharp[System.Web.UI.Page_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx.cs#2)]
 [!code-vb[System.Web.UI.Page_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx.vb#2)]  
  
 El ejemplo de código siguiente muestra el archivo .aspx que corresponde al archivo de origen de código subyacente anterior.  
  
> [!IMPORTANT]
>  Este ejemplo tiene un cuadro de texto que acepta datos proporcionados por el usuario, lo que puede suponer una amenaza para la seguridad. De forma predeterminada, ASP.NET Web Pages valida que los datos proporcionados por el usuario no incluyen elementos HTML ni de script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx#1)]  
  
 Debe usar la directiva y usar el `Inherits` y `CodeFile` atributos para vincular el archivo de código subyacente para el archivo de aspx. En este ejemplo, el `Inherits` atributo indica la `MyCodeBehind` clase y el `CodeFile` atributo indica la ruta de acceso al archivo específico del idioma que contiene la clase.  
  
 En el ejemplo de código siguiente se muestra el modelo de página de un solo archivo y cómo tener acceso a la <xref:System.Web.UI.Page.IsPostBack%2A> propiedad y el <xref:System.Web.UI.Page.Response%2A> propiedad de la <xref:System.Web.UI.Page>.  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/vb/pageexample.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Page();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El constructor predeterminado inicializa todos los campos en sus valores predeterminados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddContentTemplate">
      <MemberSignature Language="C#" Value="protected internal void AddContentTemplate (string templateName, System.Web.UI.ITemplate template);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddContentTemplate(string templateName, class System.Web.UI.ITemplate template) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddContentTemplate(System.String,System.Web.UI.ITemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddContentTemplate (templateName As String, template As ITemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddContentTemplate(System::String ^ templateName, System::Web::UI::ITemplate ^ template);" />
      <MemberSignature Language="F#" Value="member this.AddContentTemplate : string * System.Web.UI.ITemplate -&gt; unit" Usage="page.AddContentTemplate (templateName, template)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="templateName" Type="System.String" />
        <Parameter Name="template" Type="System.Web.UI.ITemplate" />
      </Parameters>
      <Docs>
        <param name="templateName">Nombre de la plantilla de contenido que se va a agregar.</param>
        <param name="template">Plantilla de contenido</param>
        <summary>Se llama durante la inicialización de la página para crear una colección de contenido (a partir de los controles de contenido) que se pasa a una página maestra, si la página actual o la página maestra hace referencia a una página maestra.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">Ya existe una plantilla de contenido con el mismo nombre.</exception>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOnPreRenderCompleteAsync">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra los delegados de controlador de eventos inicial y final de una página asincrónica.</summary>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOnPreRenderCompleteAsync (beginHandler As BeginEventHandler, endHandler As EndEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOnPreRenderCompleteAsync(System::Web::BeginEventHandler ^ beginHandler, System::Web::EndEventHandler ^ endHandler);" />
      <MemberSignature Language="F#" Value="member this.AddOnPreRenderCompleteAsync : System.Web.BeginEventHandler * System.Web.EndEventHandler -&gt; unit" Usage="page.AddOnPreRenderCompleteAsync (beginHandler, endHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
      </Parameters>
      <Docs>
        <param name="beginHandler">Delegado del método <see cref="T:System.Web.BeginEventHandler" />.</param>
        <param name="endHandler">Delegado del método <see cref="T:System.Web.EndEventHandler" />.</param>
        <summary>Registra los delegados de controlador de eventos inicial y final que no requieren información de estado para una página asincrónica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A> para agregar controladores a una página Web asincrónica.  
  
 Puede registrar varios controladores asincrónicos; Sin embargo, solo un controlador se ejecuta en un momento. Si desea procesar varios métodos asincrónicos simultáneamente, debe usar una sola <xref:System.Web.BeginEventHandler> método e iniciar varias operaciones asincrónicas desde ese controlador.  
  
 Se llama a los controladores asincrónicos entre el <xref:System.Web.UI.Control.PreRender> y <xref:System.Web.UI.Page.PreRenderComplete> eventos.  
  
 Primero, todos los <xref:System.Web.UI.Page> eventos (a través de la <xref:System.Web.UI.Control.PreRender> eventos) se registran ejecución y, a continuación, cada <xref:System.Web.BeginEventHandler> se llama al método. Cuando finalice el controlador, el correspondiente <xref:System.Web.EndEventHandler> se llama al método. Si hay varios controladores asincrónicos, se llama al controlador siguiente.  
  
 Una vez que se ha llamado a los controladores de eventos asincrónicos registrados, el resto de los eventos de página se denominan, empezando por el <xref:System.Web.UI.Page.PreRenderComplete> eventos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se usa una solicitud asincrónica para mostrar el código fuente HTML de la página de forma predeterminada del servidor Web local en un <xref:System.Web.UI.WebControls.TextBox> control.  
  
> [!IMPORTANT]
>  Este ejemplo tiene un cuadro de texto que acepta datos proporcionados por el usuario, lo que puede suponer una amenaza para la seguridad. De forma predeterminada, ASP.NET Web Pages valida que los datos proporcionados por el usuario no incluyen elementos HTML ni de script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La directiva de página <see langword="&lt;async&gt;" /> no está establecida en <see langword="true" />.  \- o bien - Se ha llamado al método <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> después del evento <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> o <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </Member>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOnPreRenderCompleteAsync (beginHandler As BeginEventHandler, endHandler As EndEventHandler, state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOnPreRenderCompleteAsync(System::Web::BeginEventHandler ^ beginHandler, System::Web::EndEventHandler ^ endHandler, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.AddOnPreRenderCompleteAsync : System.Web.BeginEventHandler * System.Web.EndEventHandler * obj -&gt; unit" Usage="page.AddOnPreRenderCompleteAsync (beginHandler, endHandler, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginHandler">Delegado del método <see cref="T:System.Web.BeginEventHandler" />.</param>
        <param name="endHandler">Delegado del método <see cref="T:System.Web.EndEventHandler" />.</param>
        <param name="state">Objeto que contiene información de estado para los controladores de eventos.</param>
        <summary>Registra los delegados de controlador de eventos inicial y final de una página asincrónica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A> método para agregar controladores que requieren información de estado para una página Web asincrónica. El objeto pasado en el `state` parámetro puede ser cualquier objeto que requiere la aplicación para transferir información entre los delegados de controlador de eventos especificados en el `beginHandler` y `endHandler` parámetros.  
  
 Puede registrar varios controladores asincrónicos; Sin embargo, solo un controlador se ejecuta en un momento. Si desea procesar varios métodos asincrónicos simultáneamente, debe usar una sola <xref:System.Web.BeginEventHandler> método e iniciar varias operaciones asincrónicas desde ese controlador.  
  
 Se llama a los controladores asincrónicos entre el <xref:System.Web.UI.Control.PreRender> y <xref:System.Web.UI.Page.PreRenderComplete> eventos.  
  
 Primero, todos los <xref:System.Web.UI.Page> eventos (a través de la <xref:System.Web.UI.Control.PreRender> eventos) se registran ejecución y, a continuación, cada <xref:System.Web.BeginEventHandler> se llama al método. Cuando finalice el controlador, el correspondiente <xref:System.Web.EndEventHandler> se llama al método. Si hay varios controladores asincrónicos, se llama al controlador siguiente.  
  
 Una vez que se ha llamado a los controladores de eventos asincrónicos registrados, el resto de los eventos de página se denominan, empezando por el <xref:System.Web.UI.Page.PreRenderComplete> eventos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se usa una solicitud asincrónica para mostrar el código fuente HTML de la página de forma predeterminada del servidor Web local en un <xref:System.Web.UI.WebControls.TextBox> control.  
  
> [!IMPORTANT]
>  Este ejemplo tiene un cuadro de texto que acepta datos proporcionados por el usuario, lo que puede suponer una amenaza para la seguridad. De forma predeterminada, ASP.NET Web Pages valida que los datos proporcionados por el usuario no incluyen elementos HTML ni de script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La directiva de página <see langword="&lt;async&gt;" /> no está establecida en <see langword="true" />.  \- o bien - Se ha llamado al método <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> después del evento <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> o <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected internal void AddWrappedFileDependencies (object virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddWrappedFileDependencies(object virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddWrappedFileDependencies(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddWrappedFileDependencies (virtualFileDependencies As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddWrappedFileDependencies(System::Object ^ virtualFileDependencies);" />
      <MemberSignature Language="F#" Value="member this.AddWrappedFileDependencies : obj -&gt; unit" Usage="page.AddWrappedFileDependencies virtualFileDependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">
          <see cref="T:System.Object" /> que contiene la lista de nombres de archivo.</param>
        <summary>Agrega una lista de archivos dependientes que constituyen la página actual. El marco de trabajo de la página ASP.NET utiliza internamente este método, que no está pensado para utilizarlo directamente en el código.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.AddWrappedFileDependencies%2A> método agrega una lista de archivos, como archivos de control de usuario, que componen la página actual. Si se modifica cualquiera de estas páginas, toda la página se compila la próxima vez que se solicita. Este método es compatible con la infraestructura de .NET Framework y no está diseñado para utilizarse directamente desde el código.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.UI.Page.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.HttpApplicationState" /> de la solicitud web actual.</summary>
        <value>Datos actuales de la clase <see cref="T:System.Web.HttpApplicationState" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page.Application_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Application_Sample1/CS/applicationcs.aspx#1)]
 [!code-vb[Page.Application_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Application_Sample1/VB/applicationvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpApplicationState" />
      </Docs>
    </Member>
    <Member MemberName="AspCompatBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AspCompatBeginProcessRequest (System.Web.HttpContext context, AsyncCallback cb, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AspCompatBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback cb, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function AspCompatBeginProcessRequest (context As HttpContext, cb As AsyncCallback, extraData As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IAsyncResult ^ AspCompatBeginProcessRequest(System::Web::HttpContext ^ context, AsyncCallback ^ cb, System::Object ^ extraData);" />
      <MemberSignature Language="F#" Value="member this.AspCompatBeginProcessRequest : System.Web.HttpContext * AsyncCallback * obj -&gt; IAsyncResult" Usage="page.AspCompatBeginProcessRequest (context, cb, extraData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="cb" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> con información sobre la solicitud actual.</param>
        <param name="cb">Método de devolución de llamada.</param>
        <param name="extraData">Datos adicionales necesarios para procesar la solicitud como una solicitud de ASP.</param>
        <summary>Inicia una solicitud de recursos de páginas Active Server (ASP). Este método se proporciona por compatibilidad con las aplicaciones ASP heredadas.</summary>
        <returns>Un objeto <see cref="T:System.IAsyncResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No llame a este método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AspCompatEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AspCompatEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatEndProcessRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AspCompatEndProcessRequest (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AspCompatEndProcessRequest(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.AspCompatEndProcessRequest : IAsyncResult -&gt; unit" Usage="page.AspCompatEndProcessRequest result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Página ASP generada por la solicitud.</param>
        <summary>Finaliza una solicitud de recursos de páginas Active Server (ASP). Este método se proporciona por compatibilidad con las aplicaciones ASP heredadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No llame a este método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatMode">
      <MemberSignature Language="C#" Value="protected bool AspCompatMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AspCompatMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AspCompatMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property AspCompatMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool AspCompatMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AspCompatMode : bool with get, set" Usage="System.Web.UI.Page.AspCompatMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece un valor que indica si la página se puede ejecutar en un subproceso de un contenedor uniproceso (STA).</summary>
        <value>Es <see langword="true" /> si la página admite el código de las páginas Active Server (ASP); de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se establece en `true`, esta propiedad permite que la página que se ejecuta en un subproceso de contenedor uniproceso (STA). Esto permite que la página llamar a componentes STA, como componentes desarrollados con Visual Basic 6.0. Establecer esta propiedad en `true` también permite que la página llamar a componentes COM + que requieren acceso a los objetos integrados de ASP no administrados. Estos son accesibles a través de ASP `ObjectContext` objeto o el `OnStartPage` método.  
  
 En la mayoría de los casos, no establezca esta propiedad en el código. Establecer el `aspcompat` atributo `true` utilizando la directiva en el archivo .aspx. Cuando se solicita la página, la clase generada dinámicamente establece la propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncMode">
      <MemberSignature Language="C#" Value="protected bool AsyncMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsyncMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property AsyncMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool AsyncMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncMode : bool with get, set" Usage="System.Web.UI.Page.AsyncMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece un valor que indica si se procesa la página sincrónica o asincrónicamente.</summary>
        <value>Es <see langword="true" /> si la página se procesa de forma asincrónica; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.AsyncMode%2A> propiedad se establece mediante la <xref:System.Web.UI.Page> analizador cuando se genera código para la página. Use el `Async` atributo en la directiva para establecer este valor.  
  
 Páginas asincrónicas no funcionan cuando el `AspCompat` atributo está establecido en `true` o `Transaction` atributo se establece en un valor distinto `Disabled` en la directiva.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AsyncPageBeginProcessRequest (System.Web.HttpContext context, AsyncCallback callback, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AsyncPageBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback callback, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function AsyncPageBeginProcessRequest (context As HttpContext, callback As AsyncCallback, extraData As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IAsyncResult ^ AsyncPageBeginProcessRequest(System::Web::HttpContext ^ context, AsyncCallback ^ callback, System::Object ^ extraData);" />
      <MemberSignature Language="F#" Value="member this.AsyncPageBeginProcessRequest : System.Web.HttpContext * AsyncCallback * obj -&gt; IAsyncResult" Usage="page.AsyncPageBeginProcessRequest (context, callback, extraData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> de la solicitud.</param>
        <param name="callback">Método de devolución de llamada para notificar la finalización del proceso.</param>
        <param name="extraData">Datos de estado para el método asincrónico.</param>
        <summary>Comienza a procesar una solicitud de página asincrónica.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la solicitud asincrónica.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AsyncPageEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AsyncPageEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageEndProcessRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AsyncPageEndProcessRequest (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AsyncPageEndProcessRequest(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.AsyncPageEndProcessRequest : IAsyncResult -&gt; unit" Usage="page.AsyncPageEndProcessRequest result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> que hace referencia a una solicitud asincrónica pendiente.</param>
        <summary>Termina de procesar una solicitud de página asincrónica.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan AsyncTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan AsyncTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan AsyncTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncTimeout : TimeSpan with get, set" Usage="System.Web.UI.Page.AsyncTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica el intervalo de tiempo de espera utilizado al procesar tareas asincrónicas.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> que contiene el intervalo de tiempo asignado a la realización de la tarea asincrónica. El intervalo de tiempo predeterminado es de 45 segundos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tiempo de espera asincrónico de la página representa la cantidad de tiempo que esperará la página para realizar las tareas asincrónicas. En la mayoría de los casos, no establezca esta propiedad en el código. Establecer el intervalo de tiempo de espera asincrónico de página con del archivo de configuración Web o en la directiva. La directiva de página sobrescribirán los valores establecidos en la sección de configuración de página.  
  
 Definir la tarea asincrónica mediante el <xref:System.Web.UI.PageAsyncTask> clase y registrar un principio, un final y un controlador de tiempo de espera. Si la tarea asincrónica no se completa en el intervalo de tiempo especificado, se invocará el controlador de tiempo de espera.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.Page.AsyncTimeout%2A> propiedad con el <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> y <xref:System.Web.UI.Page.RegisterAsyncTask%2A> métodos. Tenga en cuenta el uso de controladores de inicio, finalización y tiempo de espera. En el ejemplo, se introduce un retraso artificial para ilustrar la situación de una tarea asincrónica que supere el tiempo asignado para la tarea como se especifica en el <xref:System.Web.UI.Page.AsyncTimeout%2A> propiedad. En un escenario real, una tarea asincrónica podría usarse para realizar llamadas de base de datos o de generación de imágenes, por ejemplo, y el controlador de tiempo de espera proporciona degradación correcta si la tarea no se realiza en un período de tiempo especificado. Tenga en cuenta que el <xref:System.Web.UI.Page.AsyncTimeout%2A> propiedad está establecida en la directiva de página.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La propiedad fue establecida en un valor negativo.</exception>
        <altmember cref="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
        <altmember cref="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
      </Docs>
    </Member>
    <Member MemberName="AutoPostBackControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control AutoPostBackControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control AutoPostBackControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AutoPostBackControl" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoPostBackControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ AutoPostBackControl { System::Web::UI::Control ^ get(); void set(System::Web::UI::Control ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AutoPostBackControl : System.Web.UI.Control with get, set" Usage="System.Web.UI.Page.AutoPostBackControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el control de la página que se usa para realizar los postbacks.</summary>
        <value>Control que se usa para realizar los postbacks.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.UI.Page.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece un valor que indica si el resultado de la página se va a almacenar en un búfer.</summary>
        <value>Es <see langword="true" /> si el resultado de la página se almacena en un búfer; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la mayoría de los casos, no establezca esta propiedad en el código. Establecer el <xref:System.Web.UI.Page.Buffer%2A> atributo `true` utilizando la directiva en el archivo .aspx. Cuando se solicita la página, la clase generada dinámicamente establece la propiedad.  
  
> [!NOTE]
>  El <xref:System.Web.UI.Page.Buffer%2A> propiedad establece y obtiene la <xref:System.Web.HttpResponse.BufferOutput%2A> propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.UI.Page.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.Caching.Cache" /> que está asociado a la aplicación en que reside la página.</summary>
        <value>
          <see cref="T:System.Web.Caching.Cache" /> asociado a la aplicación de la página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una aplicación <xref:System.Web.Caching.Cache> objeto le permite almacenar y recuperar datos arbitrarios en solicitudes posteriores. La memoria caché no es específicamente asociada con una sesión de usuario o página. Sirve principalmente para mejorar el rendimiento de la aplicación. Para obtener más información, consulte [Caching Application Data](http://msdn.microsoft.com/library/206f977d-7860-4d20-bdd5-c3b3d8479f3d). Para obtener más información sobre la diferencia entre la aplicación de almacenamiento en caché y caché de resultados de página, vea [información general sobre el almacenamiento en caché de ASP.NET](http://msdn.microsoft.com/library/5ec28012-4972-4dc3-b3e8-9d20401fe11d).  
  
   
  
## Examples  
 El siguiente ejemplo de código inserta la suma de dos enteros en el <xref:System.Web.Caching.Cache?displayProperty=nameWithType> objeto utilizando el <xref:System.Web.UI.Page.Cache%2A?displayProperty=nameWithType> propiedad. A continuación, recupera el valor mediante el <xref:System.Web.Caching.Cache.Get%2A?displayProperty=nameWithType> método y lo escribe en un <xref:System.Web.UI.WebControls.Label> control de servidor Web.  
  
 [!code-csharp[System.Web.Page.Cache_Replacement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/CS/pagecachecs.aspx#1)]
 [!code-vb[System.Web.Page.Cache_Replacement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/VB/pagecachevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">No se crea una instancia de <see cref="T:System.Web.Caching.Cache" />.</exception>
        <altmember cref="T:System.Web.Caching.Cache" />
      </Docs>
    </Member>
    <Member MemberName="ClientQueryString">
      <MemberSignature Language="C#" Value="public string ClientQueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientQueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientQueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientQueryString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientQueryString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientQueryString : string" Usage="System.Web.UI.Page.ClientQueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la parte de la cadena de consulta de la dirección URL solicitada.</summary>
        <value>Parte de la cadena de consulta de la dirección URL solicitada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.ClientQueryString%2A> propiedad contiene la parte de la cadena de consulta de la dirección URL solicitada por el explorador. Por ejemplo, si la dirección URL solicitada es "http://www.contoso.com/default.aspx?id=100", el <xref:System.Web.UI.Page.ClientQueryString%2A> contendrá la propiedad "id = 100". El <xref:System.Web.UI.Page.ClientQueryString%2A> propiedad está codificada; utilice el <xref:System.Web.HttpServerUtility.UrlDecode%2A?displayProperty=nameWithType> método para descodificar la cadena de consulta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.ClientScriptManager ClientScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ClientScriptManager ClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientScript" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientScript As ClientScriptManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ClientScriptManager ^ ClientScript { System::Web::UI::ClientScriptManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientScript : System.Web.UI.ClientScriptManager" Usage="System.Web.UI.Page.ClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientScriptManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Web.UI.ClientScriptManager" /> que se utiliza para administrar, registrar y agregar script a la página.</summary>
        <value>Un objeto <see cref="T:System.Web.UI.ClientScriptManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Web.UI.Page.ClientScript%2A> propiedad va a obtener un <xref:System.Web.UI.ClientScriptManager> objeto que puede usarse para administrar, registrar y agregar script a una página Web. Para obtener más información, vea la clase <xref:System.Web.UI.ClientScriptManager>.  
  
 El <xref:System.Web.UI.ClientScriptManager> clase es nueva en [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] y reemplaza <xref:System.Web.UI.Page> métodos para administrar secuencias de comandos que están en desuso de la clase.  
  
   
  
## Examples  
 Para obtener un ejemplo, vea el <xref:System.Web.UI.ClientScriptManager> tema de información general sobre la clase.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="ClientTarget">
      <MemberSignature Language="C#" Value="public string ClientTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientTarget" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientTarget As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientTarget { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientTarget : string with get, set" Usage="System.Web.UI.Page.ClientTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que permite reemplazar la detección automática de las funciones del explorador y especificar cómo se representa una página para clientes de explorador concretos.</summary>
        <value>
          <see cref="T:System.String" /> que especifica las funciones de explorador que se desean reemplazar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no establece la <xref:System.Web.UI.Page.ClientTarget%2A> propiedad, el <xref:System.Web.HttpBrowserCapabilities> objeto asociado con el <xref:System.Web.UI.Page.Request%2A?displayProperty=nameWithType> propiedad refleja las capacidades del explorador del cliente. Si establece esta propiedad, se deshabilita la detección de explorador del cliente y la página usará las capacidades del explorador asociadas al valor (alias) que proporcione.  
  
 El archivo de configuración Web.config raíz en el equipo servidor Web define los siguientes alias predeterminados que puede utilizar como forma abreviada de las cadenas de agente de usuario habituales:  
  
-   `uplevel`, que especifica las capacidades del explorador equivalentes a Internet Explorer 6.0.  
  
-   `downlevel`, que especifica las capacidades del explorador equivalentes a los exploradores más antiguos que no admiten el script de cliente. Puede usar este alias para determinar cómo funcionaría páginas Web en un explorador que tiene el script de cliente deshabilitado.  
  
 Puede establecer el alias mediante programación con esta propiedad, o puede establecer mediante declaración con el `ClientTarget` atributo de la directiva.  
  
 Puede definir alias adicionales en el `clientTarget` sección del archivo Web.config de nivel de aplicación. Para obtener más información, consulte [clientTarget Element (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/17a0fa6e-a065-49cc-b900-ef73eda6a922).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se define un `ie302` alias e incluye las secciones necesarias para configurar la aplicación en su archivo Web.config. Mediante este alias, puede establecer el <xref:System.Web.UI.Page.ClientTarget%2A> propiedad `ie302` y personalizar las páginas específicamente para los exploradores de Internet Explorer 3.02.  
  
```  
<configuration>  
  <system.web>  
   <clientTarget>  
    <add alias="ie302" useragent="Mozilla/2.0 (compatible; MSIE 3.02; Windows NT 3.5)" />  
   </clientTarget>  
  </system.web>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public int CodePage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CodePage { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int with get, set" Usage="System.Web.UI.Page.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece el identificador de la página de códigos para el <see cref="T:System.Web.UI.Page" /> actual.</summary>
        <value>Entero que representa el identificador de la página de códigos para el <see cref="T:System.Web.UI.Page" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la mayoría de los casos, no establezca esta propiedad en el código. Establecer el `CodePage` para el valor que desea usar la directiva en el archivo .aspx de atributo. Cuando se solicita la página, la clase generada dinámicamente establece la propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.UI.Page.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece el tipo MIME HTTP para el objeto <see cref="T:System.Web.HttpResponse" /> asociado a la página.</summary>
        <value>Tipo MIME HTTP asociado a la página actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la mayoría de los casos, no establezca esta propiedad en el código. Establecer el `ContentType` utilizando la directiva en el archivo .aspx de atributo. Cuando se solicita la página, la clase generada dinámicamente establece la propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected internal override System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Context" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property Context As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Web::HttpContext ^ Context { System::Web::HttpContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Context : System.Web.HttpContext" Usage="System.Web.UI.Page.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.HttpContext" /> asociado a la página.</summary>
        <value>Objeto <see cref="T:System.Web.HttpContext" /> que contiene información asociada a la página actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad proporciona acceso mediante programación al contexto de que la página se ejecuta, incluida información acerca de la solicitud, respuesta, sesión y aplicación.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.UI.Page.Context%2A> propiedad para tener acceso a la <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> y <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> métodos y <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> propiedad. El ejemplo crea tres excepciones personalizadas mediante el <xref:System.Web.HttpContext.AddError%2A> método y se usa el <xref:System.Web.HttpContext.AllErrors%2A> propiedad cargar estas excepciones en una matriz. Después escribe la matriz en la página contenedora y utiliza el <xref:System.Web.HttpContext.ClearError%2A> método para borrar todos los errores desde el <xref:System.Web.UI.Page.Context%2A> propiedad.  
  
 [!code-csharp[System.Web.UI.Page.Context#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Context/CS/pagecontextcs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Context#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Context/VB/pagecontextvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriter">
      <MemberSignature Language="C#" Value="protected internal virtual System.Web.UI.HtmlTextWriter CreateHtmlTextWriter (System.IO.TextWriter tw);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Web.UI.HtmlTextWriter CreateHtmlTextWriter(class System.IO.TextWriter tw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateHtmlTextWriter (tw As TextWriter) As HtmlTextWriter" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Web::UI::HtmlTextWriter ^ CreateHtmlTextWriter(System::IO::TextWriter ^ tw);" />
      <MemberSignature Language="F#" Value="abstract member CreateHtmlTextWriter : System.IO.TextWriter -&gt; System.Web.UI.HtmlTextWriter&#xA;override this.CreateHtmlTextWriter : System.IO.TextWriter -&gt; System.Web.UI.HtmlTextWriter" Usage="page.CreateHtmlTextWriter tw" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="tw">El objeto <see cref="T:System.IO.TextWriter" /> utilizado para crear el objeto <see cref="T:System.Web.UI.HtmlTextWriter" />.</param>
        <summary>Crea un objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> para representar el contenido de la página.</summary>
        <returns>
          <see cref="T:System.Web.UI.HtmlTextWriter" /> o <see cref="T:System.Web.UI.Html32TextWriter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> método crea un <xref:System.IO.TextWriter> a través de la <xref:System.Web.HttpRequest.Browser%2A> propiedad de la <xref:System.Web.HttpContext.Request%2A> objeto asociado a la solicitud de página. Puede agregar una referencia a un <xref:System.Web.UI.HtmlTextWriter> en la `browserCaps` sección de configuración. Invalidar el <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> método para realizar una búsqueda personalizada.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> método para crear una instancia de un personalizado <xref:System.Web.UI.HtmlTextWriter> objeto denominado `MyHtmlTextWriter`. El <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> método se invalide en el `MyPage` (clase), que se deriva de <xref:System.Web.UI.Page>, de modo que `MyHtmlTextWriter` representa los controles de servidor ASP.NET cuando se solicita la página. Tenga en cuenta que este ejemplo permitirá que el adaptador <xref:System.IO.TextWriter> comportamiento.  
  
 [!code-csharp[Page_CreateHtmlTextWriter#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/CS/page_createhtmltextwriter.cs#2)]
 [!code-vb[Page_CreateHtmlTextWriter#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/VB/page_createhtmltextwriter.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Html32TextWriter" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriterFromType">
      <MemberSignature Language="C#" Value="public static System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType (System.IO.TextWriter tw, Type writerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType(class System.IO.TextWriter tw, class System.Type writerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateHtmlTextWriterFromType (tw As TextWriter, writerType As Type) As HtmlTextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::HtmlTextWriter ^ CreateHtmlTextWriterFromType(System::IO::TextWriter ^ tw, Type ^ writerType);" />
      <MemberSignature Language="F#" Value="static member CreateHtmlTextWriterFromType : System.IO.TextWriter * Type -&gt; System.Web.UI.HtmlTextWriter" Usage="System.Web.UI.Page.CreateHtmlTextWriterFromType (tw, writerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
        <Parameter Name="writerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="tw">El objeto <see cref="T:System.IO.TextWriter" /> utilizado para crear el objeto <see cref="T:System.Web.UI.HtmlTextWriter" />.</param>
        <param name="writerType">Tipo de escritor de texto que se va a crear.</param>
        <summary>Crea un objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> especificado para representar el contenido de la página.</summary>
        <returns>
          <see cref="T:System.Web.UI.HtmlTextWriter" /> que representa el contenido de la página.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se usa internamente en adaptadores de página.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El parámetro <paramref name="writerType" /> se ha establecido en un tipo no válido.</exception>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public string Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Culture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Culture { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : string with get, set" Usage="System.Web.UI.Page.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece el id. de referencia cultural del objeto <see cref="T:System.Threading.Thread" /> asociado a la página.</summary>
        <value>Id. de referencia cultural válido.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer el `Culture` atributo en la directiva en el archivo de aspx. Cuando se solicita la página, la clase generada dinámicamente establece el valor de esta propiedad. Además, puede establecer explícitamente el valor de la <xref:System.Web.UI.Page.Culture%2A> propiedad mediante programación o en el elemento del archivo Web.config de archivos.  
  
 El <xref:System.Web.UI.Page.Culture%2A> propiedad se utiliza para ayudar a localizar el contenido de la página. Se puede establecer en cualquier identificador de referencia cultural válido. Por ejemplo, el `en-us` identificador de referencia cultural establece la página en while, inglés estadounidense el `fr` identificador de referencia cultural establece la página en francés. También se puede establecer el valor como `auto` que llevará a cabo la detección automática del explorador del idioma preferido y establecerlo. La detección automática de idioma se puede calificar con un valor predeterminado como `auto:en-us`.  
  
 Para obtener más información, consulte el <xref:System.Globalization.CultureInfo> información general de clases.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.LCID" />
      </Docs>
    </Member>
    <Member MemberName="DesignerInitialize">
      <MemberSignature Language="C#" Value="public void DesignerInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DesignerInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DesignerInitialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub DesignerInitialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DesignerInitialize();" />
      <MemberSignature Language="F#" Value="member this.DesignerInitialize : unit -&gt; unit" Usage="page.DesignerInitialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Realiza las inicializaciones de la instancia de la clase <see cref="T:System.Web.UI.Page" /> que requieran los diseñadores RAD. Este método sólo se usa en tiempo de diseño.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.UserControl.DesignerInitialize" />
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackMode">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.Specialized.NameValueCollection DeterminePostBackMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function DeterminePostBackMode () As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Collections::Specialized::NameValueCollection ^ DeterminePostBackMode();" />
      <MemberSignature Language="F#" Value="abstract member DeterminePostBackMode : unit -&gt; System.Collections.Specialized.NameValueCollection&#xA;override this.DeterminePostBackMode : unit -&gt; System.Collections.Specialized.NameValueCollection" Usage="page.DeterminePostBackMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un <see cref="T:System.Collections.Specialized.NameValueCollection" /> de datos devuelto a la página mediante un comando POST o GET.</summary>
        <returns>Objeto <see cref="T:System.Collections.Specialized.NameValueCollection" /> que contiene los datos de formulario. Si para el postback se utilizó el comando POST, la información del formulario se devuelve desde el objeto <see cref="P:System.Web.UI.Page.Context" />. Si se utilizó el comando GET para el postback, se devuelve la información de la cadena de consulta. Si es la primera vez que se solicita la página, se devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.DeterminePostBackMode%2A> método devuelve un <xref:System.Collections.Specialized.NameValueCollection> registrado de objeto que contiene los datos a la página. La presencia de la página oculta campos VIEWSTATE y EVENTTARGET se usa para ayudar a determinar si se ha producido un evento de postback. El <xref:System.Web.UI.Page.IsPostBack%2A> propiedad se establece cuando el <xref:System.Web.UI.Page.DeterminePostBackMode%2A> se llama al método.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackModeUnvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackModeUnvalidated" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function DeterminePostBackModeUnvalidated () As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Collections::Specialized::NameValueCollection ^ DeterminePostBackModeUnvalidated();" />
      <MemberSignature Language="F#" Value="abstract member DeterminePostBackModeUnvalidated : unit -&gt; System.Collections.Specialized.NameValueCollection&#xA;override this.DeterminePostBackModeUnvalidated : unit -&gt; System.Collections.Specialized.NameValueCollection" Usage="page.DeterminePostBackModeUnvalidated " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una colección de datos de nombre-valor que se envió a la página con un comando POST o GET, sin realizar la validación de solicitudes de ASP.NET en la solicitud.</summary>
        <returns>Objeto que contiene datos de formulario no validados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, vea la clase <xref:System.Web.UnvalidatedRequestValues>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableEventValidation">
      <MemberSignature Language="C#" Value="public virtual bool EnableEventValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableEventValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableEventValidation" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableEventValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableEventValidation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableEventValidation : bool with get, set" Usage="System.Web.UI.Page.EnableEventValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la página valida eventos de postback y de devolución de llamada.</summary>
        <value>
          <see langword="true" /> si la página valida los eventos de postback y de devolución de llamada; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Web.UI.Page.EnableEventValidation%2A> propiedad está establecida en `true`, ASP.NET valida que un evento de control se originó desde la interfaz de usuario es representado por ese control. Un control registra sus eventos durante la representación y, a continuación, valida los eventos durante el control de devolución de datos o la devolución de llamada. Por ejemplo, si un control de lista incluye opciones numeradas 1, 2 o 3 cuando se representa la página, y si se recibe una solicitud de devolución de datos especifica el número de opción 4, ASP.NET genera una excepción. Todos los controles de orientada a eventos en ASP.NET utilizan esta característica de forma predeterminada.  
  
 Si escribe el script de cliente que cambia un control en el cliente en tiempo de ejecución, es posible que deba usar el <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> método con el fin de evitar errores de validación de eventos es false.  
  
> [!IMPORTANT]
>  Esta característica reduce el riesgo de las solicitudes de devolución no autorizadas o malintencionadas y devoluciones de llamada. Se recomienda deshabilitar la validación de eventos.  
  
 Establece el <xref:System.Web.UI.Page.EnableEventValidation%2A> propiedad estableciendo el `enableEventValidation` atributo de la directiva o la `enableEventValidation` atributo del elemento en el archivo Web.config. Si establece esta propiedad en el código, debe establecer antes de que se inicializa la página.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Web.UI.Page.EnableEventValidation" /> se estableció una vez inicializada la página.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
        <altmember cref="T:System.Web.UI.SupportsEventValidationAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public override bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewState" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableViewState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableViewState : bool with get, set" Usage="System.Web.UI.Page.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la página debe mantener su estado de vista y el de los controles de servidor que contenga cuando finalice la solicitud de página actual.</summary>
        <value>Es <see langword="true" /> si la página mantiene su estado de vista; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener información sobre por qué podría desear deshabilitar el estado de vista, consulte <xref:System.Web.UI.Control.EnableViewState%2A?displayProperty=nameWithType>.  
  
 Incluso si <xref:System.Web.UI.Page.EnableViewState%2A> es `false`, la página puede contener un campo de estado de vista oculto que ASP.NET utiliza para detectar un postback.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Web.UI.Page.EnableViewState%2A> propiedad `false` cuando se carga la página. Esto deshabilita el estado de vista para la <xref:System.Web.UI.Page> objeto, lo que significa que se guardan ni información de estado de vista de la página ni los controles contenidos en la página.  
  
> [!IMPORTANT]
>  Este ejemplo tiene un cuadro de texto que acepta datos proporcionados por el usuario, lo que puede suponer una amenaza para la seguridad. De forma predeterminada, ASP.NET Web Pages valida que los datos proporcionados por el usuario no incluyen elementos HTML ni de script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/CS/page_enableviewstate.cs#1)]
 [!code-vb[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/VB/page_enableviewstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.EnableViewStateMac" />
      </Docs>
    </Member>
    <Member MemberName="EnableViewStateMac">
      <MemberSignature Language="C#" Value="public bool EnableViewStateMac { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewStateMac" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewStateMac" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableViewStateMac As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableViewStateMac { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableViewStateMac : bool with get, set" Usage="System.Web.UI.Page.EnableViewStateMac" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si ASP.NET debe comprobar los códigos de autenticación de mensajes (MAC) en el estado de vista de la página cuando la página se devuelva desde el cliente.</summary>
        <value>Es <see langword="true" /> si debe realizarse la comprobación MAC y la codificación del estado de vista; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un equipo MAC de estado de vista es una versión cifrada de la variable oculta que se conserva el estado de vista de página cuando la página se envía al explorador. Cuando esta propiedad se establece en `true`, se comprueba el estado de vista cifrada para comprobar que no se ha manipulado en el cliente.  
  
 No establezca esta propiedad en el código. Establecer el `EnableViewStateMac` utilizando la directiva en el archivo .aspx de atributo. Cuando se solicita la página, la clase generada dinámicamente establece la propiedad.  
  
> [!IMPORTANT]
>  Este atributo no debe establecerse nunca en `false` en un sitio Web de producción, incluso si la página o aplicación no utiliza el estado de vista. El estado de vista MAC le ayuda a garantizar la seguridad de otras funciones ASP.NET, además del estado de vista.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.EnableViewState" />
      </Docs>
    </Member>
    <Member MemberName="ErrorPage">
      <MemberSignature Language="C#" Value="public string ErrorPage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ErrorPage" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorPage As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ErrorPage { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ErrorPage : string with get, set" Usage="System.Web.UI.Page.ErrorPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la página de errores a la que se redirige el explorador que realiza la solicitud si se produce una excepción de página no controlada.</summary>
        <value>Página de errores a la que se redirige el explorador.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page_ErrorPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_ErrorPage/CS/page_errorpage.cs.aspx#1)]
 [!code-vb[Page_ErrorPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_ErrorPage/VB/page_errorpage.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteRegisteredAsyncTasks">
      <MemberSignature Language="C#" Value="public void ExecuteRegisteredAsyncTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecuteRegisteredAsyncTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExecuteRegisteredAsyncTasks ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExecuteRegisteredAsyncTasks();" />
      <MemberSignature Language="F#" Value="member this.ExecuteRegisteredAsyncTasks : unit -&gt; unit" Usage="page.ExecuteRegisteredAsyncTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia la ejecución de una tarea asincrónica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Defina una tarea asincrónica mediante el <xref:System.Web.UI.PageAsyncTask> clase. Después de la tarea se define y se registra con la página mediante el <xref:System.Web.UI.Page.RegisterAsyncTask%2A> método, el <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> se puede invocar el método para iniciar la tarea asincrónica.  
  
 El <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> automáticamente se llama al método en el punto en el procesamiento de la página cuando cualquier registra las tareas asincrónicas, si existen, se invocan para una página de código asincrónico. Esta llamada automática a <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> se produce justo antes del <xref:System.Web.UI.Page.PreRenderComplete> eventos. Llame a la <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> método para las tareas que desea invocar a veces distinta de la llamada automática a este método. Tenga en cuenta que solo una vez, aunque se ejecutarán las tareas asincrónicas <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> puede llamarse varias veces.  
  
 El <xref:System.Web.UI.Page.AsyncTimeout%2A> propiedad se restablece en cada llamada a la <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> método. El último valor de la <xref:System.Web.UI.Page.AsyncTimeout%2A> antes de invocar el <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> método tiene prioridad. Si una tarea asincrónica tarda más de <xref:System.Web.UI.Page.AsyncTimeout%2A>, se invoca durante el que las tareas subsiguientes <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> llamada se agotó el tiempo inmediatamente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.Page.AsyncTimeout%2A> propiedad con el <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> y <xref:System.Web.UI.Page.RegisterAsyncTask%2A> métodos. Tenga en cuenta el uso de controladores de inicio, finalización y tiempo de espera. En el ejemplo, se introduce un retraso artificial para ilustrar la situación de una tarea asincrónica que supere el tiempo asignado para la tarea como se especifica en el <xref:System.Web.UI.Page.AsyncTimeout%2A> propiedad. En un escenario real, una tarea asincrónica podría usarse para realizar llamadas de base de datos o de generación de imágenes, por ejemplo, y el controlador de tiempo de espera proporciona degradación correcta si la tarea no se realiza en un período de tiempo especificado.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Hay una excepción en la tarea asincrónica.</exception>
        <altmember cref="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
        <altmember cref="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      </Docs>
    </Member>
    <Member MemberName="FileDependencies">
      <MemberSignature Language="C#" Value="protected System.Collections.ArrayList FileDependencies { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ArrayList FileDependencies" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.FileDependencies" />
      <MemberSignature Language="VB.NET" Value="Protected Property FileDependencies As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::ArrayList ^ FileDependencies {  void set(System::Collections::ArrayList ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FileDependencies : System.Collections.ArrayList" Usage="System.Web.UI.Page.FileDependencies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is HttpResponse.AddFileDependencies. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece una matriz de archivos de la que depende el objeto <see cref="T:System.Web.HttpResponse" /> actual.</summary>
        <value>Matriz de archivos de la que depende el objeto <see cref="T:System.Web.HttpResponse" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad está en desuso. Use la <xref:System.Web.HttpResponse.AddFileDependencies%2A> método o la <xref:System.Web.HttpResponse.AddFileDependency%2A> método de la <xref:System.Web.HttpResponse> clase en su lugar.  
  
 En la mayoría de los casos, no establezca esta propiedad en el código. Establecer el `FileDependencies` atributo `true` utilizando la directiva en el archivo .aspx. Cuando se solicita la página, la clase generada dinámicamente establece la propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public override System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FindControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FindControl (id As String) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Web::UI::Control ^ FindControl(System::String ^ id);" />
      <MemberSignature Language="F#" Value="override this.FindControl : string -&gt; System.Web.UI.Control" Usage="page.FindControl id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Identificador del control que se va a buscar.</param>
        <summary>Busca un control de servidor con el identificador especificado en el contenedor de nomenclatura de la página.</summary>
        <returns>Control especificado, o <see langword="null" /> si el control especificado no existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.FindControl%2A> método puede utilizarse para tener acceso a un control cuya <xref:System.Web.UI.Control.ID%2A> no está disponible en tiempo de diseño. El método busca solo en el contenedor inmediato, o de nivel superior de la página; Esto consigue no busca de forma recursiva los controles en contenedores de nomenclatura incluidos en la página. Para obtener acceso a los controles en un contenedor de nomenclatura subordinado, llame a la `FindControl` método de ese contenedor.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Web.UI.Page.FindControl%2A> método para buscar los controles dentro de las plantillas. En este ejemplo, dos <xref:System.Web.UI.WebControls.Repeater> se definen los controles; cada una muestra otra forma de detectar el <xref:System.Web.UI.WebControls.LinkButton.Click> eventos de un <xref:System.Web.UI.WebControls.LinkButton> dentro de la plantilla de elemento del repetidor.  
  
 [!code-aspx-csharp[System.Web.UI.Page_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/cs/pagefindcontrolcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/vb/pagefindcontrolvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlForm Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlForm Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Form" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Form As HtmlForm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::HtmlControls::HtmlForm ^ Form { System::Web::UI::HtmlControls::HtmlForm ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Form : System.Web.UI.HtmlControls.HtmlForm" Usage="System.Web.UI.Page.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlForm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el formulario HTML de la página.</summary>
        <value>Objeto <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> asociado a la página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Web.UI.Page.Form%2A> propiedad para tener acceso a los métodos y propiedades de la <xref:System.Web.UI.HtmlControls.HtmlForm> objeto que es la base de la jerarquía de controles en la página.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
      </Docs>
    </Member>
    <Member MemberName="FrameworkInitialize">
      <MemberSignature Language="C#" Value="protected override void FrameworkInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void FrameworkInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FrameworkInitialize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub FrameworkInitialize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void FrameworkInitialize();" />
      <MemberSignature Language="F#" Value="override this.FrameworkInitialize : unit -&gt; unit" Usage="page.FrameworkInitialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicializa el árbol de control durante la generación de la página sobre la base de la naturaleza declarativa de la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.FrameworkInitialize%2A> método inicializa la <xref:System.Web.UI.Page> de objetos y crea el árbol de control según la naturaleza declarativa de la página. El <xref:System.Web.UI.Page.FrameworkInitialize%2A> método se reemplaza por la generación de código y análisis de página para el <xref:System.Web.UI.Page> clase para una página declarativa. Normalmente, no debería necesitar reemplazar este método. Si se reemplaza, asegúrese de llamar a la clase base <xref:System.Web.UI.Page.FrameworkInitialize%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      </Docs>
    </Member>
    <Member MemberName="GetDataItem">
      <MemberSignature Language="C#" Value="public object GetDataItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetDataItem() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetDataItem" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDataItem () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetDataItem();" />
      <MemberSignature Language="F#" Value="member this.GetDataItem : unit -&gt; obj" Usage="page.GetDataItem " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el elemento de datos en la parte superior de la pila de contexto de enlace de datos.</summary>
        <returns>Objeto en la parte superior de la pila de contexto de enlace de datos.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">No hay ningún contexto de enlace de datos para la página.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientEvent">
      <MemberSignature Language="C#" Value="public string GetPostBackClientEvent (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientEvent(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientEvent(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientEvent(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientEvent : System.Web.UI.Control * string -&gt; string" Usage="page.GetPostBackClientEvent (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">El control de servidor que recibe la devolución de datos de los eventos de cliente.</param>
        <param name="argument">
          <see cref="T:System.String" /> que se pasa a <see cref="M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)" />.</param>
        <summary>Obtiene una referencia que puede utilizarse en un evento de cliente para devolver datos al servidor para el control especificado y con los argumentos de evento especificados.</summary>
        <returns>Cadena que representa el evento de cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consulte la <xref:System.Web.UI.ClientScriptManager> clase alternativas a este miembro en desuso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.Button.OnClientClick" />
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string -&gt; string" Usage="page.GetPostBackClientHyperlink (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackClientHyperlink. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Control de servidor que va a procesar el valor devuelto.</param>
        <param name="argument">Parámetro pasado al control de servidor.</param>
        <summary>Obtiene una referencia, con <see langword="javascript:" /> anexado al principio, que se puede utilizar en un evento de devolución de datos del cliente al servidor para el control especificado y con los argumentos de evento especificados.</summary>
        <returns>Cadena que representa una llamada de JavaScript a la función de postback que incluye el id. del control de destino y los argumentos del evento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consulte la <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> método para conocer una alternativa a este miembro en desuso.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una cadena que se puede utilizar en un evento de cliente para que se produzca un postback al servidor. Este método está en desuso. Por ello, utilice el método <see cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" /> en la clase <see cref="T:System.Web.UI.ClientScriptManager" />.</summary>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control -&gt; string" Usage="page.GetPostBackEventReference control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Control de servidor que procesará los datos devueltos en el servidor.</param>
        <summary>Devuelve una cadena que se puede utilizar en un evento de cliente para que se produzca un postback al servidor. El objeto <see cref="T:System.Web.UI.Control" /> especificado define la cadena de referencia.</summary>
        <returns>Cadena que, cuando se trata como script en el cliente, inicia el postback.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método está en desuso. Por ello, utilice el método <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> en la clase <xref:System.Web.UI.ClientScriptManager>.  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#2)]
 [!code-vb[Page_GetPostBackEventReference#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string -&gt; string" Usage="page.GetPostBackEventReference (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Control de servidor que va a procesar el valor devuelto.</param>
        <param name="argument">Parámetro pasado al control de servidor.</param>
        <summary>Devuelve una cadena que se puede utilizar en un evento de cliente para que se produzca un postback al servidor. El control especificado para controlar el postback y un argumento de cadena con información adicional sobre el evento definen la cadena de referencia.</summary>
        <returns>Cadena que, cuando se trata como script en el cliente, inicia el postback.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método está en desuso. Por ello, utilice el método <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> en la clase <xref:System.Web.UI.ClientScriptManager>.  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#1)]
 [!code-vb[Page_GetPostBackEventReference#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetTypeHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetTypeHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetTypeHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetTypeHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeHashCode : unit -&gt; int&#xA;override this.GetTypeHashCode : unit -&gt; int" Usage="page.GetTypeHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera código hash generado por objetos <see cref="T:System.Web.UI.Page" /> generados en tiempo de ejecución. Este código hash es único en la jerarquía de control del objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Código hash generado en tiempo de ejecución. El valor predeterminado es 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No invalide este método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValidators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection GetValidators (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.ValidatorCollection GetValidators(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetValidators(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValidators (validationGroup As String) As ValidatorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::ValidatorCollection ^ GetValidators(System::String ^ validationGroup);" />
      <MemberSignature Language="F#" Value="member this.GetValidators : string -&gt; System.Web.UI.ValidatorCollection" Usage="page.GetValidators validationGroup" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">Grupo de validaciones que se va a devolver, o <see langword="null" /> para devolver el grupo de validaciones predeterminado.</param>
        <summary>Devuelve una colección de validadores de control para un grupo de validaciones especificado.</summary>
        <returns>
          <see cref="T:System.Web.UI.ValidatorCollection" /> que contiene los validadores de control para el grupo de validaciones especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.GetValidators%2A> método devuelve todos los objetos de validación asociados con un grupo de validación concretas. Puede devolver el grupo de validaciones predeterminado (todos los controles de validación asociados a los controles sin la `ValidationGroup` conjunto de propiedades) estableciendo el `validationGroup` parámetro `null`.  
  
 Para validar los miembros del grupo de validación, puede enumerar a través de la colección y llamar a la <xref:System.Web.UI.IValidator.Validate%2A> devuelto del método de cada control de validación.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.UI.Page.GetValidators%2A> método para devolver el grupo de validaciones predeterminado.  
  
 [!code-csharp[PageGetValidators#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageGetValidators/CS/pagegetvalidatorscs.aspx#1)]
 [!code-vb[PageGetValidators#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageGetValidators/VB/pagegetvalidatorsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.Validate(System.String)" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
      </Docs>
    </Member>
    <Member MemberName="GetWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected object GetWrappedFileDependencies (string[] virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object GetWrappedFileDependencies(string[] virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetWrappedFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetWrappedFileDependencies (virtualFileDependencies As String()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ GetWrappedFileDependencies(cli::array &lt;System::String ^&gt; ^ virtualFileDependencies);" />
      <MemberSignature Language="F#" Value="member this.GetWrappedFileDependencies : string[] -&gt; obj" Usage="page.GetWrappedFileDependencies virtualFileDependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">Matriz de cadenas de ubicaciones de archivo virtuales.</param>
        <summary>Devuelve una lista de nombres de archivo físicos que se corresponden con una lista de ubicaciones de archivo virtuales.</summary>
        <returns>Objeto que contiene una lista de ubicaciones de archivo físicas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.GetWrappedFileDependencies%2A> método obtiene una lista de archivos, como archivos de control de usuario, que componen la página actual. Si se modifica cualquiera de estas páginas, toda la página se compila la próxima vez que se solicita. No invalide este método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Header">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlHead Header { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlHead Header" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Header" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Header As HtmlHead" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::HtmlControls::HtmlHead ^ Header { System::Web::UI::HtmlControls::HtmlHead ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Header : System.Web.UI.HtmlControls.HtmlHead" Usage="System.Web.UI.Page.Header" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlHead</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el encabezado de documento de la página si el elemento <see langword="head" /> está definido con <see langword="runat=server" /> en la declaración de la página.</summary>
        <value>
          <see cref="T:System.Web.UI.HtmlControls.HtmlHead" /> que contiene el encabezado de página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.Header%2A> propiedad obtiene una referencia a un <xref:System.Web.UI.HtmlControls.HtmlHead> de objeto que puede usar para establecer la información de encabezado de documento de la página. El <xref:System.Web.UI.HtmlControls.HtmlHead> le permite agregar información como las hojas de estilos, las reglas de estilo, un título y los metadatos para el `head` elemento.  
  
> [!NOTE]
>  Agregar estilos mediante programación utilizando los métodos de la <xref:System.Web.UI.IStyleSheet> no se admite la interfaz durante los postbacks asincrónicos. Al agregar capacidades AJAX a una página Web, postbacks asincrónicos actualizan regiones de la página sin actualizar la página entera. Para obtener más información, consulte [Microsoft Ajax Overview](http://msdn.microsoft.com/library/be84d9b3-b7cd-47d7-8494-be4abfaad9cb).  
  
   
  
## Examples  
 El código siguiente muestra cómo obtener acceso a la <xref:System.Web.UI.HtmlControls.HtmlHead> controlar mediante programación con el <xref:System.Web.UI.Page.Header%2A> propiedad. Un `title` elemento y `style` elemento se agregan a la `head` elemento de la página.  
  
 [!code-aspx-csharp[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/CS/htmlheadclasscs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/VB/htmlheadclassvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlHead" />
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlLink" />
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public override string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ID : string with get, set" Usage="System.Web.UI.Page.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un identificador para una instancia determinada de la clase <see cref="T:System.Web.UI.Page" />.</summary>
        <value>Identificador de la instancia de la clase <see cref="T:System.Web.UI.Page" />. El valor predeterminado es '_Page'.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.Page.IdSeparator" />
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="public virtual char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IdSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IdSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char IdSeparator { char get(); };" />
      <MemberSignature Language="F#" Value="member this.IdSeparator : char" Usage="System.Web.UI.Page.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el carácter utilizado para separar los identificadores de control al crear un identificador único para un control de una página.</summary>
        <value>Carácter utilizado para separar los identificadores de control. La instancia de <see cref="T:System.Web.UI.Adapters.PageAdapter" /> que representa la página establece el valor predeterminado. <see cref="P:System.Web.UI.Page.IdSeparator" /> es un campo de servidor y no se debe modificar.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.Page.ID" />
      </Docs>
    </Member>
    <Member MemberName="InitComplete">
      <MemberSignature Language="C#" Value="public event EventHandler InitComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InitComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.InitComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InitComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ InitComplete;" />
      <MemberSignature Language="F#" Value="member this.InitComplete : EventHandler " Usage="member this.InitComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se completa la inicialización de la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.InitComplete> al final de la fase de inicialización de la página se llama al evento. En esta etapa del ciclo de vida de la página, todos los declarados se inicializan los controles de la página, pero no se ha rellenado el estado de la página. Puede tener acceso a los controles de servidor, pero aún no contiene información devuelta por el usuario.  
  
 Para obtener más información sobre cómo controlar eventos, vea [NIB: consumir eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Page.LoadComplete" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
      </Docs>
    </Member>
    <Member MemberName="InitializeCulture">
      <MemberSignature Language="C#" Value="protected virtual void InitializeCulture ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeCulture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitializeCulture" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeCulture ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeCulture();" />
      <MemberSignature Language="F#" Value="abstract member InitializeCulture : unit -&gt; unit&#xA;override this.InitializeCulture : unit -&gt; unit" Usage="page.InitializeCulture " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establece <see cref="P:System.Web.UI.Page.Culture" /> y <see cref="P:System.Web.UI.Page.UICulture" /> para el subproceso actual de la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.InitializeCulture%2A> método no contiene ninguna lógica de codificación. Controlar los desarrolladores para ampliar la funcionalidad de la <xref:System.Web.UI.Page> clase puede invalidar el <xref:System.Web.UI.Page.InitializeCulture%2A> método para inicializar el <xref:System.Web.UI.Page.Culture%2A> y <xref:System.Web.UI.Page.UICulture%2A> información de la página.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.Web.UI.Page.FrameworkInitialize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InitOutputCache">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa la memoria caché de resultados para la solicitud de página actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no está pensado para usarse directamente desde su código. Para habilitar y manipular la memoria caché de salida para una página, use uno de estos enfoques:  
  
-   Establecer opciones de manera declarativa mediante la directiva en el archivo .aspx.  
  
-   Utilice los métodos y propiedades de la <xref:System.Web.HttpCachePolicy> (clase), que se expone mediante la `Response.Cache` objeto en el código de la página.  
  
 Para obtener más información, consulte [almacenamiento en caché las páginas ASP.NET](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected internal virtual void InitOutputCache (System.Web.UI.OutputCacheParameters cacheSettings);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void InitOutputCache(class System.Web.UI.OutputCacheParameters cacheSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Web.UI.OutputCacheParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub InitOutputCache (cacheSettings As OutputCacheParameters)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void InitOutputCache(System::Web::UI::OutputCacheParameters ^ cacheSettings);" />
      <MemberSignature Language="F#" Value="abstract member InitOutputCache : System.Web.UI.OutputCacheParameters -&gt; unit&#xA;override this.InitOutputCache : System.Web.UI.OutputCacheParameters -&gt; unit" Usage="page.InitOutputCache cacheSettings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheSettings" Type="System.Web.UI.OutputCacheParameters" />
      </Parameters>
      <Docs>
        <param name="cacheSettings">
          <see cref="T:System.Web.UI.OutputCacheParameters" /> que contiene la configuración de la caché.</param>
        <summary>Inicializa la caché de resultados para la solicitud de página actual sobre la base de un objeto <see cref="T:System.Web.UI.OutputCacheParameters" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No debe llamar a este método. Para habilitar y manipular la memoria caché de salida para una página, utilice la directiva en el archivo .aspx, o los métodos y propiedades de la <xref:System.Web.HttpCachePolicy> clase. Estos últimos son accesibles a través de `Response.Cache` sintaxis en el archivo de código subyacente o de bloque de la declaración del código de la página. Para obtener más información, consulte [almacenamiento en caché las páginas ASP.NET](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">No se ha encontrado el perfil de caché.  \- o bien - Directiva o atributo de perfil de configuración perdidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La ubicación de la configuración de la caché de resultados es no válida.</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitOutputCache (duration As Integer, varyByHeader As String, varyByCustom As String, location As OutputCacheLocation, varyByParam As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitOutputCache(int duration, System::String ^ varyByHeader, System::String ^ varyByCustom, System::Web::UI::OutputCacheLocation location, System::String ^ varyByParam);" />
      <MemberSignature Language="F#" Value="abstract member InitOutputCache : int * string * string * System.Web.UI.OutputCacheLocation * string -&gt; unit&#xA;override this.InitOutputCache : int * string * string * System.Web.UI.OutputCacheLocation * string -&gt; unit" Usage="page.InitOutputCache (duration, varyByHeader, varyByCustom, location, varyByParam)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">El período de tiempo durante el cual los objetos se almacenan en la memoria caché de resultados es válido.</param>
        <param name="varyByHeader">Lista de encabezados, separados por punto y coma, por la que va a variar el contenido de la memoria caché de resultados.</param>
        <param name="varyByCustom">Encabezado <see langword="Vary" /> HTTP.</param>
        <param name="location">Uno de los valores de <see cref="T:System.Web.UI.OutputCacheLocation" />.</param>
        <param name="varyByParam">Lista de parámetros, separados por punto y coma y recibidos mediante un método GET o POST, por la que va a variar el contenido de la memoria caché de resultados.</param>
        <summary>Inicializa la memoria caché de resultados para la solicitud de página actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No debe llamar a este método. Para habilitar y manipular la memoria caché de salida para una página, utilice la directiva en el archivo .aspx, o los métodos y propiedades de la <xref:System.Web.HttpCachePolicy> clase. Estos últimos son accesibles a través de `Response.Cache` sintaxis en el código de la página. Para obtener más información, consulte [almacenamiento en caché las páginas ASP.NET](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Se ha especificado un valor no válido para <paramref name="location" />.</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitOutputCache (duration As Integer, varyByContentEncoding As String, varyByHeader As String, varyByCustom As String, location As OutputCacheLocation, varyByParam As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitOutputCache(int duration, System::String ^ varyByContentEncoding, System::String ^ varyByHeader, System::String ^ varyByCustom, System::Web::UI::OutputCacheLocation location, System::String ^ varyByParam);" />
      <MemberSignature Language="F#" Value="abstract member InitOutputCache : int * string * string * string * System.Web.UI.OutputCacheLocation * string -&gt; unit&#xA;override this.InitOutputCache : int * string * string * string * System.Web.UI.OutputCacheLocation * string -&gt; unit" Usage="page.InitOutputCache (duration, varyByContentEncoding, varyByHeader, varyByCustom, location, varyByParam)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByContentEncoding" Type="System.String" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">El período de tiempo durante el cual los objetos se almacenan en la memoria caché de resultados es válido.</param>
        <param name="varyByContentEncoding">Conjunto de caracteres (codificaciones de contenido), separados por punto y coma, por el que va a variar el contenido de la memoria caché de resultados.</param>
        <param name="varyByHeader">Lista de encabezados, separados por punto y coma, por la que va a variar el contenido de la memoria caché de resultados.</param>
        <param name="varyByCustom">Encabezado <see langword="Vary" /> HTTP.</param>
        <param name="location">Uno de los valores de <see cref="T:System.Web.UI.OutputCacheLocation" />.</param>
        <param name="varyByParam">Lista de parámetros, separados por punto y coma y recibidos mediante un método GET o POST, por la que va a variar el contenido de la memoria caché de resultados.</param>
        <summary>Inicializa la memoria caché de resultados para la solicitud de página actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No debe llamar a este método. Para habilitar y manipular la memoria caché de salida para una página, utilice la directiva en el archivo .aspx, o los métodos y propiedades de la <xref:System.Web.HttpCachePolicy> clase. Estos últimos son accesibles a través de `Response.Cache` sintaxis en el código de la página. Para obtener más información, consulte [almacenamiento en caché las páginas ASP.NET](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Se ha especificado un valor no válido para <paramref name="location" />.</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.Web.UI.Page.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la página se va a procesar de manera asincrónica.</summary>
        <value>Es <see langword="true" /> si la página está en modo asincrónico; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Web.UI.Page.IsAsync%2A> propiedad para determinar si la página Web se está ejecutando en modo asincrónico. Esta información es útil si necesita modificar su comportamiento dependiendo de si la página es asincrónica controles o el código en la página. Para obtener más información sobre la programación asincrónica, vea [operaciones asincrónicas](~/docs/framework/data/adonet/sql/asynchronous-operations.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCallback">
      <MemberSignature Language="C#" Value="public bool IsCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCallback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCallback { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCallback : bool" Usage="System.Web.UI.Page.IsCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la solicitud de página es el resultado de una devolución de llamada.</summary>
        <value>Es <see langword="true" /> si la solicitud de página es el resultado de una devolución de llamada; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, consulte [Implementing devoluciones de llamada de cliente sin Postbacks](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : string -&gt; bool" Usage="page.IsClientScriptBlockRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsClientScriptBlockRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Clave de cadena del script de cliente que se va a buscar.</param>
        <summary>Determina si el bloque de script de cliente con la clave especificada se ha registrado con la página.</summary>
        <returns>Es <see langword="true" /> si el bloque de script está registrado; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a este método antes de llamar a <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A?displayProperty=nameWithType> para evitar innecesariamente ensamblar el script del lado cliente. Esto es especialmente importante si la secuencia de comandos requiere una gran cantidad de recursos del servidor para crear.  
  
 El método <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> está desusado. Use la <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> método en el <xref:System.Web.UI.ClientScriptManager> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> método junto con el <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> método. Si el ECMAScript escrito en el bloque de código de declaración aún no se ha registrado, según lo determinado por <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>, un <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> se realiza la llamada.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsCrossPagePostBack">
      <MemberSignature Language="C#" Value="public bool IsCrossPagePostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCrossPagePostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCrossPagePostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCrossPagePostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCrossPagePostBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCrossPagePostBack : bool" Usage="System.Web.UI.Page.IsCrossPagePostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la página participa en un postback entre páginas.</summary>
        <value>Es <see langword="true" /> si esta página participa en una solicitud entre páginas; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET proporciona dos mecanismos para transferir el control de una página a otra. Puede usar el <xref:System.Web.HttpServerUtility.Transfer%2A> método para transferir el procesamiento entre páginas, o bien puede realizar una solicitud entre páginas asignando una dirección URL de página a la <xref:System.Web.UI.WebControls.IButtonControl.PostBackUrl%2A> propiedad de un control de botón que implementa el <xref:System.Web.UI.WebControls.IButtonControl> interfaz.  
  
 En cualquier caso, el <xref:System.Web.UI.Page.PreviousPage%2A> propiedad página contendrá un objeto que representa la página anterior o autor. Si, por ejemplo, expone Page A página B, Page A <xref:System.Web.UI.Page.IsCrossPagePostBack%2A> propiedad (accesible a través de la <xref:System.Web.UI.Page.PreviousPage%2A> propiedad) será `true` y la página B <xref:System.Web.UI.Page.PreviousPage%2A> propiedad tendrá el nombre de la Page A. de  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.IButtonControl.PostBackUrl" />
      </Docs>
    </Member>
    <Member MemberName="IsPostBack">
      <MemberSignature Language="C#" Value="public bool IsPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostBack : bool" Usage="System.Web.UI.Page.IsPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la página se está mostrando por primera vez o si se está cargando como respuesta a un postback.</summary>
        <value>Es <see langword="true" /> si la página se carga como respuesta a un postback del cliente; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una explicación de la diferencia entre las devoluciones de datos y las devoluciones de llamada, vea [Implementing devoluciones de llamada de cliente sin Postbacks](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo probar el valor de la <xref:System.Web.UI.Page.IsPostBack%2A> propiedad cuando se carga la página con el fin de determinar si la página se está representando por primera vez o se responde a un valor devuelto. Si se está representando la página por primera vez, el código llama a la <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> método.  
  
 Contiene el marcado de página (no mostrado) <xref:System.Web.UI.WebControls.RequiredFieldValidator> controles que muestren los asteriscos si no se realiza ninguna entrada para un campo de entrada obligatorio. Una llamada a <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> hace que los asteriscos que se mostrará inmediatamente cuando se representa la página, en lugar de esperar hasta que el usuario hace clic en el botón Enviar. Después de un postback, no es necesario llamar a <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>, porque ese método se llama como parte de la <xref:System.Web.UI.Page> ciclo de vida.  
  
 [!code-csharp[System.Web.UI.Page.Validate#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Validate#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
        <altmember cref="P:System.Web.UI.Page.IsCallback" />
      </Docs>
    </Member>
    <Member MemberName="IsPostBackEventControlRegistered">
      <MemberSignature Language="C#" Value="public bool IsPostBackEventControlRegistered { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBackEventControlRegistered" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBackEventControlRegistered" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostBackEventControlRegistered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostBackEventControlRegistered { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostBackEventControlRegistered : bool" Usage="System.Web.UI.Page.IsPostBackEventControlRegistered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se ha registrado el control de la página que realiza los postbacks.</summary>
        <value>Es <see langword="true" /> si se ha registrado el control; en caso contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReusable">
      <MemberSignature Language="C#" Value="public bool IsReusable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReusable" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsReusable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReusable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReusable : bool" Usage="System.Web.UI.Page.IsReusable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.IHttpHandler.IsReusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si puede reutilizarse el objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <value>
          <see langword="false" /> en todos los casos.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.IHttpHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : string -&gt; bool" Usage="page.IsStartupScriptRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsStartupScriptRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Clave de cadena del script de inicio que se va a buscar.</param>
        <summary>Determina si el script de inicio del cliente se encuentra registrado con el objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Es <see langword="true" /> si el script de inicio está registrado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a este método antes de llamar a <xref:System.Web.UI.Page.RegisterStartupScript%2A?displayProperty=nameWithType> para evitar innecesariamente ensamblar el script del lado cliente. Esto es especialmente importante si la secuencia de comandos requiere una gran cantidad de recursos del servidor para crear.  
  
 El método <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> está desusado. Use la <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> método en el <xref:System.Web.UI.ClientScriptManager> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.Page.RegisterStartupScript%2A> método junto con el <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> método. Si el ECMAScript escrito en el bloque de código de declaración aún no se ha registrado, según lo determinado por <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A>, un <xref:System.Web.UI.Page.RegisterStartupScript%2A> se realiza la llamada.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public bool IsValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValid" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValid : bool" Usage="System.Web.UI.Page.IsValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la validación de la página ha sido correcta.</summary>
        <value>Es <see langword="true" /> si la validación de la página se ha realizado correctamente; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para esta propiedad devolver `true`, todos los controles de servidor de validación en el grupo de validación actual deben validarse correctamente. Debe comprobar esta propiedad sólo después de haber llamado el <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> método o conjunto el `CausesValidation` propiedad `true` en el `OnServerClick` controlador de eventos para un control de servidor ASP.NET que inicia el procesamiento de formularios. Estos controles de servidor incluyen la <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.HtmlControls.HtmlButton>, <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, <xref:System.Web.UI.WebControls.ImageButton>, y <xref:System.Web.UI.WebControls.LinkButton> clases.  
  
 Si se fuerza la validación de un grupo de validación mediante el <xref:System.Web.UI.Page.Validate%2A> método y, a continuación, todos los controles de validación en el grupo de validaciones especificado deben validarse correctamente también.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Web.UI.Page.IsValid%2A> propiedad para establecer una instrucción condicional. Si la propiedad devuelve `true`, `Text` propiedad de la `lblOutput` control se establece en "Página es válida." En caso contrario, se establece en "Algunos de los campos obligatorios están vacíos."  
  
 [!code-csharp[System.Web.UI.Page.Validate#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Validate#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Se llama a la propiedad <see cref="P:System.Web.UI.Page.IsValid" /> antes de que se haya realizado la validación.</exception>
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="M:System.Web.UI.Page.Validate" />
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.UI.Page.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una lista de objetos almacenados en el contexto de la página.</summary>
        <value>Referencia a <see cref="T:System.Collections.IDictionary" /> que contiene los objetos almacenados en el contexto de la página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Web.UI.Page.Items%2A> propiedad para almacenar objetos con la misma duración que la solicitud de página. Esta propiedad es de solo lectura. Sin embargo, puede agregar objetos a la <xref:System.Collections.IDictionary> objeto devuelve.  
  
 Objetos agregados a la <xref:System.Web.UI.Page.Items%2A> propiedad están disponibles durante la vigencia de la página, por lo que puede agregar objetos a la <xref:System.Web.UI.Page.Items%2A> propiedad al principio de la vida de la página eventos de ciclo y tener acceso a esos objetos en eventos posteriores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LCID">
      <MemberSignature Language="C#" Value="public int LCID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LCID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.LCID" />
      <MemberSignature Language="VB.NET" Value="Public Property LCID As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LCID { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.LCID : int with get, set" Usage="System.Web.UI.Page.LCID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece el identificador de configuración regional del objeto <see cref="T:System.Threading.Thread" /> asociado a la página.</summary>
        <value>Identificador de configuración regional que se pasa a <see cref="T:System.Threading.Thread" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la mayoría de los casos, no establezca esta propiedad en el código. El `LCID` atributo puede establecerse en la directiva del archivo .aspx, sin embargo, el método preferido para establecer el identificador de configuración regional es mediante el uso de la <xref:System.Web.UI.Page.Culture%2A> y <xref:System.Web.UI.Page.UICulture%2A> propiedades.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="P:System.Web.UI.Page.Culture" />
        <altmember cref="P:System.Web.UI.Page.UICulture" />
      </Docs>
    </Member>
    <Member MemberName="LoadComplete">
      <MemberSignature Language="C#" Value="public event EventHandler LoadComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LoadComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.LoadComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LoadComplete;" />
      <MemberSignature Language="F#" Value="member this.LoadComplete : EventHandler " Usage="member this.LoadComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce al final de la fase de carga del ciclo de vida de la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.LoadComplete> evento se produce después del postback todos los datos y se cargan los datos de estado de vista en la página y después la <xref:System.Web.UI.Control.OnLoad%2A> se ha llamado al método para todos los controles en la página.  
  
 Para obtener más información sobre cómo controlar eventos, vea [NIB: consumir eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Page.InitComplete" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
      </Docs>
    </Member>
    <Member MemberName="LoadPageStateFromPersistenceMedium">
      <MemberSignature Language="C#" Value="protected internal virtual object LoadPageStateFromPersistenceMedium ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object LoadPageStateFromPersistenceMedium() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function LoadPageStateFromPersistenceMedium () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ LoadPageStateFromPersistenceMedium();" />
      <MemberSignature Language="F#" Value="abstract member LoadPageStateFromPersistenceMedium : unit -&gt; obj&#xA;override this.LoadPageStateFromPersistenceMedium : unit -&gt; obj" Usage="page.LoadPageStateFromPersistenceMedium " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Carga toda la información de estado de vista que se haya guardado en el objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Estado de vista guardado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A> método usa la <xref:System.Web.UI.PageStatePersister.Load%2A> método de la <xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType> hacen referencia al objeto la <xref:System.Web.UI.Page.PageStatePersister%2A> propiedad cargará todos guarda información de estado de vista para la <xref:System.Web.UI.Page> objeto.  
  
 ASP.NET incluye dos descendientes de los <xref:System.Web.UI.PageStatePersister> (clase), el <xref:System.Web.UI.HiddenFieldPageStatePersister> clase que guarda la información de estado en un campo oculto que se incluye en la página ASP.NET, y el <xref:System.Web.UI.SessionPageStatePersister> clase que guarda el estado en el <xref:System.Web.UI.Page.Session%2A> objeto asociado con el solicitud.  
  
 Para guardar el estado en la ubicación de su elección, debe crear un nuevo descendiente de la <xref:System.Web.UI.PageStatePersister> clase que guarda y carga el estado en el medio de persistencia que prefiera. Para obtener un ejemplo de creación de un nuevo <xref:System.Web.UI.PageStatePersister> de objetos, consulte el <xref:System.Web.UI.PageStatePersister> clase.  
  
 Si usa .NET Framework versión 1.0 o 1.1, invalide este método si desea cargar el <xref:System.Web.UI.Page> estado desde cualquier otra cosa que no sea un campo oculto. Si decide hacerlo, también debe invalidar el <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
        <altmember cref="P:System.Web.UI.Page.PageStatePersister" />
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="MaintainScrollPositionOnPostBack">
      <MemberSignature Language="C#" Value="public bool MaintainScrollPositionOnPostBack { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaintainScrollPositionOnPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      <MemberSignature Language="VB.NET" Value="Public Property MaintainScrollPositionOnPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaintainScrollPositionOnPostBack { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MaintainScrollPositionOnPostBack : bool with get, set" Usage="System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el usuario regresará a la misma posición del explorador cliente después del postback. Esta propiedad reemplaza la propiedad <see cref="P:System.Web.UI.Page.SmartNavigation" /> obsoleta.</summary>
        <value>Es <see langword="true" /> si debe mantenerse la posición del cliente; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se registran las páginas Web al servidor, se devuelve al usuario a la parte superior de la página. En páginas Web largas, esto significa que el usuario tiene que desplazar la página a la última posición en la página.  
  
 Cuando el <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> propiedad está establecida en `true`, el usuario en su lugar, vuelve a la última posición en la página.  
  
 Establece el <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> propiedad en el [@ Page](http://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) directiva.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="page.MapPath virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">
          <see cref="T:System.String" /> que representa la ruta de acceso virtual.</param>
        <summary>Recupera la ruta de acceso física a la que está asignada una ruta de acceso virtual absoluta o relativa, o una ruta de acceso relativa a la aplicación.</summary>
        <returns>Ruta de acceso física asociada a la ruta de acceso virtual o a la ruta de acceso relativa a la aplicación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  El <xref:System.Web.UI.Page.MapPath%2A> propiedad puede contener información confidencial sobre el entorno de hospedaje. El valor devuelto no debe mostrarse a los usuarios.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Web.UI.Page.MapPath%2A> método para obtener la ruta de acceso física de una subcarpeta. A continuación, anexa el nombre de archivo que se lee desde el <xref:System.Web.UI.WebControls.TextBox.Text%2A> propiedad de un <xref:System.Web.UI.WebControls.TextBox> control. El resultado es la ruta de acceso física absoluta a ese archivo.  
  
 [!code-csharp[Page_MapPath_ResponseEncoding#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/CS/page_mappath_responseencoding.cs.aspx#1)]
 [!code-vb[Page_MapPath_ResponseEncoding#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/VB/page_mappath_responseencoding.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Master">
      <MemberSignature Language="C#" Value="public System.Web.UI.MasterPage Master { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.MasterPage Master" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Master" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Master As MasterPage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::MasterPage ^ Master { System::Web::UI::MasterPage ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Master : System.Web.UI.MasterPage" Usage="System.Web.UI.Page.Master" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.MasterPage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la página maestra que determina la apariencia general de la página.</summary>
        <value>El <see cref="T:System.Web.UI.MasterPage" /> asociado a esta página, si existe; de lo contrario, es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.Master%2A> propiedad devuelve el <xref:System.Web.UI.MasterPage> objeto asociado a esta página. Esta propiedad es de solo lectura. Sin embargo, puede establecer propiedades en el <xref:System.Web.UI.MasterPage> objeto devuelve.  
  
 El <xref:System.Web.UI.Page.Master%2A> propiedad sólo es válida en las páginas que hacen referencia a una página maestra en el <xref:System.Web.UI.Page.MasterPageFile%2A> propiedad. Si tiene acceso a la <xref:System.Web.UI.Page.Master%2A> propiedad en una página que no hace referencia a una página maestra, `null` se devuelve. El contenido de una página maestra no está disponible hasta después de la <xref:System.Web.UI.Page.PreInit> ha generado el evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.MasterPageFile" />
      </Docs>
    </Member>
    <Member MemberName="MasterPageFile">
      <MemberSignature Language="C#" Value="public virtual string MasterPageFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MasterPageFile" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MasterPageFile" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MasterPageFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ MasterPageFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MasterPageFile : string with get, set" Usage="System.Web.UI.Page.MasterPageFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la ruta virtual de la página maestra.</summary>
        <value>Ruta de acceso virtual de la página maestra.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.MasterPageFile%2A> propiedad es una ruta de acceso virtual (desde la raíz de la aplicación) de la página principal de archivo asociado a esta página. El <xref:System.Web.UI.Page.MasterPageFile%2A> propiedad puede establecerse solo en el <xref:System.Web.UI.Page.PreInit> evento; al intentar establecer el <xref:System.Web.UI.Page.MasterPageFile%2A> propiedad después de la <xref:System.Web.UI.Page.PreInit> evento producirá un <xref:System.InvalidOperationException> excepción. Si el <xref:System.Web.UI.Page.MasterPageFile%2A> propiedad no es válida, una excepción de tipo <xref:System.Web.HttpException> se produce más adelante en el ciclo de vida de la página, pero se produce ninguna excepción cuando la propiedad está establecida el <xref:System.Web.UI.Page.PreInit> eventos.  
  
 Las páginas que tienen la <xref:System.Web.UI.Page.MasterPageFile%2A> conjunto de propiedades son páginas de contenido y, por lo tanto, puede contener controles sólo de nivel superior que se encuentran <xref:System.Web.UI.WebControls.Content> controles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Web.UI.Page.MasterPageFile" /> se establece cuando ha finalizado el evento <see cref="E:System.Web.UI.Page.PreInit" />.</exception>
        <exception cref="T:System.Web.HttpException">El archivo especificado en la propiedad <see cref="P:System.Web.UI.Page.MasterPageFile" /> no existe.  \- o bien - La página no tiene un control <see cref="T:System.Web.UI.WebControls.Content" /> como control de nivel superior.</exception>
        <altmember cref="P:System.Web.UI.Page.Master" />
      </Docs>
    </Member>
    <Member MemberName="MaxPageStateFieldLength">
      <MemberSignature Language="C#" Value="public int MaxPageStateFieldLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPageStateFieldLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaxPageStateFieldLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPageStateFieldLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxPageStateFieldLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxPageStateFieldLength : int with get, set" Usage="System.Web.UI.Page.MaxPageStateFieldLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la longitud máxima del campo de estado de la página.</summary>
        <value>Longitud máxima, en bytes, del campo de estado de la página. El valor predeterminado es -1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> propiedad está establecida en un número positivo, el estado de vista que se envía al explorador del cliente se divide en varios campos ocultos y valor de cada campo es menor que el tamaño especificado en el <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> propiedad.  
  
 Establecer el <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> propiedad en un número negativo (valor predeterminado) indica que el campo de estado de vista no se debería dividir en fragmentos. Establecer el <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> en un número pequeño puede causar un bajo rendimiento.  
  
 Establezca el valor de la <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> propiedad en del archivo Web.config.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> no es igual a -1 o un número positivo.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> se estableció una vez inicializada la página.</exception>
      </Docs>
    </Member>
    <Member MemberName="MetaDescription">
      <MemberSignature Language="C#" Value="public string MetaDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property MetaDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MetaDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MetaDescription : string with get, set" Usage="System.Web.UI.Page.MetaDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el contenido del elemento <see langword="meta" /> "description".</summary>
        <value>Contenido del elemento <see langword="meta" /> "description".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML `meta` elementos se pueden utilizar para mejorar las listas de motor de búsqueda. "description" `meta` elemento usa algunos motores de búsqueda para mejorar las versiones preliminares de anuncio.  
  
 Si no hay ningún "description" `meta` elemento en el `head` elemento de marcado de la página, el `meta` elemento se agrega a la página cuando se representa la página. Si el marcado de página ya tiene una "Descripción" `meta` elemento, esta propiedad obtiene o establece el `content` atributo de la `meta` elemento.  
  
 También puede establecer esta propiedad en la directiva.  
  
   
  
## Examples  
 Si establece la <xref:System.Web.UI.Page.MetaDescription%2A> propiedad de la página "Información general sobre ASP.NET", el siguiente elemento aparecerá en el HTML representado:  
  
 `<meta name="description" content="ASP.NET Overview" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La página no tiene un control de encabezado (un elemento de <see langword="head" /> con el atributo <see langword="runat" /> establecido en el "servidor").</exception>
        <altmember cref="P:System.Web.UI.Page.MetaKeywords" />
      </Docs>
    </Member>
    <Member MemberName="MetaKeywords">
      <MemberSignature Language="C#" Value="public string MetaKeywords { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaKeywords" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaKeywords" />
      <MemberSignature Language="VB.NET" Value="Public Property MetaKeywords As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MetaKeywords { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MetaKeywords : string with get, set" Usage="System.Web.UI.Page.MetaKeywords" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el contenido del elemento <see langword="meta" /> "keywords".</summary>
        <value>Contenido del elemento <see langword="meta" /> "keywords".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML `meta` elementos se pueden utilizar para mejorar las listas de motor de búsqueda. "keywords" `meta` elemento no se utiliza en absoluto o se le asigna un peso muy pequeño por los principales motores de búsqueda.  
  
 Si no hay ningún "keywords" `meta` elemento en el `head` elemento de marcado de la página, el `meta` elemento se agrega a la página cuando se representa la página. Si el marcado de página ya tiene un "keywords" `meta` elemento, esta propiedad obtiene o establece el `content` atributo de la `meta` elemento.  
  
 También puede establecer esta propiedad en la directiva.  
  
   
  
## Examples  
 Si establece la <xref:System.Web.UI.Page.MetaKeywords%2A> propiedad de una página "HTML, CSS, XML, JavaScript", el siguiente elemento aparecerá en el HTML representado:  
  
 `<meta name="keywords" content=" HTML,CSS,XML,JavaScript" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La página no tiene un control de encabezado (un elemento de <see langword="head" /> con el atributo <see langword="runat" /> establecido en el "servidor").</exception>
        <altmember cref="P:System.Web.UI.Page.MetaDescription" />
      </Docs>
    </Member>
    <Member MemberName="ModelBindingExecutionContext">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelBindingExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModelBindingExecutionContext As ModelBindingExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ModelBinding::ModelBindingExecutionContext ^ ModelBindingExecutionContext { System::Web::ModelBinding::ModelBindingExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ModelBindingExecutionContext : System.Web.ModelBinding.ModelBindingExecutionContext" Usage="System.Web.UI.Page.ModelBindingExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelBindingExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el contexto de ejecución del enlace de modelos.</summary>
        <value>Contexto de ejecución del enlace de modelos. Si el contexto ejecución de enlace de modelos es <see langword="null" />, se crea y se devuelve uno nuevo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModelState">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelStateDictionary ModelState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelStateDictionary ModelState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModelState As ModelStateDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ModelBinding::ModelStateDictionary ^ ModelState { System::Web::ModelBinding::ModelStateDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ModelState : System.Web.ModelBinding.ModelStateDictionary" Usage="System.Web.UI.Page.ModelState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelStateDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto de diccionario de estados del modelo que contiene el estado del modelo y la validación de enlace del modelo.</summary>
        <value>Objeto del diccionario del modelo de estado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para una serie de tutoriales sobre el uso de enlace de modelos con formularios Web Forms, consulte [enlace de modelos y formularios Web Forms](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="page.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento <see cref="E:System.Web.UI.Control.Init" /> para inicializar la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.OnInit%2A> método lleva a cabo los pasos de inicialización y configuración necesarios para crear un <xref:System.Web.UI.Page> instancia. En esta fase del ciclo de vida de la página, los controles de servidor declarada en la página se inicializan en su estado predeterminado; Sin embargo, no se ha rellenado el estado de vista de cada control. Un control en la página no puede obtener acceso a otros controles de servidor en la página durante la `Page_Init` fase, independientemente de si los demás controles son controles de primario o secundario. Otros controles de servidor no se garantiza que se crea y se prepara para el acceso.  
  
 El <xref:System.Web.UI.Page.OnInit%2A> se llama al método después de la <xref:System.Web.UI.Page.OnPreInit%2A> método y antes de la <xref:System.Web.UI.Page.OnInitComplete%2A> método.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Web.UI.Page.OnInit%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInitComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnInitComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitComplete : EventArgs -&gt; unit&#xA;override this.OnInitComplete : EventArgs -&gt; unit" Usage="page.OnInitComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento <see cref="E:System.Web.UI.Page.InitComplete" /> después de la inicialización de la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.OnInitComplete%2A> se llama al método una vez completada la inicialización de la página. En esta fase del ciclo de vida de la página, todos los declarados se inicializan los controles de la página, pero no se ha rellenado el estado de vista de la página. Puede tener acceso a los controles de servidor, pero aún no contiene información devuelta por el usuario.  
  
 El <xref:System.Web.UI.Page.OnInitComplete%2A> método se produce al final de la <xref:System.Web.UI.Page> fase de inicialización y antes de la fase de carga.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Web.UI.Page.OnInitComplete%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLoadComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadComplete : EventArgs -&gt; unit&#xA;override this.OnLoadComplete : EventArgs -&gt; unit" Usage="page.OnLoadComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento <see cref="E:System.Web.UI.Page.LoadComplete" /> al final de la fase de carga de la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.OnLoadComplete%2A> se llama al método al final de la fase de carga de página. En este momento en el ciclo de vida de página, todos los datos de estado de vista y los datos de postback se carga en los controles en la página.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Web.UI.Page.OnLoadComplete%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreInit">
      <MemberSignature Language="C#" Value="protected virtual void OnPreInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreInit : EventArgs -&gt; unit&#xA;override this.OnPreInit : EventArgs -&gt; unit" Usage="page.OnPreInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento <see cref="E:System.Web.UI.Page.PreInit" /> al principio de la inicialización de la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.OnPreInit%2A> se llama al método al principio de la fase de inicialización de la página.  
  
 Después de la <xref:System.Web.UI.Page.OnPreInit%2A> se llama al método, se carga la información de personalización y el tema de página, si existe, se inicializa. También es la etapa preferida para definir de forma dinámica un <xref:System.Web.UI.PageTheme> o <xref:System.Web.UI.MasterPage> para la página.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Web.UI.Page.OnPreInit%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnPreLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreLoad : EventArgs -&gt; unit&#xA;override this.OnPreLoad : EventArgs -&gt; unit" Usage="page.OnPreLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Web.UI.Page.PreLoad" /> después de que se han cargado los datos de postback en los controles de servidor de la página, pero antes del evento <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.OnPreLoad%2A> se llama al método después de todo postback datos devueltos por el usuario se cargan. En esta etapa del ciclo de vida de la página, información de estado de vista y datos de postback para declararían los controles y los controles creados durante la fase de inicialización se cargan en los controles de la página.  
  
 Los controles creados en el <xref:System.Web.UI.Page.OnPreLoad%2A> método también se cargarán con estado de vista y los datos devueltos.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Web.UI.Page.OnPreLoad%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreRenderComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnPreRenderComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreRenderComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreRenderComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreRenderComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRenderComplete : EventArgs -&gt; unit&#xA;override this.OnPreRenderComplete : EventArgs -&gt; unit" Usage="page.OnPreRenderComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento <see cref="E:System.Web.UI.Page.PreRenderComplete" /> después del evento <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> y antes de que se represente la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.OnPreRenderComplete%2A> se llama al método una vez completada la fase de representación previa del ciclo de vida de página. En esta etapa del ciclo de vida de página, se crean todos los controles y está lista para representar la salida de la página.  
  
 Este es el último evento que se llama antes de que se guarda el estado de vista.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Web.UI.Page.OnPreRenderComplete%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSaveStateComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnSaveStateComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSaveStateComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSaveStateComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSaveStateComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSaveStateComplete : EventArgs -&gt; unit&#xA;override this.OnSaveStateComplete : EventArgs -&gt; unit" Usage="page.OnSaveStateComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento <see cref="E:System.Web.UI.Page.SaveStateComplete" /> después de que el estado de la página se ha guardado en el medio de persistencia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.OnSaveStateComplete%2A> método se llama cuando se ha escrito la información de estado para el control en el medio de persistencia de la página. La información de estado se escribe en el medio de persistencia mediante una llamada a la <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> método.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Web.UI.Page.OnSaveStateComplete%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
        <altmember cref="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
        <altmember cref="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="public System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Page.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el adaptador que representa la página del explorador específico que realizó la solicitud.</summary>
        <value>
          <see cref="T:System.Web.UI.Adapters.PageAdapter" /> que representa la página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.PageAdapter%2A> propiedad devuelve específico del <xref:System.Web.UI.Adapters.PageAdapter> objeto que modifica el comportamiento de la <xref:System.Web.UI.Page> objeto para el explorador solicitante.  
  
 Específico del <xref:System.Web.UI.Adapters.PageAdapter> objeto se determina mediante el examen de las características del entrante <xref:System.Web.UI.Page.Request%2A> objeto. Cuando se elige un adaptador para la solicitud, los eventos de ciclo de vida en el <xref:System.Web.UI.Adapters.PageAdapter> objeto invalidar los eventos correspondientes en el <xref:System.Web.UI.Page> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageStatePersister">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.PageStatePersister PageStatePersister { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.PageStatePersister PageStatePersister" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageStatePersister" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property PageStatePersister As PageStatePersister" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Web::UI::PageStatePersister ^ PageStatePersister { System::Web::UI::PageStatePersister ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageStatePersister : System.Web.UI.PageStatePersister" Usage="System.Web.UI.Page.PageStatePersister" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.PageStatePersister</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.UI.PageStatePersister" /> asociado a la página.</summary>
        <value>
          <see cref="T:System.Web.UI.PageStatePersister" /> asociado a la página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solicitudes y respuestas HTTP son inherentemente sin estado. Para mantener el estado entre las solicitudes HTTP, pueden almacenar páginas de servidor ASP.NET <xref:System.Web.UI.Page> estado. Este estado, denominado estado de vista, consta de página y configuración de control y los datos que hacen que la página y controles aparecen como si son los mismos que el usuario vio e interactúe con él en su última ida y vuelta a la página. Existen varios mecanismos para almacenar el estado de vista entre las sucesivas solicitudes a la misma página. El resumen <xref:System.Web.UI.PageStatePersister> clase representa la clase base para estos mecanismos de almacenamiento de información de estado.  
  
 Los desarrolladores de páginas normalmente no necesitará utilizar el <xref:System.Web.UI.Page.PageStatePersister%2A> propiedad. El <xref:System.Web.UI.Page.PageStatePersister%2A> propiedad la utilizan principalmente los desarrolladores de controles para extender la funcionalidad de la <xref:System.Web.UI.Page> clase.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="postEventArgumentID">
      <MemberSignature Language="C#" Value="public const string postEventArgumentID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventArgumentID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventArgumentID" />
      <MemberSignature Language="VB.NET" Value="Public Const postEventArgumentID As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ postEventArgumentID;" />
      <MemberSignature Language="F#" Value="val mutable postEventArgumentID : string" Usage="System.Web.UI.Page.postEventArgumentID" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cadena que define el campo oculto EVENTARGUMENT de la página representada.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="F:System.Web.UI.Page.postEventSourceID" />
      </Docs>
    </Member>
    <Member MemberName="postEventSourceID">
      <MemberSignature Language="C#" Value="public const string postEventSourceID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventSourceID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventSourceID" />
      <MemberSignature Language="VB.NET" Value="Public Const postEventSourceID As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ postEventSourceID;" />
      <MemberSignature Language="F#" Value="val mutable postEventSourceID : string" Usage="System.Web.UI.Page.postEventSourceID" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cadena que define el campo oculto EVENTTARGET de la página representada.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="F:System.Web.UI.Page.postEventArgumentID" />
      </Docs>
    </Member>
    <Member MemberName="PreInit">
      <MemberSignature Language="C#" Value="public event EventHandler PreInit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreInit" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreInit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreInit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreInit;" />
      <MemberSignature Language="F#" Value="member this.PreInit : EventHandler " Usage="member this.PreInit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce antes de la inicialización de la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento le permite comprobar las condiciones de la solicitud de página, por ejemplo, si la página se está cargando como respuesta a un postback. También puede comprobar los valores de propiedades de perfil.  
  
 El evento permite establecer los valores que se usan más adelante en el ciclo de vida de la página. Dinámicamente, puede establecer una página maestra o un tema para la página solicitada y crear controles dinámicos.  
  
 Para obtener más información acerca de cómo los <xref:System.Web.UI.Page.PreInit> evento encaja en el ciclo de vida ASP.NET, vea [información general sobre el ciclo de vida de página ASP.NET](http://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreLoad" />
      </Docs>
    </Member>
    <Member MemberName="PreLoad">
      <MemberSignature Language="C#" Value="public event EventHandler PreLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreLoad" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreLoad As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreLoad;" />
      <MemberSignature Language="F#" Value="member this.PreLoad : EventHandler " Usage="member this.PreLoad : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce antes del evento <see cref="E:System.Web.UI.Control.Load" /> de la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.PreLoad> evento se desencadena después de todo el procesamiento de datos de devolución de datos y antes de la <xref:System.Web.UI.Control.Load> eventos. Hay un segundo intento para cargar los datos de postback antes de la <xref:System.Web.UI.Page.OnLoadComplete%2A> eventos. Para obtener más información sobre cómo controlar eventos, vea [NIB: consumir eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreInit" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
      </Docs>
    </Member>
    <Member MemberName="PreRenderComplete">
      <MemberSignature Language="C#" Value="public event EventHandler PreRenderComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRenderComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreRenderComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreRenderComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreRenderComplete;" />
      <MemberSignature Language="F#" Value="member this.PreRenderComplete : EventHandler " Usage="member this.PreRenderComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce antes de que se represente el contenido de la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.PreRenderComplete> evento se desencadena una vez completada la fase de preprocesamiento del ciclo de vida de página. En esta etapa del ciclo de vida de página, se crean todos los controles de paginación necesaria se ha completado y está lista para representar a la salida de la página.  
  
 Este es el último evento que se genera antes de que se guarda el estado de vista.  
  
 Para obtener más información sobre cómo controlar eventos, vea [NIB: consumir eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreLoad" />
        <altmember cref="E:System.Web.UI.Page.PreInit" />
      </Docs>
    </Member>
    <Member MemberName="PreviousPage">
      <MemberSignature Language="C#" Value="public System.Web.UI.Page PreviousPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page PreviousPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PreviousPage" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousPage As Page" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Page ^ PreviousPage { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousPage : System.Web.UI.Page" Usage="System.Web.UI.Page.PreviousPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la página que transfirió el control a la página actual.</summary>
        <value>
          <see cref="T:System.Web.UI.Page" /> que representa la página que transfirió el control a la página actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se usa el <xref:System.Web.HttpServerUtility.Transfer%2A> método o uso entre páginas de registro para transferir el procesamiento de una página ASP.NET a otra, la página de origen contiene información de la solicitud que podría ser necesario para la página de destino. Puede usar el <xref:System.Web.UI.Page.PreviousPage%2A> propiedad para tener acceso a esa información.  
  
 Si se está representando la página actual como resultado de una solicitud directa (no una transferencia o publicación entre páginas desde otra página), el <xref:System.Web.UI.Page.PreviousPage%2A> contiene la propiedad `null`.  
  
   
  
## Examples  
 El ejemplo siguiente es de dos partes. La primera es una página ASP.NET que usa el <xref:System.Web.HttpServerUtility.Transfer%2A> método, que se exponen en el modelo de página como `Server.Transfer("path")`. La segunda parte es la página de destino, que usa el <xref:System.Web.UI.Page.PreviousPage%2A> propiedad va a obtener el título de la primera página.  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Main.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Main.aspx#1)]  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Notify.aspx#2)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Notify.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se permite al usuario actual tener acceso a la página anterior.  -o bien- El enrutamiento de ASP.NET está en uso y la dirección URL de la página anterior es una dirección URL enrutada. Cuando ASP.NET comprueba los permisos de acceso, supone que la dirección URL es una ruta de acceso real a un archivo. Dado que este no es el caso con una dirección URL enrutada, se produce un error en la comprobación.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessRequest">
      <MemberSignature Language="C#" Value="public virtual void ProcessRequest (System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessRequest(class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ProcessRequest (context As HttpContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessRequest(System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ProcessRequest : System.Web.HttpContext -&gt; unit&#xA;override this.ProcessRequest : System.Web.HttpContext -&gt; unit" Usage="page.ProcessRequest context" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.IHttpHandler.ProcessRequest(System.Web.HttpContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="context">Objeto <see cref="T:System.Web.HttpContext" /> que proporciona referencias a los objetos de servidor intrínsecos (por ejemplo, <see cref="P:System.Web.HttpContext.Request" />, <see cref="P:System.Web.HttpContext.Response" /> y <see cref="P:System.Web.HttpContext.Session" />) utilizados para atender las solicitudes HTTP.</param>
        <summary>Establece los objetos de servidor intrínsecos del objeto <see cref="T:System.Web.UI.Page" />, como las propiedades <see cref="P:System.Web.UI.Page.Context" />, <see cref="P:System.Web.UI.Page.Request" />, <see cref="P:System.Web.UI.Page.Response" /> y <see cref="P:System.Web.UI.Page.Application" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No debe llamar a este método.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Context" />
        <altmember cref="P:System.Web.UI.Page.Request" />
        <altmember cref="P:System.Web.UI.Page.Response" />
        <altmember cref="P:System.Web.UI.Page.Application" />
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(class System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RaisePostBackEvent(System.Web.UI.IPostBackEventHandler,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostBackEvent (sourceControl As IPostBackEventHandler, eventArgument As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostBackEvent(System::Web::UI::IPostBackEventHandler ^ sourceControl, System::String ^ eventArgument);" />
      <MemberSignature Language="F#" Value="abstract member RaisePostBackEvent : System.Web.UI.IPostBackEventHandler * string -&gt; unit&#xA;override this.RaisePostBackEvent : System.Web.UI.IPostBackEventHandler * string -&gt; unit" Usage="page.RaisePostBackEvent (sourceControl, eventArgument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceControl" Type="System.Web.UI.IPostBackEventHandler" />
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceControl">Control de servidor ASP.NET que provocó el postback. Este control debe implementar la interfaz <see cref="T:System.Web.UI.IPostBackEventHandler" />.</param>
        <param name="eventArgument">El argumento de postback.</param>
        <summary>Informa al control de servidor que originó el postback de que debería controlar un evento de postback entrante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page> de objeto llama el <xref:System.Web.UI.Page.RaisePostBackEvent%2A> método cuando se produce un postback. Esta llamada se produce en el ciclo de vida de página después de la notificación de cambios y carga pero antes del procesamiento previo.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Web.UI.Page.RaisePostBackEvent%2A> método para notificar a ASP.NET que se provoca un evento de devolución cuando un personalizado `userButton` se hace clic en el control de servidor.  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterArrayDeclaration : string * string -&gt; unit" Usage="page.RegisterArrayDeclaration (arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterArrayDeclaration(string arrayName, string arrayValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Nombre de la matriz en la que se va a declarar el valor.</param>
        <param name="arrayValue">Valor que se va a colocar en la matriz.</param>
        <summary>Declara un valor que se declara como matriz ECMAScript cuando se representa la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede utilizar controles basados en script para declarar a sí mismos dentro de una matriz para que una biblioteca de scripts de cliente puede trabajar con todos los controles del mismo tipo.  
  
 El método <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> está desusado. Use la <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> método en el <xref:System.Web.UI.ClientScriptManager> clase.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> método para declarar una matriz, `myArray`, que contiene tres objetos denominados `x`, `y`, y `z`. En el ejemplo se define y registra un script de inicio mediante el <xref:System.Web.UI.Page.RegisterStartupScript%2A> método. Cuando el ECMAScript `doClick` función se llama desde la página que contiene este código, la matriz y sus objetos se inicializan.  
  
 [!code-csharp[Page_RegisterArrayDeclaration#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/CS/page_registerarraydeclaration.cs.aspx#1)]
 [!code-vb[Page_RegisterArrayDeclaration#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/VB/page_registerarraydeclaration.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncTask">
      <MemberSignature Language="C#" Value="public void RegisterAsyncTask (System.Web.UI.PageAsyncTask task);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterAsyncTask(class System.Web.UI.PageAsyncTask task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAsyncTask (task As PageAsyncTask)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterAsyncTask(System::Web::UI::PageAsyncTask ^ task);" />
      <MemberSignature Language="F#" Value="member this.RegisterAsyncTask : System.Web.UI.PageAsyncTask -&gt; unit" Usage="page.RegisterAsyncTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Web.UI.PageAsyncTask" />
      </Parameters>
      <Docs>
        <param name="task">
          <see cref="T:System.Web.UI.PageAsyncTask" /> que define la tarea asincrónica.</param>
        <summary>Registra una nueva tarea asincrónica con la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Defina una tarea asincrónica mediante el <xref:System.Web.UI.PageAsyncTask> clase. Cuando se define la tarea, utilice el <xref:System.Web.UI.Page.RegisterAsyncTask%2A> método para registrar la tarea en la página. Después de registrar la tarea, invocar el <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> método para iniciar la tarea asincrónica.  
  
 El <xref:System.Web.UI.Page.RegisterAsyncTask%2A> método puede utilizarse con páginas sincrónicas y asincrónicas.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.Page.AsyncTimeout%2A> propiedad con el <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> y <xref:System.Web.UI.Page.RegisterAsyncTask%2A> métodos. Tenga en cuenta el uso de controladores de inicio, finalización y tiempo de espera. En el ejemplo, se introduce un retraso artificial para ilustrar la situación de una tarea asincrónica que supere el tiempo asignado para la tarea como se especifica en el <xref:System.Web.UI.Page.AsyncTimeout%2A> propiedad. En un escenario real, una tarea asincrónica podría usarse para realizar llamadas de base de datos o de generación de imágenes, por ejemplo, y el controlador de tiempo de espera proporciona degradación correcta si la tarea no se realiza en un período de tiempo especificado.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La tarea asincrónica es <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public virtual void RegisterClientScriptBlock (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterClientScriptBlock(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterClientScriptBlock (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterClientScriptBlock(System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="abstract member RegisterClientScriptBlock : string * string -&gt; unit&#xA;override this.RegisterClientScriptBlock : string * string -&gt; unit" Usage="page.RegisterClientScriptBlock (key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterClientScriptBlock(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Clave única que identifica un bloque de script.</param>
        <param name="script">Contenido del script que se envía al cliente.</param>
        <summary>Emite bloques de script de cliente para la respuesta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El script de cliente se emite justo después de la etiqueta de apertura del <xref:System.Web.UI.Page> del objeto `<form runat= server>` elemento. No olvide incluir la apertura y cierre `<script>` elementos alrededor de la secuencia de comandos bloquea la cadena especificada en el `script` parámetro.  
  
 Dado que este método usa una clave para identificar el bloque de script, el bloque de script no tiene que pueden emitirse para el flujo de salida cada vez que se solicita una instancia del control de servidor diferente. También se usa una clave reduce la probabilidad de los bloques de script controles diferentes interfieran entre sí.  
  
 Cualquier script de bloques con el mismo `key` los valores de parámetro se consideran duplicados.  
  
> [!NOTE]
>  No olvide incluir etiquetas de comentario HTML en torno a la secuencia de comandos para que no se representará si el explorador no admite secuencias de comandos.  
  
 El método <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> está desusado. Por ello, utilice el método <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> en la clase <xref:System.Web.UI.ClientScriptManager>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> método junto con el <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> método. Si el ECMAScript en el bloque de código de declaración aún no se ha registrado, según lo determinado por <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>, el <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> se realiza la llamada.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public virtual void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="abstract member RegisterHiddenField : string * string -&gt; unit&#xA;override this.RegisterHiddenField : string * string -&gt; unit" Usage="page.RegisterHiddenField (hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Nombre único del campo oculto que se va a representar.</param>
        <param name="hiddenFieldInitialValue">Valor que se va a emitir en el formulario oculto.</param>
        <summary>Permite que los controles de servidor registren automáticamente un campo oculto en el formulario. El campo se enviará al objeto <see cref="T:System.Web.UI.Page" /> cuando se represente el control de servidor <see cref="T:System.Web.UI.HtmlControls.HtmlForm" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.Web.UI.Page.RegisterHiddenField%2A> está desusado. Use la <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> método en el <xref:System.Web.UI.ClientScriptManager> clase.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.UI.Page.RegisterHiddenField%2A> método para ayudar a crear código ECMAScript que se pasa al explorador solicitante. El nombre del campo oculto se establece en `myHiddenField` y su valor se establece en "Bienvenido a Microsoft". El <xref:System.Web.UI.Page.RegisterStartupScript%2A> llamadas al método el `myHiddenField` valor cuando el usuario hace clic en un botón en la página.  
  
> [!IMPORTANT]
>  En este ejemplo tiene un campo oculto, que es una amenaza de seguridad. De forma predeterminada, debe validar el valor de un campo oculto como lo haría con el valor de un cuadro de texto. ASP.NET Web pages valida la entrada del usuario no incluye elementos HTML o script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterHiddenField#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#1)]
 [!code-vb[Page_RegisterHiddenField#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterOnSubmitStatement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterOnSubmitStatement (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterOnSubmitStatement : string * string -&gt; unit" Usage="page.RegisterOnSubmitStatement (key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterOnSubmitStatement(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Clave única que identifica un bloque de script.</param>
        <param name="script">Script de cliente que se va a enviar al cliente.</param>
        <summary>Permite que una página tenga acceso al evento <see langword="OnSubmit" /> del cliente. El script debe ser una llamada de función a código de cliente registrado en otra parte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> está desusado. Use la <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> método en el <xref:System.Web.UI.ClientScriptManager> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> para tener acceso a una secuencia de comandos que responda cuando se hace clic en un botón de envío del lado cliente. Cuando se produce este evento, el código ECMAScript registrado se ejecuta en el cliente.  
  
> [!IMPORTANT]
>  En este ejemplo tiene un campo oculto, que es una amenaza de seguridad. De forma predeterminada, debe validar el valor de un campo oculto como lo haría con el valor de un cuadro de texto. ASP.NET Web pages valida la entrada del usuario no incluye elementos HTML o script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterHiddenField#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#2)]
 [!code-vb[Page_RegisterHiddenField#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void RegisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.RegisterRequiresControlState : System.Web.UI.Control -&gt; unit" Usage="page.RegisterRequiresControlState control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Control que se va a registrar.</param>
        <summary>Registra un control como un control cuyo estado se debe conservar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles de servidor personalizados que utilizan el estado de control deben llamar a la <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> método en cada solicitud porque el registro del estado de control de no se realiza a través de solicitud a petición durante un evento de postback. Se recomienda que el registro se realizan en el <xref:System.Web.UI.Control.Init> eventos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra una llamada de control de servidor personalizado el <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> método.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El control que se va a registrar es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Solamente se puede llamar al método <see cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" /> antes de o durante el evento <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
        <altmember cref="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresPostBack">
      <MemberSignature Language="C#" Value="public void RegisterRequiresPostBack (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresPostBack(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresPostBack(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.RegisterRequiresPostBack : System.Web.UI.Control -&gt; unit" Usage="page.RegisterRequiresPostBack control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Control que se va a registrar.</param>
        <summary>Registra un control como un control que requiere el control de postback cuando la página se devuelva al servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe implementar el control que se registrarán los <xref:System.Web.UI.IPostBackDataHandler> interfaz o un <xref:System.Web.HttpException> se genera. Cuando se implementa mediante un control, el <xref:System.Web.UI.IPostBackDataHandler> permite de interfaz de control de los datos devueltos y generación de cualquier publicación a eventos de datos modificados. Para obtener más información sobre el modelo de evento de control de servidor, consulte [modelo de eventos de Control de servidor ASP.NET Web Forms](http://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3).  
  
 Registrar controles con la página antes o la `Page_PreRender` eventos del ciclo de vida de página.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.UI.Page.RegisterRequiresPostBack%2A> método para exigir un control de cuadro de texto, `myTextBox`, para que se envíe de nuevo antes de que puede ejecutar cualquier código asociado con el cuadro de texto. <xref:System.Web.UI.WebControls.TextBox> los controles implementan el <xref:System.Web.UI.IPostBackDataHandler> interfaz.  
  
> [!IMPORTANT]
>  Este ejemplo tiene un cuadro de texto que acepta datos proporcionados por el usuario, lo que puede suponer una amenaza para la seguridad. De forma predeterminada, ASP.NET Web Pages valida que los datos proporcionados por el usuario no incluyen elementos HTML ni de script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterRequiresPostBack#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/CS/page_registerrequirespostback.cs.aspx#1)]
 [!code-vb[Page_RegisterRequiresPostBack#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/VB/page_registerrequirespostback.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El control que debe registrarse no implementa la interfaz <see cref="T:System.Web.UI.IPostBackDataHandler" />.</exception>
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresRaiseEvent">
      <MemberSignature Language="C#" Value="public virtual void RegisterRequiresRaiseEvent (System.Web.UI.IPostBackEventHandler control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterRequiresRaiseEvent(class System.Web.UI.IPostBackEventHandler control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresRaiseEvent(System.Web.UI.IPostBackEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterRequiresRaiseEvent (control As IPostBackEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterRequiresRaiseEvent(System::Web::UI::IPostBackEventHandler ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RegisterRequiresRaiseEvent : System.Web.UI.IPostBackEventHandler -&gt; unit&#xA;override this.RegisterRequiresRaiseEvent : System.Web.UI.IPostBackEventHandler -&gt; unit" Usage="page.RegisterRequiresRaiseEvent control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.IPostBackEventHandler" />
      </Parameters>
      <Docs>
        <param name="control">Control que se va a registrar.</param>
        <summary>Registra un control de servidor ASP.NET como control que requiere que se provoque un evento cuando se procese en el objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Control de solo servidor se puede registrar por solicitud de página. El <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A> debe usarse cuando el control no incluye su identificador en el formulario registrar datos de control. Además, debe implementar el control que está registrado el <xref:System.Web.UI.IPostBackEventHandler> interfaz.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A> método para registrar un <xref:System.Web.UI.WebControls.Button> Web control de servidor como la necesidad de que se produzca un evento. Después de haber registrado el primer <xref:System.Web.UI.WebControls.Button> control, puede hacer que el segundo <xref:System.Web.UI.WebControls.Button> declarado en el código para registrar los resultados del primer botón de control, haga clic en el evento a la página.  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresViewStateEncryption">
      <MemberSignature Language="C#" Value="public void RegisterRequiresViewStateEncryption ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresViewStateEncryption() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterRequiresViewStateEncryption ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresViewStateEncryption();" />
      <MemberSignature Language="F#" Value="member this.RegisterRequiresViewStateEncryption : unit -&gt; unit" Usage="page.RegisterRequiresViewStateEncryption " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Registra un control con la página como un control que requiere el cifrado del estado de vista.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si está desarrollando un control personalizado que se encarga de información potencialmente confidencial, llame a la <xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A> método para registrar el control con la página y asegúrese de que el estado de vista para el control está cifrado.  
  
 El estado de la página entera se cifrarán si el <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A> está establecido en <xref:System.Web.UI.ViewStateEncryptionMode.Auto> o <xref:System.Web.UI.ViewStateEncryptionMode.Always>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo establecer el modo de cifrado del estado de vista para un <xref:System.Web.UI.Page> objeto y solicitará cifrado del estado de vista a través de <xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A>. En este ejemplo, el estado de vista se cifrarán cuando se recupera información del cliente de una base de datos.  
  
 [!code-aspx-csharp[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/CS/encryptViewState.cs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/VB/encryptViewState.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Debe llamarse al método <see cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" /> antes o durante la fase <see langword="PreRender" /> de página del ciclo de vida de la página.</exception>
        <altmember cref="P:System.Web.UI.Page.ViewStateEncryptionMode" />
        <altmember cref="T:System.Web.UI.WebControls.GridView" />
        <altmember cref="T:System.Web.UI.WebControls.DetailsView" />
        <altmember cref="T:System.Web.UI.WebControls.FormView" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public virtual void RegisterStartupScript (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterStartupScript(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterStartupScript (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterStartupScript(System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="abstract member RegisterStartupScript : string * string -&gt; unit&#xA;override this.RegisterStartupScript : string * string -&gt; unit" Usage="page.RegisterStartupScript (key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterStartupScript(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Clave única que identifica un bloque de script.</param>
        <param name="script">Contenido del script que se enviará al cliente.</param>
        <summary>Emite un bloque de script de cliente en la respuesta a la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Similar a la <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> método, el <xref:System.Web.UI.Page.RegisterStartupScript%2A> método emite el script justo antes de la etiqueta de cierre de la <xref:System.Web.UI.Page> del objeto `<form runat= server>` elemento. No olvide incluir la apertura y cierre `<script>` elementos alrededor de la secuencia de comandos bloquea la cadena especificada en el `script` parámetro.  
  
 Dado que este método usa una clave para identificar el bloque de script, el bloque de script no tiene que emitirse en el flujo de salida cada vez que se solicita una instancia del control de servidor diferente  
  
 Cualquier script de bloques con el mismo `key` los valores de parámetro se consideran duplicados.  
  
> [!NOTE]
>  No olvide incluir etiquetas de comentario HTML en torno a la secuencia de comandos para que no se representará si el explorador no admite secuencias de comandos.  
  
 El método <xref:System.Web.UI.Page.RegisterStartupScript%2A> está desusado. Por ello, utilice el método <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> en la clase <xref:System.Web.UI.ClientScriptManager>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.Page.RegisterStartupScript%2A> método junto con el <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> método. Si el ECMAScript escrito en el bloque de código de declaración aún no se ha registrado, según lo determinado por la <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> método, un <xref:System.Web.UI.Page.RegisterStartupScript%2A> se realiza la llamada.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterViewStateHandler">
      <MemberSignature Language="C#" Value="public void RegisterViewStateHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterViewStateHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterViewStateHandler" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterViewStateHandler ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterViewStateHandler();" />
      <MemberSignature Language="F#" Value="member this.RegisterViewStateHandler : unit -&gt; unit" Usage="page.RegisterViewStateHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hace que se almacene el estado de vista de página, si se le llama.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.RegisterViewStateHandler%2A> método se llama automáticamente a través de la <xref:System.Web.UI.HtmlControls.HtmlForm> control de servidor. Si no se invoca este método, no se conservará el estado de vista de página.  
  
> [!NOTE]
>  Normalmente, sólo el <xref:System.Web.UI.HtmlControls.HtmlForm> control de servidor para la página llama a este método.  
  
   
  
## Examples  
 [!code-csharp[Page_RegisterViewStateHandler#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterViewStateHandler/CS/page_registerviewstatehandler.cs#1)]
 [!code-vb[Page_RegisterViewStateHandler#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterViewStateHandler/VB/page_registerviewstatehandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="page.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> que recibe el contenido de la página.</param>
        <summary>Inicializa el objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> y llama a los controles secundarios del <see cref="T:System.Web.UI.Page" /> que se va a representar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.Render%2A> método es responsable de crear el texto y el marcado que se envía al explorador del cliente. El valor predeterminado <xref:System.Web.UI.Page.Render%2A> llamadas al método <xref:System.Web.UI.Control.RenderChildren%2A> para escribir el texto y el marcado para los controles contenidos en la página.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.UI.Page.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.HttpRequest" /> para la página solicitada.</summary>
        <value>Objeto <see cref="T:System.Web.HttpRequest" /> actual asociado a la página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Objeto <xref:System.Web.HttpRequest> que contiene información sobre la solicitud HTTP actual.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo obtener el <xref:System.Web.HttpRequest.Headers%2A> colección desde la <xref:System.Web.HttpRequest> objeto y escribirla en una página ASP.NET.  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Se produce cuando el objeto <see cref="T:System.Web.HttpRequest" /> no está disponible.</exception>
        <altmember cref="T:System.Web.HttpException" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="RequiresControlState">
      <MemberSignature Language="C#" Value="public bool RequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.RequiresControlState : System.Web.UI.Control -&gt; bool" Usage="page.RequiresControlState control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.Control" /> para el que se comprobará si requiere el estado de control.</param>
        <summary>Determina si el objeto <see cref="T:System.Web.UI.Control" /> especificado se registra para participar en la administración del estado de control.</summary>
        <returns>Es <see langword="true" /> si el <see cref="T:System.Web.UI.Control" /> especificado requiere el estado de control; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de control es un objeto formado por datos críticos de estado de vista que los controles de servidor Web tienen que funcionar; que está contenida en un objeto independiente del estado de vista normal.  
  
 Controles personalizados mediante el estado de control deben llamar a la <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> método antes de guardar el estado del control. Use el <xref:System.Web.UI.Page.RequiresControlState%2A> método para comprobar los controles que están registrados en la página requieren el estado del control.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
        <altmember cref="P:System.Web.UI.PageStatePersister.ControlState" />
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.UI.Page.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.HttpResponse" /> asociado al objeto <see cref="T:System.Web.UI.Page" />. Este objeto permite enviar datos de respuesta HTTP a un cliente y contiene información sobre esa respuesta.</summary>
        <value>Objeto <see cref="T:System.Web.HttpResponse" /> actual asociado a la página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo crear una cookie y agregarlo a la salida de la página HTTP mediante el uso de la <xref:System.Web.HttpResponse> objeto.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El objeto <see cref="T:System.Web.HttpResponse" /> no está disponible.</exception>
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="ResponseEncoding">
      <MemberSignature Language="C#" Value="public string ResponseEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ResponseEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ResponseEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ResponseEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseEncoding : string with get, set" Usage="System.Web.UI.Page.ResponseEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece el lenguaje de codificación del objeto <see cref="T:System.Web.HttpResponse" /> actual.</summary>
        <value>Cadena que contiene el lenguaje de codificación del objeto <see cref="T:System.Web.HttpResponse" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la mayoría de los casos, no establezca esta propiedad en el código. Establecer el `ResponseEncoding` para el valor que desea usar la directiva en el archivo .aspx de atributo. Cuando se solicita la página, la clase generada dinámicamente establece la propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData RouteData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteData RouteData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.RouteData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RouteData As RouteData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RouteData ^ RouteData { System::Web::Routing::RouteData ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RouteData : System.Web.Routing.RouteData" Usage="System.Web.UI.Page.RouteData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el valor de <see cref="P:System.Web.Routing.RequestContext.RouteData" /> de la instancia actual de <see cref="T:System.Web.Routing.RequestContext" />.</summary>
        <value>Valor de <see cref="P:System.Web.Routing.RequestContext.RouteData" /> de la instancia actual de <see cref="T:System.Web.Routing.RequestContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si una página se ejecuta en respuesta a una solicitud realizada a través de enrutamiento de ASP.NET, esta propiedad proporciona acceso a los valores de parámetro de dirección URL que se pasaron como datos de ruta. Si la página se ejecuta en respuesta a una dirección URL física en lugar de una dirección URL de ruta, esta propiedad es `null`. El ejemplo siguiente muestra cómo extraer el valor de un parámetro de dirección URL que se denomina `year`.  
  
```vb  
Dim year As Integer = Convert.ToInt32(Page.RouteData.Values("year"))  
```  
  
```csharp  
int year = Convert.ToInt32(Page.RouteData.Values["year"])  
```  
  
 Si la ruta se define mediante el patrón de URL `{locale}/{year}` para el dominio `contoso.com`, y si la dirección URL solicitada es `contoso.com/US/2010`, `year` contendrá el valor "2010" cuando se ejecuta este código.  
  
 Para obtener más información sobre el enrutamiento de ASP.NET, vea [enrutamiento de ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.Routing.RequestContext.RouteData" />
      </Docs>
    </Member>
    <Member MemberName="SavePageStateToPersistenceMedium">
      <MemberSignature Language="C#" Value="protected virtual void SavePageStateToPersistenceMedium (object viewState);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SavePageStateToPersistenceMedium(object viewState) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SavePageStateToPersistenceMedium (viewState As Object)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SavePageStateToPersistenceMedium(System::Object ^ viewState);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member SavePageStateToPersistenceMedium : obj -&gt; unit&#xA;override this.SavePageStateToPersistenceMedium : obj -&gt; unit" Usage="page.SavePageStateToPersistenceMedium viewState" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="protected internal virtual void SavePageStateToPersistenceMedium (object state);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SavePageStateToPersistenceMedium(object state) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub SavePageStateToPersistenceMedium (state As Object)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void SavePageStateToPersistenceMedium(System::Object ^ state);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="F#" Value="abstract member SavePageStateToPersistenceMedium : obj -&gt; unit&#xA;override this.SavePageStateToPersistenceMedium : obj -&gt; unit" Usage="page.SavePageStateToPersistenceMedium state" FrameworkAlternate="netframework-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="viewState" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="state" Type="System.Object" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Object" /> en el que se almacena la información de estado de vista.</param>
        <param name="viewState">To be added.</param>
        <summary>Guarda la información de estado de vista y de estado de control de la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> método usa la <xref:System.Web.UI.PageStatePersister.Save%2A> método de la <xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType> hacen referencia al objeto la <xref:System.Web.UI.Page.PageStatePersister%2A> propiedad para almacenar información de estado de vista y el estado de control de la página.  
  
 ASP.NET incluye dos descendientes de los <xref:System.Web.UI.PageStatePersister> (clase), el <xref:System.Web.UI.HiddenFieldPageStatePersister> clase que guarda la información de estado en un campo oculto que se incluye en la página ASP.NET, y el <xref:System.Web.UI.SessionPageStatePersister> clase que guarda el estado en el <xref:System.Web.UI.Page.Session%2A> objeto asociado con el solicitud. Tenga en cuenta que cuando se usa el <xref:System.Web.UI.SessionPageStatePersister> clase aún se representa el campo oculto VIEWSTATE puesto que se usa para determinar la devolución de datos.  
  
 Para guardar el estado en la ubicación de su elección, debe crear un nuevo descendiente de la <xref:System.Web.UI.PageStatePersister> clase que guarda y carga el estado en el medio de persistencia que prefiera. Para obtener un ejemplo de creación de un nuevo <xref:System.Web.UI.PageStatePersister> de objetos, consulte el <xref:System.Web.UI.PageStatePersister> clase.  
  
 Si usa .NET Framework versión 1.0 o 1.1, invalide este método si desea guardar el <xref:System.Web.UI.Page> estado en algo distinto de un campo oculto. Si decide hacerlo, también debe invalidar el <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
        <altmember cref="P:System.Web.UI.Page.PageStatePersister" />
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="SaveStateComplete">
      <MemberSignature Language="C#" Value="public event EventHandler SaveStateComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SaveStateComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.SaveStateComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SaveStateComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SaveStateComplete;" />
      <MemberSignature Language="F#" Value="member this.SaveStateComplete : EventHandler " Usage="member this.SaveStateComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce después de que la página ha terminado de guardar toda la información de estado de vista y estado de control para la página y los controles de la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Información de estado de los controles en la página Web se guarda después de la <xref:System.Web.UI.Page.PreRenderComplete> eventos. El <xref:System.Web.UI.Page.SaveStateComplete> se genera el evento después del estado de vista y el estado de control de la página y controles de la página se guardan en el medio de persistencia.  
  
 Se trata del último evento que se genera antes de la página se representa en el explorador solicitante.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.InitComplete" />
        <altmember cref="E:System.Web.UI.Page.LoadComplete" />
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.UI.Page.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see langword="Server" />, que es una instancia de la clase <see cref="T:System.Web.HttpServerUtility" />.</summary>
        <value>Objeto <see langword="Server" /> actual asociado a la página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad proporciona acceso a los usados con frecuencia <xref:System.Web.HttpServerUtility.HtmlEncode%2A> y <xref:System.Web.HttpServerUtility.MapPath%2A> métodos, entre otros.  
  
   
  
## Examples  
 El código siguiente muestra cómo obtener acceso a información de error desde el servidor mediante el uso de la `Server` objeto. En concreto, el ejemplo obtiene la dirección URL solicitada desde el `Request` (objeto), el error más reciente desde el `Server` objeto (mediante el <xref:System.Web.HttpServerUtility.GetLastError%2A> método) y los convierte en cadenas que se pueden mostrar por el cliente. Una vez el `message` variable se escribe en el cliente, el error se elimina mediante el <xref:System.Web.HttpServerUtility.ClearError%2A> método.  
  
 [!code-csharp[System.Web.UI.Page_Error method#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Error method/CS/sourcecs.aspx#1)]
 [!code-vb[System.Web.UI.Page_Error method#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Error method/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpServerUtility" />
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public virtual System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Session" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.UI.Page.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see langword="Session" /> actual proporcionado por ASP.NET.</summary>
        <value>Datos de estado de la sesión actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad proporciona información acerca de la sesión de la solicitud actual. Un `Session` objeto se mantiene para cada usuario que solicita una página o un documento desde una aplicación ASP.NET. Las variables se almacenan en la `Session` objeto no se descartan cuando el usuario mueve páginas en la aplicación; en su lugar, estas variables persisten siempre y cuando el usuario tiene acceso a las páginas de la aplicación. Para obtener más información sobre el estado de sesión, vea [información general sobre el estado de sesión ASP.NET](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un `GetStyle` función que recupera una clave almacenada en el estado de sesión de la página de formularios Web Forms y convierte su valor en una cadena.  
  
 [!code-csharp[Page.Session_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Session_Samples1/CS/sessioncs.aspx#1)]
 [!code-vb[Page.Session_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Session_Samples1/VB/sessionvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Se produce cuando la información de sesión se establece en <see langword="null" />.</exception>
        <altmember cref="T:System.Web.HttpException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetFocus">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece el foco del explorador en el control especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFocus (clientID As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::String ^ clientID);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : string -&gt; unit" Usage="page.SetFocus clientID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">Id. del control en el que se establece el foco.</param>
        <summary>Establece el foco del explorador en el control con el identificador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Web.UI.Page.SetFocus%2A> el control activo en la página Web muestra el Explorador de la cadena de método para que el control con el identificador especificado. El <xref:System.Web.UI.Page.SetFocus%2A> método debe llamarse antes de la página está preparada para la representación al cliente en el <xref:System.Web.UI.Control.PreRender> eventos.  
  
> [!NOTE]
>  El <xref:System.Web.UI.Page.SetFocus%2A> método funcionará sólo en exploradores que admiten ECMAScript versión 1.3 o posterior.  
  
   
  
## Examples  
 El ejemplo de código siguiente establece el foco en el segundo cuadro de texto en una página Web.  
  
> [!IMPORTANT]
>  Este ejemplo tiene un cuadro de texto que acepta datos proporcionados por el usuario, lo que puede suponer una amenaza para la seguridad. De forma predeterminada, ASP.NET Web Pages valida que los datos proporcionados por el usuario no incluyen elementos HTML ni de script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageSetFocus#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbyidcs.aspx#1)]
 [!code-aspx-vb[PageSetFocus#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbyidvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="clientID" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Cuando el control no forma parte de una página de formularios Web Forms, se llama al método <see cref="M:System.Web.UI.Page.SetFocus(System.String)" />.  \- o bien - Se ha llamado a <see cref="M:System.Web.UI.Page.SetFocus(System.String)" /> después del evento <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : System.Web.UI.Control -&gt; unit" Usage="page.SetFocus control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Control que recibirá el foco.</param>
        <summary>Establece el foco del explorador en el control especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Web.UI.Page.SetFocus%2A> método para hacer el control especificado en el control activo en la página Web muestra el explorador. El <xref:System.Web.UI.Page.SetFocus%2A> método debe llamarse antes de la página está preparada para la representación al cliente en el <xref:System.Web.UI.Control.PreRender> eventos.  
  
> [!NOTE]
>  El <xref:System.Web.UI.Page.SetFocus%2A> método funcionará sólo en exploradores que admiten ECMAScript versión 1.3 o posterior.  
  
   
  
## Examples  
 El ejemplo de código siguiente establece el foco en el segundo cuadro de texto en una página Web.  
  
> [!IMPORTANT]
>  Este ejemplo tiene un cuadro de texto que acepta datos proporcionados por el usuario, lo que puede suponer una amenaza para la seguridad. De forma predeterminada, ASP.NET Web Pages valida que los datos proporcionados por el usuario no incluyen elementos HTML ni de script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageSetFocus#2](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbycontrolcs.aspx#2)]
 [!code-aspx-vb[PageSetFocus#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbycontrolvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Cuando el control no forma parte de una página de formularios Web Forms, se llama al método <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />.  \- o bien - Se ha llamado a <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" /> después del evento <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipFormActionValidation">
      <MemberSignature Language="C#" Value="public bool SkipFormActionValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipFormActionValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SkipFormActionValidation" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipFormActionValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipFormActionValidation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipFormActionValidation : bool with get, set" Usage="System.Web.UI.Page.SkipFormActionValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el valor de la cadena de consulta se validan.</summary>
        <value>
          <see langword="true" /> si se debe omitir la validación de la cadena de consulta (la cadena de consulta no debe validarse); si no, <see langword="false" /> si la validación de la cadena de consulta se realiza de la forma normal. El valor predeterminado es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SmartNavigation">
      <MemberSignature Language="C#" Value="public bool SmartNavigation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SmartNavigation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SmartNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Property SmartNavigation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SmartNavigation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SmartNavigation : bool with get, set" Usage="System.Web.UI.Page.SmartNavigation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is Page.SetFocus and Page.MaintainScrollPositionOnPostBack. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si está habilitada la navegación inteligente. Esta propiedad está desusada.</summary>
        <value>Es <see langword="true" /> si la animación inteligente está habilitada; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la mayoría de los casos, no establezca esta propiedad en el código. Establecer el `SmartNavigation` atributo `true` en la directiva en el archivo de aspx. Cuando se solicita la página, la clase generada dinámicamente establece esta propiedad.  
  
> [!NOTE]
>  En ASP.NET 2.0, el <xref:System.Web.UI.Page.SmartNavigation%2A> propiedad está desusada. Use la <xref:System.Web.UI.Page.SetFocus%2A> método y el <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> propiedad en su lugar.  
  
 Cuando se solicita una página mediante el explorador Microsoft Internet Explorer 5.5 o versiones posteriores, navegación inteligente mejora la experiencia del usuario de la página realizando lo siguiente:  
  
-   Eliminar el parpadeo originado por la navegación.  
  
-   Conservar la posición de desplazamiento al pasar de página a página.  
  
-   Mantener el foco del elemento entre navegaciones.  
  
-   Conserva solo el último estado de página en el historial del explorador.  
  
 Navegación inteligente se usa mejor con páginas ASP.NET que requieren frecuentes devoluciones de datos, pero con contenido visual que no cambia drásticamente la devolución. Considere detenidamente al decidir si desea establecer esta propiedad en `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.Page.SetFocus" />
        <altmember cref="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      </Docs>
    </Member>
    <Member MemberName="StyleSheetTheme">
      <MemberSignature Language="C#" Value="public virtual string StyleSheetTheme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StyleSheetTheme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.StyleSheetTheme" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property StyleSheetTheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StyleSheetTheme { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StyleSheetTheme : string with get, set" Usage="System.Web.UI.Page.StyleSheetTheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del tema que se aplica a la página al comienzo del ciclo de vida de la página.</summary>
        <value>El nombre del tema que se aplica a la página al comienzo del ciclo de vida de la página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad no hace referencia directamente a una hoja de estilos en cascada (CSS). La propiedad contiene el nombre de un tema ASP.NET, que puede incluir archivos CSS dentro de él.  
  
 El <xref:System.Web.UI.Page.StyleSheetTheme%2A> propiedad especifica el nombre de un tema que se aplica a una página al principio en el ciclo de vida de la página, mientras que el <xref:System.Web.UI.Page.Theme%2A> propiedad especifica el nombre de un tema que se aplica a una página más adelante en el ciclo de vida de la página. Esto significa que la configuración en la página tiene prioridad sobre la configuración de tema de la hoja de estilo. Para obtener más información, consulte [ASP.NET temas y máscaras](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 Normalmente, un valor para esta propiedad se establece en la directiva de página o invalidando la propiedad. Para obtener información, vea los temas siguientes:  
  
-   [Cómo: aplicar temas de ASP.NET](http://msdn.microsoft.com/library/f9d72364-4d77-4b73-84be-7630dc63e0fe)  
  
-   [Cómo: aplicar temas de ASP.NET mediante programación](http://msdn.microsoft.com/library/02eed7c3-01e8-4e20-8358-df47dbd4f148))  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se intentó establecer la propiedad <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> después de que se hubiera llamado al método <see cref="M:System.Web.UI.Page.FrameworkInitialize" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> se ha establecido en un nombre de tema no válido. Esta excepción se produce cuando se llama al método <see cref="M:System.Web.UI.Page.FrameworkInitialize" />, no por el establecedor de propiedad.</exception>
        <altmember cref="P:System.Web.UI.Page.Theme" />
      </Docs>
    </Member>
    <Member MemberName="Theme">
      <MemberSignature Language="C#" Value="public virtual string Theme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Theme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Theme" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Theme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Theme { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Theme : string with get, set" Usage="System.Web.UI.Page.Theme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del tema de la página.</summary>
        <value>Nombre del tema de la página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.Theme%2A> propiedad establece el nombre del tema utilizado para la página. Si desea que la configuración de la página tendrá prioridad sobre la configuración en el tema, utilice el <xref:System.Web.UI.Page.StyleSheetTheme%2A> propiedad. Para obtener más información, consulte [ASP.NET temas y máscaras](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 El <xref:System.Web.UI.Page.Theme%2A> propiedad debe establecerse antes de la <xref:System.Web.UI.Page.PreInit> eventos; la configuración de la <xref:System.Web.UI.Page.Theme%2A> propiedad después de la <xref:System.Web.UI.Page.PreInit> hará que el evento un <xref:System.InvalidOperationException> excepción.  
  
 El tema especificado debe existir como una aplicación o un tema global. Si no existe el tema, una <xref:System.Web.HttpException> es una excepción.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Web.UI.Page.Theme%2A> pasa de la propiedad a un nombre de la cadena de consulta.  
  
 [!code-csharp[PageTheme#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageTheme/CS/pagethemecs.aspx#1)]
 [!code-vb[PageTheme#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageTheme/VB/pagethemevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se ha intentado establecer <see cref="P:System.Web.UI.Page.Theme" /> una vez provocado el evento <see cref="E:System.Web.UI.Page.PreInit" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.Theme" /> se ha establecido en un nombre de tema no válido.</exception>
        <altmember cref="P:System.Web.UI.Page.StyleSheetTheme" />
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Web.UI.Page.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el título de la página.</summary>
        <value>Título de la página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Web.UI.Page.Title%2A> propiedad para establecer el título de página en el encabezado HTML enviado al explorador solicitante.  
  
> [!NOTE]
>  La página debe contener un `head` elemento que tiene el atributo `runat="server"`, en caso contrario, no se representará el título.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Web.UI.Page.Title" /> requiere un control de encabezado en la página.</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlTitle" />
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.UI.Page.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.TraceContext" /> de la solicitud web actual.</summary>
        <value>Datos procedentes del objeto <see cref="T:System.Web.TraceContext" /> para la solicitud Web actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El seguimiento se realiza un seguimiento y presenta los detalles de ejecución sobre una solicitud Web. Para que los datos de seguimiento esté visible en una página representada, debe habilitar el seguimiento en el nivel de página o aplicación.  
  
 Seguimiento en una página está deshabilitado de forma predeterminada. Para habilitar el seguimiento para una página, utilice la directiva `<% @ Page trace="true" %>`. Para habilitar el seguimiento para una aplicación completa, debe habilitarla en el archivo de configuración de la aplicación, Web.config, que reside en el directorio raíz de la aplicación. Para obtener más información, consulte [información general del seguimiento ASP.NET](http://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo tener acceso el <xref:System.Web.TraceContext.IsEnabled%2A?displayProperty=nameWithType> propiedad y el <xref:System.Web.TraceContext.Write%2A?displayProperty=nameWithType> método a través de la <xref:System.Web.UI.Page.Trace%2A> propiedad. Este código llama a la <xref:System.Diagnostics.Trace.Write%2A> método únicamente cuando el seguimiento está habilitado para el <xref:System.Web.UI.Page> objeto. Si no está habilitado, no se ejecutará este código, lo que puede ayudar a reducir la carga de la aplicación.  
  
 [!code-csharp[System.Web.UI.Page.Trace#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Trace/CS/trace1cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Trace#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Trace/VB/trace1vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TraceEnabled">
      <MemberSignature Language="C#" Value="public bool TraceEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TraceEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property TraceEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TraceEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TraceEnabled : bool with get, set" Usage="System.Web.UI.Page.TraceEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece un valor que indica si se habilita la traza para el objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <value>Es <see langword="true" /> si se habilita la traza en la página; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la mayoría de los casos, no establezca esta propiedad en el código. Establecer el `Trace` atributo `true` en la directiva en el archivo de aspx. Cuando se solicita la página, la clase generada dinámicamente establece la propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Trace" />
        <altmember cref="P:System.Web.UI.Page.TraceModeValue" />
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TraceModeValue">
      <MemberSignature Language="C#" Value="public System.Web.TraceMode TraceModeValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.TraceMode TraceModeValue" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceModeValue" />
      <MemberSignature Language="VB.NET" Value="Public Property TraceModeValue As TraceMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceMode TraceModeValue { System::Web::TraceMode get(); void set(System::Web::TraceMode value); };" />
      <MemberSignature Language="F#" Value="member this.TraceModeValue : System.Web.TraceMode with get, set" Usage="System.Web.UI.Page.TraceModeValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece el modo en que se muestran las instrucciones de seguimiento en la página.</summary>
        <value>Uno de los miembros de la enumeración <see cref="T:System.Web.TraceMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la mayoría de los casos, no establezca esta propiedad en el código. Establecer el `TraceMode` atributo en la directiva en el archivo de aspx. Cuando se solicita la página, la clase generada dinámicamente establece la propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Trace" />
        <altmember cref="P:System.Web.UI.Page.TraceEnabled" />
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TransactionMode">
      <MemberSignature Language="C#" Value="protected int TransactionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TransactionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TransactionMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property TransactionMode As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int TransactionMode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionMode : int with get, set" Usage="System.Web.UI.Page.TransactionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece el nivel de compatibilidad con transacciones para la página.</summary>
        <value>Entero que representa uno de los miembros de la enumeración <see cref="T:System.EnterpriseServices.TransactionOption" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la mayoría de los casos, no establezca esta propiedad en el código. Establecer el `Transaction` atributo en la directiva en el archivo de aspx. Cuando se solicita la página, la clase generada dinámicamente establece la propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryUpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Actualiza la instancia de modelo especificada con los valores de un proveedor de valores.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para una serie de tutoriales sobre el uso de enlace de modelos con formularios Web Forms, consulte [enlace de modelos y formularios Web Forms](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUpdateModel(Of TModel As Class) (model As TModel) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual bool TryUpdateModel(TModel model);" />
      <MemberSignature Language="F#" Value="abstract member TryUpdateModel : 'Model -&gt; bool (requires 'Model : null)&#xA;override this.TryUpdateModel : 'Model -&gt; bool (requires 'Model : null)" Usage="page.TryUpdateModel model" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Tipo del modelo.</typeparam>
        <param name="model">Modelo.</param>
        <summary>Actualiza la instancia de modelo especificada mediante los valores del control enlazado a datos.</summary>
        <returns>Es <see langword="true" /> si el enlace de modelo se realiza correctamente; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método solo debe llamarse desde un método que se especifica mediante un control enlazado a datos `UpdateMethod` o `InsertMethod` propiedad.  
  
 Para una serie de tutoriales sobre el uso de enlace de modelos con formularios Web Forms, consulte [enlace de modelos y formularios Web Forms](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUpdateModel(Of TModel As Class) (model As TModel, valueProvider As IValueProvider) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual bool TryUpdateModel(TModel model, System::Web::ModelBinding::IValueProvider ^ valueProvider);" />
      <MemberSignature Language="F#" Value="abstract member TryUpdateModel : 'Model * System.Web.ModelBinding.IValueProvider -&gt; bool (requires 'Model : null)&#xA;override this.TryUpdateModel : 'Model * System.Web.ModelBinding.IValueProvider -&gt; bool (requires 'Model : null)" Usage="page.TryUpdateModel (model, valueProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Tipo del modelo.</typeparam>
        <param name="model">Modelo.</param>
        <param name="valueProvider">Proveedor de valores.</param>
        <summary>Actualiza el modelo especificada con los valores del proveedor de valores especificado.</summary>
        <returns>Es <see langword="true" /> si el enlace de modelo se realiza correctamente; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para una serie de tutoriales sobre el uso de enlace de modelos con formularios Web Forms, consulte [enlace de modelos y formularios Web Forms](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UICulture">
      <MemberSignature Language="C#" Value="public string UICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UICulture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property UICulture As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UICulture { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UICulture : string with get, set" Usage="System.Web.UI.Page.UICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece el id. de interfaz de usuario (UI) para el objeto <see cref="T:System.Threading.Thread" /> asociado a la página.</summary>
        <value>Id. de interfaz de usuario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es un acceso directo para la <xref:System.Threading.Thread.CurrentThread%2A> propiedad. La referencia cultural es una propiedad del subproceso en ejecución  
  
 Establecer el `UICulture` atributo en la directiva en el archivo de aspx. Cuando se solicita la página, la clase generada dinámicamente establece el valor de esta propiedad. Además, puede establecer explícitamente el valor de la <xref:System.Web.UI.Page.UICulture%2A> propiedad en del archivo Web.config.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.LCID" />
        <altmember cref="P:System.Web.UI.Page.Culture" />
      </Docs>
    </Member>
    <Member MemberName="UniqueFilePathSuffix">
      <MemberSignature Language="C#" Value="protected internal virtual string UniqueFilePathSuffix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueFilePathSuffix" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UniqueFilePathSuffix" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property UniqueFilePathSuffix As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::String ^ UniqueFilePathSuffix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueFilePathSuffix : string" Usage="System.Web.UI.Page.UniqueFilePathSuffix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un sufijo único que se anexa a la ruta de acceso de archivo para los exploradores con almacenamiento en caché.</summary>
        <value>Sufijo único que se anexa a la ruta de acceso al archivo. El valor predeterminado es "__ufps =" más un número único de 6 dígitos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.UniqueFilePathSuffix%2A> propiedad devuelve una cadena que se anexa al final de una ruta de acceso de archivo cuando sea necesario para los exploradores de almacenamiento en caché. Esta cadena se usa para identificar la ruta de acceso de archivo asociado a una solicitud específica.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnobtrusiveValidationMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UnobtrusiveValidationMode" />
      <MemberSignature Language="VB.NET" Value="Public Property UnobtrusiveValidationMode As UnobtrusiveValidationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::UnobtrusiveValidationMode UnobtrusiveValidationMode { System::Web::UI::UnobtrusiveValidationMode get(); void set(System::Web::UI::UnobtrusiveValidationMode value); };" />
      <MemberSignature Language="F#" Value="member this.UnobtrusiveValidationMode : System.Web.UI.UnobtrusiveValidationMode with get, set" Usage="System.Web.UI.Page.UnobtrusiveValidationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.UnobtrusiveValidationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor válido que indica si se usa JavaScript discreto para la validación en el lado cliente.</summary>
        <value>
          <see langword="true" /> si se usa JavaScript discreto; si no, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void UnregisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UnregisterRequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterRequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.UnregisterRequiresControlState : System.Web.UI.Control -&gt; unit" Usage="page.UnregisterRequiresControlState control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.Control" /> para el que se detendrá la persistencia del estado de control.</param>
        <summary>Detiene la persistencia del estado de control para el control especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles de servidor personalizados que utilizan el estado de control deben llamar a la <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> en cada solicitud durante antes de que se conserva el estado. Registro del estado de control de no se realiza a través de solicitud a petición durante un postback. Use el <xref:System.Web.UI.Page.UnregisterRequiresControlState%2A> método para asegurarse de que no se conserva el estado de control para los controles que ya no necesitan conservar para el postback.  
  
 Internamente, el <xref:System.Web.UI.Page.UnregisterRequiresControlState%2A> método se invoca cuando se usa el <xref:System.Web.UI.Control.RemovedControl%2A> método para quitar un control de una colección de controles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <see cref="T:System.Web.UI.Control" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
        <altmember cref="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Actualiza la instancia de modelo especificada con los valores de un proveedor de valores.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para una serie de tutoriales sobre el uso de enlace de modelos con formularios Web Forms, consulte [enlace de modelos y formularios Web Forms](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateModel(Of TModel As Class) (model As TModel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual void UpdateModel(TModel model);" />
      <MemberSignature Language="F#" Value="abstract member UpdateModel : 'Model -&gt; unit (requires 'Model : null)&#xA;override this.UpdateModel : 'Model -&gt; unit (requires 'Model : null)" Usage="page.UpdateModel model" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Tipo del modelo.</typeparam>
        <param name="model">Modelo.</param>
        <summary>Actualiza la instancia de modelo especificada mediante los valores del control enlazado a datos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método solo debe llamarse desde un método que se especifica mediante un control enlazado a datos `UpdateMethod` o `InsertMethod` propiedad.  
  
 Para una serie de tutoriales sobre el uso de enlace de modelos con formularios Web Forms, consulte [enlace de modelos y formularios Web Forms](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateModel(Of TModel As Class) (model As TModel, valueProvider As IValueProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual void UpdateModel(TModel model, System::Web::ModelBinding::IValueProvider ^ valueProvider);" />
      <MemberSignature Language="F#" Value="abstract member UpdateModel : 'Model * System.Web.ModelBinding.IValueProvider -&gt; unit (requires 'Model : null)&#xA;override this.UpdateModel : 'Model * System.Web.ModelBinding.IValueProvider -&gt; unit (requires 'Model : null)" Usage="page.UpdateModel (model, valueProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Tipo del modelo.</typeparam>
        <param name="model">Modelo.</param>
        <param name="valueProvider">Proveedor de valores.</param>
        <summary>Actualiza la instancia de modelo especificada con los valores del proveedor de valores especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para una serie de tutoriales sobre el uso de enlace de modelos con formularios Web Forms, consulte [enlace de modelos y formularios Web Forms](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.User" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal" Usage="System.Web.UI.Page.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene información sobre el usuario que realiza la solicitud de página.</summary>
        <value>
          <see cref="T:System.Security.Principal.IPrincipal" /> que representa al usuario que realiza la solicitud de página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Security.Principal.IPrincipal> objeto representa el contexto de seguridad del usuario se ejecuta el código, incluida la identidad del usuario y los roles a los que pertenecen.  
  
 Esta propiedad usa el <xref:System.Web.HttpContext> del objeto <xref:System.Web.HttpContext.User%2A> propiedad para determinar dónde se origina la solicitud.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.UI.Page.User%2A> propiedad obtener acceso a información de autenticación e identidad del usuario actual. Si el usuario no está autenticado, redirige a una página de inicio de sesión.  
  
 [!code-csharp[Page_User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_User/CS/page_user.cs.aspx#1)]
 [!code-vb[Page_User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_User/VB/page_user.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Security.Principal.IPrincipal" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica a los controles de validación incluidos en la página que validen la información que se les ha asignado.</summary>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Validate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Validate();" />
      <MemberSignature Language="F#" Value="abstract member Validate : unit -&gt; unit&#xA;override this.Validate : unit -&gt; unit" Usage="page.Validate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica a los controles de validación incluidos en la página que validen la información que se les ha asignado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se invoca cuando un usuario hace clic en cualquier control de servidor ASP.NET que tenga el `CausesValidation` propiedad establecida en `true`, que es el valor predeterminado. Estos incluyen el <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.WebControls.ImageButton>, y <xref:System.Web.UI.WebControls.LinkButton> controles de servidor Web el <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, y <xref:System.Web.UI.HtmlControls.HtmlButton> controles de servidor HTML y controles que pueden registrar automáticamente al servidor como el <xref:System.Web.UI.WebControls.TextBox>, <xref:System.Web.UI.WebControls.CheckBox>, <xref:System.Web.UI.WebControls.ListControl>, y <xref:System.Web.UI.WebControls.BulletedList> controles.  
  
 Para deshabilitar la validación para cualquier control de botón en la página, establezca el control de botón `CausesValidation` propiedad `false`.  
  
 Cuando se invoca este método, recorre en iteración los controles de validación contenidos en el <xref:System.Web.UI.ValidatorCollection> objeto asociado con el <xref:System.Web.UI.Page.Validators%2A?displayProperty=nameWithType> propiedad e invoca la lógica de validación para cada control de validación en el grupo de validación actual. El grupo de validaciones viene determinada por el control que registra la página al servidor. Si se especifica ningún grupo de validación, no se utiliza ningún grupo de validación.  
  
> [!NOTE]
>  Ha cambiado el comportamiento de validación de la página. En [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)], ya no controla la llamada la <xref:System.Web.UI.Page.Validate?displayProperty=nameWithType> método; se utiliza el <xref:System.Web.UI.Page.Validate%28System.String%29?displayProperty=nameWithType> método en su lugar. Si usas el <xref:System.Web.UI.Page.Validate?displayProperty=nameWithType> método en un [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] página, se omiten los grupos de validación y se validan todos los controles.  
  
   
  
## Examples  
 El siguiente ejemplo de código llama el <xref:System.Web.UI.Page.Validate%2A> definido por el método en una página en un escenario con varios grupos de diferentes validaciones.  
  
> [!IMPORTANT]
>  Este ejemplo tiene un cuadro de texto que acepta datos proporcionados por el usuario, lo que puede suponer una amenaza para la seguridad. De forma predeterminada, ASP.NET Web Pages valida que los datos proporcionados por el usuario no incluyen elementos HTML ni de script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>El <see cref="M:System.Web.UI.Page.Validate" /> no se utiliza el método por [! INCLUDE[vstecasplong](~/includes/vstecasplong-MD.MD)]. Cuando se usa [! INCLUDE[vstecasplong](~/includes/vstecasplong-MD.MD)], reemplazar el <see cref="M:System.Web.UI.Page.Validate(System.String)" /> método para cambiar el comportamiento de validación de la página.</para>
        </block>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Validate (validationGroup As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Validate(System::String ^ validationGroup);" />
      <MemberSignature Language="F#" Value="abstract member Validate : string -&gt; unit&#xA;override this.Validate : string -&gt; unit" Usage="page.Validate validationGroup" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">Nombre del grupo de validaciones de los controles que se van a validar.</param>
        <summary>Indica a los controles de validación del grupo de validaciones especificado que validen la información asignada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se invoca cuando un usuario hace clic en cualquier control de servidor ASP.NET que tenga el `CausesValidation` propiedad establecida en `true`, que es el valor predeterminado. Estos incluyen el <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.WebControls.ImageButton>, y <xref:System.Web.UI.WebControls.LinkButton> controles de servidor Web el <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, y <xref:System.Web.UI.HtmlControls.HtmlButton> controles de servidor HTML y controles que pueden registrar automáticamente al servidor como el <xref:System.Web.UI.WebControls.TextBox>, <xref:System.Web.UI.WebControls.CheckBox>, <xref:System.Web.UI.WebControls.ListControl>, y <xref:System.Web.UI.WebControls.BulletedList> controles.  
  
 Para deshabilitar la validación para cualquier control de botón en la página, establezca el control de botón `CausesValidation` propiedad `false`.  
  
 El <xref:System.Web.UI.Page.Validate%2A> método valida el grupo de validaciones especificado. Después de llamar a la <xref:System.Web.UI.Page.Validate%2A> método en un grupo de validación, el <xref:System.Web.UI.Page.IsValid%2A> método devolverá `true` solo si el grupo de validaciones especificado y el grupo de validación del control que provocó la página que se publicará en el servidor son válidos.  
  
   
  
## Examples  
 El siguiente ejemplo de código llama el <xref:System.Web.UI.Page.Validate%2A> definido por el método en una página en un escenario con varios grupos de diferentes validaciones.  
  
> [!IMPORTANT]
>  Este ejemplo tiene un cuadro de texto que acepta datos proporcionados por el usuario, lo que puede suponer una amenaza para la seguridad. De forma predeterminada, ASP.NET Web Pages valida que los datos proporcionados por el usuario no incluyen elementos HTML ni de script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ValidateRequestMode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ValidateRequestMode As ValidateRequestMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ValidateRequestMode ValidateRequestMode { System::Web::UI::ValidateRequestMode get(); void set(System::Web::UI::ValidateRequestMode value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateRequestMode : System.Web.UI.ValidateRequestMode with get, set" Usage="System.Web.UI.Page.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la página comprueba la entrada del cliente desde el explorador para valores potencialmente peligrosos.</summary>
        <value>Un valor que indica si la página comprueba la entrada del cliente. El valor predeterminado es <see cref="F:System.Web.UI.ValidateRequestMode.Enabled" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor <xref:System.Web.UI.ValidateRequestMode.Inherit> no se utiliza en el <xref:System.Web.UI.Page> porque no hay nada que heredan de la clase.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Validators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection Validators { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ValidatorCollection Validators" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Validators" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Validators As ValidatorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ValidatorCollection ^ Validators { System::Web::UI::ValidatorCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Validators : System.Web.UI.ValidatorCollection" Usage="System.Web.UI.Page.Validators" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de todos los controles de validación que contiene la página solicitada.</summary>
        <value>Colección de controles de validación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede utilizar esta propiedad para manipular los métodos y propiedades de la <xref:System.Web.UI.ValidatorCollection> objeto asociado con el actual <xref:System.Web.UI.Page> instancia. Esta colección contiene todos los controles de servidor de validación que se encuentran en una página.  
  
 Una llamada a la <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> método hace que la lógica de validación que se ejecutará para cada control de servidor de validación en el grupo de validación actual. Si cualquiera de estos controles no pase el <xref:System.Web.UI.Page.IsValid%2A?displayProperty=nameWithType> propiedad devuelve `false`.  
  
 Para obtener más información sobre los controles de validación, consulte [controles de validación ASP.NET](http://msdn.microsoft.com/library/fa2aa14d-a461-492e-9a79-c990904613ef).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
      </Docs>
    </Member>
    <Member MemberName="VerifyRenderingInServerForm">
      <MemberSignature Language="C#" Value="public virtual void VerifyRenderingInServerForm (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void VerifyRenderingInServerForm(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.VerifyRenderingInServerForm(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void VerifyRenderingInServerForm(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member VerifyRenderingInServerForm : System.Web.UI.Control -&gt; unit&#xA;override this.VerifyRenderingInServerForm : System.Web.UI.Control -&gt; unit" Usage="page.VerifyRenderingInServerForm control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Control de servidor ASP.NET que es necesario en el control <see cref="T:System.Web.UI.HtmlControls.HtmlForm" />.</param>
        <summary>Confirma que un control <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> se represente para el control de servidor ASP.NET especificado en tiempo de ejecución.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los controles que deben estar dentro de `<form runat=server>` etiquetas pueden llamar a este método antes de su representación para que se muestre un mensaje de error si se colocan fuera de las etiquetas. Los controles que devuelven datos o que dependen de los bloques de script registrado deben llamar a este método en un reemplazo del <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> método. Las páginas que tienen una forma diferente de representar el elemento de formulario de servidor pueden invalidar este método para producir una excepción en diferentes condiciones.  
  
 Los controles de servidor que devuelven datos o usar el script de cliente no funcionará si no se encuentren en el <xref:System.Web.UI.HtmlControls.HtmlForm> control de servidor (<`form runat="server">`) etiquetas. Estos controles pueden llamar a este método cuando se procesen para proporcionar un mensaje de error claro cuando no se encuentren en el <xref:System.Web.UI.HtmlControls.HtmlForm> control.  
  
 Al desarrollar un control de servidor personalizado, es habitual llamar a este método cuando se reemplaza el `Render` método para cualquier tipo de etiqueta de entrada. Esto es especialmente importante si el control de entrada llama <xref:System.Web.UI.Page.GetPostBackEventReference%2A>, o si emite script de cliente. Un control de servidor compuesta no es necesario realizar esta llamada.  
  
   
  
## Examples  
 El siguiente código de ejemplo invalida el <xref:System.Web.UI.Page.Render%2A?displayProperty=nameWithType> método de un control de servidor personalizado. Cuando este control escribe su contenido en una página, usa el <xref:System.Web.UI.Page.VerifyRenderingInServerForm%2A> método para asegurarse de que el control aparece entre las etiquetas apertura y cierre de un <xref:System.Web.UI.HtmlControls.HtmlForm> control.  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#3)]
 [!code-vb[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/vb/testlinkbutton.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El control de servidor especificado no está incluido entre las etiquetas de apertura y cierre del control de servidor <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> en tiempo de ejecución.</exception>
        <exception cref="T:System.ArgumentNullException">El control que se va a comprobar es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewStateEncryptionMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateEncryptionMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewStateEncryptionMode As ViewStateEncryptionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ViewStateEncryptionMode ViewStateEncryptionMode { System::Web::UI::ViewStateEncryptionMode get(); void set(System::Web::UI::ViewStateEncryptionMode value); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateEncryptionMode : System.Web.UI.ViewStateEncryptionMode with get, set" Usage="System.Web.UI.Page.ViewStateEncryptionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateEncryptionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el modo del cifrado del estado de vista.</summary>
        <value>Uno de los valores de <see cref="T:System.Web.UI.ViewStateEncryptionMode" />. El valor predeterminado es <see cref="F:System.Web.UI.ViewStateEncryptionMode.Auto" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A> no se puede establecer la propiedad en el código. Solo puede establecerse en la directiva o en el < elemento del archivo de configuración. Valores establecidos en la invalidación de la Directiva los valores establecidos en el archivo de configuración.  
  
 La sintaxis para establecer esta propiedad en la directiva es como sigue:  
  
```vb  
<%@ Page Language="VB" ViewStateEncryptionMode="Always" %>  
```  
  
```csharp  
<%@ Page Language="C#" ViewStateEncryptionMode="Always" %>  
```  
  
 La sintaxis para establecer esta propiedad en el archivo de configuración es como sigue:  
  
```vb  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
```csharp  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
 Los desarrolladores de controles personalizados que desee comprobar el valor de esta propiedad en el código antes de guardar datos potencialmente confidenciales para ver el estado de su control.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor establecido no es un miembro de la enumeración <see cref="T:System.Web.UI.ViewStateEncryptionMode" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Web.UI.Page.ViewStateEncryptionMode" /> solamente se puede establecer durante o antes de la fase <see langword="PreRender" /> de página del ciclo de vida de la página.</exception>
        <altmember cref="T:System.Web.UI.ViewStateEncryptionMode" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateUserKey">
      <MemberSignature Language="C#" Value="public string ViewStateUserKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ViewStateUserKey" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateUserKey" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewStateUserKey As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ViewStateUserKey { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateUserKey : string with get, set" Usage="System.Web.UI.Page.ViewStateUserKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Asigna un identificador a un usuario individual en la variable de estado de vista asociada a la página actual.</summary>
        <value>Identificador del usuario individual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer el <xref:System.Web.UI.Page.ViewStateUserKey%2A> propiedad puede ayudar a evitar ataques en la aplicación de usuarios malintencionados. Esto lo consigue que le permite asignar un identificador a la variable de estado de vista para usuarios individuales para que la variable no pueden usar para generar un ataque. Para obtener más información acerca de los ataques Web y lo que puede hacer para evitarlos, vea [aprovechar las ventajas de ASP.NET características integradas para protegerse de ataques de Web](http://go.microsoft.com/fwlink/?LinkId=163557).  
  
 Puede establecer esta propiedad en cualquier valor de cadena, como el usuario del nombre autenticado o <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> valor.  
  
> [!NOTE]
>  Debe establecer esta propiedad durante el `Page_Init` fase de procesamiento de la página. Al establecer esta propiedad durante el `Page_Load` fase produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El acceso a la propiedad <see cref="P:System.Web.UI.Page.ViewStateUserKey" /> se realizó demasiado tarde durante el procesamiento de la página.</exception>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.Page.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se representa el objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <value>Es <see langword="true" /> si se debe representar <see cref="T:System.Web.UI.Page" />; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se establece la <xref:System.Web.UI.Page.Visible%2A> propiedad `false` para ocultar el contenido representado de una página. Cuando se solicita esta página por primera vez, un origen de datos se rellena y se muestra en la página. Cuando un usuario hace clic en el botón, el `HideButton_Click` controlador de eventos oculta todo el contenido de la página procesado.  
  
 [!code-csharp[Page_Visible#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_Visible/CS/page_visible.cs.aspx#1)]
 [!code-vb[Page_Visible#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_Visible/VB/page_visible.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.UI.TemplateControl" />
        <altmember cref="T:System.Web.UI.UserControl" />
      </Docs>
    </Member>
  </Members>
</Type>