<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e19ff5181caa07c458ad6ff38334f4d37a7d0917" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31910627" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientScriptManager sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Define los métodos para la administración de scripts de cliente en aplicaciones web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Web.UI.ClientScriptManager> clase se utiliza para administrar secuencias de comandos de cliente y agregarlas a las aplicaciones Web. Puede obtener una referencia a la <xref:System.Web.UI.ClientScriptManager> clase desde el <xref:System.Web.UI.Page.ClientScript%2A> propiedad de la <xref:System.Web.UI.Page> objeto.  
  
 Puede agregar mediante declaración un script de cliente a una página Web mediante la inclusión de la secuencia de comandos en el marcado HTML de la página. Sin embargo, hay situaciones cuando se necesita agregar dinámicamente el script de cliente. Para agregar dinámicamente un script, use la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método, el <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> método, el <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> método, o la <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> método, dependiendo de cuándo y cómo desea agregar el script. Para obtener más información, consulte [Cómo: Agregar cliente Script dinámicamente a ASP.NET Web Pages](http://msdn.microsoft.com/library/e89f1306-e43d-49ae-a66a-e18b71007666).  
  
 El <xref:System.Web.UI.ClientScriptManager> clase identifica de forma única las secuencias de comandos mediante una clave <xref:System.String> y <xref:System.Type>. Las secuencias de comandos con la misma clave y tipo se consideran duplicadas. Utilizando el tipo de script ayuda a evitar la confusión entre scripts similares de controles de usuario diferentes que podrían estar en uso en la página.  
  
 La <xref:System.Web.UI.ClientScriptManager> clase puede usarse para invocar las devoluciones de llamada de cliente en situaciones cuando, es conveniente ejecutar el código del servidor desde el cliente sin realizar una devolución de datos. Esto se conoce como realizar una devolución de llamada fuera de banda al servidor. En una devolución de llamada de cliente, una función de script de cliente envía una solicitud asincrónica para una página Web ASP.NET. La página Web se ejecuta una versión modificada de su ciclo de vida normal para procesar la devolución de llamada. Use la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> método para obtener una referencia a una función de cliente que, cuando se invoca, inicia una devolución de llamada de cliente a un evento de servidor. Para obtener más información, consulte [Implementing las devoluciones de llamada de cliente sin Postbacks](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Las devoluciones de llamada de la secuencia de comandos no funcionará en los exploradores más antiguos que no admiten el modelo de objetos de documento (DOM) y requieren que ECMAScript esté habilitado en el cliente. Para comprobar si el explorador admite las devoluciones de llamada, use la <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> propiedad, que es accesible a través de la <xref:System.Web.HttpRequest.Browser%2A> propiedad de la función intrínseca de ASP.NET <xref:System.Web.HttpContext.Request%2A> objeto.  
  
 Use la <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> método y <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> método para definir un evento de postback de cliente. Estos métodos permiten las funciones de script de cliente, cuando se invoca, para hacer que el servidor enviar a la página. Un evento de postback de cliente es diferente de una devolución de llamada de cliente en que la página Web finaliza un ciclo de vida normal para procesar el evento de devolución de cliente.  
  
> [!NOTE]
>  Si utilizas un <xref:System.Web.UI.WebControls.Button> control y el <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> propiedad está establecida en `false`, puede usar el <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> método para devolver el cliente devolución de datos del evento para el <xref:System.Web.UI.WebControls.Button> control.  
  
 El <xref:System.Web.UI.WebControls.Button.OnClientClick%2A> propiedad de la <xref:System.Web.UI.WebControls.Button> (control), <xref:System.Web.UI.WebControls.ImageButton> (control), y <xref:System.Web.UI.WebControls.LinkButton> control puede usarse para ejecutar el script de cliente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método de la <xref:System.Web.UI.ClientScriptManager> clase. Se definen dos scripts de cliente en la página: `PopupScript`, que muestra un mensaje de alerta cuando se carga la página, y `ButtonClickScript`, que define un controlador de cliente para un botón HTML `onClick` eventos.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
  </Docs>
  <Members>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene una referencia a una función de cliente que, cuando se invoca, inicia una devolución de llamada del cliente a un evento de servidor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Objeto <see cref="T:System.Web.UI.Control" /> de servidor que controla la devolución de llamada de cliente. El control debe implementar la interfaz <see cref="T:System.Web.UI.ICallbackEventHandler" /> y proporcionar un método <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Argumento pasado desde el script de cliente al de servidor  
  
 Método <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="clientCallback">Nombre del controlador de eventos de cliente que recibe el resultado de un evento de servidor correcto.</param>
        <param name="context">El script de cliente que se evalúa en el cliente antes de iniciar la devolución de llamada. El resultado del script se devuelve al controlador de eventos de cliente.</param>
        <summary>Obtiene una referencia a una función de cliente que, cuando se invoca, inicia una devolución de llamada del cliente a un evento de servidor. La función de cliente para este método sobrecargado incluye un control, un argumento, un script de cliente y un contexto especificados.</summary>
        <returns>El nombre de una función de cliente que invoca la devolución de llamada de cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> método realiza una devolución de llamada fuera de banda en el servidor que es una versión modificada del ciclo de vida normal de una página. Para obtener más información, consulte [Implementing las devoluciones de llamada de cliente sin Postbacks](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Cuando el explorador es Microsoft Internet Explorer (versión 5.0 o posterior), el mecanismo de devolución de llamada de secuencia de comandos se implementa a través del objeto COM Microsoft.XmlHttp y requiere que el explorador se establezca para ejecutar los controles ActiveX. Para otros exploradores, se utiliza un objeto XMLHttpRequest utilizando local Document Object Model (DOM) del explorador. Para comprobar si un explorador admite las devoluciones de llamada de cliente, utilice la <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> propiedad. Para comprobar si un explorador admite XML sobre HTTP, utilice el <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A> propiedad. Ambas propiedades son accesibles a través de la <xref:System.Web.HttpRequest.Browser%2A> propiedad de la función intrínseca de ASP.NET <xref:System.Web.HttpContext.Request%2A> objeto.  
  
 El <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> sobrecarga de la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> método realiza una devolución de llamada de forma sincrónica utilizando XML sobre HTTP. Al enviar datos de forma sincrónica en un escenario de devolución de llamada, las devoluciones de llamada sincrónicas devuelvan inmediatamente y no bloquean el explorador. Devolución de llamada de dos devoluciones de llamada sincrónica no puede ejecutar al mismo tiempo en el explorador. Si se desencadena una segunda devolución de llamada sincrónica mientras otra está actualmente pendiente, la segunda devolución de llamada sincrónica cancela la primera y la segunda devolución de llamada se devolverá.  
  
 Para enviar datos de forma asincrónica, use una de las sobrecargas que toma el `useAsync` parámetro, que es un valor booleano valor que controla este comportamiento. En el escenario asincrónico puede tener varias devoluciones de llamada pendientes; Sin embargo, no se garantiza el orden en el que devuelven para que coincida con el orden en el que se iniciaron.  
  
 Además, esta sobrecarga de la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> método no especifica ninguna función de cliente para controlar el caso de una condición de error generado por el <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> método. Para especificar un controlador de devolución de llamada de error de cliente, utilice una de las sobrecargas que toma el `clientErrorCallback` parámetro.  
  
 El <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> método toma una cadena opcional `argument` parámetro y devuelve una cadena. Para pasar o recibir varios valores, concatene los valores en la entrada o cadena devuelta, respectivamente.  
  
> [!NOTE]
>  Evite utilizar el estado de vista en la implementación de página o propiedades de control que necesiten actualizarse durante las operaciones de devolución de llamada de secuencia de comandos. Si las propiedades son sobrevivir a las solicitudes de página, puede usar el estado de sesión.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar dos sobrecargas de la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> método en un escenario de devolución de llamada de cliente que incrementa enteros.  
  
 Se muestran dos mecanismos de devolución de llamada; la diferencia entre ellos es el uso de la `context` parámetro. A `ReceiveServerData1` función de devolución de llamada de cliente se proporciona mediante la `context` parámetro. En cambio, el `ReceiveServerData2` función de devolución de llamada de cliente se define en un `<script>` bloque en la página. A <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> método es el controlador de servidor que se incrementa el valor que se pasa y <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> método devuelve el valor incrementado como una cadena. Si el <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> método devuelve un error, el `ProcessCallBackError` se llama la función de cliente.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El <see cref="T:System.Web.UI.Control" /> especificado es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El objeto <see cref="T:System.Web.UI.Control" /> no implementa la interfaz <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, bool useAsync);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Objeto <see cref="T:System.Web.UI.Control" /> de servidor que controla la devolución de llamada de cliente. El control debe implementar la interfaz <see cref="T:System.Web.UI.ICallbackEventHandler" /> y proporcionar un método <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Argumento pasado desde el script de cliente al de servidor  
  
 Método <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="clientCallback">Nombre del controlador de eventos de cliente que recibe el resultado de un evento de servidor correcto.</param>
        <param name="context">El script de cliente que se evalúa en el cliente antes de iniciar la devolución de llamada. El resultado del script se devuelve al controlador de eventos de cliente.</param>
        <param name="useAsync">
          Es <see langword="true" /> para realizar la devolución de llamada de forma asincrónica; es <see langword="false" /> para realizar la devolución de llamada de forma sincrónica.</param>
        <summary>Obtiene una referencia a una función de cliente que, cuando se invoca, inicia una devolución de llamada del cliente a los eventos de servidor. La función de cliente para este método sobrecargado incluye un control, un argumento, un script de cliente, un contexto y un valor booleano especificados.</summary>
        <returns>El nombre de una función de cliente que invoca la devolución de llamada de cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga de la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> método requiere un `useAsync` parámetro, que le permite realizar la devolución de llamada de cliente de forma asincrónica estableciendo el valor en `true`. Las versiones de sobrecarga de este método que no requieren la `useAsync` parámetro establece el valor en `false` de forma predeterminada.  
  
 Para obtener más información sobre este método, vea la sección Comentarios para la sobrecarga <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El <see cref="T:System.Web.UI.Control" /> especificado es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El objeto <see cref="T:System.Web.UI.Control" /> no implementa la interfaz <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (target As String, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::String ^ target, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">Nombre de un servidor <see cref="T:System.Web.UI.Control" /> que controla la devolución de llamada del cliente. El control debe implementar la interfaz <see cref="T:System.Web.UI.ICallbackEventHandler" /> y proporcionar un método <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Argumento pasado desde el script de cliente al de servidor  
  
 Método <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="clientCallback">Nombre del controlador de eventos de cliente que recibe el resultado de un evento de servidor correcto.</param>
        <param name="context">El script de cliente que se evalúa en el cliente antes de iniciar la devolución de llamada. El resultado del script se devuelve al controlador de eventos de cliente.</param>
        <param name="clientErrorCallback">Nombre del controlador de eventos de cliente que recibe el resultado cuando se produce un error en el controlador de eventos de servidor.</param>
        <param name="useAsync">
          Es <see langword="true" /> para realizar la devolución de llamada de forma asincrónica; es <see langword="false" /> para realizar la devolución de llamada de forma sincrónica.</param>
        <summary>Obtiene una referencia a una función de cliente que, cuando se invoca, inicia una devolución de llamada del cliente a los eventos de servidor. La función de cliente para este método sobrecargado incluye un destino, un argumento, un script de cliente, un contexto, un controlador de errores y un valor booleano especificados.</summary>
        <returns>El nombre de una función de cliente que invoca la devolución de llamada de cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga de la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> método toma un `target` cadena de parámetro en lugar de un <xref:System.Web.UI.Control> parámetro. Utilice esta sobrecarga cuando desee que la devolución de llamada para volver atrás y un valor distinto de una cadena que contiene el <xref:System.Web.UI.Control.UniqueID%2A> del control.  
  
 Además, esta sobrecarga de la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> método requiere un `useAsync` y un `clientErrorCallback` parámetro. El `useAsync` parámetro le permite realizar la devolución de llamada de cliente de forma asincrónica estableciendo el valor en `true`. Las versiones de sobrecarga de este método que no requieren la `useAsync` parámetro establece el valor en `false` de forma predeterminada. El `clientErrorCallback` parámetro le permite definir el nombre de la función de cliente que se llama si el controlador de servidor, el <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> método, devuelve un error. Las versiones de sobrecarga de este método que no requieren la `clientErrorCallback` parámetro establece el valor en null.  
  
 Para obtener más información sobre este método, vea la sección Comentarios para la sobrecarga <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar dos sobrecargas de la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> método en un escenario de devolución de llamada de cliente que incrementa enteros.  
  
 Se muestran dos mecanismos de devolución de llamada; la diferencia entre ellos es el uso de la `context` parámetro. A `ReceiveServerData1` función de devolución de llamada de cliente se proporciona mediante la `context` parámetro. En cambio, el `ReceiveServerData2` función de devolución de llamada de cliente se define en un `<script>` bloque en la página. A <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> método es el controlador de servidor que se incrementa el valor que se pasa y <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> método devuelve el valor incrementado como una cadena. Si el <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> método devuelve un error y, a continuación, la función de cliente `ProcessCallBackError` se llama.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Objeto <see cref="T:System.Web.UI.Control" /> de servidor que controla la devolución de llamada de cliente. El control debe implementar la interfaz <see cref="T:System.Web.UI.ICallbackEventHandler" /> y proporcionar un método <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Argumento pasado desde el script de cliente al método <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> de servidor</param>
        <param name="clientCallback">Nombre del controlador de eventos de cliente que recibe el resultado de un evento de servidor correcto.</param>
        <param name="context">El script de cliente que se evalúa en el cliente antes de iniciar la devolución de llamada. El resultado del script se devuelve al controlador de eventos de cliente.</param>
        <param name="clientErrorCallback">Nombre del controlador de eventos de cliente que recibe el resultado cuando se produce un error en el controlador de eventos de servidor.</param>
        <param name="useAsync">
          Es <see langword="true" /> para realizar la devolución de llamada de forma asincrónica; es <see langword="false" /> para realizar la devolución de llamada de forma sincrónica.</param>
        <summary>Obtiene una referencia a una función de cliente que, cuando se invoca, inicia una devolución de llamada del cliente a los eventos de servidor. La función de cliente para este método sobrecargado incluye un control, un argumento, un script de cliente, un contexto, un controlador de errores y un valor booleano especificados.</summary>
        <returns>El nombre de una función de cliente que invoca la devolución de llamada de cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga de la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> método requiere un `useAsync` y un `clientErrorCallback` parámetro. El `useAsync` parámetro le permite realizar la devolución de llamada de cliente de forma asincrónica estableciendo el valor en `true`. Las versiones de sobrecarga de este método que no requieren la `useAsync` parámetro establece el valor en `false` de forma predeterminada. El `clientErrorCallback` parámetro le permite definir el nombre de la función de cliente que se llama si el controlador del servidor (el <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> (método)) devuelve un error. Las versiones de sobrecarga de este método que no requieren la `clientErrorCallback` parámetro establece el valor en null.  
  
 Para obtener más información sobre este método, vea la sección Comentarios para la sobrecarga <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El <see cref="T:System.Web.UI.Control" /> especificado es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El objeto <see cref="T:System.Web.UI.Control" /> no implementa la interfaz <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene una referencia, con <see langword="javascript:" /> anexado al principio, que se puede utilizar en un evento de devolución de datos del cliente al servidor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Control de servidor que va a procesar el valor devuelto.</param>
        <param name="argument">Parámetro pasado al control de servidor.</param>
        <summary>Obtiene una referencia, con <see langword="javascript:" /> anexado al principio, que se puede utilizar en un evento de devolución de datos del cliente al servidor para el control especificado y con los argumentos de evento especificados.</summary>
        <returns>Cadena que representa una llamada de JavaScript a la función de postback que incluye el id. del control de destino y los argumentos del evento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mediante el <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> método requiere que el control que controla la devolución de datos para implementar la <xref:System.Web.UI.IPostBackEventHandler> interfaz. Para implementar la <xref:System.Web.UI.IPostBackEventHandler> interfaz para un <xref:System.Web.UI.Page>, use la directiva.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> método. El control personalizado, `MyControl`, implementa el <xref:System.Web.UI.IPostBackEventHandler> interfaz. Cuando se hace clic en el elemento delimitador HTML en la página, el <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> se invoca el método del control personalizado.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 En el ejemplo de código siguiente se tiene la misma funcionalidad que el anterior, excepto que en lugar de un control personalizado, el <xref:System.Web.UI.Page> la clase implementa la <xref:System.Web.UI.IPostBackEventHandler> interfaz.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Control de servidor que va a procesar el valor devuelto.</param>
        <param name="argument">Parámetro pasado al control de servidor.</param>
        <param name="registerForEventValidation">
          Es <see langword="true" /> para registrar el evento postback para su validación; es <see langword="false" /> para no registrarlo.</param>
        <summary>Obtiene una referencia, con <see langword="javascript:" /> anexado al principio, que se puede utilizar en un evento de devolución de datos del cliente al servidor para el control especificado y con los argumentos de evento especificados y, también, con una indicación booleana de si se debe registrar la devolución de datos para realizar la validación del evento.</summary>
        <returns>Cadena que representa una llamada de JavaScript a la función de postback que incluye el id. del control de destino y los argumentos del evento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mediante el <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> método requiere que el control que controla la devolución de datos para implementar la <xref:System.Web.UI.IPostBackEventHandler> interfaz. Para implementar la <xref:System.Web.UI.IPostBackEventHandler> interfaz para un <xref:System.Web.UI.Page>, use la directiva.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una cadena que se puede utilizar en un evento de cliente para que se produzca un postback al servidor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">Objeto <see cref="T:System.Web.UI.PostBackOptions" /> que define el postback.</param>
        <summary>Devuelve una cadena que se puede utilizar en un evento de cliente para que se produzca un postback al servidor. La instancia <see cref="T:System.Web.UI.PostBackOptions" /> especificada define la cadena de referencia.</summary>
        <returns>Cadena que, cuando se trata como script en el cliente, inicia el postback del cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para implementar la <xref:System.Web.UI.IPostBackEventHandler> interfaz para un <xref:System.Web.UI.Page>, use la directiva.  
  
 El <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> método puede utilizarse con el <xref:System.Web.UI.WebControls.Button> controlar cuándo el <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> propiedad es `false`. En este escenario, el <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> método devuelve el cliente de devolución de datos del evento para el <xref:System.Web.UI.WebControls.Button> control.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <see cref="T:System.Web.UI.PostBackOptions" /> es <see langword="null" /></exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Servidor <see cref="T:System.Web.UI.Control" /> que procesa los datos devueltos en el servidor.</param>
        <param name="argument">Cadena de argumentos opcionales para pasar al control que procesa el postback.</param>
        <summary>Devuelve una cadena que se puede utilizar en un evento de cliente para que se produzca un postback al servidor. El control especificado para controlar el postback y un argumento de cadena con información adicional sobre el evento definen la cadena de referencia.</summary>
        <returns>Cadena que, cuando se trata como script en el cliente, inicia el postback.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para implementar la <xref:System.Web.UI.IPostBackEventHandler> interfaz para un <xref:System.Web.UI.Page>, use la directiva.  
  
 El <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> método puede utilizarse con el <xref:System.Web.UI.WebControls.Button> controlar cuándo el <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> propiedad es `false`. En este escenario, el <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> método devuelve el cliente de devolución de datos del evento para el <xref:System.Web.UI.WebControls.Button> control.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> método. El control personalizado, `MyControl`, implementa el <xref:System.Web.UI.IPostBackEventHandler> interfaz. Cuando se hace clic en el botón en la página, el <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> se invoca el método del control personalizado.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 En el ejemplo de código siguiente se tiene la misma funcionalidad que el anterior, excepto que en lugar de un control personalizado, el <xref:System.Web.UI.Page> la clase implementa la <xref:System.Web.UI.IPostBackEventHandler> interfaz.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El <see cref="T:System.Web.UI.Control" /> especificado es <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options, bool registerForEventValidation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options">Objeto <see cref="T:System.Web.UI.PostBackOptions" /> que define el postback.</param>
        <param name="registerForEventValidation">
          <see langword="true" /> para registrar la referencia de evento para su validación; de lo contrario, <see langword="false" />.</param>
        <summary>Devuelve una cadena que se puede utilizar en un evento de cliente para que se produzca un postback al servidor. El objeto <see cref="T:System.Web.UI.PostBackOptions" /> especificado define la cadena de referencia. Opcionalmente, registra la referencia de evento para su validación.</summary>
        <returns>Cadena que, cuando se trata como script en el cliente, inicia el postback del cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para implementar la <xref:System.Web.UI.IPostBackEventHandler> interfaz para un <xref:System.Web.UI.Page> de objetos, use la directiva.  
  
 El <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> método puede utilizarse con el <xref:System.Web.UI.WebControls.Button> controlar cuándo el <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> propiedad es `false`. En este escenario, el <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> método devuelve el cliente de devolución de datos del evento para el <xref:System.Web.UI.WebControls.Button> control.  
  
 Si `registerForEventValidation` es `true`, <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> llamadas al método el <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> método para registrar la referencia de evento para su validación con un identificador de control único que representa el control de cliente que se va a generar el evento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <see cref="T:System.Web.UI.PostBackOptions" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Servidor <see cref="T:System.Web.UI.Control" /> que procesa los datos devueltos en el servidor.</param>
        <param name="argument">Cadena de argumentos opcionales que se va a pasar a <c>control</c>.</param>
        <param name="registerForEventValidation">
          <see langword="true" /> para registrar la referencia de evento para su validación; de lo contrario, <see langword="false" />.</param>
        <summary>Devuelve una cadena que se debe utilizar en un evento de cliente para que se produzca un postback al servidor. El control especificado para controlar el postback y un argumento de cadena con información adicional sobre el evento definen la cadena de referencia. Opcionalmente, registra la referencia de evento para su validación.</summary>
        <returns>Cadena que, cuando se trata como script en el cliente, inicia el postback.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para implementar la <xref:System.Web.UI.IPostBackEventHandler> interfaz para un <xref:System.Web.UI.Page>, use la directiva.  
  
 El <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> método puede utilizarse con el <xref:System.Web.UI.WebControls.Button> controlar cuándo el <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> propiedad es `false`. En este escenario, el <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> método devuelve el cliente de devolución de datos del evento para el <xref:System.Web.UI.WebControls.Button> control.  
  
 Si `registerForEventValidation` es true, el <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> llamadas al método el <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> método para registrar la referencia de evento para su validación con un identificador de control único que representa el control de cliente que se va a generar el evento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El <see cref="T:System.Web.UI.Control" /> especificado es <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetWebResourceUrl(Type ^ type, System::String ^ resourceName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo del recurso.</param>
        <param name="resourceName">Nombre completo del recurso en el ensamblado.</param>
        <summary>Obtiene una referencia de la dirección URL de un recurso en un ensamblado.</summary>
        <returns>Referencia de la dirección URL al recurso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> método devuelve una referencia de dirección URL a un recurso incrustado en un ensamblado. La referencia devuelta no es una dirección URL codificada. Recursos pueden ser archivos de script, imágenes o cualquier archivo estático. Especifique el tipo basándose en el objeto que se va a tener acceso al recurso.  
  
 Un recurso Web registrado en la página se identifica por su tipo y nombre. Solo un recurso con un par de nombre y un tipo determinado se puede registrar con la página. Al intentar registrar un recurso que ya está registrado, no crea un duplicado del recurso registrado.  
  
 El <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> método se utiliza junto con el <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> método para tener acceso a recursos incrustados en ensamblados. Para obtener más información sobre el uso de recursos en aplicaciones, consulte [ASP.NET Web Page Resources Overview](http://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> método. El *tipo* parámetro en este ejemplo se establece en el tipo de clase en el ensamblado que contiene el recurso. El `resourceName` parámetro se especifica con la ruta de acceso completa al recurso, que incluye el espacio de nombres predeterminado.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 En el ejemplo de código siguiente se muestra cómo aplicar mediante programación el <xref:System.Web.UI.WebResourceAttribute> atributo de metadatos para marcar el ensamblado para los recursos que se enviarán. Compile la clase siguiente en una biblioteca de clases con un espacio de nombres predeterminado establecido en `Samples.AspNet.CS.Controls` o `Samples.AspNet.VB.Controls`, dependiendo de qué lenguaje que esté utilizando.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 Este ejemplo requiere un archivo JavaScript denominado `Script_include.js`. El archivo .js es un recurso incrustado en el ensamblado que contiene el `ClientScriptResourceLabel` objeto. Si está utilizando Visual Studio], en la ventana de propiedades del proyecto de biblioteca de clase, establezca **acción de compilación** a **recurso incrustado** cuando se selecciona el archivo de script. Si está compilando la biblioteca, en la línea de comandos, utilice el modificador para incrustar el recurso.  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El nombre del recurso de Web es <see langword="null" />.  
  
 \- o -  
  
 El nombre del recurso del Web tiene una longitud de cero.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si el bloque de script de cliente se encuentra registrado con el objeto <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Clave del bloque de script de cliente que se va a buscar.</param>
        <summary>Determina si el bloque de script de cliente se encuentra registrado con el objeto <see cref="T:System.Web.UI.Page" /> utilizando la clave especificada.</summary>
        <returns>
          Es <see langword="true" /> si el bloque de script de cliente está registrado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método antes de llamar a la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método para evitar registrar scripts duplicados. Esto es especialmente importante si el script requiere una gran cantidad de recursos del servidor para crear.  
  
 Un script de cliente se identifica mediante su clave y su tipo. Las secuencias de comandos con la misma clave y tipo se consideran duplicadas.  
  
 Esta sobrecarga de la <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> método llama a la sobrecarga que toma tanto un `key` y un `type` parámetro con el tipo establecido como un <xref:System.Web.UI.Page> objeto  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(Type ^ type, System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo del bloque de script de cliente que se va a buscar.</param>
        <param name="key">Clave del bloque de script de cliente que se va a buscar.</param>
        <summary>Determina si el bloque de script de cliente se encuentra registrado con el objeto <see cref="T:System.Web.UI.Page" /> utilizando una clave y un tipo.</summary>
        <returns>
          Es <see langword="true" /> si el bloque de script de cliente está registrado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método antes de llamar a la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método para evitar registrar scripts duplicados. Esto es especialmente importante si el script requiere una gran cantidad de recursos del servidor para crear.  
  
 Un script de cliente se identifica mediante su clave y su tipo. Las secuencias de comandos con la misma clave y tipo se consideran duplicadas. Especifique el tipo basándose en el objeto que se va a tener acceso al recurso. Por ejemplo, cuando se usa un `Page` instancia para tener acceso al recurso, especifique el `Page` tipo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> método. Tenga en cuenta que, si se quita la lógica para comprobar si el bloque de script de cliente existente, no habría dos scripts de cliente duplicados en el código fuente HTML de la página representada, porque el <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método comprueba los duplicados. La ventaja de la comprobación es reducir los cálculos innecesarios.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El tipo de script de cliente es <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si la inclusión de script de cliente se encuentra registrada con el objeto <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Clave de la inclusión de script de cliente que se va a buscar.</param>
        <summary>Determina si la inclusión de script de cliente se encuentra registrada con el objeto <see cref="T:System.Web.UI.Page" /> utilizando la clave especificada.</summary>
        <returns>
          Es <see langword="true" /> si la inclusión de script de cliente está registrada; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método antes de llamar a la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> método para evitar registrar scripts duplicados. Esto es especialmente importante si el script requiere una gran cantidad de recursos del servidor para crear.  
  
 Incluir un script de cliente se identifica mediante su clave y su tipo. Las secuencias de comandos con la misma clave y tipo se consideran duplicadas.  
  
 Esta sobrecarga de la <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> método llama a la sobrecarga que toma tanto un `key` y un `type` parámetro con el tipo establecido como un <xref:System.Web.UI.Page> objeto.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(Type ^ type, System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de la inclusión de script de cliente que se va a buscar.</param>
        <param name="key">Clave de la inclusión de script de cliente que se va a buscar.</param>
        <summary>Determina si la inclusión de script de cliente se encuentra registrada con el objeto <see cref="T:System.Web.UI.Page" /> utilizando una clave y un tipo.</summary>
        <returns>
          Es <see langword="true" /> si la inclusión de script de cliente está registrada; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método antes de llamar a la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> incluye el método para evitar registrar scripts de cliente duplicados. Esto es especialmente importante si el script requiere una gran cantidad de recursos del servidor para crear.  
  
 Incluir un script de cliente se identifica mediante su clave y su tipo. Las secuencias de comandos con la misma clave y tipo se consideran duplicadas. Especifique el tipo basándose en el objeto que se va a tener acceso al recurso. Por ejemplo, al utilizar una instancia de la página para tener acceso al recurso, especifique el `Page` tipo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> método. Tenga en cuenta que, si se quita la lógica para comprobar la inclusión de la secuencia de comandos de cliente existente, no habría dos scripts de cliente duplicados en el código fuente HTML de la página representada, porque el <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> método comprueba los duplicados. La ventaja de la comprobación es reducir los cálculos innecesarios.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 Este ejemplo requiere un archivo JavaScript denominado `Script_include.js`, con el siguiente contenido:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El tipo de inclusión de script de cliente es <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si la instrucción OnSubmit se encuentra registrada con el objeto <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Clave de la instrucción OnSubmit que se va a buscar.</param>
        <summary>Determina si la instrucción OnSubmit se encuentra registrada con el objeto <see cref="T:System.Web.UI.Page" /> utilizando la clave especificada.</summary>
        <returns>
          Es <see langword="true" /> si la instrucción OnSubmit se encuentra registrada; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método antes de llamar a la <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> método para evitar registrar instrucciones OnSubmit duplicadas. Esto es especialmente importante si la instrucción requiere una gran cantidad de recursos del servidor para crear.  
  
 Una instrucción se identifica mediante su clave y su tipo. Instrucciones con la misma clave y tipo se consideran duplicadas.  
  
 Esta sobrecarga de la <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> método llama a la sobrecarga que toma tanto un `key` y un `type` parámetro con el tipo establecido como un <xref:System.Web.UI.Page> objeto  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(Type ^ type, System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de la instrucción OnSubmit que se va a buscar.</param>
        <param name="key">Clave de la instrucción OnSubmit que se va a buscar.</param>
        <summary>Determina si la instrucción OnSubmit se encuentra registrada con el objeto <see cref="T:System.Web.UI.Page" /> utilizando la clave y el tipo especificados.</summary>
        <returns>
          Es <see langword="true" /> si la instrucción OnSubmit se encuentra registrada; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método antes de llamar a la <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> método para evitar registrar instrucciones duplicadas. Esto es especialmente importante si la instrucción requiere una gran cantidad de recursos del servidor para crear.  
  
 Una instrucción se identifica mediante su clave y su tipo. Instrucciones con la misma clave y tipo se consideran duplicadas. Especifique el tipo basándose en el objeto que se va a tener acceso al recurso. Por ejemplo, cuando se usa un `Page` instancia para tener acceso al recurso, especifique el `Page` tipo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> método. Un script denominado `OnSubmitScript` está registrado con el <xref:System.Web.UI.Page> para que cuando se envía el formulario de la página se invoca la secuencia de comandos.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El tipo de instrucción OnSubmit es <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si el script de inicio se encuentra registrado con el objeto <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Clave del script de inicio que se va a buscar.</param>
        <summary>Determina si el script de inicio se encuentra registrado con el objeto <see cref="T:System.Web.UI.Page" /> utilizando la clave especificada.</summary>
        <returns>
          Es <see langword="true" /> si el script de inicio está registrado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método antes de llamar a la <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> método para evitar registrar scripts duplicados. Esto es especialmente importante si el script requiere una gran cantidad de recursos del servidor para crear.  
  
 Un script de inicio se identifica mediante su clave y su tipo. Las secuencias de comandos con la misma clave y tipo se consideran duplicadas.  
  
 Esta sobrecarga de la <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> método llama a la sobrecarga que toma una cadena de ambos `key` y un `type` parámetro con el tipo establecido como un <xref:System.Web.UI.Page> objeto  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(Type ^ type, System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo del script de inicio que se va a buscar.</param>
        <param name="key">Clave del script de inicio que se va a buscar.</param>
        <summary>Determina si el script de inicio se encuentra registrado con el objeto <see cref="T:System.Web.UI.Page" /> utilizando la clave y el tipo especificados.</summary>
        <returns>
          Es <see langword="true" /> si el script de inicio está registrado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método antes de llamar a la <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> método para evitar registrar scripts duplicados. Esto es especialmente importante si el script requiere una gran cantidad de recursos del servidor para crear.  
  
 Un script de inicio de cliente se identifica mediante su clave y su tipo. Las secuencias de comandos con la misma clave y tipo se consideran duplicadas.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> método. Tenga en cuenta que, si se han quitado la lógica para comprobar si el bloque de script de inicio existente, no habría dos scripts de inicio duplicadas en el código fuente HTML de la página representada, porque el <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> método comprueba los duplicados. La ventaja de la comprobación es reducir los cálculos innecesarios.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El tipo de script es <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Nombre de matriz que se va a registrar.</param>
        <param name="arrayValue">Valor o valores de la matriz que se va a registrar.</param>
        <summary>Registra una declaración de matriz JavaScript con el objeto <see cref="T:System.Web.UI.Page" /> utilizando un nombre y un valor de matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> comprueba si una matriz registrada existe con el mismo nombre que el nombre especificado en el `arrayName` parámetro y, si es así, agrega los valores especificados en la `arrayValue` parámetro. Dado que el mecanismo de almacenamiento subyacente se basa en un <xref:System.Collections.ArrayList>, se permiten los duplicados. Si una matriz registrada con el mismo nombre que el `arrayName` no existe el parámetro, se crea y los valores de la `arrayValue` parámetro agregado a él.  
  
 Si desea que los literales de cadena en la matriz de JavaScript resultante, incluya entre comillas simples (') o comillas dobles de escape (\\") en el `arrayValue` parámetro. El valor de la `arrayValue` parámetro debe ser un único elemento. Si más de un valor debe agregarse a la matriz, realizar varias llamadas con el <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> y <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> métodos. En el ejemplo se registra una matriz y un valor oculto y define la `OnClick` eventos de un `<input>` botón para calcular la suma de dos valores de la matriz y el valor hidden.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayName" /> es <see langword="null" />.</exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra el script de cliente con el objeto <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo del script de cliente que se va a registrar.</param>
        <param name="key">Clave del script de cliente que se va a registrar.</param>
        <param name="script">Literal del script de cliente que se va a registrar.</param>
        <summary>Registra el script de cliente con el objeto <see cref="T:System.Web.UI.Page" /> utilizando un tipo, clave y literal de script.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un script de cliente se identifica mediante su clave y su tipo. Las secuencias de comandos con la misma clave y tipo se consideran duplicadas. Con la página, se puede registrar un único script con un tipo determinado y un par de claves. Al intentar registrar un script que ya está registrado, no crea un duplicado de la secuencia de comandos.  
  
 Llame a la <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> método para determinar si ya está registrado un script de cliente con un par de clave y un tipo determinado y evitar innecesariamente agregar la secuencia de comandos.  
  
 En esta sobrecarga de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método, debe asegurarse de que el script proporcionado en el `script` parámetro se encapsula en un `<script>` bloque del elemento.  
  
 El <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método agrega un bloque de script a la parte superior de la página representada. No se garantiza que los bloques de script se generen en el orden en que están registrados. Si es importante el orden de los bloques de script, use un <xref:System.Text.StringBuilder> de objetos para recopilar las secuencias de comandos en una sola cadena y, a continuación, registrarlas en un bloque de script de cliente único.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Tipo del script de cliente que se va a registrar.</param>
        <param name="key">Clave del script de cliente que se va a registrar.</param>
        <param name="script">Literal del script de cliente que se va a registrar.</param>
        <param name="addScriptTags">Valor booleano que indica si se agregan etiquetas de script.</param>
        <summary>Registra el script de cliente con el objeto <see cref="T:System.Web.UI.Page" /> utilizando un tipo, clave, literal de script y valor booleano que indican si se agregan etiquetas de script.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un script de cliente se identifica mediante su clave y su tipo. Las secuencias de comandos con la misma clave y tipo se consideran duplicadas. Con la página, se puede registrar un único script con un tipo determinado y un par de claves. Al intentar registrar un script que ya está registrado, no crea un duplicado de la secuencia de comandos.  
  
 Llame a la <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> método para determinar si ya está registrado un script de cliente con un par de clave y un tipo determinado. Esto le permite evitar innecesariamente agregar la secuencia de comandos.  
  
 En esta sobrecarga de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método, puede indicar si el script proporcionado en el `script` parámetro se ajusta con un `<script>` bloque del elemento mediante el uso de la `addScriptTags` parámetro. Establecer `addScriptTags` a `true` indica que se agregarán automáticamente las etiquetas de script.  
  
 El <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método agrega un bloque de script a la parte superior de la página representada. No se garantiza que los bloques de script se generen en el orden en que están registrados. Si es importante el orden de los bloques de script, use un <xref:System.Text.StringBuilder> de objetos para recopilar las secuencias de comandos en una sola cadena y, a continuación, registrarlas en un bloque de script de cliente único.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método. Tenga en cuenta que la `addScriptTags` parámetro está establecido en `true` para la apertura y cierre etiquetas de script no se incluye con el `script` parámetro.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El tipo del bloque de script de cliente es <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra la inclusión de script de cliente con el objeto <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(System::String ^ key, System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Clave de la inclusión de script de cliente que se va a registrar.</param>
        <param name="url">Dirección URL de la inclusión de script de cliente que se va a registrar.</param>
        <summary>Registra el script de cliente con el objeto <see cref="T:System.Web.UI.Page" /> utilizando una clave y una dirección URL que permiten que se llame desde el script del cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Incluir un script de cliente se identifica mediante su clave y su tipo. Las secuencias de comandos con la misma clave y tipo se consideran duplicadas. Con la página, se puede registrar un único script con un tipo determinado y un par de claves. Al intentar registrar un script que ya está registrado, no crea un duplicado de la secuencia de comandos.  
  
 Llame a la <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> método para determinar si una secuencia de comandos de cliente se incluyen con una clave dada y par de tipo ya está registrada y evitar innecesariamente agregar la secuencia de comandos.  
  
> [!NOTE]
>  Para resolver la dirección URL del cliente, use el <xref:System.Web.UI.Control.ResolveClientUrl%2A> método. Este método utiliza el contexto de la dirección URL en la que se llama para resolver la ruta de acceso.  
  
 Esta sobrecarga de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> método llama a la sobrecarga que toma un `key`, `URL`y un `type` parámetro.  
  
 El método agrega un bloque de script en la parte superior de la página presentada.  
  
   
  
## Examples  
 Para obtener información relacionada, incluida la sintaxis, uso y un ejemplo, vea <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de la inclusión de script de cliente que se va a registrar.</param>
        <param name="key">Clave de la inclusión de script de cliente que se va a registrar.</param>
        <param name="url">Dirección URL de la inclusión de script de cliente que se va a registrar.</param>
        <summary>Registra la inclusión de script de cliente con el objeto <see cref="T:System.Web.UI.Page" /> utilizando un tipo, una clave y una dirección URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> método toma *clave* y *url* parámetros para identificar la secuencia de comandos, así como un `type` parámetro para especificar la identificación de la secuencia de comandos de cliente que incluya. Especifique el tipo basándose en el objeto que se va a tener acceso al recurso. Por ejemplo, cuando se usa un `Page` instancia para tener acceso al recurso, especifique el `Page` tipo.  
  
> [!NOTE]
>  Para resolver la dirección URL del cliente, use el <xref:System.Web.UI.Control.ResolveClientUrl%2A> método. Este método utiliza el contexto de la dirección URL en la que se llama para resolver la ruta de acceso.  
  
 Este método agrega un bloque de script en la parte superior de la página presentada.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> método. Tenga en cuenta que si se quita la lógica para comprobar la inclusión de la secuencia de comandos de cliente existente, podría no haber scripts de cliente duplicados en la página presentada porque el <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> método comprueba los duplicados. La ventaja de la comprobación es reducir los cálculos innecesarios.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 Este ejemplo requiere un archivo JavaScript denominado Script_include.js con el siguiente contenido:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El tipo de inclusión de script de cliente es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La dirección URL es <see langword="null" />.  
  
 \- o -  
  
 URL está vacío.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptResource(Type ^ type, System::String ^ resourceName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo del recurso de script de cliente que se va a registrar.</param>
        <param name="resourceName">Nombre del recurso de script de cliente que se va a registrar.</param>
        <summary>Registra el recurso de script de cliente con el objeto <see cref="T:System.Web.UI.Page" /> utilizando un tipo y un nombre de recurso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> método se utiliza cuando se obtiene acceso a recursos compilados desde ensamblados a través del controlador HTTP WebResource.axd. El <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> método registra el script con el <xref:System.Web.UI.Page> de objetos y evita los script duplicados. Este método ajusta el contenido de la dirección URL de recurso con un `<script>` bloque del elemento.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> método.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 En el ejemplo de código siguiente se muestra cómo aplicar mediante programación el <xref:System.Web.UI.WebResourceAttribute> atributo de metadatos para marcar el ensamblado para los recursos que se enviarán.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 Este ejemplo requiere un archivo JavaScript denominado `Script_include.js`, con el siguiente contenido:  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 Compile el `Script_include.js` archivo como un recurso en el `Samples.AspNet.CS.Controls` ensamblado que contiene el `ClientScriptResourceLabel` clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El nombre del recurso de cliente es <see langword="null" />.  
  
 \- o -  
  
 El nombre del recurso de cliente tiene una longitud de cero.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra un par de nombre y valor como atributo personalizado (expando) del control especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId">Control <see cref="T:System.Web.UI.Control" /> en la página que contiene el atributo personalizado.</param>
        <param name="attributeName">Nombre del atributo personalizado que se va a registrar.</param>
        <param name="attributeValue">Valor del atributo personalizado.</param>
        <summary>Registra un par de nombre y valor como atributo personalizado (expando) del control especificado incluyendo un Id. de control, nombre de atributo y valor de atributo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> método registra un par de nombre/valor como un atributo personalizado (expando) en las clases <xref:System.Web.UI.Control>. El atributo expando se establece dinámicamente desde JavaScript para conservar la compatibilidad de XHTML con marcado del control representado. Se escapan las comillas y barras diagonales inversas en valores de atributo personalizado (expando). Si no desea utilizar comillas y barras diagonales inversas de escape, llame a la <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> sobrecarga de método y establezca la `encode` parámetro `false`.  
  
 Si no se encuentra el atributo expando o no se encuentra el control para agregar el atributo expando, todavía se genera el script de cliente, pero no afectará al control.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String, encode As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId">Control <see cref="T:System.Web.UI.Control" /> en la página que contiene el atributo personalizado.</param>
        <param name="attributeName">Nombre del atributo personalizado que se va a registrar.</param>
        <param name="attributeValue">Valor del atributo personalizado.</param>
        <param name="encode">Valor booleano que indica si se codifica el atributo personalizado que se va a registrar.</param>
        <summary>Registra un par de nombre y valor como atributo personalizado (expando) del control especificado proporcionando un Id. de control, un nombre de atributo, un valor de atributo y un valor booleano que indica si se codifica el valor de atributo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> método registra un par de nombre/valor como un atributo personalizado (expando) en las clases <xref:System.Web.UI.Control>. El atributo expando se establece dinámicamente desde JavaScript para conservar la compatibilidad de XHTML con marcado del control representado. Establecer el `encode` parámetro `true` si necesita utilizar comillas y barras diagonales inversas en el valor de su atributo expando escape.  
  
 Si no se encuentra el atributo expando o no se encuentra el control para agregar el atributo expando, todavía se genera el script de cliente, pero no afectará al control.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> método de la <xref:System.Web.UI.ClientScriptManager> clase. El script de cliente en los conjuntos de la página representada la `title` atributo de un `<span>` elemento.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra una referencia de evento para su validación.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Identificador único que representa el control de cliente que genera el evento.</param>
        <summary>Registra una referencia de evento para su validación con un identificador de control único que representa el control de cliente que genera el evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información y ejemplos, vea el <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> método y <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> método con el fin de registrar una devolución de llamada para la validación y cómo validar que la devolución de llamada se origina en la página.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (options As PostBackOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::Web::UI::PostBackOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">Objeto <see cref="T:System.Web.UI.PostBackOptions" /> que especifica cómo se genera el código JavaScript de cliente para iniciar un evento de postback.</param>
        <summary>Registra una referencia de evento para su validación con <see cref="T:System.Web.UI.PostBackOptions" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información y ejemplos, vea el <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Identificador único que representa el control de cliente que genera el evento.</param>
        <param name="argument">Argumentos de evento que se pasan con el evento de cliente.</param>
        <summary>Registra una referencia de evento para su validación con un identificador de control único y argumentos de evento que representan el control de cliente que genera el evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> método y <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> método para registrar una devolución de llamada para la validación y para validar que la devolución de llamada se origina en la página. Para mejorar la validación se muestra en el ejemplo, puede modificar la validación `argument` parámetro para incluir información específica del usuario como una identidad o función  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> método para registrar una devolución de llamada para la validación.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llama al método antes del método <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Nombre del campo oculto que se va a registrar.</param>
        <param name="hiddenFieldInitialValue">Valor inicial del campo que se va a registrar.</param>
        <summary>Registra un valor oculto con el objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> método crea oculto `<input>` elemento de la página HTML representada.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> y <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> métodos. En el ejemplo se registra una matriz y un valor oculto y define la `OnClick` eventos de un `<input>` botón para calcular la suma de dos valores de la matriz y el valor hidden.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hiddenFieldName" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de la instrucción OnSubmit que se va a registrar.</param>
        <param name="key">Clave de la instrucción OnSubmit que se va a registrar.</param>
        <param name="script">Literal de script de la instrucción OnSubmit que se va a registrar.</param>
        <summary>Registra una instrucción OnSubmit con el objeto <see cref="T:System.Web.UI.Page" /> utilizando un tipo, una clave y un literal de script. La instrucción se ejecuta cuando se envía el objeto <see cref="T:System.Web.UI.HtmlControls.HtmlForm" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una instrucción OnSubmit se identifica mediante su clave y su tipo. Instrucciones con la misma clave y tipo se consideran duplicadas. Solo una instrucción con un tipo determinado y un par de claves se puede registrar con la página. Al intentar registrar una instrucción que ya está registrada, no creará un duplicado de la instrucción.  
  
 Llame a la <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> método para determinar si una instrucción OnSubmit ya está registrada con un par de clave y un tipo determinado y evitar innecesariamente agregar la secuencia de comandos.  
  
 El `script` parámetro de la <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> método puede contener varios comandos de script, siempre que están correctamente delimitadas con un punto y coma (;).  
  
 El <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> agrega una secuencia de comandos que se ejecuta antes de enviar la página y le da la oportunidad de cancelar el envío.  
  
 Para obtener más información sobre los formularios HTML y el `OnSubmit` de atributo, vea la [sitio Web de World Wide Web Consortium (W3C)](http://go.microsoft.com/fwlink/?linkid=37125).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> método.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra el script de inicio con el objeto <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo del script de inicio que se va a registrar.</param>
        <param name="key">Clave del script de inicio que se va a registrar.</param>
        <param name="script">Literal del script de inicio que se va a registrar.</param>
        <summary>Registra el script de inicio con el objeto <see cref="T:System.Web.UI.Page" /> utilizando un tipo, una clave y un literal de script.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un script de cliente se identifica mediante su clave y su tipo. Las secuencias de comandos con la misma clave y tipo se consideran duplicadas. Con la página, se puede registrar un único script con un tipo determinado y un par de claves. Al intentar registrar un script que ya está registrado, no crea un duplicado de la secuencia de comandos.  
  
 Llame a la <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> método para determinar si ya está registrado un script de inicio con un par de clave y un tipo determinado y evitar innecesariamente agregar la secuencia de comandos.  
  
 En esta sobrecarga de la <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> método, debe asegurarse de que el script proporcionado en el `script` parámetro se ajusta con un `<script>` bloque del elemento.  
  
 El bloque de script agregado por el <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> el método se ejecuta cuando finaliza la carga de la página, pero antes de la página <xref:System.Web.UI.Control.OnLoad%2A> evento se desencadena. No se garantiza que los bloques de script se generen en el orden en que están registrados. Si es importante el orden de los bloques de script, use un <xref:System.Text.StringBuilder> de objetos para recopilar las secuencias de comandos en una sola cadena y, a continuación, registrarlas en un bloque de script de cliente único.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> método. Tenga en cuenta que la apertura y cierre etiquetas de script se incluyen dentro de la `script` parámetro. Que el script agregadas las etiquetas en función de un valor del parámetro adicional, consulte el <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> método.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Tipo del script de inicio que se va a registrar.</param>
        <param name="key">Clave del script de inicio que se va a registrar.</param>
        <param name="script">Literal del script de inicio que se va a registrar.</param>
        <param name="addScriptTags">Valor booleano que indica si se agregan etiquetas de script.</param>
        <summary>Registra el script de inicio con el objeto <see cref="T:System.Web.UI.Page" /> utilizando un tipo, una clave, un literal de script y un valor booleano que indican si se agregan etiquetas de script.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un script de inicio se identifica mediante su clave y su tipo. Las secuencias de comandos con la misma clave y tipo se consideran duplicadas. Con la página, se puede registrar un único script con un tipo determinado y un par de claves. Al intentar registrar un script que ya está registrado, no crea un duplicado de la secuencia de comandos.  
  
 Llame a la <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> método para determinar si ya está registrado un script de inicio con un par de clave y un tipo determinado y evitar innecesariamente agregar la secuencia de comandos.  
  
 En esta sobrecarga de la <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> método, puede indicar si el script proporcionado en el `script` parámetro se ajusta con un `<script>` bloque del elemento mediante el uso de la `addScriptTags` parámetro. Establecer `addScriptTags` a `true` indica que se agregarán automáticamente las etiquetas de script.  
  
 El bloque de script agregado por el <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> el método se ejecuta cuando finaliza la carga de la página, pero antes de la página <xref:System.Web.UI.Control.OnLoad%2A> evento se desencadena. No se garantiza que los bloques de script se generen en el orden en que están registrados. Si es importante el orden de los bloques de script, use un <xref:System.Text.StringBuilder> de objetos para recopilar las secuencias de comandos en una sola cadena y, a continuación, registrarlas en un bloque de script de cliente único.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> método. Tenga en cuenta que la `addScriptTags` parámetro está establecido en `false` para la apertura y cierre etiquetas de script se incluyen con el `script` parámetro.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Valida un evento de cliente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Identificador único que representa el control de cliente que genera el evento.</param>
        <summary>Valida un evento de cliente que se registró para la validación de eventos mediante el método <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Identificador único que representa el control de cliente que genera el evento.</param>
        <param name="argument">Los argumentos de evento que se pasan con el evento de cliente.</param>
        <summary>Valida un evento de cliente que se registró para la validación de eventos mediante el método <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> método y <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> método para registrar una devolución de llamada para la validación y para validar que la devolución de llamada se origina en la página. Para mejorar la validación se muestra a continuación, puede modificar la validación `argument` parámetro para incluir información específica del usuario como una identidad o función  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uniqueId" /> es <see langword="null" /> o una cadena vacía ("").</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>