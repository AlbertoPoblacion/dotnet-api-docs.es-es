<Type Name="Control" FullName="System.Web.UI.Control">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c5e204b7a88d9c05e9f718f5fcc598809702c48c" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30610879" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Control : IDisposable, System.ComponentModel.IComponent, System.Web.UI.IControlBuilderAccessor, System.Web.UI.IControlDesignerAccessor, System.Web.UI.IDataBindingsAccessor, System.Web.UI.IExpressionsAccessor, System.Web.UI.IParserAccessor, System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Control extends System.Object implements class System.ComponentModel.IComponent, class System.IDisposable, class System.Web.UI.IControlBuilderAccessor, class System.Web.UI.IControlDesignerAccessor, class System.Web.UI.IDataBindingsAccessor, class System.Web.UI.IExpressionsAccessor, class System.Web.UI.IParserAccessor, class System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Implements IComponent, IControlBuilderAccessor, IControlDesignerAccessor, IDataBindingsAccessor, IDisposable, IExpressionsAccessor, IParserAccessor, IUrlResolutionService" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : IDisposable, System::ComponentModel::IComponent, System::Web::UI::IControlBuilderAccessor, System::Web::UI::IControlDesignerAccessor, System::Web::UI::IDataBindingsAccessor, System::Web::UI::IExpressionsAccessor, System::Web::UI::IParserAccessor, System::Web::UI::IUrlResolutionService" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlBuilderAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlDesignerAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IDataBindingsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IExpressionsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IParserAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IUrlResolutionService</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("ID")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Code")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Define las propiedades, los métodos y los eventos que comparten todos los controles de servidor ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ésta es la clase principal que se derivan de al desarrollar controles de servidor ASP.NET personalizados. <xref:System.Web.UI.Control> no tiene ninguna característica específica de interfaz de usuario. Si va a crear un control que no tiene una interfaz de usuario o que combina otros controles que generan sus propias interfaces de usuario, que se derivan de <xref:System.Web.UI.Control>. Si va a crear un control que tiene una interfaz de usuario, que se derivan de <xref:System.Web.UI.WebControls.WebControl> o cualquier control que implemente en la <xref:System.Web.UI.WebControls> espacio de nombres que proporciona una adecuado a partir de punto para el control personalizado.  
  
 La <xref:System.Web.UI.Control> clase es la clase base para todos los controles de servidor ASP.NET, incluidos los controles personalizados, los controles de usuario y páginas. Las páginas ASP.NET son instancias de la <xref:System.Web.UI.Page> (clase), que se hereda de la <xref:System.Web.UI.Control> clase y que controlan las solicitudes de archivos que tienen una extensión .aspx.  
  
 La <xref:System.Web.UI.Control> clase directa o indirectamente se puede usar como parte de la interfaz de usuario para la aplicación Web y como tal se debe estudiar para hacer que los procedimientos recomendados para escribir código seguro y proteger las aplicaciones se siguen.  
  
 Para obtener información general acerca de estos temas, consulte [Overview of Web Application Security Threats](http://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a), [NIB: Security Policy Best Practices](http://msdn.microsoft.com/library/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05), y [conceptos clave de seguridad](~/docs/standard/security/key-security-concepts.md). Para más información, consulte [protección de los controles estándar](http://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8), [Cómo: mostrar mensajes de Error seguros](http://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa), [Cómo: proteger frente a ataques mediante secuencias de una aplicación Web mediante la aplicación de la codificación de HTML a cadenas](http://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b), y [Introducción a los controles de validación](http://msdn.microsoft.com/library/3c0e7514-cff2-4bed-936d-ee3f7b740190).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un control de servidor personalizado que se deriva de la <xref:System.Web.UI.Control> clase. El `InnerContent` clase invalida la <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> método, se comprueba para ver si la clase tiene todos los controles secundarios en la página y determina si el primer elemento secundario del control es un control del literal. Si se cumplen ambas condiciones, el método reemplazado escribe la cadena HTML \<H2 > el mensaje:, el contenido del control literal y un cierre  \< /h2 > etiqueta a la página de formularios Web Forms.  
  
> [!IMPORTANT]
>  Este ejemplo tiene un cuadro de texto que acepta datos proporcionados por el usuario, lo que puede suponer una amenaza para la seguridad. De forma predeterminada, ASP.NET Web Pages valida que los datos proporcionados por el usuario no incluyen elementos HTML ni de script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Classic Control Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control Example/CS/source.cs#1)]
 [!code-vb[Classic Control Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="T:System.Web.UI.TemplateControl" />
    <altmember cref="T:System.Web.UI.LiteralControl" />
    <altmember cref="T:System.Web.UI.WebControls.WebControl" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Web.UI.Control" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Adapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.ControlAdapter Adapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.ControlAdapter Adapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Adapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Adapter As ControlAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::ControlAdapter ^ Adapter { System::Web::UI::Adapters::ControlAdapter ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el adaptador específico del explorador para el control.</summary>
        <value>Objeto <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> para este control. Si el explorador de destino no requiere ningún adaptador, devuelve <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las páginas Web ASP.NET son utilizables en una amplia variedad de dispositivos y exploradores que pueden solicitar información de la Web. El <xref:System.Web.UI.Control.Adapter%2A> propiedad devuelve el <xref:System.Web.UI.Adapters.ControlAdapter> objeto que representa el control en la pantalla del explorador o el dispositivo que lo solicitado.  
  
 Para obtener más información acerca de los adaptadores, vea [arquitectura Overview of Adaptive Control Behavior](http://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
      </Docs>
    </Member>
    <Member MemberName="AddedControl">
      <MemberSignature Language="C#" Value="protected internal virtual void AddedControl (System.Web.UI.Control control, int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void AddedControl(class System.Web.UI.Control control, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void AddedControl(System::Web::UI::Control ^ control, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.Control" /> que se agregó.</param>
        <param name="index">Índice del control de la colección <see cref="P:System.Web.UI.Control.Controls" />.</param>
        <summary>Se llama después de agregar un control secundario a la colección <see cref="P:System.Web.UI.Control.Controls" /> del objeto <see cref="T:System.Web.UI.Control" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Control.AddedControl%2A> método se llama inmediatamente después de agrega un control a la <xref:System.Web.UI.Control.Controls%2A> colección.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="control" /> es un control <see cref="T:System.Web.UI.WebControls.Substitution" />.</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AddParsedSubObject">
      <MemberSignature Language="C#" Value="protected virtual void AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddParsedSubObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddParsedSubObject (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddParsedSubObject(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Object" /> que representa el elemento analizado.</param>
        <summary>Notifica al control de servidor que se analizó un elemento, ya sea XML o HTML, y agrega el elemento al objeto <see cref="T:System.Web.UI.ControlCollection" /> del control del servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A menos que se reemplace, este método agrega automáticamente <xref:System.Web.UI.LiteralControl> objetos para el control de servidor <xref:System.Web.UI.ControlCollection> objeto. Esta colección es accesible a través de <xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType> propiedad.  
  
   
  
## Examples  
 El ejemplo siguiente es un control de servidor personalizado que utiliza el <xref:System.Web.UI.Control.AddParsedSubObject%2A> son el método para determinar si los elementos declarados entre las etiquetas de cierre de este control y apertura <xref:System.Web.UI.WebControls.TextBox> controles de servidor Web. Si es así, se agregan a un <xref:System.Collections.ArrayList> objeto, `items`. Cuando el invalidado <xref:System.Web.UI.Control.CreateChildControls%2A> método se llama, se recorre en iteración la <xref:System.Collections.ArrayList> y agrega cada objeto en la misma para el <xref:System.Web.UI.ControlCollection> del control de servidor personalizado.  
  
> [!IMPORTANT]
>  Este ejemplo tiene un cuadro de texto que acepta datos proporcionados por el usuario, lo que puede suponer una amenaza para la seguridad. De forma predeterminada, ASP.NET Web Pages valida que los datos proporcionados por el usuario no incluyen elementos HTML ni de script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Control_AddParsedSubObject#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_AddParsedSubObject/CS/control_addparsedsubobject.cs#1)]
 [!code-vb[Control_AddParsedSubObject#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_AddParsedSubObject/VB/control_addparsedsubobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ApplyStyleSheetSkin">
      <MemberSignature Language="C#" Value="public virtual void ApplyStyleSheetSkin (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyStyleSheetSkin(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ApplyStyleSheetSkin(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyStyleSheetSkin(System::Web::UI::Page ^ page);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">
          <see cref="T:System.Web.UI.Page" /> que contiene el control.</param>
        <summary>Aplica al control las propiedades de estilo definidas en la hoja de estilos de la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> método establece las propiedades de estilo en el control basándose en Propiedades de máscara definidas en un directorio de temas. La máscara que se aplica es la máscara de acceso predeterminada para el control o la máscara especificada en el <xref:System.Web.UI.Control.SkinID%2A> propiedad. El <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> método se llama ASP.NET para controles declarativos situados en una página. Debe llamar a la <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> método los controles que se crea mediante programación en tiempo de ejecución para estilo máscaras de hoja para aplicar al control. Las máscaras de tema se aplican automáticamente. Para obtener más información acerca de la diferencia entre temas y hojas de estilos en cascada, consulte [ASP.NET temas y máscaras](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La hoja de estilos ya se ha aplicado.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeTemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public string AppRelativeTemplateSourceDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property AppRelativeTemplateSourceDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeTemplateSourceDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el directorio virtual relativo a la aplicación del objeto <see cref="T:System.Web.UI.Page" /> o el objeto <see cref="T:System.Web.UI.UserControl" /> que contiene este control.</summary>
        <value>Directorio virtual relativo a la aplicación del control de página o de usuario que contiene este control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> propiedad contiene la ruta de acceso relativa a la aplicación a la página o control de usuario que contiene el control actual. Por ejemplo, si la página Web reside en http://www.contoso.com/application/subdirectory, el <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> propiedad devuelve "~ / subdirectorio".  
  
 Para devolver la ruta de acceso virtual ("application/subdirectory"), use el <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenderTracing">
      <MemberSignature Language="C#" Value="protected void BeginRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BeginRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BeginRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BeginRenderTracing (writer As TextWriter, traceObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BeginRenderTracing(System::IO::TextWriter ^ writer, System::Object ^ traceObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="traceObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">El objeto que escribe datos de seguimiento.</param>
        <param name="traceObject">El objeto de seguimiento.</param>
        <summary>Comienza el seguimiento en tiempo de diseño de los datos de representación.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control BindingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control BindingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.BindingContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BindingContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ BindingContainer { System::Web::UI::Control ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el control que contiene el enlace de datos de este control.</summary>
        <value>
          <see cref="T:System.Web.UI.Control" /> que contiene el enlace de datos de este control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Control.BindingContainer%2A> propiedad contiene una referencia a la <xref:System.Web.UI.Control> objeto que contiene la información de enlace de datos para el control actual.  
  
 El <xref:System.Web.UI.Control.BindingContainer%2A> propiedad es el mismo que el <xref:System.Web.UI.Control.NamingContainer%2A> propiedad, excepto cuando el control forma parte de una plantilla. En ese caso, el <xref:System.Web.UI.Control.BindingContainer%2A> propiedad está establecida en el <xref:System.Web.UI.Control> que define la plantilla.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="BuildProfileTree">
      <MemberSignature Language="C#" Value="protected void BuildProfileTree (string parentId, bool calcViewState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BuildProfileTree(string parentId, bool calcViewState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BuildProfileTree(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BuildProfileTree (parentId As String, calcViewState As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BuildProfileTree(System::String ^ parentId, bool calcViewState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentId" Type="System.String" />
        <Parameter Name="calcViewState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="parentId">Identificador del control principal del control.</param>
        <param name="calcViewState">Valor de tipo Boolean que indica si se calcula el tamaño del estado de vista.</param>
        <summary>Recopila información sobre el control de servidor y la pasa a la propiedad <see cref="P:System.Web.UI.Page.Trace" /> para que se muestre cuando está habilitada la traza de la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad recopila la información necesaria acerca de la jerarquía de la interfaz de usuario de la página y la pasa a la página [ &lt;seguimiento&gt; ](~/docs/framework/configure-apps/file-schema/trace-debug/trace-element.md) propiedad. Cuando se habilita el seguimiento para una página o para la aplicación, esta información se muestra en la `Control Tree` sección de la salida del seguimiento. Resultado del seguimiento de una página se anexa al final de la página; mientras que los resultados de seguimiento para una aplicación pueden verse desde el Visor de seguimiento (trace.axd archivo) que se almacena en el directorio raíz de la aplicación. Para obtener más información acerca del seguimiento, vea [información general de traza de ASP.NET](http://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildControlsCreated">
      <MemberSignature Language="C#" Value="protected bool ChildControlsCreated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ChildControlsCreated" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ChildControlsCreated" />
      <MemberSignature Language="VB.NET" Value="Protected Property ChildControlsCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ChildControlsCreated { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se han creado controles secundarios del control de servidor.</summary>
        <value>
          Es <see langword="true" /> si se han creado controles secundarios; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra una invalidación de la <xref:System.Web.UI.Control.OnDataBinding%2A> método personalizado <xref:System.Web.UI.WebControls.Repeater> control. Para asegurarse de que no se crean controles secundarios hasta que el enlace de datos se produce de nuevo, el <xref:System.Web.UI.Control.ChildControlsCreated%2A> propiedad está establecida en `true` después de la <xref:System.Web.UI.WebControls.RepeaterItem> objetos se crean y agregan al control <xref:System.Web.UI.ControlCollection> objeto.  
  
 [!code-csharp[TemplatedDataBoundControl3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/customrepeater.cs#1)]
 [!code-vb[TemplatedDataBoundControl3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/customrepeater.vb#1)]  
  
 En el ejemplo siguiente se muestra cómo utilizar el control de repetidor personalizado en una página Web.  
  
 [!code-aspx-csharp[TemplatedDataBoundControl3#2](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/default.aspx#2)]
 [!code-aspx-vb[TemplatedDataBoundControl3#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/default.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="ClearCachedClientID">
      <MemberSignature Language="C#" Value="protected void ClearCachedClientID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearCachedClientID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearCachedClientID" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearCachedClientID ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearCachedClientID();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establece en <see langword="null" /> el valor de <see cref="P:System.Web.UI.Control.ClientID" /> almacenado en caché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChildControlState">
      <MemberSignature Language="C#" Value="protected void ClearChildControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildControlState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildControlState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina la información sobre el estado de control de los controles secundarios del control de servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Control.ClearChildControlState%2A> método se utiliza cuando se reemplaza la información de estado del control secundario escrita en estado de control del control primario cuando se crean nuevos controles secundarios, por ejemplo, cuando controla el enlace de datos secundarios en un control de servidor enlazado a datos con plantilla. Llamar a la <xref:System.Web.UI.Control.ClearChildControlState%2A> método para vaciar los controles secundarios antes de llamar a la <xref:System.Web.UI.Control.SaveControlState%2A> método reduce el tamaño de la información de estado del control que se debe almacenar o transmitir.  
  
 Al volver a crear los controles secundarios de un <xref:System.Web.UI.Control> objeto, utilice el <xref:System.Web.UI.Control.ClearChildControlState%2A> método para borrar el estado del control secundario y no se aplique a los nuevos controles sin darse cuenta.  
  
 Para borrar el estado del control secundario y el estado de vista, use la <xref:System.Web.UI.Control.ClearChildState%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildState">
      <MemberSignature Language="C#" Value="protected void ClearChildState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina la información sobre el estado de vista y el estado de control de los controles secundarios del control de servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Control.ClearChildState%2A> método borra toda la información de estado de vista y el estado de control para los controles secundarios. Es equivalente a llamar a la <xref:System.Web.UI.Control.ClearChildViewState%2A> método y <xref:System.Web.UI.Control.ClearChildControlState%2A> método.  
  
 Al volver a crear los controles secundarios de un <xref:System.Web.UI.Control> objeto, utilice el <xref:System.Web.UI.Control.ClearChildState%2A> método para borrar el estado secundario y no se aplique a los nuevos controles sin darse cuenta.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo invalidar el <xref:System.Web.UI.Control.OnDataBinding%2A> método para un control enlazado a datos con plantilla. Si el origen de datos que se enlaza el control está lleno, el control <xref:System.Web.UI.ControlCollection> colección se vacía mediante el <xref:System.Web.UI.ControlCollection.Clear%2A> método y el <xref:System.Web.UI.Control.ClearChildState%2A> método se usa para quitar cualquier información de estado que se haya guardado para los controles secundarios.  
  
 [!code-csharp[TemplatedDataBoundControl2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl2/cs/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl2/vb/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildViewState">
      <MemberSignature Language="C#" Value="protected void ClearChildViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildViewState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina la información sobre el estado de vista de todos los controles secundarios del control de servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza normalmente cuando se reemplaza el <xref:System.Web.UI.Control.DataBind%2A> método al desarrollar controles de servidor enlazado a datos con plantilla. Si no se llama a este método, información de estado de la vista de control de secundarios puede escribirse en un control de servidor principal, solo para invalidarse cuando se enlazan a los datos.  
  
 Al volver a crear los controles secundarios de un <xref:System.Web.UI.Control>, use el <xref:System.Web.UI.Control.ClearChildViewState%2A> método para borrar el estado de vista secundario y no se aplique a los nuevos controles sin darse cuenta.  
  
 Para obtener más información acerca de cómo utilizar este método, consulte [Cómo: crear controles de usuario de ASP.NET con plantilla](http://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
      </Docs>
    </Member>
    <Member MemberName="ClearEffectiveClientIDMode">
      <MemberSignature Language="C#" Value="protected void ClearEffectiveClientIDMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearEffectiveClientIDMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearEffectiveClientIDMode" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearEffectiveClientIDMode ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearEffectiveClientIDMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establece la propiedad <see cref="P:System.Web.UI.Control.ClientIDMode" /> de la instancia del control actual y de cualquier control secundario en <see cref="F:System.Web.UI.ClientIDMode.Inherit" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientID">
      <MemberSignature Language="C#" Value="public virtual string ClientID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ClientID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ClientID { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el id. de control para marcado HTML que se genera por ASP.NET.</summary>
        <value>Id. de control para marcado HTML que se genera por ASP.NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un control de servidor Web se representa como un elemento HTML, el `id` atributo del elemento HTML se establece en el valor de la <xref:System.Web.UI.Control.ClientID%2A> propiedad. El <xref:System.Web.UI.Control.ClientID%2A> valor a menudo se utiliza para tener acceso al elemento HTML en el script de cliente mediante el uso de la `document.getElementById` método. El identificador se usa a menudo, también en las reglas de CSS para especificar elementos para crear estilos. Por ejemplo, la siguiente regla de estilo CSS selecciona todos los `span` elementos que tienen la `id` valor del atributo `ProductIDLabel` y establece su `background-color` atribuir a `white`:  
  
```  
span#ProductIDLabel { background-color: white; }  
```  
  
 ASP.NET proporciona varios algoritmos para generar el <xref:System.Web.UI.Control.ClientID%2A> valor de propiedad. Seleccione qué algoritmo debe utilizar para un control estableciendo su <xref:System.Web.UI.Control.ClientIDMode%2A> propiedad. Los algoritmos se identifican por la <xref:System.Web.UI.ClientIDMode> valores de enumeración que se muestran en la tabla siguiente.  
  
|Valor|Descripción|  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|El valor <xref:System.Web.UI.Control.ClientID%2A> se genera mediante la concatenación de los valores <xref:System.Web.UI.Control.ID%2A> de cada contenedor de nomenclatura primario con el valor <xref:System.Web.UI.Control.ID%2A> del control. En escenarios de enlace de datos donde se presentan varias instancias de un control, se inserta un valor de incremento delante del valor <xref:System.Web.UI.Control.ID%2A> del control. Un carácter de subrayado (_) separa cada segmento. Este algoritmo se utilizó en versiones de ASP.NET anteriores a ASP.NET 4.|  
|<xref:System.Web.UI.ClientIDMode.Static>|El valor de <xref:System.Web.UI.Control.ClientID%2A> se establece en el valor de la propiedad <xref:System.Web.UI.Control.ID%2A>. Si el control es un contenedor de nomenclatura, se utiliza como la parte superior de la jerarquía de contenedores de nomenclatura para cualquier control que contenga.|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|Este algoritmo se utiliza para los controles que están en controles enlazados a datos. El valor <xref:System.Web.UI.Control.ClientID%2A> se genera mediante la concatenación del valor <xref:System.Web.UI.Control.ClientID%2A> del contenedor de nomenclatura primario con el valor <xref:System.Web.UI.Control.ID%2A> del control. Si se trata de un control enlazado a datos que genera varias filas, el valor del campo de datos especificado en la propiedad <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> se agrega al final. En el caso del control <xref:System.Web.UI.WebControls.GridView> se pueden especificar varios campos de datos. Si el <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> propiedad está en blanco, se agrega un número secuencial al final en lugar de un valor de campo de datos. Un carácter de subrayado (_) separa cada segmento.|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|El control hereda la configuración de <xref:System.Web.UI.ClientIDMode> de este control <xref:System.Web.UI.Control.NamingContainer%2A>.|  
  
 El valor predeterminado de <xref:System.Web.UI.Control.ClientIDMode%2A> para una página es <xref:System.Web.UI.ClientIDMode.Predictable>. El valor predeterminado de <xref:System.Web.UI.Control.ClientIDMode%2A> para un control es <xref:System.Web.UI.ClientIDMode.Inherit>. Dado que es el valor predeterminado para los controles <xref:System.Web.UI.ClientIDMode.Inherit>, la generación predeterminada es el modo <xref:System.Web.UI.ClientIDMode.Predictable>. (Sin embargo, si utiliza Visual Studio para convertir un proyecto Web a ASP.NET 4 desde una versión anterior, Visual Studio establece automáticamente el valor predeterminado de sitio en <xref:System.Web.UI.ClientIDMode.AutoID> en el archivo Web.config.)  
  
 Para obtener más información, vea [Identificación de controles de formularios Web Forms](http://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7).  
  
   
  
## Examples  
 Los ejemplos siguientes muestran un control de usuario Web que está dentro de una página de contenido de una página maestra. El control de usuario contiene una <xref:System.Web.UI.WebControls.DropDownList> control y un <xref:System.Web.UI.WebControls.Label> control. El texto que se muestra en el <xref:System.Web.UI.WebControls.Label> control viene determinado por el valor que el usuario selecciona en el <xref:System.Web.UI.WebControls.DropDownList> control. El valor de texto se establece a través de script de cliente para que la página Web no tiene que registrar en el servidor con el fin de establecer este valor. Para obtener una referencia al elemento HTML representado en el <xref:System.Web.UI.WebControls.Label> control en el script de cliente, debe conocer el valor del control <xref:System.Web.UI.Control.ClientID%2A> propiedad. Sin embargo, dado que el control de usuario se puede colocar en cualquier parte en una página Web, es imposible conocer de antemano qué contenedores de nomenclatura contendrán los controles. Para asegurarse de que el <xref:System.Web.UI.Control.ClientID%2A> valor será el mismo que el <xref:System.Web.UI.Control.ID%2A> valor, el código establece la <xref:System.Web.UI.Control.ClientIDMode%2A> valor a <xref:System.Web.UI.WebControls.ValidatorDisplay.Static>.  
  
 En el ejemplo siguiente se muestra el control de usuario.  
  
  
  
 En el ejemplo siguiente se muestra la página de contenido que contiene el control de usuario.  
  
  
  
 En el ejemplo siguiente se muestra la página maestra que contiene la página de contenido.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="ClientIDMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ClientIDMode ClientIDMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ClientIDMode ClientIDMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ClientIDMode As ClientIDMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ClientIDMode ClientIDMode { System::Web::UI::ClientIDMode get(); void set(System::Web::UI::ClientIDMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientIDMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el algoritmo que se utiliza para generar el valor de la propiedad <see cref="P:System.Web.UI.Control.ClientID" />.</summary>
        <value>Valor que indica cómo se genera la propiedad <see cref="P:System.Web.UI.Control.ClientID" />. El valor predeterminado es <see cref="F:System.Web.UI.ClientIDMode.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET proporciona varios algoritmos para generar el <xref:System.Web.UI.Control.ClientID%2A> valor de propiedad. Seleccione qué algoritmo debe utilizar para un control estableciendo su <xref:System.Web.UI.Control.ClientIDMode%2A> propiedad. Los algoritmos se identifican por la <xref:System.Web.UI.ClientIDMode> valores de enumeración que se muestran en la tabla siguiente.  
  
|Valor|Descripción|  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|El valor <xref:System.Web.UI.Control.ClientID%2A> se genera mediante la concatenación de los valores <xref:System.Web.UI.Control.ID%2A> de cada contenedor de nomenclatura primario con el valor <xref:System.Web.UI.Control.ID%2A> del control. En escenarios de enlace de datos donde se presentan varias instancias de un control, se inserta un valor de incremento delante del valor <xref:System.Web.UI.Control.ID%2A> del control. Un carácter de subrayado (_) separa cada segmento. Este algoritmo se utilizó en versiones de ASP.NET anteriores a ASP.NET 4.|  
|<xref:System.Web.UI.ClientIDMode.Static>|El valor de <xref:System.Web.UI.Control.ClientID%2A> se establece en el valor de la propiedad <xref:System.Web.UI.Control.ID%2A>. Si el control es un contenedor de nomenclatura, se utiliza como la parte superior de la jerarquía de contenedores de nomenclatura para cualquier control que contenga.|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|Este algoritmo se utiliza para los controles que están en controles enlazados a datos. El valor <xref:System.Web.UI.Control.ClientID%2A> se genera mediante la concatenación del valor <xref:System.Web.UI.Control.ClientID%2A> del contenedor de nomenclatura primario con el valor <xref:System.Web.UI.Control.ID%2A> del control. Si se trata de un control enlazado a datos que genera varias filas, el valor del campo de datos especificado en la propiedad <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> se agrega al final. En el caso del control <xref:System.Web.UI.WebControls.GridView> se pueden especificar varios campos de datos. Si el <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> propiedad está en blanco, se agrega un número secuencial al final en lugar de un valor de campo de datos. Este número comienza en cero y se incrementa en 1 para cada fila. Un carácter de subrayado (_) separa cada segmento.|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|El control hereda la configuración de <xref:System.Web.UI.ClientIDMode> de este control <xref:System.Web.UI.Control.NamingContainer%2A>.|  
  
 El valor predeterminado de <xref:System.Web.UI.Control.ClientIDMode%2A> para una página es <xref:System.Web.UI.ClientIDMode.Predictable>. El valor predeterminado de <xref:System.Web.UI.Control.ClientIDMode%2A> para un control es <xref:System.Web.UI.ClientIDMode.Inherit>. Dado que es el valor predeterminado para los controles <xref:System.Web.UI.ClientIDMode.Inherit>, la generación predeterminada es el modo <xref:System.Web.UI.ClientIDMode.Predictable>. (Sin embargo, si utiliza Visual Studio para convertir un proyecto Web a ASP.NET 4 desde una versión anterior, Visual Studio establece automáticamente el valor predeterminado de sitio en <xref:System.Web.UI.ClientIDMode.AutoID> en el archivo Web.config.)  
  
 Para obtener más información, vea [Identificación de controles de formularios Web Forms](http://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7).  
  
   
  
## Examples  
 El ejemplo siguiente muestra <xref:System.Web.UI.WebControls.Label> controles que se encuentran en un <xref:System.Web.UI.WebControls.ListView> control. En el <xref:System.Web.UI.WebControls.ListView> (control), el <xref:System.Web.UI.Control.ClientIDMode%2A> propiedad está establecida en <xref:System.Web.UI.ClientIDMode.Predictable> y <xref:System.Web.UI.WebControls.ListView.ClientIDRowSuffix%2A> propiedad está establecida en `ProductID`. En el HTML representado, esto crea tres `span` elementos que corresponden a tres `ProductIDLabel` controles. Cuando se ejecuta la página, el `id` atributos para el `span` elementos se establecen en los siguientes valores:  
  
-   `ListView1_ProductIDLabel_1`  
  
-   `ListView1_ProductIDLabel_34`  
  
-   `ListView1_ProductIDLabel_43`  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientIDSeparator">
      <MemberSignature Language="C#" Value="protected char ClientIDSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char ClientIDSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDSeparator" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ClientIDSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property char ClientIDSeparator { char get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor de carácter que representa el carácter separado utilizado en la propiedad <see cref="P:System.Web.UI.Control.ClientID" />.</summary>
        <value>Siempre devuelve el carácter de subrayado (_).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Control.ClientID%2A> valor se genera concatenando el <xref:System.Web.UI.Control.ID%2A> valor del control y la <xref:System.Web.UI.Control.UniqueID%2A> valor de su control primario. Cada parte de los botones generados <xref:System.Web.UI.Control.ID%2A> propiedad está separada por el <xref:System.Web.UI.Control.ClientIDSeparator%2A> valor de propiedad. El valor siempre devuelve un carácter de subrayado (_).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.ClientID" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.IdSeparator" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected internal virtual System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Context" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property Context As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Web::HttpContext ^ Context { System::Web::HttpContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.HttpContext" /> asociado al control de servidor para la solicitud Web actual.</summary>
        <value>Objeto <see cref="T:System.Web.HttpContext" /> especificado asociado a la solicitud actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad proporciona acceso a la <xref:System.Web.HttpContext> objeto de la solicitud Web actual. El objeto proporciona propiedades que tienen acceso a la <xref:System.Web.HttpContext.Application%2A>, <xref:System.Web.HttpContext.Session%2A>, <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A> y otros objetos que contienen información acerca de la solicitud HTTP actual. También proporciona métodos que permiten obtener información de configuración y establecer o borrar errores de la solicitud.  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#1)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Web.HttpApplication" />
        <altmember cref="T:System.Web.HttpServerUtility" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Web.UI.ControlCollection" /> que representa los controles secundarios de un control de servidor especificado en la jerarquía de la interfaz de usuario.</summary>
        <value>Colección de controles secundarios del control de servidor especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En una página ASP.NET, cuando se agregan controles mediante declaración entre la apertura y etiquetas de cierre de un control de servidor ASP.NET agrega automáticamente los controles para el control de servidor que contiene <xref:System.Web.UI.ControlCollection>. Las etiquetas HTML o las cadenas de texto que no se procesan en el servidor se tratan como <xref:System.Web.UI.LiteralControl> objetos. Se agregan a la colección como otros controles de servidor.  
  
 El <xref:System.Web.UI.Control.Controls%2A> propiedad permite obtener acceso mediante programación a la instancia de la <xref:System.Web.UI.ControlCollection> clase para cualquier control de servidor. Puede agregar controles a la colección, quitar controles de la colección o recorrer en iteración los controles de servidor en la colección.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo agregar controles secundarios a un control de servidor <xref:System.Web.UI.ControlCollection> objeto a través de su <xref:System.Web.UI.Control.Controls%2A> propiedad.  
  
 [!code-csharp[Classic Control.Controls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Controls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Controls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Controls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar el <see cref="P:System.Web.UI.Control.Controls" /> propiedad, no olvide llamar el <see cref="M:System.Web.UI.Control.EnsureChildControls" /> método. Además, si va a agregar controles a la colección de controles mediante programación, considere la posibilidad de agregar los controles en un invalidado <see cref="M:System.Web.UI.Control.CreateChildControls" /> método.</para>
        </block>
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lo llama el marco de páginas ASP.NET para indicar a los controles de servidor que usan la implementación basada en composición que creen los controles secundarios que contengan como forma de preparar la devolución o representación de los datos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al desarrollar un control de servidor compuesto o con plantilla, debe invalidar este método. Controles que la invalidación de la <xref:System.Web.UI.Control.CreateChildControls%2A> método debe implementar la <xref:System.Web.UI.INamingContainer> interfaz para evitar conflictos de nombres.  
  
 Para obtener más información, consulte [plantillas de controles de servidor Web](http://msdn.microsoft.com/library/f769d290-fd04-4084-85fc-4ea30dd2e8ae) y [desarrollar controles de servidor ASP.NET personalizado](http://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra una versión reemplazada de la <xref:System.Web.UI.Control.CreateChildControls%2A> método. En esta implementación, el control compuesto muestra un <xref:System.Web.UI.WebControls.TextBox> control incluido en dos controles literales que se procesan como HTML.  
  
> [!IMPORTANT]
>  Este ejemplo tiene un cuadro de texto que acepta datos proporcionados por el usuario, lo que puede suponer una amenaza para la seguridad. De forma predeterminada, ASP.NET Web Pages valida que los datos proporcionados por el usuario no incluyen elementos HTML ni de script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#2)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuevo objeto <see cref="T:System.Web.UI.ControlCollection" /> que contendrá los controles secundarios (de literal y servidor) del control de servidor.</summary>
        <returns>Objeto <see cref="T:System.Web.UI.ControlCollection" /> que va a contener los controles de servidor secundarios del control de servidor actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalide este método en un control de servidor personalizado, si ha creado un objeto de colección que se deriva de la <xref:System.Web.UI.ControlCollection> clase. A continuación, puede crear una instancia de esa clase de colección en la invalidación de este método.  
  
   
  
## Examples  
 El siguiente código de ejemplo reemplaza el <xref:System.Web.UI.Control.CreateControlCollection%2A> método para crear una instancia de un `CustomControlCollection` (clase), que se hereda de la <xref:System.Web.UI.ControlCollection> clase.  
  
 [!code-csharp[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/cs/controlcollection_7.cs#2)]
 [!code-vb[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/VB/controlcollection_7.vb#2)]  
  
 El siguiente ejemplo de código utiliza el <xref:System.Web.UI.Control.CreateControlCollection%2A> reemplazo del método en un control de servidor personalizado de la <xref:System.Web.UI.Control.CreateChildControls%2A> método. La nueva colección se crea y se rellena con dos controles secundarios, `firstControl` y `secondControl`.  
  
 [!code-csharp[Control_Sample_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#1)]
 [!code-vb[Control_Sample_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DataBind">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Enlaza un origen de datos al control de servidor invocado y a todos sus controles secundarios.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="public virtual void DataBind ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DataBind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DataBind ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DataBind();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enlaza un origen de datos al control de servidor invocado y a todos sus controles secundarios.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para enlazar datos desde un origen a un control de servidor. Este método se utiliza normalmente después de recuperar un conjunto de datos a través de una consulta de base de datos. Enlace de datos automáticamente, lo que significa que normalmente no debe llamar a este método explícitamente realiza la mayoría de los controles.  
  
 Este método es se reemplazan con frecuencia cuando se crea un control enlazado a datos con plantilla personalizado. Para obtener más información, consulte [Cómo: crear controles de usuario de ASP.NET con plantilla](http://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2) y [enlazados a datos de personalizado desarrollar controles de servidor Web](http://msdn.microsoft.com/library/88fe02a3-957f-4ff7-84f5-2d7ab78db4c1). Cuando se llama en un control de servidor, este método resuelve todas las expresiones de enlace de datos en el control de servidor y en cualquiera de sus controles secundarios.  
  
   
  
## Examples  
 El siguiente ejemplo se reemplaza el <xref:System.Web.UI.Control.DataBind%2A> método en un control de servidor ASP.NET personalizado. Inicia llamando a la base de <xref:System.Web.UI.Control.OnDataBinding%2A> método y, a continuación, utiliza el <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType> método para eliminar todos los controles secundarios y los <xref:System.Web.UI.Control.ClearChildViewState%2A> método para eliminar la configuración de estado de vista para los controles secundarios guardada. Por último, el <xref:System.Web.UI.Control.ChildControlsCreated%2A> propiedad está establecida en `true` y el control se indica a realizar el seguimiento de los cambios en el estado de vista de los controles recién creados con el <xref:System.Web.UI.Control.TrackViewState%2A> método. Esto es una técnica común al enlazar datos a un control para garantizar que los nuevos datos no entra en conflicto con los datos almacenados en una anterior <xref:System.Web.UI.Control.DataBind%2A> llamada al método.  
  
 [!code-csharp[Control_StateManagement#6](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#6)]
 [!code-vb[Control_StateManagement#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
      </Docs>
    </Member>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="protected virtual void DataBind (bool raiseOnDataBinding);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBind(bool raiseOnDataBinding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DataBind (raiseOnDataBinding As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DataBind(bool raiseOnDataBinding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="raiseOnDataBinding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="raiseOnDataBinding">
          <see langword="true" /> si se genera el evento <see cref="E:System.Web.UI.Control.DataBinding" />; en caso contrario, <see langword="false" />.</param>
        <summary>Enlaza un origen de datos al control de servidor que se ha invocado y a todos sus controles secundarios con una opción para generar el evento <see cref="E:System.Web.UI.Control.DataBinding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> método en un escenario cuando su control personalizado reemplaza la <xref:System.Web.UI.Control.DataBind%2A> método e implementa el <xref:System.Web.UI.IDataItemContainer> interfaz. En este escenario, el control personalizado llama el <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> método con `raiseOnDataBinding` establecido en `false` para asegurarse de que la clase base <xref:System.Web.UI.Control.DataBind%2A> se invoca el método.  
  
 El <xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType> método invoca el <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> método con `raiseOnDataBinding` establecido en `true`.  
  
> [!NOTE]
>  Llamar a la <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> método con `raiseOnDataBinding` establecido en `false` hace que todos los controles se enlazan con a datos el <xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
      </Docs>
    </Member>
    <Member MemberName="DataBindChildren">
      <MemberSignature Language="C#" Value="protected virtual void DataBindChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBindChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBindChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DataBindChildren ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DataBindChildren();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enlaza un origen de datos a los controles secundarios del control de servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Web.UI.Control.DataBindChildren%2A> método para enlazar un origen de datos a los controles secundarios de un control de servidor.  
  
> [!NOTE]
>  Cuando se llama en un control de servidor, este método no enlazar datos al control. Para enlazar un control de servidor y todos sus controles secundarios, llame a la <xref:System.Web.UI.Control.DataBind%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataBinding">
      <MemberSignature Language="C#" Value="public event EventHandler DataBinding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataBinding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.DataBinding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataBinding As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataBinding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el control de servidor se enlaza a un origen de datos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento notifica al control de servidor para realizar cualquier lógica de enlace de datos que se ha escrito para él.  
  
   
  
## Examples  
 [!code-csharp[ITemplate_Interface#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ITemplate_Interface/CS/itemplate.cs#1)]
 [!code-vb[ITemplate_Interface#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ITemplate_Interface/VB/itemplate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DataItemContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataItemContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataItemContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataItemContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataItemContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ DataItemContainer { System::Web::UI::Control ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una referencia al contenedor de nomenclatura si este implementa <see cref="T:System.Web.UI.IDataItemContainer" />.</summary>
        <value>Contenedor de nomenclatura. En una jerarquía de contenedores de nomenclatura que implementan <see cref="T:System.Web.UI.IDataItemContainer" />, esta propiedad devuelve el contenedor de nomenclatura situado en la parte superior de la jerarquía o <see langword="null" /> si el objeto <see cref="T:System.Web.UI.Control" /> actual no está en un contenedor de nomenclatura que implemente <see cref="T:System.Web.UI.IDataItemContainer" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataKeysContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataKeysContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataKeysContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataKeysContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataKeysContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ DataKeysContainer { System::Web::UI::Control ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una referencia al contenedor de nomenclatura si este implementa <see cref="T:System.Web.UI.IDataKeysControl" />.</summary>
        <value>Contenedor de nomenclatura. En una jerarquía de contenedores de nomenclatura que implementan <see cref="T:System.Web.UI.IDataKeysControl" />, la propiedad devuelve el contenedor de nomenclatura situado en la parte superior de la jerarquía o <see langword="null" /> si el objeto <see cref="T:System.Web.UI.Control" /> actual no está en un contenedor de nomenclatura que implemente <see cref="T:System.Web.UI.IDataKeysControl" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignMode">
      <MemberSignature Language="C#" Value="protected internal bool DesignMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DesignMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DesignMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DesignMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool DesignMode { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se está utilizando un control en una superficie de diseño.</summary>
        <value>
          <see langword="true" /> si se está usando el control en un diseñador; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Control.DesignMode%2A> propiedad devuelve `true` para indicar que el control está en uso en el contexto de un diseñador. Los controles personalizados pueden utilizar esta propiedad al comportamiento de tiempo de diseño es diferente del comportamiento en tiempo de ejecución.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Habilita un control de servidor para que realice la limpieza final antes de que se libere de la memoria.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a <xref:System.Web.UI.Control.Dispose%2A> cuando haya terminado de usar <xref:System.Web.UI.Control>. El método <xref:System.Web.UI.Control.Dispose%2A> deja el <xref:System.Web.UI.Control> en un estado no utilizable. Después de llamar a este método, debe liberar todas las referencias al control para que la memoria que se estaba ocupando puede ser reclamada por la recolección.  
  
   
  
## Examples  
 El siguiente código de ejemplo reemplaza el <xref:System.Web.UI.Control.Dispose%2A> método para cerrar la <xref:System.Web.UI.HtmlTextWriter> objeto asociado a un control y llaman a la <xref:System.Web.UI.Control.Dispose%2A> método en un <xref:System.Web.UI.WebControls.Button> control, denominado `myButton`. Si un <xref:System.Exception> se produce cuando esta versión de la <xref:System.Web.UI.Control.Dispose%2A> método se llama, el control escribe un mensaje en el actual <xref:System.Web.HttpResponse> objeto.  
  
 [!code-csharp[Control_Dispose#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Dispose/CS/control_disposemethod.cs#1)]
 [!code-vb[Control_Dispose#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Dispose/VB/control_disposemethod.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Disposed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Disposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Disposed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un control de servidor se libera de la memoria, lo que constituye la última fase del período de duración de un control de servidor cuando se solicita una página ASP.NET.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deben liberarse los recursos que requieran un tiempo de procesador significativo, como conexiones de base de datos, con este evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public virtual bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si los temas se aplican a este control.</summary>
        <value>
          <see langword="true" /> para usar temas; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Control.EnableTheming%2A> propiedad indica si los temas están habilitados para un control especificado. Cuando el <xref:System.Web.UI.Control.EnableTheming%2A> propiedad es `true`, directorio de temas de la aplicación se busca máscaras para los controles. Si no existe ninguna máscara para un control determinado en el directorio de temas, no se aplican máscaras.  
  
 Cuando el <xref:System.Web.UI.Control.EnableTheming%2A> propiedad es `false`, no se busca en el directorio de temas y el contenido de la <xref:System.Web.UI.Control.SkinID%2A> no se utiliza la propiedad.  
  
 Temas pueden habilitarse en la página, el contenedor o el nivel de control. Un control puede invalidar la <xref:System.Web.UI.Control.EnableTheming%2A> valor establecido por su control principal o por la página que lo contiene.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El evento <see langword="Page_PreInit" /> ya se ha producido.  
  
 \- o -  
  
 El control ya se ha agregado a la colección <see langword="Controls" />.</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public virtual bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableViewState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableViewState { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el control de servidor conserva su estado de vista, así como el estado de vista de los controles secundarios que contiene, al cliente solicitante.</summary>
        <value>
          <see langword="true" /> si el control de servidor mantiene su estado de vista; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de vista permite que un control de servidor mantener su estado entre las solicitudes HTTP. Estado de vista para un control se habilita si se cumplen todas las condiciones siguientes:  
  
-   El <xref:System.Web.UI.Control.EnableViewState%2A> propiedad de la página se establece en `true`.  
  
-   El <xref:System.Web.UI.Control.EnableViewState%2A> propiedad del control se establece en `true`.  
  
-   El <xref:System.Web.UI.Control.ViewStateMode%2A> propiedad del control se establece en <xref:System.Web.UI.ViewStateMode.Enabled> o hereda el <xref:System.Web.UI.ViewStateMode.Enabled> configuración.  
  
 Para obtener más información, vea la propiedad <xref:System.Web.UI.Control.ViewStateMode%2A>.  
  
 Estado de vista de un control de servidor es la acumulación de todos sus valores de propiedad. Para conservar estos valores en las solicitudes HTTP, ASP.NET utiliza una instancia de la <xref:System.Web.UI.StateBag> clase para almacenar los valores de propiedad. Los valores, a continuación, se pasan como una variable a un campo oculto cuando se procesan las solicitudes posteriores. Para obtener más información acerca del estado de vista, vea [información general sobre el estado de vista de ASP.NET](http://msdn.microsoft.com/library/19d2a6ed-9a77-4c7c-a7f5-74dd4b6c3818).  
  
 Hay ocasiones en que es adecuado deshabilitar el estado de vista, especialmente para mejorar el rendimiento de la aplicación. Por ejemplo, si está cargando una solicitud de base de datos en un control de servidor, establezca esta propiedad `false`. Si no lo hace, se ocupará de tiempo de procesador cargar el estado de vista en el control de servidor que sólo será reemplazado por la consulta de base de datos. Si <xref:System.Web.UI.Control.EnableViewState%2A> es `false`, puede usar el estado de control para almacenar información de la propiedad que es específico de un control y no se puede desactivar como la propiedad de estado de vista. Para obtener más información sobre las diferencias entre el estado del control y el estado de vista, vea [estado del Control. Ejemplo de estado de vista](http://msdn.microsoft.com/library/9e98c7de-a888-48df-b14e-02ec8bef7681).  
  
 Para obtener información acerca de cómo habilitar o deshabilitar el estado de vista mediante declaración para una página ASP.NET, vea.  
  
   
  
## Examples  
 El ejemplo siguiente se establece la <xref:System.Web.UI.Control.EnableViewState%2A> propiedad `false`.  
  
 [!code-csharp[Control_StateManagement#7](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_statemanagement.cs.aspx#7)]
 [!code-vb[Control_StateManagement#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_statemanagement.vb.aspx#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
      </Docs>
    </Member>
    <Member MemberName="EndRenderTracing">
      <MemberSignature Language="C#" Value="protected void EndRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EndRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EndRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EndRenderTracing (writer As TextWriter, traceObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EndRenderTracing(System::IO::TextWriter ^ writer, System::Object ^ traceObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="traceObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">El objeto que escribe datos de seguimiento.</param>
        <param name="traceObject">El objeto de seguimiento.</param>
        <summary>Finaliza el seguimiento en tiempo de diseño de los datos de representación.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureChildControls">
      <MemberSignature Language="C#" Value="protected virtual void EnsureChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void EnsureChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub EnsureChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void EnsureChildControls();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina si el control de servidor contiene controles secundarios. Si no tiene controles secundarios, los crea.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método comprueba primero el valor actual de la <xref:System.Web.UI.Control.ChildControlsCreated%2A> propiedad. Si este valor es `false`, el <xref:System.Web.UI.Control.CreateChildControls%2A> se llama al método.  
  
 El <xref:System.Web.UI.Control.EnsureChildControls%2A> método se utiliza normalmente en controles compuestos, que son controles que usan los controles secundarios para algunas o todas sus funciones. El <xref:System.Web.UI.Control.EnsureChildControls%2A> se invoca con el fin de asegurarse de que los controles secundarios se han creado y están listos para procesar la entrada, para realizar el enlace de datos o realizar otras tareas.  
  
 El <xref:System.Web.UI.WebControls.GridView> control es un ejemplo de un control compuesto. Crea controles secundarios como <xref:System.Web.UI.WebControls.Table>, <xref:System.Web.UI.WebControls.TableRow>, <xref:System.Web.UI.WebControls.TableCell>, <xref:System.Web.UI.WebControls.Label>, y <xref:System.Web.UI.WebControls.TextBox> controles, que se usan para representar el código HTML de la tabla que la <xref:System.Web.UI.WebControls.GridView> genera.  
  
 En la mayoría de los casos, los programadores de controles de servidor personalizado no es necesario invalidar este método. Si invalida este método, utilice de forma similar al comportamiento predeterminado.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Web.UI.Control.EnsureChildControls%2A> método para asegurarse de que el control de servidor actual tiene controles secundarios. A continuación, obtiene o establece un <xref:System.Web.UI.WebControls.TextBox.Text%2A> propiedad para un elemento secundario <xref:System.Web.UI.WebControls.TextBox> control en el control de servidor actual Web <xref:System.Web.UI.ControlCollection> objeto.  
  
> [!IMPORTANT]
>  Este ejemplo tiene un cuadro de texto que acepta datos proporcionados por el usuario, lo que puede suponer una amenaza para la seguridad. De forma predeterminada, ASP.NET Web Pages valida que los datos proporcionados por el usuario no incluyen elementos HTML ni de script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#1)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="EnsureID">
      <MemberSignature Language="C#" Value="protected void EnsureID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EnsureID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureID" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EnsureID ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EnsureID();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un identificador para controles que no tiene un identificador asignado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Control.EnsureID%2A> método genera un identificador para los controles que se encuentran en otro control. Se generan identificadores solo para los controles que no tienen un valor asignado a la <xref:System.Web.UI.Control.ID%2A> propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Events">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.EventHandlerList Events { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.EventHandlerList Events" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Events" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Events As EventHandlerList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::ComponentModel::EventHandlerList ^ Events { System::ComponentModel::EventHandlerList ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventHandlerList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una lista de delegados de controladores de eventos del control. Esta propiedad es de sólo lectura.</summary>
        <value>Lista de delegados de controladores de eventos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es de tipo <xref:System.ComponentModel.EventHandlerList>, que utiliza un algoritmo de búsqueda lineal para buscar entradas en la lista de delegados. Un algoritmo de búsqueda lineal es ineficaz cuando se trabaja con un gran número de entradas. Por lo tanto, cuando tenga una lista grande, encontrar entradas con esta propiedad será lentas.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un evento, denominado `Click`, que agrega y quita los controladores del control <xref:System.ComponentModel.EventHandlerList> colección cuando se llama al evento desde una página.  
  
 **Tenga en cuenta** en este ejemplo optimiza cómo un control agrega y quita eventos de la lista de las mismas que mantiene el control. Si crea un control personalizado y desea definir un evento, use código similar al siguiente. Esta técnica puede usarse en C#, pero no en Visual Basic.  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventHandlerList" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca el control de servidor especificado en el contenedor de nomenclatura actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindControl (id As String) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::Control ^ FindControl(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Identificador del control que se va a buscar.</param>
        <summary>Busca un control de servidor con el parámetro <paramref name="id" /> especificado en el contenedor de nomenclatura actual.</summary>
        <returns>Control especificado, o <see langword="null" /> si el control especificado no existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Web.UI.Control.FindControl%2A> para tener acceso a un control de una función en una página de código subyacente, para tener acceso a un control que está dentro de otro contenedor o en otras circunstancias donde el control de destino no es directamente accesible al llamador. Este método encontrará un control solo si el control está incluido directamente en el contenedor especificado; es decir, el método no busca en toda una jerarquía de controles dentro de controles. Para obtener información sobre cómo buscar un control cuando no se conoce su contenedor inmediato, vea [Cómo: controles de servidor de acceso con el identificador](http://msdn.microsoft.com/library/59964ef8-72ef-4159-9f1a-5b230ff46fb3).  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `Button1_Click` controlador de eventos. Cuando se invoca, este controlador utiliza el <xref:System.Web.UI.Control.FindControl%2A> método para buscar un control con un <xref:System.Web.UI.Control.ID%2A> propiedad de `TextBox2` en la página que lo contiene. Si se encuentra el control, su elemento primario se determina según la <xref:System.Web.UI.Control.Parent%2A> propiedad y el control primario <xref:System.Web.UI.Control.ID%2A> se escribe en la página. Si `TextBox2` no se encuentra, "Control Not Found" se escribe en la página.  
  
> [!IMPORTANT]
>  Este ejemplo tiene un cuadro de texto que acepta datos proporcionados por el usuario, lo que puede suponer una amenaza para la seguridad. De forma predeterminada, ASP.NET Web Pages valida que los datos proporcionados por el usuario no incluyen elementos HTML ni de script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Control FindControl (string id, int pathOffset);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id, int32 pathOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FindControl (id As String, pathOffset As Integer) As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::Control ^ FindControl(System::String ^ id, int pathOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="pathOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="id">Identificador del control que se va a buscar.</param>
        <param name="pathOffset">Número de controles situados más arriba en la jerarquía de controles de la página necesario para llegar a un contenedor de nomenclatura.</param>
        <summary>Busca el contenedor de nomenclatura actual para un control de servidor con el <paramref name="id" /> especificado y un entero, que se especifica en el parámetro <paramref name="pathOffset" />, que ayuda a realizar la búsqueda. Esta versión del método <see cref="Overload:System.Web.UI.Control.FindControl" /> no se debe reemplazar.</summary>
        <returns>Control especificado, o <see langword="null" /> si el control especificado no existe.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public virtual void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Focus();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establece el foco de entrada en un control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Web.UI.Control.Focus%2A> método para establecer el foco inicial de la página Web en el control. Se abrirá la página en el explorador con el control seleccionado.  
  
 El <xref:System.Web.UI.Control.Focus%2A> método provoca una llamada a la secuencia de comandos de foco de página que se emitan en la página representada. Si la página no contiene un control con una etiqueta HTML `ID` atributo que coincida con el control que el <xref:System.Web.UI.Control.Focus%2A> se invoca el método en, a continuación, no se puede establecer el foco en la página. Un ejemplo que esto puede ocurrir es cuando se establece el foco en un control de usuario en lugar de establecer el foco en un control secundario del control de usuario. En este escenario, puede usar el <xref:System.Web.UI.Control.FindControl%2A> método para buscar el control secundario del control de usuario e invocar su <xref:System.Web.UI.Control.Focus%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.FindControl(System.String)" />
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="GetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IDictionary GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IDictionary GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetDesignModeState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetDesignModeState () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IDictionary ^ GetDesignModeState();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene datos en tiempo de diseño para un control.</summary>
        <returns>
          <see cref="T:System.Collections.IDictionary" /> que contiene los datos en tiempo de diseño del control.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Control.GetDesignModeState%2A> método devuelve los datos de tiempo de diseño para un control.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>El <see cref="M:System.Web.UI.Control.GetDesignModeState" /> método <see langword="null" /> de forma predeterminada. Debe invalidar este método para proporcionar los datos en tiempo de diseño que requiere el control.</para>
        </block>
        <altmember cref="T:System.Web.UI.IControlDesignerAccessor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRouteUrl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene la dirección URL que corresponde a un conjunto de parámetros de ruta y, de forma opcional, a un nombre de ruta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Es equivalente a llamar a la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeParameters As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::Object ^ routeParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeParameters">Parámetros de ruta.</param>
        <summary>Obtiene la dirección URL que corresponde a un conjunto de parámetros de ruta.</summary>
        <returns>Dirección URL que corresponde al conjunto especificado de parámetros de ruta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Es equivalente a llamar a la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> método. Este método convierte el objeto que se pasa en `routeParameters` a una <xref:System.Web.Routing.RouteValueDictionary> objeto mediante el uso de la <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructor.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo llamar a la <xref:System.Web.UI.Control.GetRouteUrl%2A?displayProperty=nameWithType> método para obtener la dirección URL de una ruta que tiene parámetros que se denominan `productid` y `category`. En este ejemplo se da por supuesto que ha creado un <xref:System.Web.UI.WebControls.HyperLink> control que se denomina `HyperLink1`.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeParameters As RouteValueDictionary) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::Web::Routing::RouteValueDictionary ^ routeParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeParameters">Parámetros de ruta.</param>
        <summary>Obtiene la dirección URL que corresponde a un conjunto de parámetros de ruta.</summary>
        <returns>Dirección URL que corresponde al conjunto especificado de parámetros de ruta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Es equivalente a llamar a la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo llamar a este método para obtener la dirección URL de una ruta que tiene parámetros que se denominan `productid` y `category`. En este ejemplo se da por supuesto que ha creado un <xref:System.Web.UI.WebControls.HyperLink> control que se denomina `HyperLink1`.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeName As String, routeParameters As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::String ^ routeName, System::Object ^ routeParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeParameters" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Nombre de la ruta.</param>
        <param name="routeParameters">Parámetros de ruta.</param>
        <summary>Obtiene la dirección URL que corresponde a un conjunto de parámetros de ruta y un nombre de ruta.</summary>
        <returns>Dirección URL que corresponde al conjunto de parámetros de ruta y nombre de ruta especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Es equivalente a llamar a la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> método. Este método convierte el objeto que se pasa en `routeParameters` a una <xref:System.Web.Routing.RouteValueDictionary> objeto mediante el uso de la <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructor.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo llamar a este método para obtener la dirección URL de una ruta que se denomina `Product` y tiene los parámetros que se denominan `productid` y `category`. En este ejemplo se da por supuesto que ha creado un <xref:System.Web.UI.WebControls.HyperLink> control que se denomina `HyperLink1`.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeName As String, routeParameters As RouteValueDictionary) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nombre de la ruta.</param>
        <param name="routeParameters">Parámetros de ruta.</param>
        <summary>Obtiene la dirección URL que corresponde a un conjunto de parámetros de ruta y un nombre de ruta.</summary>
        <returns>Dirección URL que corresponde al conjunto de parámetros de ruta y nombre de ruta especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Es equivalente a llamar a la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo llamar a este método para obtener la dirección URL de una ruta que se denomina `Product` y tiene los parámetros que se denominan `productid` y `category`. En este ejemplo se da por supuesto que ha creado un <xref:System.Web.UI.WebControls.HyperLink> control que se denomina `HyperLink1`.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUniqueIDRelativeTo">
      <MemberSignature Language="C#" Value="public string GetUniqueIDRelativeTo (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetUniqueIDRelativeTo(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetUniqueIDRelativeTo(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetUniqueIDRelativeTo(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Control que está en un contenedor de nomenclatura.</param>
        <summary>Devuelve la parte correspondiente al prefijo de la propiedad <see cref="P:System.Web.UI.Control.UniqueID" /> del control especificado.</summary>
        <returns>Parte correspondiente al prefijo de la propiedad <see cref="P:System.Web.UI.Control.UniqueID" /> del control especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Control.UniqueID%2A> propiedad de un control se genera agregando un prefijo para el control <xref:System.Web.UI.Control.ID%2A> propiedad. El prefijo se compone de la <xref:System.Web.UI.Control.UniqueID%2A> concatenado con un carácter separador de contenedor de nomenclatura de propiedad del control. Si el contenedor de nomenclatura es la página, no hay ningún prefijo. Este método devuelve la cadena de prefijo. Si no hay ninguna cadena de prefijo, devuelve el <xref:System.Web.UI.Control.UniqueID%2A> valor del control.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Web.UI.Control.NamingContainer" /> de <paramref name="control" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasChildViewState">
      <MemberSignature Language="C#" Value="protected bool HasChildViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.HasChildViewState" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property HasChildViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool HasChildViewState { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si los controles secundarios del control de servidor actual tienen guardada alguna configuración del estado de vista.</summary>
        <value>
          Es <see langword="true" /> si alguno de los controles secundarios tiene guardada información sobre el estado de vista; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede evitar llamadas innecesarias a la <xref:System.Web.UI.Control.ClearChildViewState%2A> método mediante el uso de esta propiedad para comprobar que todos los controles secundarios del control de servidor están almacenando la información de estado de vista.  
  
   
  
## Examples  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="HasControls">
      <MemberSignature Language="C#" Value="public virtual bool HasControls ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasControls" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasControls () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool HasControls();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina si el control de servidor contiene controles secundarios.</summary>
        <returns>
          Es <see langword="true" /> si el control contiene otros controles; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puesto que este método simplemente determina si existen controles secundarios, puede mejorar el rendimiento al permitirle evitar un innecesarios <xref:System.Web.UI.ControlCollection.Count%2A> llamada a la propiedad. Las llamadas a esta propiedad requieren una <xref:System.Web.UI.ControlCollection> objeto que se va a crear una instancia. Si no hay ningún elemento secundario, la creación de este objeto desperdicia recursos del servidor.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Web.UI.Control.HasControls%2A> método para determinar si existen controles antes de utilizar el <xref:System.Web.UI.ControlCollection.Count%2A> propiedad para recorrer en iteración un <xref:System.Web.UI.ControlCollection> objeto.  
  
 [!code-csharp[Classic Control.HasControls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.HasControls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.HasControls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.HasControls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>El <see cref="M:System.Web.UI.Control.HasControls" /> método se debe invalidar solo para cambiar los atributos de metadatos como <see cref="T:System.ComponentModel.EditorBrowsableAttribute" />. Para obtener más información sobre el uso de atributos, vea [atributos](~/docs/standard/attributes/index.md).</para>
        </block>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="HasEvents">
      <MemberSignature Language="C#" Value="protected bool HasEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool HasEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Function HasEvents () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool HasEvents();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si se registran eventos para el control o los controles secundarios.</summary>
        <returns>
          <see langword="true" />, si se registran eventos; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public virtual string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el identificador de programación asignado al control de servidor.</summary>
        <value>Identificador de programación asignado al control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al establecer esta propiedad en un control de servidor proporciona acceso mediante programación a las propiedades del control de servidor, eventos y métodos. Los desarrolladores Web puede establecer esta propiedad declarando un <xref:System.Web.UI.Control.ID%2A> atributo en la etiqueta de apertura de un control de servidor ASP.NET.  
  
 Si no se especifica esta propiedad para un control de servidor, mediante declaración o mediante programación, puede obtener una referencia al control a través de su control primario <xref:System.Web.UI.Control.Controls%2A> propiedad.  
  
> [!NOTE]
>  Sólo las combinaciones de caracteres alfanuméricos y el carácter de subrayado (_) son valores válidos para esta propiedad. Se incluyen espacios u otros caracteres no válidos se producirá un error de analizador de página ASP.NET.  
  
   
  
## Examples  
 [!code-csharp[Control_Sample#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs.aspx#2)]
 [!code-vb[Control_Sample#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="protected char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IdSeparator" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IdSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property char IdSeparator { char get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el carácter utilizado para separar los identificadores de control.</summary>
        <value>Carácter separador. El valor predeterminado es "$".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El carácter que se encuentra en la <xref:System.Web.UI.Control.IdSeparator%2A> propiedad se utiliza para separar los identificadores de control para los controles secundarios. El carácter de separador de identificadores se anexa a la <xref:System.Web.UI.Control.ID%2A> propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public event EventHandler Init;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Init" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Init" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Init As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Init;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tiene lugar al inicializar el control de servidor, que es el primer paso en su ciclo de vida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles de servidor deben realizar los pasos de inicialización necesarias para crear y configurar una instancia. No se puede usar la información de estado de vista dentro de este evento; aún no se rellena. No debe tener acceso a otro control de servidor durante este evento, independientemente de si es un control secundario o primario de este control. Otros controles de servidor no están seguro sea creado y listo para el acceso. Para obtener más información sobre los eventos de control de servidor, consulte [modelo de eventos de Control de servidor de ASP.NET Web Forms](http://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3).  
  
   
  
## Examples  
 En el ejemplo siguiente se asigna un controlador de eventos personalizado, `Calendar_Init`, a la `Init` eventos de un <xref:System.Web.UI.WebControls.Calendar> control.  
  
 [!code-aspx-csharp[Control_Sample#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples2.cs.aspx#4)]
 [!code-aspx-vb[Control_Sample#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples2.vb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsChildControlStateCleared">
      <MemberSignature Language="C#" Value="protected internal bool IsChildControlStateCleared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsChildControlStateCleared" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property IsChildControlStateCleared As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsChildControlStateCleared { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si los controles que se encuentran en este control tienen estado de control.</summary>
        <value>
          <see langword="true" /> si los controles secundarios de este control no utilizan el estado de control; en caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLiteralContent">
      <MemberSignature Language="C#" Value="protected bool IsLiteralContent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsLiteralContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.IsLiteralContent" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsLiteralContent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsLiteralContent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina si el control de servidor alberga únicamente contenido literal.</summary>
        <returns>
          Es <see langword="true" /> si el control de servidor está compuesto únicamente de contenido literal; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando este método devuelve `true`, colección del control de servidor contiene un único control literal.  
  
   
  
## Examples  
 En el ejemplo siguiente se comprueba si ha devuelto la página que contiene los controles de servidor. Si es así, llama a la <xref:System.Web.UI.Control.IsLiteralContent%2A> método para determinar si el control sólo tiene contenido literal o es un control primario en otros controles de servidor. Si contiene únicamente contenido literal, el <xref:System.Web.UI.Control.UniqueID%2A> propiedad de la <xref:System.Web.UI.LiteralControl> que representa que el contenido se escribe en la respuesta.  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#1)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.HasControls" />
        <altmember cref="T:System.Web.UI.LiteralControl" />
      </Docs>
    </Member>
    <Member MemberName="IsTrackingViewState">
      <MemberSignature Language="C#" Value="protected bool IsTrackingViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTrackingViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsTrackingViewState" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsTrackingViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsTrackingViewState { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el control de servidor está guardando los cambios realizados en su estado de vista.</summary>
        <value>
          Es <see langword="true" /> si el control está marcado para guardar su estado; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para un control de servidor personalizado de ejemplo que utiliza esta propiedad, vea [ejemplo de Control de servidor con plantilla](http://msdn.microsoft.com/library/986f63b8-6b50-42b9-a62d-a2f13cafa88b)  
  
   
  
## Examples  
 El siguiente ejemplo se reemplaza el <xref:System.Web.UI.Control.DataBind%2A> método en un control de servidor ASP.NET personalizado. Inicia llamando a la base de <xref:System.Web.UI.Control.OnDataBinding%2A> método y, a continuación, utiliza el `ControlCollection` objeto. <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType> método para eliminar todos los controles secundarios y los <xref:System.Web.UI.Control.ClearChildViewState%2A> método para eliminar la configuración de estado de vista para los controles secundarios guardada. Por último, el <xref:System.Web.UI.Control.ChildControlsCreated%2A> propiedad está establecida en `true`. El control, a continuación, utiliza el <xref:System.Web.UI.Control.IsTrackingViewState%2A> propiedad para determinar si está habilitado el seguimiento de cambios de estado de vista para el control. Si no está habilitado, el <xref:System.Web.UI.Control.TrackViewState%2A> se llama al método.  
  
 [!code-csharp[Control_StateManagement#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#4)]
 [!code-vb[Control_StateManagement#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="IsViewStateEnabled">
      <MemberSignature Language="C#" Value="protected internal bool IsViewStateEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsViewStateEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsViewStateEnabled" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property IsViewStateEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsViewStateEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el estado de vista está habilitado para este control.</summary>
        <value>
          <see langword="true" /> si el estado de vista está habilitado para el control; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de vista se puede habilitar en el nivel de control, el contenedor o la página. Cuando se deshabilita el estado de vista en el nivel de página o el contenedor, el estado de vista está deshabilitado para todos los controles incluidos en la página o el contenedor. El <xref:System.Web.UI.Control.IsViewStateEnabled%2A> propiedad indica si el estado de vista está habilitado por páginas, los contenedores o los controles.  
  
 Es posible que el <xref:System.Web.UI.Control.EnableViewState%2A> propiedad y el <xref:System.Web.UI.Control.IsViewStateEnabled%2A> propiedad sea diferente. Por ejemplo, si la <xref:System.Web.UI.Page> que contiene el control tiene el estado de vista deshabilitado, la <xref:System.Web.UI.Control.EnableViewState%2A> propiedad puede ser `true` mientras el <xref:System.Web.UI.Control.IsViewStateEnabled%2A> propiedad es `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Los desarrolladores de páginas se establecerá el <see cref="P:System.Web.UI.Control.EnableViewState" /> propiedad y el <see cref="P:System.Web.UI.Control.ViewStateMode" /> propiedad para indicar si están usando el estado de vista con el control. Use la <see cref="P:System.Web.UI.Control.IsViewStateEnabled" /> propiedad y el <see cref="P:System.Web.UI.Control.ViewStateMode" /> propiedad en el código para determinar si está habilitado el estado de vista para el control y todos los contenedores.</para>
        </block>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Load;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el control de servidor se carga en el objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notifica al control de servidor que siga los pasos de procesamiento que se establecen para que se produzca en cada solicitud de página. De este evento puede tener acceso a información de estado de vista y datos POST de formulario de Web. También puede tener acceso a otros controles de servidor dentro de la jerarquía de control de la página.  
  
> [!NOTE]
>  Si establece una plantilla personalizada en un control durante la `Page_Load` eventos, los valores de texto de los controles secundarios en la plantilla personalizada se perderán. Esto ocurre porque ya se han cargado los valores del formulario.  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Load#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Load/CS/control_load.cs#2)]
 [!code-vb[System.Web.UI.Control_Load#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Load/VB/control_load.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadControlState(System::Object ^ savedState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">
          <see cref="T:System.Object" /> que representa el estado del control que se va a restaurar.</param>
        <summary>Restaura información de estado de control de una solicitud de página anterior guardada por el método <see cref="M:System.Web.UI.Control.SaveControlState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalide este método cuando necesite especificar la forma en que un control de servidor personalizado restaura su estado de control. Para obtener más información, consulte [ASP.NET State Management Overview](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce).  
  
   
  
## Examples  
 El siguiente código de ejemplo reemplaza el <xref:System.Web.UI.Control.LoadControlState%2A> método en un control personalizado de ASP.NET. Cuando se invoca este método, determina si el estado del control se guardó previamente para el control y, si es así, Establece la propiedad interna `currentIndex` en el valor guardado.  
  
 El <xref:System.Web.UI.Control.OnInit%2A> método se invalida para llamar a la <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> método en el <xref:System.Web.UI.Control.Page%2A> para indicar que el control personalizado utiliza el estado de control.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="LoadViewState">
      <MemberSignature Language="C#" Value="protected virtual void LoadViewState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadViewState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadViewState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadViewState(System::Object ^ savedState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">
          <see cref="T:System.Object" /> que representa el estado del control que se va a restaurar.</param>
        <summary>Restaura la información sobre el estado de vista de una solicitud de página anterior guardada por el método <see cref="M:System.Web.UI.Control.SaveViewState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza principalmente por la infraestructura de .NET Framework y no está diseñada para utilizarse directamente desde el código. Sin embargo, los programadores de controles pueden reemplazar este método para especificar la forma en que un control de servidor personalizado restaura su estado de vista. Para obtener más información, consulte [ASP.NET State Management Overview](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce).  
  
   
  
## Examples  
 El siguiente ejemplo se reemplaza el <xref:System.Web.UI.Control.LoadViewState%2A> método para un control de servidor ASP.NET personalizado. Crea un <xref:System.Object> matriz que contendrá la información de estado de vista pasada el `savedState` parámetro y, a continuación, llama a la implementación base de la <xref:System.Web.UI.Control.LoadViewState%2A> método para la primera ubicación de índice de la matriz. Asigna los valores almacenados en las dos ubicaciones de índice a las variables denominadas `UserText` y `PasswordText`, respectivamente.  
  
 [!code-csharp[Control_StateManagement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#1)]
 [!code-vb[Control_StateManagement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="LoadViewStateByID">
      <MemberSignature Language="C#" Value="protected bool LoadViewStateByID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadViewStateByID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.LoadViewStateByID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property LoadViewStateByID As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool LoadViewStateByID { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el control participa en la carga de su estado de vista mediante <see cref="P:System.Web.UI.Control.ID" /> en lugar de índice.</summary>
        <value>
          <see langword="true" /> si el control carga su estado de vista mediante <see cref="P:System.Web.UI.Control.ID" />; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, cuando un control principal carga el estado de vista en controles secundarios que crea, esto hace la posición de cada control secundario en el control primario <xref:System.Web.UI.Control.Controls%2A> colección. Cuando inicialmente se aplica el estado de vista, todos los controles secundarios podrían no haberse creados. En este caso, el estado de vista para los controles que aún no se ha creado se guarda y aplica cuando se crean los controles secundarios con posterioridad.  
  
 Para que un control principal aplicar el estado de vista a sus controles secundarios, se deben cumplir dos condiciones:  
  
-   En la devolución de datos, el control principal debe crear los controles secundarios en exactamente el mismo orden que la solicitud anterior para que el orden de los controles permanezca coherente.  
  
-   Después de la devolución de datos, todos los controles secundarios creados deben agregarse al final del control primario <xref:System.Web.UI.Control.Controls%2A> colección.  
  
 Si no se cumplen estas dos condiciones, como en el caso de la creación diferida de un control secundario, el control principal puede cargar el estado de vista mediante el uso de <xref:System.Web.UI.Control.ID%2A>. Para establecer el <xref:System.Web.UI.Control.LoadViewStateByID%2A> propiedad `true`, use el <xref:System.Web.UI.ViewStateModeByIdAttribute> atributo de metadatos para el control primario.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.ViewStateModeByIdAttribute" />
      </Docs>
    </Member>
    <Member MemberName="MapPathSecure">
      <MemberSignature Language="C#" Value="protected internal string MapPathSecure (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance string MapPathSecure(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.MapPathSecure(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function MapPathSecure (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::String ^ MapPathSecure(System::String ^ virtualPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Dirección URL relativa o relativa a la raíz.</param>
        <summary>Recupera la ruta de acceso física a la que se asigna una ruta de acceso virtual, absoluta o relativa.</summary>
        <returns>Ruta de acceso física al archivo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método solo se puede utilizar controles de servidor que tienen permiso para leer archivos y que forman parte de los archivos .dll de plena confianza, como System.Web.dll. Esto ayuda a evitar infracciones de seguridad.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Web.UI.Control.MapPathSecure%2A> método para obtener la ruta de acceso física de un directorio virtual de la que contiene <xref:System.Web.UI.Page> o <xref:System.Web.UI.UserControl> objeto.  
  
 [!code-csharp[Control_MapPathSecure#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_MapPathSecure/CS/control_templatesourcedirectory.cs#1)]
 [!code-vb[Control_MapPathSecure#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_MapPathSecure/VB/control_templatesourcedirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="virtualPath" /> es <see langword="null" /> o una cadena vacía ("").</exception>
      </Docs>
    </Member>
    <Member MemberName="NamingContainer">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control NamingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control NamingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.NamingContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NamingContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Control ^ NamingContainer { System::Web::UI::Control ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una referencia al contenedor de nomenclatura del control de servidor, que crea un espacio de nombres único para diferenciar los distintos controles de servidor que tienen el mismo valor para la propiedad <see cref="P:System.Web.UI.Control.ID" />.</summary>
        <value>Contenedor de nomenclatura del control de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada página de una aplicación Web ASP.NET contiene una jerarquía de controles. Esta jerarquía no es dependiente de si genera un control de la interfaz de usuario visible para el usuario. El contenedor de nomenclatura de un control determinado es el control primario por encima de él en la jerarquía que implementa la <xref:System.Web.UI.INamingContainer> interfaz. Un control de servidor que implementa esta interfaz crea un espacio de nombres único para el <xref:System.Web.UI.Control.ID%2A> valores de propiedad de sus controles de servidor secundarios. Puede usar el <xref:System.Web.UI.Control.NamingContainer%2A> propiedad del control secundario de un contenedor de nomenclatura para obtener una referencia a su contenedor primario.  
  
 Crear un espacio de nombres único para los controles de servidor es especialmente importante al enlazar controles de servidor Web a los datos, como el <xref:System.Web.UI.WebControls.Repeater> y <xref:System.Web.UI.WebControls.DataList> controles de servidor. Cuando varias entradas en el origen de datos crean varias instancias de un control de servidor que es un elemento secundario del control de repetición, el contenedor de nomenclatura garantiza que cada instancia de estos controles secundarios tengan <xref:System.Web.UI.Control.UniqueID%2A> valores de propiedad que no entren en conflicto. El contenedor de nomenclatura predeterminado para una página es la instancia de la <xref:System.Web.UI.Page> clase que se genera cuando se solicita dicha página.  
  
 El <xref:System.Web.UI.Control.ClientID%2A> propiedad contiene el valor que se representa como el elemento `id` atributo en el código HTML. Dependiendo del valor que se asigna a la <xref:System.Web.UI.Control.ClientIDMode%2A> propiedad, el valor que se genera para la <xref:System.Web.UI.Control.ClientID%2A> propiedad podría incluir el identificador de la <xref:System.Web.UI.Control.NamingContainer%2A> objeto. Al establecer <xref:System.Web.UI.Control.ClientIDMode%2A> a <xref:System.Web.UI.ClientIDMode.Static>, <xref:System.Web.UI.Control.ClientID%2A> valor no incluye el identificador de la <xref:System.Web.UI.Control.NamingContainer%2A> objeto. Al establecer <xref:System.Web.UI.Control.ClientIDMode%2A> como <xref:System.Web.UI.ClientIDMode.AutoID> o <xref:System.Web.UI.ClientIDMode.Predictable>, el <xref:System.Web.UI.Control.ClientID%2A> valor incluirá el identificador de la <xref:System.Web.UI.Control.NamingContainer%2A> objeto. Para obtener más información, vea [Identificación de controles de formularios Web Forms](http://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Web.UI.Control.NamingContainer%2A> propiedad.  
  
 [!code-aspx-csharp[Control_NamingContainer#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_NamingContainer/CS/control_namingcontainer.cs.aspx#1)]
 [!code-aspx-vb[Control_NamingContainer#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_NamingContainer/VB/control_namingcontainer.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.ID" />
      </Docs>
    </Member>
    <Member MemberName="OnBubbleEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnBubbleEvent (source As Object, args As EventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnBubbleEvent(System::Object ^ source, EventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">Origen del evento.</param>
        <param name="args">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Determina si el evento del control de servidor se pasa a la jerarquía de control de servidor de la interfaz de usuario (UI) de la página.</summary>
        <returns>
          Es <see langword="true" /> si se ha cancelado el evento; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles de servidor ASP.NET como el <xref:System.Web.UI.WebControls.Repeater>, <xref:System.Web.UI.WebControls.DataList> y <xref:System.Web.UI.WebControls.GridView> controles Web pueden contener controles secundarios que provocan eventos. Por ejemplo, cada fila de un <xref:System.Web.UI.WebControls.GridView> control puede contener uno o varios botones creados dinámicamente mediante plantillas. En lugar de cada botón provoque un evento individualmente, los eventos de los controles anidados se ejecutan "en burbuja", es decir, se envían al contenedor de nomenclatura. El contenedor de nomenclatura a su vez provoca un evento genérico denominado <xref:System.Web.UI.WebControls.GridView.RowCommand> con valores de parámetro. Estos valores permiten determinar qué control individual que provocó el evento original. Al responder a este evento único, puede evitar tener que escribir métodos de control de eventos individuales para los controles secundarios.  
  
   
  
## Examples  
 El siguiente ejemplo se reemplaza el <xref:System.Web.UI.Control.OnBubbleEvent%2A> método en un control de servidor ASP.NET personalizado, `ParentControl`. Este método se invoca cuando un control secundario de `ParentControl` llamadas el <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> método. Cuando esto sucede, el `ParentControl` clase escribe dos cadenas en la página ASP.NET que lo contiene, el primer sistema que indique que su <xref:System.Web.UI.Control.OnBubbleEvent%2A> llama método, la segunda que identifica el control de código fuente de la <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> método.  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#1)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataBinding">
      <MemberSignature Language="C#" Value="protected virtual void OnDataBinding (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataBinding(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataBinding (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataBinding(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Web.UI.Control.DataBinding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método notifica a un control de servidor para realizar cualquier lógica para enlazar los datos que está asociados a él.  
  
 Si desea controlar la <xref:System.Web.UI.Control.DataBinding> eventos, debe invalidar este método de control de eventos. Esto garantiza que todos los delegados asociados a la <xref:System.Web.UI.Control.DataBinding> se llama al evento.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo invalidar el <xref:System.Web.UI.Control.OnDataBinding%2A> método para agregar controles secundarios al control principal desde un origen de datos.  
  
 [!code-csharp[TemplatedDataBoundControl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl/CS/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl/VB/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Web.UI.Control.Init" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET llama a este método para generar el <xref:System.Web.UI.Control.Init> eventos. Si está desarrollando un control personalizado, puede invalidar este método para proporcionar un procesamiento adicional. Si invalida este método, llame al control base <xref:System.Web.UI.Control.OnInit%2A> método para informar a los suscriptores al evento.  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#3)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Web.UI.Control.Load" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET llama a este método para generar el <xref:System.Web.UI.Control.Load> eventos. Si está desarrollando un control personalizado, puede invalidar este método para proporcionar un procesamiento adicional. Si invalida este método, llame al control base <xref:System.Web.UI.Control.OnLoad%2A> método para informar a los suscriptores al evento.  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#3)]
 [!code-vb[Control_OnUnload#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Web.UI.Control.PreRender" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET llama a este método para generar el <xref:System.Web.UI.Control.PreRender> eventos. Si está desarrollando un control personalizado, puede invalidar este método para proporcionar un procesamiento adicional. Si invalida este método, llame al control base <xref:System.Web.UI.Control.OnPreRender%2A> método para informar a los suscriptores al evento.  
  
   
  
## Examples  
 [!code-csharp[Control_Sample_1_snipper#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1_snipper/CS/control_sample_1.cs#1)]
 [!code-vb[Control_Sample_1_snipper#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1_snipper/VB/control_sample_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Web.UI.Control.Unload" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET llama a este método para generar el <xref:System.Web.UI.Control.Unload> eventos. Si está desarrollando un control personalizado, puede invalidar este método para proporcionar un procesamiento adicional. Si invalida este método, llame al control base <xref:System.Web.UI.Control.OnUnload%2A> método para informar a los suscriptores al evento.  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#2)]
 [!code-vb[Control_OnUnload#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.Unload" />
      </Docs>
    </Member>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="protected internal System.IO.Stream OpenFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.IO.Stream OpenFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OpenFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function OpenFile (path As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::IO::Stream ^ OpenFile(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso del archivo que se desea obtener.</param>
        <summary>Obtiene un objeto <see cref="T:System.IO.Stream" /> utilizado para leer un archivo.</summary>
        <returns>Objeto <see cref="T:System.IO.Stream" /> que hace referencia al archivo que se desea obtener.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Control.OpenFile%2A> método devuelve un <xref:System.IO.Stream> objeto que puede usarse para leer el contenido del archivo especificado en el `path` parámetro. El parámetro de ruta de acceso puede ser ya sea relativa o dirección URL raíz sin especificar el protocolo (como "~ / ~/miSitio/miArchivo.txt), o una ruta de acceso física, ya sea local ("c:\mySite\myFile.txt") o UNC ("\\\myServer\myFile.txt ").  
  
 El <xref:System.Web.UI.Control.OpenFile%2A> método usa la seguridad de acceso del archivo para controlar el acceso al archivo especificado. Si el usuario ASP.NET actual no tiene acceso al archivo, a continuación, el archivo no está abierto y un <xref:System.Web.HttpException> excepción se produce para indicar que se denegó el acceso. Si el `path` parámetro especifica una ruta de acceso relativa, la excepción no incluye información acerca de la ruta de acceso física al archivo solicitado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Se ha denegado el acceso al archivo especificado.</exception>
        <altmember cref="T:System.IO.FileStream" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Page Page { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Page" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); void set(System::Web::UI::Page ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una referencia a la instancia <see cref="T:System.Web.UI.Page" /> que contiene el control de servidor.</summary>
        <value>Instancia de <see cref="T:System.Web.UI.Page" /> que contiene el control de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Valor de esta propiedad refleja el nombre del archivo .aspx que contiene el control de servidor.  
  
   
  
## Examples  
 En el siguiente ejemplo se reemplaza el método <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>. Usa el <xref:System.Web.UI.Page> propiedad para tener acceso a la <xref:System.Web.UI.Page.IsPostBack%2A?displayProperty=nameWithType> propiedad y determinar si la página que contiene este control se ha cargado por primera vez o es el resultado de una devolución de datos.  
  
 [!code-csharp[Control_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs#1)]
 [!code-vb[Control_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Éste es un control <see cref="T:System.Web.UI.WebControls.Substitution" />.</exception>
        <altmember cref="T:System.Web.UI.Page" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Parent As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Control ^ Parent { System::Web::UI::Control ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una referencia al control principal del control de servidor en la jerarquía de controles de página.</summary>
        <value>Referencia al control principal del control de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada vez que se solicita una página, se crea una jerarquía de controles de servidor en la página. Esta propiedad permite determinar el control primario del control de servidor actual en la jerarquía y programar con él.  
  
   
  
## Examples  
 En el ejemplo siguiente se establece un nuevo <xref:System.Web.UI.Control> objeto en una página, `myControl1`, en el control especificado en un <xref:System.Web.UI.Control.FindControl%2A> llamada al método. Si la llamada devuelve un control, el código usa el <xref:System.Web.UI.Control.Parent%2A> propiedad para identificar el control que contiene `myControl1`. Si el control primario no existe, la cadena "el elemento primario del cuadro de texto es" se concatena con el <xref:System.Web.UI.Control.ID%2A> propiedad del control primario y se escriben en el <xref:System.Web.UI.Control.Page%2A>. Si no se encuentra ningún control primario, la cadena "Control not found" se escribe.  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreRender">
      <MemberSignature Language="C#" Value="public event EventHandler PreRender;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRender" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.PreRender" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreRender As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreRender;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce una vez que se carga el objeto <see cref="T:System.Web.UI.Control" />, pero antes de su representación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este evento para realizar actualizaciones antes de que el control de servidor se representa en la página. Pueden guardar los cambios en el estado de vista del control de servidor durante este evento. No se guardarán los cambios realizados en la fase de representación.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseBubbleEvent">
      <MemberSignature Language="C#" Value="protected void RaiseBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseBubbleEvent (source As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseBubbleEvent(System::Object ^ source, EventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">Origen del evento.</param>
        <param name="args">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Asigna los orígenes del evento y su información al control principal del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles de servidor ASP.NET como el <xref:System.Web.UI.WebControls.Repeater>, <xref:System.Web.UI.WebControls.DataList> y <xref:System.Web.UI.WebControls.GridView> controles Web pueden contener controles secundarios que provocan eventos. Por ejemplo, cada fila de un <xref:System.Web.UI.WebControls.GridView> control puede contener uno o varios botones creados dinámicamente mediante plantillas. En lugar de cada botón provoque un evento individualmente, los eventos de los controles anidados se ejecutan "en burbuja", es decir, se envían al elemento primario del control. El elemento primario a su vez provoca un evento genérico denominado <xref:System.Web.UI.WebControls.GridView.RowCommand> con valores de parámetro. Estos valores permiten determinar qué control individual que provocó el evento original. Al responder a este evento único, puede evitar tener que escribir métodos de control de eventos individuales para los controles secundarios.  
  
 Aunque no se puede invalidar este método, controles crea pueden controlar o provocar eventos en burbuja invalidando el <xref:System.Web.UI.Control.OnBubbleEvent%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo crear una clase personalizada, `ChildControl`, invalidar la <xref:System.Web.UI.WebControls.Button.OnClick%2A?displayProperty=nameWithType> método para llamar a la <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> método que envía el <xref:System.Web.UI.WebControls.Button.Click?displayProperty=nameWithType> eventos a su elemento primario de control de servidor ASP.NET. Cuando el usuario hace clic en un botón en una página ASP.NET que incluye una instancia de `ChildControl`, genera el <xref:System.Web.UI.Control.OnBubbleEvent%2A> método en el control primario que contiene la instancia de `ChildControl` y escribe la cadena "The ChildControl class OnClick es (método) se llama"a la página.  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#2)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RemovedControl">
      <MemberSignature Language="C#" Value="protected internal virtual void RemovedControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RemovedControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void RemovedControl(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.Control" /> que se quitó.</param>
        <summary>Se llama después de quitar un control secundario de la colección <see cref="P:System.Web.UI.Control.Controls" /> del objeto <see cref="T:System.Web.UI.Control" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Control.RemovedControl%2A> método se llama inmediatamente después de que un control se quita de la <xref:System.Web.UI.Control.Controls%2A> colección.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Éste es un control <see cref="T:System.Web.UI.WebControls.Substitution" />.</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> que recibe el contenido del control de servidor.</param>
        <summary>Envía el contenido del control de servidor al objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> proporcionado, que escribe el contenido que se representará en el cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al desarrollar controles de servidor personalizado, puede invalidar este método para generar el contenido de una página ASP.NET.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo reemplazar el <xref:System.Web.UI.Control.Render%2A> método. El <xref:System.Web.UI.Control.HasControls%2A> método se utiliza para determinar si el control de servidor tiene controles secundarios almacenados en su <xref:System.Web.UI.ControlCollection> objeto, que es accesible a través de la <xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType> propiedad. Si <xref:System.Web.UI.Control.HasControls%2A> devuelve true y el primer control de servidor en la colección es texto literal, a continuación, se anexa el texto literal en una cadena HTML.  
  
 [!code-csharp[Classic Control.Render Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Render Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Render Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Render Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected internal virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> que recibe el contenido representado.</param>
        <summary>Envía el contenido del control secundario del control de servidor a un objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> suministrado, que escribe el contenido que se va a representar en el cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método notifica a ASP.NET para representar cualquier código de páginas Active Server (ASP) en la página. Si no existe ningún código ASP en la página, este método procesa los controles secundarios del control de servidor. Este método es invocado por el <xref:System.Web.UI.Control.Render%2A> método.  
  
   
  
## Examples  
 El siguiente ejemplo se reemplaza el <xref:System.Web.UI.Control.RenderChildren%2A> método en un control de servidor personalizado. Determina si el control actual tiene todos los controles secundarios en sus <xref:System.Web.UI.ControlCollection> objeto. Si es así, usa el <xref:System.Web.UI.ControlCollection.Count%2A> propiedad para recorrer en iteración la colección. A medida que encuentra cada control secundario, utiliza el <xref:System.Web.UI.Control.RenderControl%2A> método para representar el elemento primario de control y todos sus controles secundarios, a la página que lo contiene.  
  
 Reemplazados <xref:System.Web.UI.Control.Render%2A> método, a continuación, llama a la invalidado <xref:System.Web.UI.Control.RenderChildren%2A> método.  
  
 [!code-csharp[Control_Sample_1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#4)]
 [!code-vb[Control_Sample_1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RenderControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Genera el contenido del control de servidor y almacena información de traza del control si está habilitada la traza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="public virtual void RenderControl (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RenderControl(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RenderControl (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RenderControl(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> que recibe el contenido de control.</param>
        <summary>Envía el contenido de control del servidor a un objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> proporcionado y almacena información de seguimiento sobre el control si está habilitado el seguimiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un control de servidor <xref:System.Web.UI.Control.Visible%2A> propiedad está establecida en `true`, este método determina si el seguimiento está habilitado para la página. Si es así, almacena la información de seguimiento asociado al control y presenta el contenido del control de servidor a la página.  
  
 Este método llama automáticamente a la página durante la representación, pero puede reemplazarse por los programadores de controles personalizados.  
  
   
  
## Examples  
 El siguiente ejemplo se reemplaza el <xref:System.Web.UI.Control.RenderChildren%2A> método en un control de servidor personalizado. Determina si el control actual tiene todos los controles secundarios en sus <xref:System.Web.UI.ControlCollection> objeto. Si es así, usa el <xref:System.Web.UI.ControlCollection.Count%2A> propiedad para recorrer en iteración la colección. A medida que encuentra cada control secundario, utiliza el <xref:System.Web.UI.Control.RenderControl%2A> método para representar el elemento secundario de control y todos sus controles secundarios, a la página que lo contiene. El <xref:System.Web.UI.XhtmlTextWriter> se crea una instancia de objeto que se pasa a este método por el <xref:System.Web.UI.Page.Render%2A> método.  
  
 [!code-csharp[Control_Sample_1#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#3)]
 [!code-vb[Control_Sample_1#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="protected void RenderControl (System.Web.UI.HtmlTextWriter writer, System.Web.UI.Adapters.ControlAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RenderControl(class System.Web.UI.HtmlTextWriter writer, class System.Web.UI.Adapters.ControlAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RenderControl (writer As HtmlTextWriter, adapter As ControlAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RenderControl(System::Web::UI::HtmlTextWriter ^ writer, System::Web::UI::Adapters::ControlAdapter ^ adapter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
        <Parameter Name="adapter" Type="System.Web.UI.Adapters.ControlAdapter" />
      </Parameters>
      <Docs>
        <param name="writer">El objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> que recibe el contenido del control.</param>
        <param name="adapter">
          <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> que define la representación.</param>
        <summary>Coloca el contenido de un control de servidor en un objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> proporcionado, utilizando un objeto <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> proporcionado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las páginas Web ASP.NET son utilizables en una amplia variedad de dispositivos y exploradores que pueden solicitar información de la Web. El <xref:System.Web.UI.Control.Adapter%2A> propiedad devuelve el <xref:System.Web.UI.Adapters.ControlAdapter> objeto que representa el control en la pantalla del explorador o el dispositivo que lo solicitado.  
  
 Para obtener más información acerca de los adaptadores, vea [arquitectura Overview of Adaptive Control Behavior](http://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff).  
  
 Si un control de servidor <xref:System.Web.UI.Control.Visible%2A> propiedad está establecida en `true` y seguimiento está habilitado para la página, a continuación, se captura la información de seguimiento asociado al control.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar el <see cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" /> método en controles personalizados, llame al método de clase base para asegurarse de que se ha capturado correctamente la información de seguimiento.</para>
        </block>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
        <altmember cref="P:System.Web.HttpContext.Trace" />
      </Docs>
    </Member>
    <Member MemberName="RenderingCompatibility">
      <MemberSignature Language="C#" Value="public virtual Version RenderingCompatibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version RenderingCompatibility" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.RenderingCompatibility" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RenderingCompatibility As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Version ^ RenderingCompatibility { Version ^ get(); void set(Version ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica la versión de ASP.NET compatible con los elementos HTML representados.</summary>
        <value>Versión de ASP.NET compatible con los elementos HTML representados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET establece esta propiedad en el valor de la `controlRenderingCompatibilityVersion` atributo de la `pages` elemento en el archivo Web.config. Si el `controlRenderingCompatibilityVersion` atributo no está establecido en el archivo Web.config, el valor predeterminado es la versión actual de ASP.NET.  
  
> [!CAUTION]
>  Hay un descriptor de acceso público de esta propiedad, pero el descriptor de acceso es compatible con la infraestructura de .NET Framework y no está diseñada para utilizarse directamente desde el código. Si establece este valor en el código, el efecto es impredecible.  
  
 Cada versión de ASP.NET puede representar HTML de forma diferente respecto a versiones anteriores. Por ejemplo, en ASP.NET 3.5, si la <xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A> propiedad de un <xref:System.Web.UI.WebControls.Label> control es `false`, de forma predeterminada, ASP.NET presenta un `span` elemento cuyo `disabled` atributo está establecido en "disabled". En ASP.NET 4, de forma predeterminada, el `span` elemento se representa con una hoja de estilos en cascada (CSS) `class` atributo en lugar de la `disabled` atributo. Esto le permite especificar el aspecto deshabilitado del control y evita la representación de HTML no válido. (En HTML 4.0 y XHTML 1.1, el `span` elemento no admite el `disabled` atributo.)  
  
 Una aplicación Web podría incluir código que podría no funcionar correctamente si cambia la representación en HTML. Para evitar este problema, puede establecer la `controlRenderingCompatibilityVersion` atributo de la `pages` elemento en el archivo Web.config para indicar qué versión anterior que desea mantener la compatibilidad con. Por ejemplo, si establece la <xref:System.Web.UI.Control.RenderingCompatibility%2A> propiedad `3.5`, un deshabilitado <xref:System.Web.UI.WebControls.Label> control representará un `disabled` atributo y no una clase CSS.  
  
> [!NOTE]
>  La versión más antigua que se puede establecer esta propiedad es `3.5`.  
  
 Para mantener la compatibilidad con versiones anteriores, cuando se usa Visual Studio para actualizar un proyecto Web a ASP.NET 4 desde una versión anterior, Visual Studio establece automáticamente el `controlRenderingCompatibilityVersion` atributo en el archivo Web.config para `3.5`. Si desea que un sitio Web actualizado para representar HTML mediante el algoritmo que se introdujo en ASP.NET 4, puede cambiar o quitar el `controlRenderingCompatibilityVersion` atributo.  
  
 La mayoría de los casos, el comportamiento controlado por esta propiedad es automática y no es necesario que comprobar la <xref:System.Web.UI.Control.RenderingCompatibility%2A> propiedad en el código. Sin embargo, si está programando un control personalizado, tendrá que incluir código que modifica el comportamiento del control en función del valor de esta propiedad. Por ejemplo, un control personalizado para ASP.NET 4 podría estar formado por <xref:System.Web.UI.WebControls.Label> controles y el control personalizado podrían especificar el aspecto deshabilitado del control generando código JavaScript que modifica la `aspNetDisabled` clase. Esto funcionará como se esperaba si <xref:System.Web.UI.Control.RenderingCompatibility%2A> es `4.0` o posterior. Pero para obtener el mismo efecto cuando <xref:System.Web.UI.Control.RenderingCompatibility%2A> es `3.5`, código del control personalizado debe establecer el control `CssClass` propiedad en "aspNetDisabled" cuando la <xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A> propiedad es `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.Configuration.PagesSection.ControlRenderingCompatibilityVersion" />
      </Docs>
    </Member>
    <Member MemberName="ResolveAdapter">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Adapters.ControlAdapter ResolveAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Adapters.ControlAdapter ResolveAdapter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ResolveAdapter () As ControlAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::Adapters::ControlAdapter ^ ResolveAdapter();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el adaptador de controles que se encarga de representar el control especificado.</summary>
        <returns>Adaptador <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> que representará el control.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las páginas Web ASP.NET están visibles en una amplia variedad de dispositivos que tienen la capacidad de solicitar páginas de la Web. El <xref:System.Web.UI.Control.ResolveAdapter%2A> método devuelve el adaptador de control responsable para representar el control en el dispositivo o explorador específico que solicitó la página ASP.NET.  
  
 El tipo de adaptador específico devuelto depende del tipo descendente de la <xref:System.Web.UI.Control> clase que se va a representar.  
  
 Para obtener más información acerca de los adaptadores, vea [arquitectura Overview of Adaptive Control Behavior](http://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="ResolveClientUrl">
      <MemberSignature Language="C#" Value="public string ResolveClientUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveClientUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveClientUrl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveClientUrl (relativeUrl As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveClientUrl(System::String ^ relativeUrl);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IUrlResolutionService.ResolveClientUrl(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">Dirección URL relativa a la página actual.</param>
        <summary>Obtiene una dirección URL que el explorador puede utilizar.</summary>
        <returns>Dirección URL completa del recurso especificado y que se puede utilizar en el explorador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice la <xref:System.Web.UI.Control.ResolveClientUrl%2A> método para devolver una cadena de dirección URL adecuada para su uso por el cliente para tener acceso a recursos en el servidor Web, como archivos de imagen, vínculos a páginas adicionales y así sucesivamente.  
  
> [!NOTE]
>  La dirección URL devuelta por este método es relativa a la carpeta que contiene el archivo de origen en el que se crea una instancia del control. Los controles que heredan de esta propiedad, como <xref:System.Web.UI.UserControl> y <xref:System.Web.UI.MasterPage>, devolverá una dirección URL completa con respecto al control.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relativeUrl" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveUrl">
      <MemberSignature Language="C#" Value="public string ResolveUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ResolveUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveUrl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveUrl (relativeUrl As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ResolveUrl(System::String ^ relativeUrl);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">Dirección URL asociada a la propiedad <see cref="P:System.Web.UI.Control.TemplateSourceDirectory" />.</param>
        <summary>Convierte una dirección URL en una que el cliente solicitante pueda utilizar.</summary>
        <returns>Dirección URL convertida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `relativeUrl` parámetro contiene una dirección URL absoluta, la dirección URL se devuelve sin cambios. Si el `relativeUrl` parámetro contiene una dirección URL relativa, que se cambia la dirección URL a una dirección URL relativa que sea correcta para la ruta de acceso de la solicitud actual, por lo que el explorador puede resolver la dirección URL.  
  
 Por ejemplo, considere el siguiente escenario:  
  
-   Un cliente ha solicitado una página ASP.NET que contiene un control de usuario que tiene una imagen asociada con él.  
  
-   La página ASP.NET se encuentra en/Store/Page1.aspx.  
  
-   El control de usuario se encuentra en /Store/UserControls/UC1.ascx.  
  
-   El archivo de imagen se encuentra en /UserControls/Images/Image1.jpg.  
  
 Si el control de usuario pasa la ruta de acceso relativa a la imagen (es decir, /Store/UserControls/Images/Image1.jpg) a la <xref:System.Web.UI.Control.ResolveUrl%2A> método, el método devolverá el valor/images/image1.jpg.  
  
 Este método usa la <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propiedad que se va a resolver la dirección URL absoluta. La dirección URL devuelta es para uso del cliente.  
  
 Para obtener más información sobre las rutas de acceso de recursos en un sitio Web, consulte [rutas de acceso del proyecto de ASP.NET Web](http://msdn.microsoft.com/library/2447f50c-b849-483c-8093-85ed53e7a5bd).  
  
> [!NOTE]
>  Para páginas Web móviles únicamente, si la aplicación se basa en sesiones sin cookies o puede recibir solicitudes de los exploradores móviles que requieren sesiones sin cookies, uso de una tilde ("~") en una ruta de acceso puede provocar accidentalmente creando una nueva sesión y se pueden perder datos de la sesión. Para establecer una propiedad con una ruta de acceso como "~ /*ruta de acceso"*, resolver la ruta de acceso mediante una llamada a la <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> con un argumento como "~ /*ruta de acceso"* antes de asignarlo a la propiedad.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Web.UI.WebControls.Image> Web objeto de control de servidor y se utiliza el <xref:System.Web.UI.Control.ResolveUrl%2A> método para establecer la ruta de acceso a la imagen, que se almacena por el <xref:System.Web.UI.WebControls.Image.ImageUrl%2A> propiedad.  
  
 [!code-csharp[Control_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_ResolveUrl/CS/control_resolveurl.cs#1)]
 [!code-vb[Control_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_ResolveUrl/VB/control_resolveurl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Se produce si el parámetro <paramref name="relativeUrl" /> contiene <see langword="null" />.</exception>
        <altmember cref="P:System.Web.UI.Control.TemplateSourceDirectory" />
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveControlState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Guarda los cambios de estado del control de servidor que se produjeron desde la hora en que la página volvió a publicarse en el servidor.</summary>
        <returns>Devuelve el estado actual del control de servidor. Si no hay ningún estado asociado al control, este método devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Web.UI.Control.SaveControlState%2A> método para guardar la información de estado necesaria para el funcionamiento de un control determinado. Estos datos de estado del control se almacenan por separado de los datos de estado de vista del control.  
  
 Controles personalizados usando el estado del control deben llamar a la <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> método en la <xref:System.Web.UI.Control.Page%2A> antes de guardar el estado del control.  
  
   
  
## Examples  
 El siguiente código de ejemplo reemplaza el <xref:System.Web.UI.Control.SaveControlState%2A> método en un control personalizado de ASP.NET. Cuando se invoca este método, determina si la propiedad interna `currentIndex` está establecido en un valor no predeterminado y, si es así, guarda el valor de estado de control.  
  
 El <xref:System.Web.UI.Control.OnInit%2A> método se invalida para llamar a la <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> método en el <xref:System.Web.UI.Control.Page%2A> para indicar que el control personalizado utiliza el estado de control.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se guarda el estado de control, un objeto de cadena se devuelve al cliente como una variable que se almacena en un elemento HTML <see langword="HIDDEN" /> elemento. Invalide este método para extraer la información de estado debe utilizar en el control.  
  
 Estado del control está diseñada para pequeñas cantidades de datos críticos, como una palabra clave o un índice de página. Mediante el estado de control para grandes cantidades de datos puede afectar negativamente el rendimiento de la página. Para obtener más información, consulte [ASP.NET State Management Overview](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce).</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
      </Docs>
    </Member>
    <Member MemberName="SaveViewState">
      <MemberSignature Language="C#" Value="protected virtual object SaveViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object SaveViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SaveViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ SaveViewState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Guarda los cambios realizados en el estado de vista del control de servidor desde que la página volvió a publicarse en el servidor.</summary>
        <returns>Devuelve el estado de vista actual del control de servidor. Si no hay ningún estado de vista asociado al control, este método devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de vista es la acumulación de los valores de propiedades de un control de servidor. Estos valores se colocan automáticamente en el control de servidor <xref:System.Web.UI.Control.ViewState%2A> propiedad, que es una instancia de la <xref:System.Web.UI.StateBag> clase. Valor de esta propiedad, a continuación, se conserva en un objeto de cadena después de la operación de guardar estado fase del ciclo de vida del control de servidor. Para obtener más información, consulte [información general sobre el ciclo de vida de página ASP.NET](http://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991).  
  
 Cuando se guarda el estado de vista, este objeto de cadena se devuelve al cliente como una variable que se almacena en un elemento HTML `HIDDEN` elemento. Al crear un control de servidor personalizado con un estado de vista personalizada, el estado de vista puede administrarse de forma explícita con la <xref:System.Web.UI.Control.SaveViewState%2A> y <xref:System.Web.UI.Control.LoadViewState%2A> métodos. Para obtener más información, consulte [ASP.NET State Management Overview](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce). Para obtener información sobre cómo implementar un proveedor de estado de sesión personalizado, vea [implementar un proveedor de almacén de estado de sesión](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
   
  
## Examples  
 El siguiente ejemplo se reemplaza el <xref:System.Web.UI.Control.SaveViewState%2A> método en un control de servidor ASP.NET personalizado. Cuando se invoca este método, determina si el control tiene todos los controles secundarios y si la que contiene <xref:System.Web.UI.Page> objeto es el resultado de una devolución de datos. Si ambos valores son true, cambia el <xref:System.Web.UI.WebControls.Label.Text%2A> propiedad de un <xref:System.Web.UI.WebControls.Label> Web control de servidor para leer `Custom Control Has Saved State`. A continuación, guarda el estado de vista del control como una matriz de objetos denominada `allStates`.  
  
 [!code-csharp[Control_StateManagement#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#2)]
 [!code-vb[Control_StateManagement#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
      </Docs>
    </Member>
    <Member MemberName="SetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual void SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetDesignModeState(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetDesignModeState (data As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetDesignModeState(System::Collections::IDictionary ^ data);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="data">
          <see cref="T:System.Collections.IDictionary" /> que contiene los datos en tiempo de diseño del control.</param>
        <summary>Establece los datos en tiempo de diseño para un control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Control.SetDesignModeState%2A> método guarda los datos de tiempo de diseño para un control.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Debe reemplazar este método para guardar los datos de tiempo de diseño que requiere el control.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetRenderMethodDelegate">
      <MemberSignature Language="C#" Value="public void SetRenderMethodDelegate (System.Web.UI.RenderMethod renderMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetRenderMethodDelegate(class System.Web.UI.RenderMethod renderMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetRenderMethodDelegate(System.Web.UI.RenderMethod)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetRenderMethodDelegate(System::Web::UI::RenderMethod ^ renderMethod);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="renderMethod" Type="System.Web.UI.RenderMethod" />
      </Parameters>
      <Docs>
        <param name="renderMethod">Información necesaria que se debe pasar al delegado para que pueda representar el control de servidor.</param>
        <summary>Asigna un delegado de controlador de eventos para representar el control de servidor y su contenido en el control principal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona exclusivamente con fines implementación; nunca debe llamar directamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetTraceData">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece datos de seguimiento para el seguimiento en tiempo de diseño de los datos de representación.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTraceData (traceDataKey As Object, traceDataValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTraceData(System::Object ^ traceDataKey, System::Object ^ traceDataValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traceDataKey" Type="System.Object" />
        <Parameter Name="traceDataValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="traceDataKey">Clave de datos de seguimiento.</param>
        <param name="traceDataValue">Valor de datos de seguimiento.</param>
        <summary>Establece datos de seguimiento para el seguimiento en tiempo de diseño de los datos de representación, para lo que usa la clave y el valor de los datos de seguimiento.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object tracedObject, object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object tracedObject, object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTraceData (tracedObject As Object, traceDataKey As Object, traceDataValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTraceData(System::Object ^ tracedObject, System::Object ^ traceDataKey, System::Object ^ traceDataValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tracedObject" Type="System.Object" />
        <Parameter Name="traceDataKey" Type="System.Object" />
        <Parameter Name="traceDataValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tracedObject">El objeto del que se ha realizado seguimiento.</param>
        <param name="traceDataKey">Clave de datos de seguimiento.</param>
        <param name="traceDataValue">Valor de datos de seguimiento.</param>
        <summary>Establece datos de seguimiento para el seguimiento en tiempo de diseño de los datos de representación, para lo que usa el objeto del que se ha realizado seguimiento, así como la clave y el valor de los datos de seguimiento.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Site" />
      <MemberSignature Language="VB.NET" Value="Public Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene información sobre el contenedor en que se encuentra el control actual cuando se representa en una superficie de diseño.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> que contiene información sobre el contendor en que se encuentra el control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un sitio enlaza un <xref:System.ComponentModel.Component> el objeto a un <xref:System.ComponentModel.Container> objeto y permite la comunicación entre los dos. También proporciona una manera para que el contenedor administrar sus componentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Éste es un control <see cref="T:System.Web.UI.WebControls.Substitution" />.</exception>
        <altmember cref="T:System.ComponentModel.ISite" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public virtual string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la máscara que se aplica al control.</summary>
        <value>Nombre de la máscara para aplicar al control. El valor predeterminado es <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las máscaras disponibles para un control se encuentran en uno o varios archivos de máscaras de un directorio de temas. El <xref:System.Web.UI.Control.SkinID%2A> propiedad especifica cuál de estas máscaras se aplica al control. Una máscara es específica de un control determinado; no pueden compartir la configuración de la máscara entre controles de tipos diferentes.  
  
 Si no establece la <xref:System.Web.UI.Control.SkinID%2A> propiedad, un control usa la máscara predeterminada si se ha definido uno. Por ejemplo, si una máscara sin un identificador se define para un <xref:System.Web.UI.WebControls.Image> controlar esa máscara se aplica a todos los <xref:System.Web.UI.WebControls.Image> controles que no hagan referencia explícitamente una máscara con el identificador y que no estén establecidos para deshabilitar temas. Si se define una máscara con un identificador para un <xref:System.Web.UI.WebControls.Image> controlar esa máscara se aplica solo a <xref:System.Web.UI.WebControls.Image> controla cuya <xref:System.Web.UI.Control.SkinID%2A> propiedad se establece en ese identificador.  
  
 Si los archivos de la máscara en un directorio de temas no contienen una máscara con los valores especificados <xref:System.Web.UI.Control.SkinID%2A> propiedad, un <xref:System.ArgumentException> se produce una excepción en tiempo de ejecución.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La hoja de estilos ya se ha aplicado.  
  
 \- o -  
  
 El evento <see langword="Page_PreInit" /> ya se ha producido.  
  
 \- o -  
  
 El control ya se ha agregado a la colección <see langword="Controls" />.</exception>
        <altmember cref="P:System.Web.UI.Control.EnableTheming" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlBuilderAccessor.ControlBuilder">
      <MemberSignature Language="C#" Value="System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlBuilderAccessor#ControlBuilder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ControlBuilder As ControlBuilder Implements IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::ControlBuilder ^ System.Web.UI.IControlBuilderAccessor.ControlBuilder { System::Web::UI::ControlBuilder ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IControlBuilderAccessor.ControlBuilder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para una descripción de este miembro, vea <see cref="P:System.Web.UI.IControlBuilderAccessor.ControlBuilder" />.</summary>
        <value>Objeto <see cref="T:System.Web.UI.ControlBuilder" /> que creó el control; de lo contrario, <see langword="null" /> si no se ha utilizado ningún generador.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Web.UI.Control> se convierte en una interfaz <xref:System.Web.UI.IControlBuilderAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.GetDesignModeState">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary IControlDesignerAccessor.GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#GetDesignModeState" />
      <MemberSignature Language="VB.NET" Value="Function GetDesignModeState () As IDictionary Implements IControlDesignerAccessor.GetDesignModeState" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionary ^ System.Web.UI.IControlDesignerAccessor.GetDesignModeState() = System::Web::UI::IControlDesignerAccessor::GetDesignModeState;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState" />.</summary>
        <returns>
          <see cref="T:System.Collections.IDictionary" /> del estado del control.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Web.UI.Control> se convierte en una interfaz <xref:System.Web.UI.IControlDesignerAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetDesignModeState">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetDesignModeState(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub SetDesignModeState (data As IDictionary) Implements IControlDesignerAccessor.SetDesignModeState" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System::Collections::IDictionary ^ data) = System::Web::UI::IControlDesignerAccessor::SetDesignModeState;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="data">
          <see cref="T:System.Collections.IDictionary" /> que contiene los datos en tiempo de diseño del control.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Web.UI.Control> se convierte en una interfaz <xref:System.Web.UI.IControlDesignerAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetOwnerControl">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetOwnerControl (System.Web.UI.Control owner);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(class System.Web.UI.Control owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetOwnerControl(System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Sub SetOwnerControl (owner As Control) Implements IControlDesignerAccessor.SetOwnerControl" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System::Web::UI::Control ^ owner) = System::Web::UI::IControlDesignerAccessor::SetOwnerControl;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="owner">Propietario del control.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Web.UI.Control> se convierte en una interfaz <xref:System.Web.UI.IControlDesignerAccessor>.  
  
 El <xref:System.Web.UI.IControlDesignerAccessor> interfaz se usa por un diseñador de controles para realizar acciones en tiempo de diseño en el control.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="owner" /> se establece en el control actual.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.UserData">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#UserData" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property UserData As IDictionary Implements IControlDesignerAccessor.UserData" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::IDictionary ^ System.Web.UI.IControlDesignerAccessor.UserData { System::Collections::IDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IControlDesignerAccessor.UserData</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para una descripción de este miembro, vea <see cref="P:System.Web.UI.IControlDesignerAccessor.UserData" />.</summary>
        <value>Colección <see cref="T:System.Collections.IDictionary" /> que contiene información sobre el control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Web.UI.Control> se convierte en una interfaz <xref:System.Web.UI.IControlDesignerAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.DataBindings">
      <MemberSignature Language="C#" Value="System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#DataBindings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DataBindings As DataBindingCollection Implements IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::DataBindingCollection ^ System.Web.UI.IDataBindingsAccessor.DataBindings { System::Web::UI::DataBindingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IDataBindingsAccessor.DataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.DataBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para una descripción de este miembro, vea <see cref="P:System.Web.UI.IDataBindingsAccessor.DataBindings" />.</summary>
        <value>Colección de enlaces de datos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Web.UI.Control> se convierte en una interfaz <xref:System.Web.UI.IDataBindingsAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.HasDataBindings">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IDataBindingsAccessor.HasDataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#HasDataBindings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasDataBindings As Boolean Implements IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Web.UI.IDataBindingsAccessor.HasDataBindings { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IDataBindingsAccessor.HasDataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para una descripción de este miembro, vea <see cref="P:System.Web.UI.IDataBindingsAccessor.HasDataBindings" />.</summary>
        <value>
          <see langword="true" /> si el control contiene lógica de enlace a datos; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Web.UI.Control> se convierte en una interfaz <xref:System.Web.UI.IDataBindingsAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.Expressions">
      <MemberSignature Language="C#" Value="System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#Expressions" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Expressions As ExpressionBindingCollection Implements IExpressionsAccessor.Expressions" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::ExpressionBindingCollection ^ System.Web.UI.IExpressionsAccessor.Expressions { System::Web::UI::ExpressionBindingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IExpressionsAccessor.Expressions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ExpressionBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para una descripción de este miembro, vea <see cref="P:System.Web.UI.IExpressionsAccessor.Expressions" />.</summary>
        <value>Clase <see cref="T:System.Web.UI.ExpressionBindingCollection" /> que contiene objetos <see cref="T:System.Web.UI.ExpressionBinding" /> que representan las propiedades y expresiones de un control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Web.UI.Control> se convierte en una interfaz <xref:System.Web.UI.IExpressionsAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.HasExpressions">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IExpressionsAccessor.HasExpressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#HasExpressions" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasExpressions As Boolean Implements IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Web.UI.IExpressionsAccessor.HasExpressions { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IExpressionsAccessor.HasExpressions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para una descripción de este miembro, vea <see cref="P:System.Web.UI.IExpressionsAccessor.HasExpressions" />.</summary>
        <value>
          Es <see langword="true" /> si el control tiene propiedades establecidas a través de expresiones; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Web.UI.Control> se convierte en una interfaz <xref:System.Web.UI.IExpressionsAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IParserAccessor.AddParsedSubObject">
      <MemberSignature Language="C#" Value="void IParserAccessor.AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IParserAccessor.AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IParserAccessor#AddParsedSubObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddParsedSubObject (obj As Object) Implements IParserAccessor.AddParsedSubObject" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IParserAccessor.AddParsedSubObject(System::Object ^ obj) = System::Web::UI::IParserAccessor::AddParsedSubObject;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a agregar.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Web.UI.Control> se convierte en una interfaz <xref:System.Web.UI.IParserAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.TemplateControl TemplateControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.TemplateControl TemplateControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateControl" />
      <MemberSignature Language="VB.NET" Value="Public Property TemplateControl As TemplateControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::TemplateControl ^ TemplateControl { System::Web::UI::TemplateControl ^ get(); void set(System::Web::UI::TemplateControl ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.TemplateControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una referencia a la plantilla que contiene este control.</summary>
        <value>Instancia de <see cref="T:System.Web.UI.TemplateControl" /> que contiene este control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un <xref:System.Web.UI.Control> instancia forma parte de una plantilla de control, el <xref:System.Web.UI.Control.TemplateControl%2A> propiedad contiene una referencia al control contenedor. Para obtener más información, consulte el <xref:System.Web.UI.TemplateControl?displayProperty=nameWithType> documentación.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public virtual string TemplateSourceDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TemplateSourceDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ TemplateSourceDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el directorio virtual de <see cref="T:System.Web.UI.Page" /> o <see cref="T:System.Web.UI.UserControl" /> que contiene el control de servidor actual.</summary>
        <value>Directorio virtual de la página o control de usuario que contiene el control de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propiedad especifica la ruta de acceso a la página o control de usuario que contiene el control actual. Por ejemplo, si la página Web reside en http://www.contoso.com/application/subdirectory, el <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propiedad devuelve "application/subdirectory".  
  
 Para devolver la ruta de acceso virtual relativa de la aplicación ("~ / subdirectorio"), use el <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propiedad dos veces. La primera vez que se utiliza en un <xref:System.Web.UI.Control.MapPathSecure%2A?displayProperty=nameWithType> llamada de método para obtener la ruta de acceso al directorio en el que se encuentra el control. La segunda vez que se encuentra en un <xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType> llamada al método para obtener la lista de todos los archivos contenidos en ese directorio.  
  
 [!code-csharp[Control_TemplateSourceDirectory#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_TemplateSourceDirectory/CS/control_templatesourcedirectory.cs#2)]
 [!code-vb[Control_TemplateSourceDirectory#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_TemplateSourceDirectory/VB/control_templatesourcedirectory.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.UserControl" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected virtual void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void TrackViewState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Origina el seguimiento de los cambios del estado de vista del control de servidor de manera que se puedan almacenar en el objeto <see cref="T:System.Web.UI.StateBag" /> del control de servidor. Este objeto es accesible a través de la propiedad <see cref="P:System.Web.UI.Control.ViewState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama automáticamente al final de la <xref:System.Web.UI.Control.Init> eventos de ciclo de vida del control de servidor.  
  
 Invocar este método cuando se desarrollan controles enlazados a datos con plantilla. Este método indica a ASP.NET para supervisar los cambios en estado de vista de un control de servidor, que es necesario cuando se reemplaza el <xref:System.Web.UI.Control.DataBind%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 El siguiente ejemplo se reemplaza el <xref:System.Web.UI.Control.DataBind%2A> método en un control de servidor ASP.NET personalizado. Inicia llamando a la base de <xref:System.Web.UI.Control.OnDataBinding%2A> método y, a continuación, utiliza el <xref:System.Web.UI.ControlCollection.Clear%2A> método para eliminar todos los controles secundarios y los <xref:System.Web.UI.Control.ClearChildViewState%2A> método para eliminar la configuración de estado de vista para los controles secundarios guardada. Por último, el <xref:System.Web.UI.Control.ChildControlsCreated%2A> propiedad está establecida en `true`. El control, a continuación, utiliza el <xref:System.Web.UI.Control.IsTrackingViewState%2A> propiedad para determinar si está habilitado el seguimiento de cambios de estado de vista para el control. Si no está habilitado, el <xref:System.Web.UI.Control.TrackViewState%2A> se llama al método.  
  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IStateManager" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="UniqueID">
      <MemberSignature Language="C#" Value="public virtual string UniqueID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.UniqueID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UniqueID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ UniqueID { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador único calificado jerárquicamente para el control de servidor.</summary>
        <value>Identificador completo del control de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es distinta de la <xref:System.Web.UI.Control.ID%2A> propiedad, en el que el <xref:System.Web.UI.Control.UniqueID%2A> propiedad incluye el identificador para el control de servidor del contenedor de nomenclatura. Este identificador se genera automáticamente cuando se procesa una solicitud de página.  
  
 Esta propiedad es especialmente importante en la diferenciación de los controles de servidor dentro de un control de servidor de enlace de datos que se repite. El control de repetición, que son <xref:System.Web.UI.WebControls.Repeater>, <xref:System.Web.UI.WebControls.DataList>, <xref:System.Web.UI.WebControls.DetailsView>, <xref:System.Web.UI.WebControls.FormView>, y <xref:System.Web.UI.WebControls.GridView> Web controles de servidor (o cualquier control de servidor personalizado que cree que incluyen funcionalidad de repetición para enlazado a datos), sirve como contenedor de nomenclatura para sus controles secundarios. Esto significa que crea un espacio de nombres único para sus controles secundarios para que sus <xref:System.Web.UI.Control.ID%2A> valores de propiedad no entren en conflicto.  
  
 Por ejemplo, si incluye un ASP.NET <xref:System.Web.UI.WebControls.Label> Web control de servidor en un <xref:System.Web.UI.WebControls.Repeater> control de servidor y asigne el <xref:System.Web.UI.WebControls.Label> control un <xref:System.Web.UI.Control.ID%2A> valor de propiedad de `MyLabel`y el <xref:System.Web.UI.WebControls.Repeater> una <xref:System.Web.UI.Control.ID%2A> de `MyRepeater`. Si se enlazan datos a la <xref:System.Web.UI.WebControls.Repeater> a una <xref:System.Collections.ArrayList> objeto con tres entradas, resultante <xref:System.Web.UI.Control.UniqueID%2A> propiedades para cada instancia de la <xref:System.Web.UI.WebControls.Label> controles de servidor son `MyRepeater$ctl00$MyLabel`, `MyRepeater$ctl01$MyLabel`, y `MyRepeater$ctl02$MyLabel`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Collections.ArrayList> objeto y lo rellena con tres cadenas de texto y, a continuación, enlaza un <xref:System.Web.UI.WebControls.Repeater> Web control de servidor a los datos en el <xref:System.Collections.ArrayList> cuando se carga la página. El código obtiene la <xref:System.Web.UI.Control.UniqueID%2A> propiedad para cada control secundario que se genera durante el enlace de datos. El código genera tres versiones de la <xref:System.Web.UI.WebControls.Label> control y escribe sus `UniqueID` valores de propiedad a la página.  
  
 [!code-aspx-csharp[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/CS/WebFormsControlIdResolution12.aspx#2)]
 [!code-aspx-vb[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/VB/WebFormsControlIdResolution12.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public event EventHandler Unload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unload" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unload;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el control de servidor se descarga de la memoria.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles de servidor deben realizar cualquier limpieza final, como cerrar archivos, las conexiones de base de datos y descartando los objetos, durante esta fase del ciclo de vida de control antes de que se ha descargado la instancia de.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ValidateRequestMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ValidateRequestMode As ValidateRequestMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ValidateRequestMode ValidateRequestMode { System::Web::UI::ValidateRequestMode get(); void set(System::Web::UI::ValidateRequestMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el control comprueba la entrada del cliente desde el explorador para valores potencialmente peligrosos.</summary>
        <value>Un valor que determina si el control comprueba la entrada del cliente. Los valores pueden incluir <see cref="F:System.Web.UI.ValidateRequestMode.Disabled" />, <see cref="F:System.Web.UI.ValidateRequestMode.Enabled" /> y <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />. El valor predeterminado es <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />, lo que significa que el control obtiene el valor de su elemento primario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de la validación de solicitudes, consulte <xref:System.Web.UnvalidatedRequestValues>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewState">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.StateBag ViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.StateBag ViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ViewState As StateBag" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Web::UI::StateBag ^ ViewState { System::Web::UI::StateBag ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.StateBag</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un diccionario con información de estado que le permite guardar y restaurar el estado de vista de un control de servidor en las distintas solicitudes de la misma página.</summary>
        <value>Instancia de la clase <see cref="T:System.Web.UI.StateBag" /> que contiene la información sobre el estado de vista del control de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de vista de un control de servidor es la acumulación de todos sus valores de propiedad. Para conservar estos valores en las solicitudes HTTP, los controles de servidor ASP.NET utilizan esta propiedad, que es una instancia de la <xref:System.Web.UI.StateBag> (clase), para almacenar los valores de propiedad. A continuación, los valores se pasan como una variable a un elemento de entrada oculto de HTML cuando se procesan las solicitudes posteriores. Para obtener más información acerca de cómo guardar el estado de vista de control de servidor, consulte [ASP.NET State Management Overview](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce).  
  
 Estado de vista está habilitado para todos los controles de servidor de forma predeterminada, pero hay circunstancias en las que desea deshabilitar. Para obtener más información, consulte [información general sobre el rendimiento de ASP.NET](http://msdn.microsoft.com/library/f882bf1b-a009-4312-ac06-74370ffabc0b).  
  
 Para obtener información sobre los diccionarios y cómo utilizarlas, vea [colecciones y estructuras de datos](http://msdn.microsoft.com/library/60cc581f-1db5-445b-ba04-a173396bf872).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo implementar un `Text` propiedad que almacena y recupera su valor de su control <xref:System.Web.UI.Control.ViewState%2A> propiedad.  
  
 [!code-csharp[SysWebUIControlViewState#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SysWebUIControlViewState/CS/controlviewstate.cs#2)]
 [!code-vb[SysWebUIControlViewState#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SysWebUIControlViewState/VB/controlviewstate.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateIgnoresCase">
      <MemberSignature Language="C#" Value="protected virtual bool ViewStateIgnoresCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ViewStateIgnoresCase" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ViewStateIgnoresCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ViewStateIgnoresCase { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Web.UI.StateBag" /> no distingue mayúsculas de minúsculas.</summary>
        <value>
          Es <see langword="true" /> si la instancia de <see cref="T:System.Web.UI.StateBag" /> no distingue mayúsculas de minúsculas; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalide este método si crea un control de servidor personalizado que guarda su estado de vista sin distinguir entre mayúsculas y en la cuenta. Cuando lo haga por lo que varios objetos con la misma clave, pero con distintas mayúsculas y minúsculas, pueden almacenarse en el <xref:System.Web.UI.StateBag> asociados con el <xref:System.Web.UI.Control.ViewState%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo invalidar el <xref:System.Web.UI.Control.ViewStateIgnoresCase%2A> propiedad para devolver `true`.  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#2)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ViewStateMode ViewStateMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateMode ViewStateMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ViewStateMode As ViewStateMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ViewStateMode ViewStateMode { System::Web::UI::ViewStateMode get(); void set(System::Web::UI::ViewStateMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el modo del estado de vista de este control.</summary>
        <value>Modo del estado de vista de este control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el <xref:System.Web.UI.Control.ViewStateMode%2A> propiedad para habilitar el estado de vista para un control individual aun cuando el estado de vista está deshabilitado para la página. Para obtener más información sobre el estado de vista y el estado de control, vea el <xref:System.Web.UI.Control.EnableViewState%2A> propiedad.  
  
 Para deshabilitar el estado de vista de una página y habilitarlo para un control determinado en la página, establezca la <xref:System.Web.UI.Control.EnableViewState%2A> propiedad de la página y el control `true`, establezca el <xref:System.Web.UI.Control.ViewStateMode%2A> propiedad de la página para <xref:System.Web.UI.ViewStateMode.Disabled>y establezca el <xref:System.Web.UI.Control.ViewStateMode%2A> propiedad del control a <xref:System.Web.UI.ViewStateMode.Enabled>.  
  
 El valor predeterminado de la <xref:System.Web.UI.Control.ViewStateMode%2A> es propiedad de una página <xref:System.Web.UI.ViewStateMode.Enabled>. El valor predeterminado de la <xref:System.Web.UI.Control.ViewStateMode%2A> propiedad de un control de servidor Web en una página es <xref:System.Web.UI.ViewStateMode.Inherit>. Como resultado, si no establece esta propiedad en la página o el nivel de control, el valor de la <xref:System.Web.UI.Control.EnableViewState%2A> propiedad determina el comportamiento de estado de vista.  
  
 El <xref:System.Web.UI.Control.ViewStateMode%2A> propiedad de una página o un control tiene un solo si efecto el <xref:System.Web.UI.Control.EnableViewState%2A> propiedad está establecida en `true`. Si el <xref:System.Web.UI.Control.EnableViewState%2A> propiedad está establecida en `false`, estado de vista se apagarán incluso si la <xref:System.Web.UI.Control.ViewStateMode%2A> propiedad está establecida en <xref:System.Web.UI.ViewStateMode.Enabled>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Se intentó establecer esta propiedad en un valor distinto del valor de enumeración <see cref="T:System.Web.UI.ViewStateMode" />.</exception>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public virtual bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si un control de servidor se representa como interfaz de usuario en la página.</summary>
        <value>
          <see langword="true" /> si el control es visible; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si esta propiedad es `false`, no se representa el control de servidor. Debe tener en cuenta al organizar el diseño de la página.  
  
> [!NOTE]
>  Si no se procesa un control de contenedor, todos los controles que lo contiene no se representarán incluso si configura el <xref:System.Web.UI.Control.Visible%2A> propiedad de un control individual a `true`. En ese caso, se devuelve el control individual `false` para el <xref:System.Web.UI.Control.Visible%2A> propiedad incluso si se establece explícitamente en `true`. (Es decir, si la `Visible` propiedad del control primario se establece en `false`, el control secundario hereda ese valor y la configuración tiene prioridad sobre cualquier configuración local.)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>