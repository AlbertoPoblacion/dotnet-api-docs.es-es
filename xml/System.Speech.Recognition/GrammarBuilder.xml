<Type Name="GrammarBuilder" FullName="System.Speech.Recognition.GrammarBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="445ae1620c692c34154268c06fe2f355387357ff" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52231803" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class GrammarBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GrammarBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.GrammarBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class GrammarBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class GrammarBuilder" />
  <TypeSignature Language="F#" Value="type GrammarBuilder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{DebugSummary}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona un mecanismo para compilar mediante programación las restricciones de una gramática de reconocimiento de voz.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gramática de reconocimiento de voz normalmente se crea en el formato XML definido por el [especificación de gramática de reconocimiento de voz (SRGS) versión 1.0](https://go.microsoft.com/fwlink/?LinkId=201761). Si está familiarizado con, pero desea volver a generar mediante programación las gramáticas SRGS, puede usar el <xref:System.Speech.Recognition.SrgsGrammar> espacio de nombres, cuyos miembros estrechamente corresponden a los elementos y atributos definidos por SRGS. Si no está familiarizado con SRGS, o si desea un enfoque mediante programación ligero para la creación de las gramáticas con el que puede realizar muchos escenarios comunes; Puede usar el <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> clases.  
  
 Use <xref:System.Speech.Recognition.GrammarBuilder> formado por objetos para crear un árbol jerárquico <xref:System.Speech.Recognition.Choices> hacer una copia de los objetos que contengan frases alternativas, intercalados con preámbulo y posteriores a la amble frases en cada nodo e inicializar con valores semánticos que transmiten significado para el aplicación.  
  
 Para usar un <xref:System.Speech.Recognition.GrammarBuilder> para crear un <xref:System.Speech.Recognition.Grammar> de objetos, siga estos pasos.  
  
1.  Crear un objeto <xref:System.Speech.Recognition.GrammarBuilder>.  
  
2.  Anexar las restricciones para el <xref:System.Speech.Recognition.GrammarBuilder>, tales como <xref:System.String> objetos, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, <xref:System.Speech.Recognition.DictationGrammar>y otros <xref:System.Speech.Recognition.GrammarBuilder> objetos que definen las restricciones de la gramática.  
  
3.  Utilice uno de los <xref:System.Speech.Recognition.Grammar.%23ctor%2A> constructores para crear un <xref:System.Speech.Recognition.Grammar> objeto completado <xref:System.Speech.Recognition.GrammarBuilder> gramática.  
  
 Creación con <xref:System.Speech.Recognition.GrammarBuilder> se adapta mejor a las gramáticas que tienen una única regla que contiene las listas, o quizás listas de listas. Para generar mediante programación gramáticas que tienen varias reglas, o que deba realizar referencias de regla interna, utilice las clases de la <xref:System.Speech.Recognition.SrgsGrammar> espacio de nombres.  
  
 Las instancias de <xref:System.Speech.Recognition.GrammarBuilder> también puede obtenerse mediante conversiones implícitas de otras clases o combinando un <xref:System.Speech.Recognition.GrammarBuilder> con un segundo objeto que contiene las restricciones de una gramática... Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> y <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operadores y <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> métodos.  
  
 Para agregar reglas a una existente <xref:System.Speech.Recognition.GrammarBuilder>, utilice el <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, y <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> métodos.  
  
> [!IMPORTANT]
>  El reconocedor de voz puede producir una excepción cuando se usa una gramática de reconocimiento de voz que contiene los elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que repetidamente podrían modificar el valor del mismo elemento semántico. 
  
 Para ayudar con la depuración, la <xref:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases%2A> propiedad devuelve el estado actual de la <xref:System.Speech.Recognition.GrammarBuilder> como una cadena.  
  
 Para obtener más información sobre cómo crear y usar gramáticas reconocimiento de voz, consulte [el reconocimiento de voz](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) y [crear GrammarBuilder gramáticas](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> objetos para construir una gramática que pueda reconocer cualquiera de las dos frases, "convertirla en fondo *colorChoice*" o "establecido en segundo plano en *colorChoice*".  
  
 El ejemplo se usa un <xref:System.Speech.Recognition.Choices> objeto para crear una lista de valores aceptables para *colorChoice* desde una matriz de <xref:System.String> objetos. Un <xref:System.Speech.Recognition.Choices> objeto es análogo a la `one-of` elemento en la especificación de SRGS y contiene un conjunto de frases alternativas, cualquiera de los cuales puede ser reconocido cuando se habla. El ejemplo también usa un <xref:System.Speech.Recognition.Choices> objeto para agrupar una matriz de dos <xref:System.Speech.Recognition.GrammarBuilder> objetos en un par de frases alternativas que puede reconocer la gramática resultante. Frases o palabras alternativas son un componente de la mayoría de las gramáticas y el <xref:System.Speech.Recognition.Choices> objeto proporciona esta funcionalidad para construyen gramáticas con <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 El ejemplo, por último, se crea un <xref:System.Speech.Recognition.Grammar> objeto desde un <xref:System.Speech.Recognition.GrammarBuilder> construido a partir de un <xref:System.Speech.Recognition.Choices> objeto.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.Choices" />
    <altmember cref="T:System.Speech.Recognition.Grammar" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las instancias de esta clase también pueden obtenerse mediante conversiones implícitas de otras clases o combinando un <xref:System.Speech.Recognition.GrammarBuilder> objeto con un segundo objeto a partir de un nuevo <xref:System.Speech.Recognition.GrammarBuilder>. Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> y <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> métodos.  
  
 Agregar restricciones a una existente <xref:System.Speech.Recognition.GrammarBuilder>, utilice el <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, y <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> métodos y el <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operador.  
  
> [!IMPORTANT]
>  El reconocedor de voz puede producir una excepción cuando se usa una gramática de reconocimiento de voz que contiene los elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que repetidamente podrían modificar el valor del mismo elemento semántico.
  
 Para obtener más información sobre cómo crear y usar gramáticas reconocimiento de voz, consulte [el reconocimiento de voz](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) y [crear GrammarBuilder gramáticas](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia vacía de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para agregar reglas a una existente <xref:System.Speech.Recognition.GrammarBuilder> de objeto, utilice el <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, y <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> métodos y el <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operador.  
  
> [!IMPORTANT]
>  El reconocedor de voz puede producir una excepción cuando se usa una gramática de reconocimiento de voz que contiene los elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que repetidamente podrían modificar el valor del mismo elemento semántico.
  
   
  
## Examples  
 En el ejemplo siguiente se usa <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> objetos para construir una gramática que pueda reconocer cualquiera de las dos frases, "convertirla en fondo *colorChoice*" o "establecido en segundo plano en *colorChoice*".  
  
 El ejemplo se usa un <xref:System.Speech.Recognition.Choices> objeto para crear una lista de valores aceptables para *colorChoice* desde una matriz de <xref:System.String> objetos. Un <xref:System.Speech.Recognition.Choices> objeto es análogo a la `one-of` elemento en la especificación de SRGS y contiene un conjunto de frases alternativas, cualquiera de los cuales puede ser reconocido cuando se habla. El ejemplo también usa un <xref:System.Speech.Recognition.Choices> objeto para agrupar una matriz de dos <xref:System.Speech.Recognition.GrammarBuilder> objetos en un par de frases alternativas que puede reconocer la gramática resultante. Frases o palabras alternativas son un componente de la mayoría de las gramáticas y el <xref:System.Speech.Recognition.Choices> objeto proporciona esta funcionalidad para construyen gramáticas con <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 El ejemplo, por último, se crea un <xref:System.Speech.Recognition.Grammar> objeto desde un <xref:System.Speech.Recognition.GrammarBuilder> construido a partir de un <xref:System.Speech.Recognition.Choices> objeto.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  GrammarBuilder bothPhrases = new GrammarBuilder();  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  bothPhrases.Append(bothChoices);  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder alternateChoices" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">Conjunto de alternativas.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" /> a partir de un conjunto de alternativas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre la creación de una gramática de reconocimiento de voz que contiene alternativas, consulte [utilizando las opciones para crear una gramática GrammarBuilder](https://msdn.microsoft.com/library/5b18db18-a5f6-46a3-aa77-6d3141544efd).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> objetos para construir una gramática que pueda reconocer cualquiera de las dos frases, "convertirla en fondo *colorChoice*" o "establecido en segundo plano en *colorChoice*".  
  
 El ejemplo se usa un <xref:System.Speech.Recognition.Choices> objeto para crear una lista de valores aceptables para *colorChoice* desde una matriz de <xref:System.String> objetos. Un <xref:System.Speech.Recognition.Choices> objeto es análogo a la `one-of` elemento en la especificación de SRGS y contiene un conjunto de frases alternativas, cualquiera de los cuales puede ser reconocido cuando se habla. El ejemplo también usa un <xref:System.Speech.Recognition.Choices> objeto para agrupar una matriz de dos <xref:System.Speech.Recognition.GrammarBuilder> objetos en un par de frases alternativas que puede reconocer la gramática resultante. Frases o palabras alternativas son un componente de la mayoría de las gramáticas y el <xref:System.Speech.Recognition.Choices> objeto proporciona esta funcionalidad para construyen gramáticas con <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 El ejemplo, por último, se crea un <xref:System.Speech.Recognition.Grammar> objeto desde un <xref:System.Speech.Recognition.GrammarBuilder> construido a partir de un <xref:System.Speech.Recognition.Choices> objeto.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder key" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">La clave semántica.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" /> a partir de una clave semántica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando creas un <xref:System.Speech.Recognition.GrammarBuilder> instancia desde un <xref:System.Speech.Recognition.SemanticResultValue> de objeto, agregue información semántica a la gramática que se puede devolver en el resultado de reconocimiento. Puede obtener acceso a la información semántica en el resultado de reconocimiento mediante la <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> propiedad de <xref:System.Speech.Recognition.RecognizedPhrase>, que está disponible en el controlador para el `SpeechRecognized` eventos. Si el <xref:System.Speech.Recognition.GrammarBuilder> define un <xref:System.Speech.Recognition.SemanticResultKey>, esto puede usarse para recuperar la información semántica en un resultado de reconocimiento que está asociado con la clave. Vea el ejemplo de <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>y también vea <xref:System.Speech.Recognition.SemanticResultValue> y <xref:System.Speech.Recognition.SemanticResultKey>.  
  
> [!IMPORTANT]
>  Cuando se construye <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias, asegúrese de que evita la creación de elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar repetidamente el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. 
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer las dos frases, "convertirla en fondo *colorChoice*" y "establecido en segundo plano en *colorChoice*", donde  *colorChoice* está seleccionado en un conjunto de colores. La gramática permite a los usuarios hablan varios nombres de color y devuelve información semántica sobre el nombre del color reconocido para la aplicación.  
  
 El ejemplo usa una sola <xref:System.Speech.Recognition.SemanticResultKey> con que se puede recuperar el <xref:System.Speech.Recognition.SemanticValue> que está asociado con el color que se habla por el usuario. Por ejemplo, si la entrada contiene la frase, "Conjunto de fondo a rojo", el resultado de reconocimiento que contiene el valor semántico de "#ff0000", que puede recuperar mediante un controlador para el `SpeechRecognized` eventos.  
  
 El ejemplo se utiliza <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, y <xref:System.Speech.Recognition.GrammarBuilder> objetos para crear las restricciones que se encuentran en los últimos <xref:System.Speech.Recognition.GrammarBuilder> objeto, `bothPhrases`. Por último, en el ejemplo se crea un <xref:System.Speech.Recognition.Grammar> objeto completado <xref:System.Speech.Recognition.GrammarBuilder>.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices object for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the Grammar object from the GrammarBuilder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">El valor o el par de nombre y valor semántico.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" /> a partir de un valor semántico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando creas un <xref:System.Speech.Recognition.GrammarBuilder> instancia desde un <xref:System.Speech.Recognition.SemanticResultValue> de objeto, agregue información semántica a la gramática que se puede devolver en el resultado de reconocimiento. Puede obtener acceso a la información semántica en el resultado de reconocimiento mediante la <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> propiedad de <xref:System.Speech.Recognition.RecognizedPhrase>, que está disponible en el controlador para el `SpeechRecognized` eventos. Si el <xref:System.Speech.Recognition.GrammarBuilder> define un <xref:System.Speech.Recognition.SemanticResultKey>, esto puede usarse para recuperar la información semántica en un resultado de reconocimiento que está asociado con la clave. Vea el ejemplo de <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>y también vea <xref:System.Speech.Recognition.SemanticResultValue> y <xref:System.Speech.Recognition.SemanticResultKey>.  
  
> [!IMPORTANT]
>  Cuando se construye <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias, asegúrese de que evita la creación de elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar repetidamente el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. 
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer las dos frases, "convertirla en fondo *colorChoice*" y "establecido en segundo plano en *colorChoice*", donde  *colorChoice* está seleccionado en un conjunto de colores. La gramática permite a los usuarios hablan varios nombres de color y devuelve información semántica sobre el nombre del color reconocido para la aplicación.  
  
 El ejemplo usa una sola <xref:System.Speech.Recognition.SemanticResultKey> con que se puede recuperar el <xref:System.Speech.Recognition.SemanticValue> que está asociado con el color que se habla por el usuario. Por ejemplo, si la entrada contiene la frase, "Conjunto de fondo a rojo", el resultado de reconocimiento que contiene el valor semántico de "#ff0000", que puede recuperar mediante un controlador para el `SpeechRecognized` eventos.  
  
 El ejemplo se utiliza <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, y <xref:System.Speech.Recognition.GrammarBuilder> objetos para crear las restricciones que se encuentran en los últimos <xref:System.Speech.Recognition.GrammarBuilder> objeto, `bothPhrases`. Por último, en el ejemplo se crea un <xref:System.Speech.Recognition.Grammar> objeto completado <xref:System.Speech.Recognition.GrammarBuilder>.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the grammar from the grammar builder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder phrase" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">La secuencia de palabras.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" /> a partir de una secuencia de palabras.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La frase representa una frase hablada exacta que pueda reconocer la gramática de reconocimiento de voz. Para obtener más información sobre la creación de una gramática de reconocimiento de voz que contiene cadenas, vea [uso de cadenas para crear una gramática GrammarBuilder](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> objetos para construir una gramática que pueda reconocer cualquiera de las dos frases, "convertirla en fondo *colorChoice*" o "establecido en segundo plano en *colorChoice*".  
  
 Después de crear una lista de valores aceptables para *colorChoice* mediante un <xref:System.Speech.Recognition.Choices> objeto, en el ejemplo se inicializa dos <xref:System.Speech.Recognition.GrammarBuilder> objetos, `makePhrase` y `setPhrase`, mediante una cadena como argumento.  
  
 El ejemplo, por último, se crea un <xref:System.Speech.Recognition.Grammar> objeto desde un <xref:System.Speech.Recognition.Choices> convertir un objeto en un <xref:System.Speech.Recognition.GrammarBuilder> objeto.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * System.Speech.Recognition.SubsetMatchingMode -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, subsetMatchingCriteria)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">La secuencia de palabras.</param>
        <param name="subsetMatchingCriteria">El modo coincidente que la gramática de reconocimiento de voz usa para reconocer la frase.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para un subconjunto de una secuencia de palabras.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `phrase` parámetro representa la frase que pueda reconocer la gramática de reconocimiento de voz. El `subsetMatchingMode` parámetro especifica un subconjunto de la frase que se puede hablar para lograr un reconocimiento correcto de la frase completa. Puede usar esto para crear una gramática con una lista de entradas que tienen nombres largos, sin requerir que los usuarios hablan de un nombre completo para que coincida con un elemento.  
  
 Para obtener más información acerca de los modos de búsqueda de coincidencias, vea <xref:System.Speech.Recognition.SubsetMatchingMode>. Para obtener más información sobre la creación de una gramática de reconocimiento de voz que contiene cadenas, vea [uso de cadenas para crear una gramática GrammarBuilder](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz para cada <xref:System.Speech.Recognition.SubsetMatchingMode> valor y una gramática para elegir entre las gramáticas de modo que coincida. Si el valor de `phrase` es "uno dos tres cuatro cinco seis siete", a continuación, la gramática de subsecuencia reconoce la entrada "dos tres cuatro", pero no la entrada "uno tres cinco". Sin embargo, la gramática de subconjunto ordenada reconoce ambas de estas entradas.  
  
```csharp  
  
private static IEnumerable<Grammar>  
  CreateMatchingModeGrammars(string phrase)  
{  
  List<Grammar> grammars = new List<Grammar>(5);  
  
  Choices modeChoice = new Choices();  
  Type enumType = typeof(SubsetMatchingMode);  
  foreach (SubsetMatchingMode mode in Enum.GetValues(enumType))  
  {  
    string modeName = Enum.GetName(enumType, mode);  
    modeName = BreakAtCaps(modeName);  
  
    GrammarBuilder builder = new GrammarBuilder(phrase, mode);  
    Grammar modeGrammar = new Grammar(builder);  
    modeGrammar.Name = modeName;  
    modeGrammar.Enabled = false;  
    grammars.Add(modeGrammar);  
  
    modeChoice.Add(modeName);  
  }  
  
  Grammar choiceGrammar = new Grammar(modeChoice);  
  choiceGrammar.Name = "choice";  
  grammars.Add(choiceGrammar);  
  
  return grammars;  
}  
  
// Insert spaces preceding each uppercase letter in a string.   
private static string BreakAtCaps(string item)  
{  
  if (item == null || item.Length == 0)  
  {  
    return item;  
  }  
  
  StringBuilder sb = new StringBuilder(item[0].ToString());  
  for (int i = 1; i < item.Length; i++)  
  {  
    char c = item[i];  
    if (char.IsUpper(c))  
    {  
      sb.Append(" ");  
    }  
    sb.Append(c);  
  }  
  
  return sb.ToString();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.SubsetMatchingMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.GrammarBuilder * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (builder, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">Elemento repetido.</param>
        <param name="minRepeat">El número mínimo de veces que la entrada coincidente con el elemento definido por <paramref name="builder" /> debe aparecer para que constituya una coincidencia.</param>
        <param name="maxRepeat">El número máximo de veces que la entrada coincidente con el elemento definido por <paramref name="builder" /> puede aparecer para que constituya una coincidencia.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" /> a partir de un elemento repetido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor de `minRepeat` es 0, entonces el nuevo <xref:System.Speech.Recognition.GrammarBuilder> representa un elemento opcional.  
  
 El valor de `minRepeat` debe ser mayor o igual que 0 y menor o igual que el valor de `maxRepeat`.  
  
> [!IMPORTANT]
>  Al especificar repeticiones para <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias, asegúrese de que evita la creación de elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar repetidamente el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. 
  
   
  
## Examples  
 El ejemplo siguiente crea una gramática de reconocimiento de voz para pedir una pizza. Se inicia con una frase de apertura, opcional, seguida de uno a cuatro ingredientes y se cierra con la palabra "pizza".  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object from a string array of alternative toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">La secuencia repetida de palabras.</param>
        <param name="minRepeat">El número mínimo de veces que la entrada coincidente con la frase debe aparecer para que constituya una coincidencia.</param>
        <param name="maxRepeat">El número máximo de veces que la entrada coincidente con la frase puede aparecer para que constituya una coincidencia.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" /> a partir del flujo de palabras en un objeto <see cref="T:System.String" /> y especifica cuántas veces se puede repetir <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor de `minRepeat` es 0, entonces el nuevo <xref:System.Speech.Recognition.GrammarBuilder> representa un elemento opcional.  
  
 El valor de `minRepeat` debe ser mayor o igual que 0 y menor o igual que el valor de `maxRepeat`. Para obtener más información sobre la creación de una gramática de reconocimiento de voz que contiene cadenas, vea [uso de cadenas para crear una gramática GrammarBuilder](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 El ejemplo siguiente crea una gramática de reconocimiento de voz para pedir una pizza. Se inicia con una frase de apertura, opcional, seguida de uno a cuatro ingredientes y se cierra con la palabra "pizza".  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene una secuencia de dos elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estático <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> métodos proporcionan otro mecanismo por el que se pueden combinar distintos tipos para crear la diversidad y flexibilidad en las gramáticas compiladas con <xref:System.Speech.Recognition.GrammarBuilder>. Estos métodos se corresponden con estático <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> métodos, que también se definen en el <xref:System.Speech.Recognition.GrammarBuilder> clase. El orden de los parámetros determina el orden de los elementos en el nuevo <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 Un <xref:System.Speech.Recognition.GrammarBuilder> también puede obtenerse de <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, y [cadena](https://go.microsoft.com/fwlink/?LinkId=159733) objetos. Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> y <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operadores.  
  
> [!IMPORTANT]
>  El reconocedor de voz puede producir una excepción cuando se usa una gramática de reconocimiento de voz que contiene los elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que repetidamente podrían modificar el valor del mismo elemento semántico. 
  
 Para obtener más información sobre cómo crear y usar gramáticas reconocimiento de voz, consulte [el reconocimiento de voz](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) y [crear GrammarBuilder gramáticas](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (choices, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">El primer elemento grammar, que representa un conjunto de alternativas.</param>
        <param name="builder">El segundo elemento grammar.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene un objeto <see cref="T:System.Speech.Recognition.Choices" /> seguido por un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del elemento <paramref name="choices" /> seguido por el elemento <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> admite conversiones implícitas de las clases siguientes:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder` parámetro.  
  
 Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> y <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operadores.  
  
> [!IMPORTANT]
>  Si combina <xref:System.Speech.Recognition.Choices> y <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias, asegúrese de que evita la creación de elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. Para obtener más información sobre la creación de una gramática de reconocimiento de voz que contiene la información semántica, consulte [agregar semántica a una gramática GrammarBuilder](https://msdn.microsoft.com/library/hh361581.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, choices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">El primer elemento de gramática.</param>
        <param name="choices">El segundo elemento de la gramática, que representa un conjunto de alternativas.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" /> seguido por un objeto <see cref="T:System.Speech.Recognition.Choices" />.</summary>
        <returns>Un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del elemento <paramref name="builder" /> seguido por el elemento <paramref name="choices" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> admite conversiones implícitas de las clases siguientes:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder` parámetro.  
  
 Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> y <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operadores.  
  
> [!IMPORTANT]
>  Si combina <xref:System.Speech.Recognition.Choices> y <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias con otros elementos de gramática, asegúrese de evitar la creación de elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que podría modificar repetidamente el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. 
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer las dos frases, "convertirla en fondo *color*" y "establecido en segundo plano en *color*", donde *color* se seleccionan de un conjunto de colores. Varios tipos se utilizan para generar la gramática final, como [cadena](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, y <xref:System.Speech.Recognition.GrammarBuilder> objetos. Los operadores de conversión explícita en las llamadas a la <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> métodos son opcionales.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder1, builder2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">El primer elemento de gramática.</param>
        <param name="builder2">El segundo elemento grammar.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene una secuencia de dos objetos <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del elemento <paramref name="builder1" /> seguido por el elemento <paramref name="builder2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> admite conversiones implícitas de las clases siguientes:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder1` o `builder2` parámetro.  
  
 Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> y <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operadores.  
  
> [!IMPORTANT]
>  Si combina <xref:System.Speech.Recognition.Choices> y <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias con otros elementos de gramática, asegúrese de evitar la creación de elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que podría modificar repetidamente el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. 
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer las dos frases, "convertirla en fondo *color*" y "establecido en segundo plano en *color*", donde *color* se seleccionan de un conjunto de colores. Varios tipos se utilizan para generar la gramática final, como [cadena](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, y <xref:System.Speech.Recognition.GrammarBuilder> objetos. Los operadores de conversión explícita en las llamadas a la <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> métodos son opcionales.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, phrase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">El primer elemento de gramática.</param>
        <param name="phrase">El segundo elemento de la gramática, que representa una secuencia de palabras.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" /> seguido de una frase.</summary>
        <returns>Un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del elemento <paramref name="builder" /> seguido por el elemento <paramref name="phrase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> admite conversiones implícitas de las clases siguientes:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder` parámetro.  
  
 Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> y <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operadores.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer las dos frases, "convertirla en fondo *color*" y "establecido en segundo plano en *color*", donde *color* se seleccionan de un conjunto de colores. Varios tipos se utilizan para generar la gramática final, como [cadena](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, y <xref:System.Speech.Recognition.GrammarBuilder> objetos. Los operadores de conversión explícita en las llamadas a la <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> métodos son opcionales.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (phrase, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">El primer elemento de la gramática, que representa una secuencia de palabras.</param>
        <param name="builder">El segundo elemento grammar.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene una frase seguida de un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del elemento <paramref name="phrase" /> seguido por el elemento <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> admite conversiones implícitas de las clases siguientes:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder` parámetro.  
  
 Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> y <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operadores.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer las dos frases, "convertirla en fondo *color*" y "establecido en segundo plano en *color*", donde *color* se seleccionan de un conjunto de colores. Varios tipos se utilizan para generar la gramática final, como [cadena](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, y <xref:System.Speech.Recognition.GrammarBuilder> objetos. Los operadores de conversión explícita en las llamadas a la <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> métodos son opcionales.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Anexa un elemento de gramática a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice estos métodos para anexar elementos de gramática a una existente <xref:System.Speech.Recognition.GrammarBuilder>. A medida que cree elementos de gramática, se puede anexar al generador para desarrollar progresivamente las restricciones de una gramática de reconocimiento de voz existente. Cada elemento se agrega al final de la secuencia actual de elementos.  
  
 Este método tiene sobrecargas para anexar <xref:System.Speech.Recognition.GrammarBuilder>, <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, y <xref:System.Speech.Recognition.SemanticResultValue> objetos.  
  
> [!IMPORTANT]
>  El reconocedor de voz puede producir una excepción cuando se usa una gramática de reconocimiento de voz que contiene los elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que repetidamente podrían modificar el valor del mismo elemento semántico. 
  
 Para obtener más información sobre cómo crear y usar gramáticas reconocimiento de voz, consulte [el reconocimiento de voz](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) y [crear GrammarBuilder gramáticas](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.Choices -&gt; unit" Usage="grammarBuilder.Append alternateChoices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">El conjunto de alternativas para anexar.</param>
        <summary>Anexa un conjunto de alternativas a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `alternateChoices` se agrega al final de la secuencia actual de elementos.  
  
> [!IMPORTANT]
>  Cuando se anexa <xref:System.Speech.Recognition.Choices> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias a un <xref:System.Speech.Recognition.GrammarBuilder> de objetos, asegúrese de que evita la creación de elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que pudieron repetidamente modificar el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias.
  
   
  
## Examples  
 El ejemplo siguiente crea una gramática de reconocimiento de voz para frases como "Jaime llamada en el trabajo" y "Anne de llamada en su teléfono móvil", donde la palabra "teléfono" es opcional. En el ejemplo se resalta el uso de la <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> método.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder -&gt; unit" Usage="grammarBuilder.Append builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">El elemento de gramática para anexar.</param>
        <summary>Anexa un elemento de gramática a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `builder` se agrega al final de la secuencia actual de elementos de gramática.  
  
> [!NOTE]
>  Cuando se anexa <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias a un <xref:System.Speech.Recognition.GrammarBuilder> de objetos, asegúrese de que evita la creación de elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que pudieron repetidamente modificar el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. 
  
   
  
## Examples  
 El ejemplo siguiente crea una gramática de reconocimiento de voz para frases como "Jaime llamada en el trabajo" y "Anne de llamada en su teléfono móvil", donde la palabra "teléfono" es opcional. <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> objetos se usan para construir la gramática. En el ejemplo se resalta el uso de la <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> método.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultKey -&gt; unit" Usage="grammarBuilder.Append key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">La clave semántica para anexar.</param>
        <summary>Anexa una clave semántica a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `key` se agrega al final de la secuencia actual de elementos.  
  
> [!IMPORTANT]
>  Cuando se anexa <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias a un <xref:System.Speech.Recognition.GrammarBuilder> de objetos, asegúrese de que evita la creación de elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar repetidamente el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias.
  
   
  
## Examples  
 El ejemplo siguiente es parte de una aplicación de consola para elegir las ciudades de origen y destino de un vuelo. La aplicación reconoce frases como "Quiero Volar de Miami en Chicago". El controlador para el <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> evento utiliza el <xref:System.Speech.Recognition.SemanticResultKey> para extraer el código de aeropuerto especificado en el <xref:System.Speech.Recognition.SemanticResultValue> para las ciudades de origen y destino.  
  
```csharp  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create a Choices object and add  cities and airport codes  
        // using SemanticResultValue objects.  
        Choices cities = new Choices();  
        cities.Add(new SemanticResultValue("Chicago", "ORD"));  
        cities.Add(new SemanticResultValue("Boston", "BOS"));  
        cities.Add(new SemanticResultValue("Miami", "MIA"));  
        cities.Add(new SemanticResultValue("Dallas", "DFW"));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultValue -&gt; unit" Usage="grammarBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">Valor semántico que se va a agregar.</param>
        <summary>Anexa un valor semántico a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` se agrega al final de la secuencia actual de elementos.  
  
> [!IMPORTANT]
>  Cuando se anexa <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias a un <xref:System.Speech.Recognition.GrammarBuilder> de objetos, asegúrese de que evita la creación de elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar repetidamente el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias.
  
   
  
## Examples  
 El ejemplo siguiente es parte de una aplicación de consola para elegir las ciudades de origen y destino de un vuelo. La aplicación reconoce frases como "Quiero Volar de Miami en Chicago". El controlador para el <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> evento utiliza el <xref:System.Speech.Recognition.SemanticResultKey> para extraer el código de aeropuerto especificado en el <xref:System.Speech.Recognition.SemanticResultValue> para las ciudades de origen y destino.  
  
```csharp  
  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create GrammarBuilder objects and append SemanticResultValue objects   
        // that contain cities and airport codes.  
  
        GrammarBuilder chicago = new GrammarBuilder();  
        chicago.Append(new SemanticResultValue("Chicago", "ORD"));  
  
        GrammarBuilder boston = new GrammarBuilder();  
        boston.Append(new SemanticResultValue("Boston", "BOS"));  
  
        GrammarBuilder miami = new GrammarBuilder();  
        miami.Append(new SemanticResultValue("Miami", "MIA"));  
  
        GrammarBuilder dallas = new GrammarBuilder();  
        dallas.Append(new SemanticResultValue("Dallas", "DFW"));  
  
        // Create a Choices object and add the cities using implicit conversion from   
        // SemanticResultValue to GrammarBuilder.  
        Choices cities = new Choices();  
        cities.Add(new Choices(new GrammarBuilder[] { chicago, boston, miami, dallas }));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; unit" Usage="grammarBuilder.Append phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">La secuencia de palabras para anexar.</param>
        <summary>Anexa una frase a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase` se agrega al final de la secuencia actual de elementos.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="member this.Append : string * System.Speech.Recognition.SubsetMatchingMode -&gt; unit" Usage="grammarBuilder.Append (phrase, subsetMatchingCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">La secuencia de palabras para anexar.</param>
        <param name="subsetMatchingCriteria">El modo coincidente que la gramática usa para reconocer la frase.</param>
        <summary>Anexa un elemento para un subconjunto de una frase a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El elemento del subconjunto se agrega al final de la secuencia actual de elementos. Para obtener más información sobre la creación de una gramática de reconocimiento de voz con cadenas, vea [uso de cadenas para crear una gramática GrammarBuilder](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
 Para obtener información detallada sobre el uso de los modos de coincidente del subconjunto, consulte <xref:System.Speech.Recognition.SubsetMatchingMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz para cada <xref:System.Speech.Recognition.SubsetMatchingMode> valor. Por ejemplo, la gramática generada `OrderedSubset` reconoce las frases, "tres cuatro cinco" y "uno tres cinco" y la gramática `Subsequence` reconoce la frase "tres cuatro cinco", pero no la frase "una tres cinco".  
  
```csharp  
  
private Grammar[] CreateSubsetMatchTest()  
{  
  List<Grammar> grammars = new List<Grammar>(4);  
  
  string phrase = "one two three four five six";  
  foreach (SubsetMatchingMode mode in  
    Enum.GetValues(typeof(SubsetMatchingMode)))  
  {  
    GrammarBuilder gb = new GrammarBuilder();  
    gb.Append(phrase, mode);  
  
    Grammar grammar = new Grammar(gb);  
    grammar.Name = mode.ToString();  
    grammars.Add(grammar);  
  }  
  
  return grammars.ToArray();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder * int * int -&gt; unit" Usage="grammarBuilder.Append (builder, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">El elemento de gramática repetido para anexar.</param>
        <param name="minRepeat">El número mínimo de veces que la entrada coincidente con el elemento definido por <paramref name="builder" /> debe aparecer para que constituya una coincidencia.</param>
        <param name="maxRepeat">El número máximo de veces que la entrada coincidente con el elemento definido por <paramref name="builder" /> puede aparecer para que constituya una coincidencia.</param>
        <summary>Anexa un elemento de gramática repetido a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de `minRepeat` debe ser mayor o igual que 0 y menor o igual que el valor de `maxRepeat`.  
  
> [!IMPORTANT]
>  Cuando se anexa <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias a un <xref:System.Speech.Recognition.GrammarBuilder> de objetos, asegúrese de que evita la creación de elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que pudieron repetidamente modificar el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias.
  
   
  
## Examples  
 El ejemplo siguiente crea una gramática de reconocimiento de voz para frases como "Jaime llamada en el trabajo" y "Anne de llamada en su teléfono móvil", donde la palabra "teléfono" es opcional. <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> objetos se usan para construir la gramática. En el ejemplo se resalta el uso de la <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> método.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; unit" Usage="grammarBuilder.Append (phrase, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">La secuencia repetida de palabras para anexar.</param>
        <param name="minRepeat">El número mínimo de veces que la entrada coincidente <paramref name="phrase" /> debe aparecer para que constituya una coincidencia.</param>
        <param name="maxRepeat">El número máximo de veces que la entrada coincidente <paramref name="phrase" /> puede aparecer para que constituya una coincidencia.</param>
        <summary>Anexa una frase repetida a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de `minRepeat` debe ser mayor o igual que 0 y menor o igual que el valor de `maxRepeat`.  
  
   
  
## Examples  
 El ejemplo siguiente crea una gramática de reconocimiento de voz para frases como "Jaime llamada en el trabajo" y "Anne de llamada en su teléfono móvil", donde la palabra "teléfono" es opcional. <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> objetos se usan para construir la gramática. En el ejemplo se resalta el uso de la <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> método.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendDictation">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Anexa una gramática de dictado a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A> métodos permiten anexar una gramática de dictado como una regla a un <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 Para obtener más información sobre la gramática de dictado, consulte <xref:System.Speech.Recognition.DictationGrammar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation();" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : unit -&gt; unit" Usage="grammarBuilder.AppendDictation " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anexa la gramática de dictado predeterminada a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre la gramática de dictado, consulte <xref:System.Speech.Recognition.DictationGrammar>.  
  
   
  
## Examples  
 El ejemplo siguiente crea una gramática de reconocimiento de voz que incorpora el dictado.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation();  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation (string category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation(string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation (category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation(System::String ^ category);" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : string -&gt; unit" Usage="grammarBuilder.AppendDictation category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="category">La categoría de la gramática de dictado para anexar.</param>
        <summary>Anexa la gramática de dictado especificada a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar la gramática de dictado de ortografía, establezca `category` a `spelling`.  
  
 Para obtener más información sobre la gramática de dictado, consulte <xref:System.Speech.Recognition.DictationGrammar>.  
  
   
  
## Examples  
 El ejemplo siguiente crea una gramática de reconocimiento de voz que incorpora las reglas de gramática de dictado de ortografía.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation("spelling");  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendRuleReference">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Anexa un archivo o una regla de gramática a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> métodos pueden anexar un archivo o una regla de gramática desde un archivo. Estos métodos permiten a las aplicaciones hacer uso de reglas de gramática previamente implementará o estará disponible públicamente. La aplicación debe tener acceso de lectura a la ubicación de archivos de gramática especificada.  
  
 Estos métodos pueden leer una gramática de reconocimiento de voz de los siguientes formatos.  
  
-   Archivos de formato XML que cumplen con el W3C [especificación de gramática de reconocimiento de voz (SRGS) versión 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   Archivos binarios que se ajustan a la Microsoft Speech Recognition gramática formato binario (extensión de archivo .cfg)  
  
 Compilar un formato XML de SRGS el archivo de gramática a un archivo binario de gramática con la extensión .cfg puede reducir el tiempo consumido por busca una coincidencia, especialmente si requiere que la gramática de reconocimiento de un gran número de palabras y frases. Para obtener información sobre la compilación de las gramáticas SRGS en el formato binario de CFG, consulte <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string -&gt; unit" Usage="grammarBuilder.AppendRuleReference path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso o el identificador de recursos universal (URI) del archivo que describe una gramática de reconocimiento de voz en un formato admitido.</param>
        <summary>Anexa un archivo de definición de gramática a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El URI proporcionado por el `path` argumento puede ser local o remoto. La aplicación debe tener acceso de lectura a la ubicación de archivos de gramática especificada.  
  
 Una representación de la especificación de gramática de reconocimiento de voz (SRGS) de W3C puede definir una regla raíz. Este método anexa la gramática, empezando por la regla raíz, a la secuencia actual de elementos de gramática. Para anexar una regla de gramática específica, utilice el <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> método.  
  
   
  
## Examples  
 En el ejemplo de C# siguiente se crea una gramática de reconocimiento de voz que usa la regla llamada `Cities` en un archivo local de SRGS cities.grxml. El contenido del archivo cities.grxml aparece a continuación el ejemplo de código de C#.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar1()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.AppendRuleReference("file://c:/temp/cities.grxml");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 1";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-16" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path, string rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path, string rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String, rule As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path, System::String ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string * string -&gt; unit" Usage="grammarBuilder.AppendRuleReference (path, rule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rule" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso o el identificador de recursos universal (URI) del archivo que describe una gramática de reconocimiento de voz en un formato compatible.</param>
        <param name="rule">El identificador de la regla para anexar, o <see langword="null" /> para anexar la regla raíz predeterminada del archivo de gramática.</param>
        <summary>Anexa la regla especificada de un archivo de definición de gramática a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El URI proporcionado por el `path` argumento puede ser local o remoto. La aplicación debe tener acceso de lectura a la ubicación de archivos de gramática especificada.  
  
 Puede usar el <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> método para anexar un principio de archivo de gramática con su regla raíz.  
  
   
  
## Examples  
 En el ejemplo de C# siguiente se crea una gramática de reconocimiento de voz que usa la regla llamada `Cities` en un archivo local de SRGS cities.grxml. El contenido del archivo cities.grxml aparece a continuación el ejemplo de código de C#.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar2()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.Append("Does");  
  builder.AppendRuleReference(@"c:\temp\cities.grxml", "Cities");  
  builder.Append("have a shuttle");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 2";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendWildcard">
      <MemberSignature Language="C#" Value="public void AppendWildcard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendWildcard() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendWildcard ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendWildcard();" />
      <MemberSignature Language="F#" Value="member this.AppendWildcard : unit -&gt; unit" Usage="grammarBuilder.AppendWildcard " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anexa un elemento de gramática de reconocimiento que coincide con cualquier entrada a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El elemento comodín se agrega al final de la secuencia actual de elementos.  
  
 El elemento comodín coincide con todas las palabras habladas. No coincide con ruido de fondo o la latencia.  
  
   
  
## Examples  
 El ejemplo siguiente crea una gramática que acepta la entrada de contraseña como un carácter comodín. El ejemplo se adjunta un <xref:System.Speech.Recognition.Grammar.SpeechRecognized?displayProperty=nameWithType> controlador de eventos a la gramática que valida la entrada de contraseña.  
  
```csharp  
private Grammar CreatePasswordGrammar()  
{  
  GrammarBuilder wildcardBuilder = new GrammarBuilder();  
  wildcardBuilder.AppendWildcard();  
  SemanticResultKey passwordKey =  
    new SemanticResultKey("Password", wildcardBuilder);  
  
  GrammarBuilder passwordBuilder =  
    new GrammarBuilder("My Password is");  
  passwordBuilder.Append(passwordKey);  
  
  Grammar passwordGrammar = new Grammar(passwordBuilder);  
  passwordGrammar.Name = "Password input";  
  
  passwordGrammar.SpeechRecognized +=  
    new EventHandler<SpeechRecognizedEventArgs>(  
      PasswordInputHandler);  
  
  return passwordGrammar;  
}  
  
// Handle the SpeechRecognized event for the password grammar.  
private void PasswordInputHandler(object sender, SpeechRecognizedEventArgs e)  
{  
  if (e.Result == null) return;  
  
  RecognitionResult result = e.Result;  
  SemanticValue semantics = e.Result.Semantics;  
  
  if (semantics.ContainsKey("Password"))  
  {  
    RecognizedAudio passwordAudio =  
      result.GetAudioForWordRange(  
        result.Words[3], result.Words[result.Words.Count - 1]);  
  
    if (IsValidPassword(passwordAudio))  
    {  
      Console.WriteLine("Password accepted.");  
  
      // Add code to handle a valid password here.  
    }  
    else  
    {  
      Console.WriteLine("Invalid password.");  
  
      // Add code to handle an invalid password here.  
    }  
  }  
}  
  
// Validate the password input.   
private bool IsValidPassword(RecognizedAudio passwordAudio)  
{  
  Console.WriteLine("Validating password.");  
  
  // Add password validation code here.  
  
  return false;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo with get, set" Usage="System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la referencia cultural de la gramática de reconocimiento de voz.</summary>
        <value>Referencia cultural de <see cref="T:System.Speech.Recognition.GrammarBuilder" />. El valor predeterminado es la propiedad <see cref="P:System.Threading.Thread.CurrentUICulture" /> del subproceso en ejecución.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Speech.Recognition.Grammar.%23ctor%2A> el constructor crea un <xref:System.Speech.Recognition.Grammar> objeto que puede utilizarse por un reconocedor de voz de la referencia cultural correspondiente. Solo el <xref:System.Speech.Recognition.GrammarBuilder.Culture%2A> propiedad de la <xref:System.Speech.Recognition.GrammarBuilder> que se proporciona como parámetro al constructor de gramática se usa para establecer la referencia cultural de la gramática de reconocimiento de voz resultante.  
  
 Microsoft Windows y la API System.Speech aceptan todos los códigos de idioma de país válidos. Para realizar el reconocimiento de voz con el idioma especificado en el `Culture` propiedad, un motor de reconocimiento de voz que admite que se debe instalar el código de país de lenguaje. Los motores de reconocimiento de voz que se incluye con Microsoft Windows 7 funcionan con los siguientes códigos de país de lenguaje.  
  
-   en-GB. Inglés (Reino Unido)  
  
-   en-US. Inglés (Estados Unidos)  
  
-   de-DE. Alemán (Alemania)  
  
-   es-es al directorio. Español (España)  
  
-   fr-FR. Francés (Francia)  
  
-   ja-JP. Japonés (Japón)  
  
-   zh-CN. Chino (China)  
  
-   zh-TW. Chino (Taiwán)  
  
 Códigos de idioma de dos letras como "es-es", "fr", o "es" también se permiten.  
  
   
  
## Examples  
 El ejemplo siguiente crea una gramática de reconocimiento de voz para pedir una pizza con hasta cuatro ingredientes. Establece específicamente el <xref:System.Speech.Recognition.GrammarBuilder> referencia cultural del objeto para inglés (Estados Unidos).  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.RecognizerInfo" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
      </Docs>
    </Member>
    <Member MemberName="DebugShowPhrases">
      <MemberSignature Language="C#" Value="public string DebugShowPhrases { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DebugShowPhrases" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DebugShowPhrases As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DebugShowPhrases { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DebugShowPhrases : string" Usage="System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una cadena que muestra el contenido y la estructura de la gramática contenida por <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <value>El contenido y la estructura actuales de <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente crea una gramática de reconocimiento de voz para pedir una pizza con hasta cuatro ingredientes. Escribe el estado de la <xref:System.Speech.Recognition.GrammarBuilder> en la consola antes de crear la gramática. Este método genera el siguiente resultado:  
  
-   `GrammarBuilder status: I would like a [cheese,mushroom,tomato,onion,anchovy,chic ken,pepperoni] and [cheese,mushroom,tomato,onion,anchovy,chicken,pepperoni] pizza`  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Write the contents and structure of the GrammarBuilder to the console.  
  Console.WriteLine("Grammar content and structure: {0}", gb.DebugShowPhrases);  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361640(v%3doffice.14)">Crear gramáticas mediante GrammarBuilder</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Addition">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que corresponde a una secuencia de dos elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El orden de los operandos determina el orden de los elementos en el nuevo <xref:System.Speech.Recognition.GrammarBuilder>.  
  
> [!IMPORTANT]
>  Se recomienda precaución al combinar <xref:System.Speech.Recognition.Choices> o <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias con otros elementos de gramática. El reconocedor de voz puede producir una excepción cuando se usa una gramática de reconocimiento de voz que contiene los elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que repetidamente podrían modificar el valor del mismo elemento semántico. 
  
 Para obtener más información sobre cómo crear y usar gramáticas reconocimiento de voz, consulte [el reconocimiento de voz](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) y [crear GrammarBuilder gramáticas](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="choices + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">El primer elemento grammar, que representa un conjunto de alternativas.</param>
        <param name="builder">El segundo elemento grammar.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene un objeto <see cref="T:System.Speech.Recognition.Choices" /> seguido por un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Devuelve <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del parámetro <paramref name="choices" /> seguido por el parámetro <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> es compatible con conversiones de las siguientes clases.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder` parámetro. Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operadores.  
  
> [!IMPORTANT]
>  Si combina <xref:System.Speech.Recognition.Choices> y <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias, asegúrese de que evita la creación de elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias.
  
 Es el método equivalente para este operador <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.Choices%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">El primer elemento de gramática.</param>
        <param name="choices">El segundo elemento de la gramática, que representa un conjunto de elementos alternativos.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> seguido de un <see cref="T:System.Speech.Recognition.Choices" />.</summary>
        <returns>Devuelve <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del parámetro <paramref name="builder" /> seguido por el parámetro <paramref name="choices" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> admite las conversiones de las siguientes clases:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder` parámetro. Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operadores.  
  
> [!IMPORTANT]
>  Si combina <xref:System.Speech.Recognition.Choices> y <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias, asegúrese de que evita la creación de elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias.
  
 Es el método equivalente para este operador <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer las dos frases, "convertirla en fondo *color*" y "establecido en segundo plano en *color*", donde *color* se seleccionan de un conjunto de colores. Varios tipos se utilizan para generar la gramática final, como [cadena](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, y <xref:System.Speech.Recognition.GrammarBuilder> objetos.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder1 + builder2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">El primer elemento de gramática.</param>
        <param name="builder2">El segundo elemento grammar.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene una secuencia de dos objetos <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Devuelve <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del parámetro <paramref name="builder1" /> seguido por el parámetro <paramref name="builder2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> es compatible con conversiones de las siguientes clases.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder1` y `builder2` parámetros. Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operadores.  
  
> [!IMPORTANT]
>  Si combina <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias, asegúrese de que evita la creación de elementos semánticos duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar repetidamente el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias.
  
 Es el método equivalente para este operador <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">El primer elemento de gramática.</param>
        <param name="phrase">El segundo elemento de la gramática, que representa una secuencia de palabras.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> seguido de una frase.</summary>
        <returns>Devuelve <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del parámetro <paramref name="builder" /> seguido por el parámetro <paramref name="phrase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> es compatible con conversiones de las siguientes clases.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder` parámetro. Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operadores.  
  
 Es el método equivalente para este operador <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.String%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="phrase + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">El primer elemento de la gramática, que representa una secuencia de palabras.</param>
        <param name="builder">El segundo elemento grammar.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene una frase seguida de un <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Devuelve <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del parámetro <paramref name="phrase" /> seguido por el parámetro <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> es compatible con conversiones de las siguientes clases.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder` parámetro. Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operadores.  
  
 Es el método equivalente para este operador <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.String%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>  
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer las dos frases, "convertirla en fondo *color*" y "establecido en segundo plano en *color*", donde *color* se seleccionan de un conjunto de colores. Varios tipos se utilizan para generar la gramática final, como [cadena](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, y <xref:System.Speech.Recognition.GrammarBuilder> objetos.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte otro tipo en <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conversión implícita crea una nueva instancia de <xref:System.Speech.Recognition.GrammarBuilder>. Puede convertir cada una de las siguientes clases a un <xref:System.Speech.Recognition.GrammarBuilder>.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Cada una de las conversiones de tipos implícitas es equivalente a llamar al constructor.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="choices">El conjunto de alternativas para convertir.</param>
        <summary>Convierte un objeto <see cref="T:System.Speech.Recognition.Choices" /> en un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Objeto convertido <see cref="T:System.Speech.Recognition.Choices" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conversión implícita crea una nueva instancia de <xref:System.Speech.Recognition.GrammarBuilder>. Es equivalente a llamar a este operador de conversión <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> y especificando `choices` para el `alternateChoices`.  
  
 Es el método equivalente para este operador <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 El ejemplo siguiente crea una gramática de reconocimiento de voz que puede reconocer una respuesta a un "Sí" o "no" pregunta. El operador de conversión implícita se utiliza en la construcción de un <xref:System.Speech.Recognition.SemanticResultValue> objeto desde un <xref:System.Speech.Recognition.Choices> objeto, en la construcción de un <xref:System.Speech.Recognition.Choices> objeto de dos <xref:System.Speech.Recognition.SemanticResultValue> objetos y en la construcción de un <xref:System.Speech.Recognition.Grammar> objeto desde un <xref:System.Speech.Recognition.SemanticResultKey> objeto.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultKey semanticKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultKey semanticKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultKey)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticKey As SemanticResultKey) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultKey ^ semanticKey);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticKey" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="semanticKey">Clave semántica que se va a convertir.</param>
        <summary>Convierte un objeto <see cref="T:System.Speech.Recognition.SemanticResultKey" /> en un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Objeto convertido <see cref="T:System.Speech.Recognition.SemanticResultKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conversión implícita crea una nueva instancia de <xref:System.Speech.Recognition.GrammarBuilder>. Es equivalente a llamar a este operador de conversión <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> y especificando `semanticKey` para el `key`.  
  
 Es el método equivalente para este operador <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultKey%29?displayProperty=nameWithType>  
  
## Examples  
 El ejemplo siguiente crea una gramática de reconocimiento de voz que puede reconocer una respuesta a un "Sí" o "no" pregunta. El operador de conversión implícita se utiliza en la construcción de un <xref:System.Speech.Recognition.SemanticResultValue> objeto desde un <xref:System.Speech.Recognition.Choices> objeto, en la construcción de un <xref:System.Speech.Recognition.Choices> objeto de dos <xref:System.Speech.Recognition.SemanticResultValue> objetos y en la construcción de un <xref:System.Speech.Recognition.Grammar> objeto desde un <xref:System.Speech.Recognition.SemanticResultKey> objeto.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultValue semanticValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultValue semanticValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultValue)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticValue As SemanticResultValue) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultValue ^ semanticValue);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticValue" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="semanticValue">Objeto <see cref="T:System.Speech.Recognition.SemanticResultValue" /> que se va a convertir.</param>
        <summary>Convierte un objeto <see cref="T:System.Speech.Recognition.SemanticResultValue" /> en un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Objeto convertido <see cref="T:System.Speech.Recognition.SemanticResultValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conversión implícita crea una nueva instancia de <xref:System.Speech.Recognition.GrammarBuilder>. Es equivalente a llamar a este operador de conversión <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> y especificando `semanticValue` para el `value`.  
  
 Es el método equivalente para este operador <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultValue%29?displayProperty=nameWithType>  
  
## Examples  
 El ejemplo siguiente crea una gramática de reconocimiento de voz que puede reconocer una respuesta a un "Sí" o "no" pregunta. El operador de conversión implícita se utiliza en la construcción de un <xref:System.Speech.Recognition.SemanticResultValue> objeto desde un <xref:System.Speech.Recognition.Choices>objeto, en la construcción de un <xref:System.Speech.Recognition.Choices> objeto de dos <xref:System.Speech.Recognition.SemanticResultValue> objetos y en la construcción de un <xref:System.Speech.Recognition.Grammar> objeto desde un <xref:System.Speech.Recognition.SemanticResultKey> objeto.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.String)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Cadena que se va a convertir.</param>
        <summary>Convierte una cadena en un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Cadena convertida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conversión implícita crea una nueva instancia de <xref:System.Speech.Recognition.GrammarBuilder>. Es equivalente a llamar a este operador de conversión <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> y especificando el mismo `phrase`.  
  
 Es el método equivalente para este operador <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.String%29?displayProperty=nameWithType>  
  
## Examples  
 En el ejemplo siguiente se usa <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> objetos para construir una gramática que pueda reconocer cualquiera de las dos frases, "convertirla en fondo *colorChoice*" o "establecido en segundo plano en *colorChoice*".  
  
 Después de crear una lista de valores aceptables para *colorChoice* mediante un <xref:System.Speech.Recognition.Choices> objeto, en el ejemplo se inicializa dos <xref:System.Speech.Recognition.GrammarBuilder> objetos, `makePhrase` y `setPhrase`, mediante conversión implícita de cadena objetos.  
  
 El ejemplo, por último, se crea un <xref:System.Speech.Recognition.Grammar> objeto desde un <xref:System.Speech.Recognition.Choices> convertir un objeto en un <xref:System.Speech.Recognition.GrammarBuilder> objeto.  
  
```csharp  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
  </Members>
</Type>