<Type Name="GrammarBuilder" FullName="System.Speech.Recognition.GrammarBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="315163e21cdcb6f40a118f739a1b4767077c316f" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36608833" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class GrammarBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GrammarBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.GrammarBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class GrammarBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class GrammarBuilder" />
  <TypeSignature Language="F#" Value="type GrammarBuilder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{DebugSummary}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona un mecanismo para compilar mediante programación las restricciones de una gramática de reconocimiento de voz.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente se crean las gramáticas de reconocimiento de voz en el formato XML definido por el [especificación de gramática de reconocimiento de voz (SRGS) versión 1.0](http://go.microsoft.com/fwlink/?LinkId=201761). Si está familiarizado con SRGS pero desea generar las gramáticas mediante programación, puede utilizar el <xref:System.Speech.Recognition.SrgsGrammar> espacio de nombres, cuyos miembros estrechamente corresponden a los elementos y atributos definidos por SRGS. Si no está familiarizado con SRGS, o si desea un enfoque ligero, mediante programación a la creación de las gramáticas de con la que se pueden realizar eficazmente muchos escenarios comunes; Puede usar el <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> clases.  
  
 Use <xref:System.Speech.Recognition.GrammarBuilder> formada por objetos para crear un árbol jerárquico <xref:System.Speech.Recognition.Choices> objetos que contengan frases alternativos, entremezcladas con preámbulo y posteriores a la amble frases en cada nodo y se propaga por valores semántica que transmiten significado nuevo a la aplicación.  
  
 Para usar un <xref:System.Speech.Recognition.GrammarBuilder> para crear un <xref:System.Speech.Recognition.Grammar> de objetos, siga estos pasos.  
  
1.  Crear un objeto <xref:System.Speech.Recognition.GrammarBuilder>.  
  
2.  Anexar las restricciones de la <xref:System.Speech.Recognition.GrammarBuilder>, como <xref:System.String> objetos, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, <xref:System.Speech.Recognition.DictationGrammar>y otros <xref:System.Speech.Recognition.GrammarBuilder> objetos que definen las restricciones de la gramática.  
  
3.  Utilice uno de los <xref:System.Speech.Recognition.Grammar.%23ctor%2A> constructores para crear un <xref:System.Speech.Recognition.Grammar> objeto desde el completado <xref:System.Speech.Recognition.GrammarBuilder> gramática.  
  
 Creación con <xref:System.Speech.Recognition.GrammarBuilder> se adapta mejor a las gramáticas que tienen una sola regla que contiene listas o quizás listas de listas. Para generar mediante programación las gramáticas que tienen varias reglas, o que necesitan hacer referencia interna de regla, utilice las clases de la <xref:System.Speech.Recognition.SrgsGrammar> espacio de nombres.  
  
 Instancias de <xref:System.Speech.Recognition.GrammarBuilder> también se puede obtener por las conversiones implícitas de ciertas otras clases o combinando un <xref:System.Speech.Recognition.GrammarBuilder> con un segundo objeto que contiene restricciones para una gramática... Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> y <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operadores y <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> métodos.  
  
 Para agregar reglas a un archivo <xref:System.Speech.Recognition.GrammarBuilder>, use la <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, y <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> métodos.  
  
> [!IMPORTANT]
>  El reconocedor de voz puede producir una excepción cuando se usa una gramática de reconocimiento de voz que contiene los elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el valor del mismo elemento semántico. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [utilizando SemanticResultKey y objetos de SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
 Para ayudar con la depuración, el <xref:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases%2A> propiedad devuelve el estado actual de la <xref:System.Speech.Recognition.GrammarBuilder> como una cadena.  
  
 Para obtener más información acerca de la creación y el uso de las gramáticas de reconocimiento de voz, consulte [el reconocimiento de voz](http://msdn.microsoft.com/library/6a7dc524-07fc-4862-8d48-8c10dc64b919) y [crear GrammarBuilder gramáticas](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> objetos que permiten construir una gramática que pueda reconocer cualquiera de las dos frases, "convertirla en fondo *colorChoice*" o "establecer el fondo *colorChoice*".  
  
 El ejemplo se usa un <xref:System.Speech.Recognition.Choices> objeto para crear una lista de valores aceptables para *colorChoice* de una matriz de <xref:System.String> objetos. A <xref:System.Speech.Recognition.Choices> objeto es análogo a la `one-of` elemento en la especificación de SRGS y contiene un conjunto de frases alternativos, cualquiera de los cuales pueden ser reconocido cuando se pronuncia. El ejemplo también se usa un <xref:System.Speech.Recognition.Choices> objeto para agrupar una matriz de dos <xref:System.Speech.Recognition.GrammarBuilder> objetos en un par de frases alternativos que pueda reconocer la gramática resultante. Alternativas palabras o frases que son un componente de la mayoría de las gramáticas y el <xref:System.Speech.Recognition.Choices> objeto proporciona esta funcionalidad de las gramáticas construyen con <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 Por último se crea en el ejemplo un <xref:System.Speech.Recognition.Grammar> objeto desde un <xref:System.Speech.Recognition.GrammarBuilder> construido a partir de un <xref:System.Speech.Recognition.Choices> objeto.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.Choices" />
    <altmember cref="T:System.Speech.Recognition.Grammar" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Instancias de esta clase también pueden obtenerse por las conversiones implícitas de otras clases o combinando un <xref:System.Speech.Recognition.GrammarBuilder> objeto con un segundo objeto a un nuevo <xref:System.Speech.Recognition.GrammarBuilder>. Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> y <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> métodos.  
  
 Para agregar restricciones a una existente <xref:System.Speech.Recognition.GrammarBuilder>, use la <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, y <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> métodos y el <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operador.  
  
> [!IMPORTANT]
>  El reconocedor de voz puede producir una excepción cuando se usa una gramática de reconocimiento de voz que contiene los elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el valor del mismo elemento semántico. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [utilizando SemanticResultKey y objetos de SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
 Para obtener más información acerca de la creación y el uso de las gramáticas de reconocimiento de voz, consulte [el reconocimiento de voz](http://msdn.microsoft.com/library/6a7dc524-07fc-4862-8d48-8c10dc64b919) y [crear GrammarBuilder gramáticas](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia vacía de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para agregar reglas a un archivo <xref:System.Speech.Recognition.GrammarBuilder> objeto, utilice la <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, y <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> métodos y el <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operador.  
  
> [!IMPORTANT]
>  El reconocedor de voz puede producir una excepción cuando se usa una gramática de reconocimiento de voz que contiene los elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el valor del mismo elemento semántico. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [utilizando SemanticResultKey y objetos de SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> objetos que permiten construir una gramática que pueda reconocer cualquiera de las dos frases, "convertirla en fondo *colorChoice*" o "establecer el fondo *colorChoice*".  
  
 El ejemplo se usa un <xref:System.Speech.Recognition.Choices> objeto para crear una lista de valores aceptables para *colorChoice* de una matriz de <xref:System.String> objetos. A <xref:System.Speech.Recognition.Choices> objeto es análogo a la `one-of` elemento en la especificación de SRGS y contiene un conjunto de frases alternativos, cualquiera de los cuales puede ser reconocido cuando se pronuncia. El ejemplo también se usa un <xref:System.Speech.Recognition.Choices> objeto para agrupar una matriz de dos <xref:System.Speech.Recognition.GrammarBuilder> objetos en un par de frases alternativos que pueda reconocer la gramática resultante. Alternativas palabras o frases que son un componente de la mayoría de las gramáticas y el <xref:System.Speech.Recognition.Choices> objeto proporciona esta funcionalidad de las gramáticas construyen con <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 Por último se crea en el ejemplo un <xref:System.Speech.Recognition.Grammar> objeto desde un <xref:System.Speech.Recognition.GrammarBuilder> construido a partir de un <xref:System.Speech.Recognition.Choices> objeto.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  GrammarBuilder bothPhrases = new GrammarBuilder();  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  bothPhrases.Append(bothChoices);  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder alternateChoices" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">Conjunto de alternativas.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" /> a partir de un conjunto de alternativas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene alternativas, consulte [usando las opciones para crear una gramática GrammarBuilder](http://msdn.microsoft.com/library/5b18db18-a5f6-46a3-aa77-6d3141544efd).  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> objetos que permiten construir una gramática que pueda reconocer cualquiera de las dos frases, "convertirla en fondo *colorChoice*" o "establecer el fondo *colorChoice*".  
  
 El ejemplo se usa un <xref:System.Speech.Recognition.Choices> objeto para crear una lista de valores aceptables para *colorChoice* de una matriz de <xref:System.String> objetos. A <xref:System.Speech.Recognition.Choices> objeto es análogo a la `one-of` elemento en la especificación de SRGS y contiene un conjunto de frases alternativos, cualquiera de los cuales pueden ser reconocido cuando se pronuncia. El ejemplo también se usa un <xref:System.Speech.Recognition.Choices> objeto para agrupar una matriz de dos <xref:System.Speech.Recognition.GrammarBuilder> objetos en un par de frases alternativos que pueda reconocer la gramática resultante. Alternativas palabras o frases que son un componente de la mayoría de las gramáticas y el <xref:System.Speech.Recognition.Choices> objeto proporciona esta funcionalidad de las gramáticas construyen con <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 Por último se crea en el ejemplo un <xref:System.Speech.Recognition.Grammar> objeto desde un <xref:System.Speech.Recognition.GrammarBuilder> construido a partir de un <xref:System.Speech.Recognition.Choices> objeto.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder key" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">La clave semántica.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" /> a partir de una clave semántica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se crea un <xref:System.Speech.Recognition.GrammarBuilder> de la instancia de un <xref:System.Speech.Recognition.SemanticResultValue> de objeto, agregue información semántica la gramática que se pueden devolver en el resultado del reconocimiento. Puede tener acceso a la información semántica en el resultado de reconocimiento mediante la <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> propiedad de <xref:System.Speech.Recognition.RecognizedPhrase>, que está disponible en el controlador para el `SpeechRecognized` eventos. Si el <xref:System.Speech.Recognition.GrammarBuilder> define un <xref:System.Speech.Recognition.SemanticResultKey>, esto puede usarse para recuperar la información semántica en un resultado de reconocimiento que está asociado a la clave. Vea el ejemplo de <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>y también vea <xref:System.Speech.Recognition.SemanticResultValue> y <xref:System.Speech.Recognition.SemanticResultKey>.  
  
> [!IMPORTANT]
>  Cuando se construyen <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias, asegúrese de que evita la creación de elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [utilizando SemanticResultKey y objetos de SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer las dos frases, "convertirla en fondo *colorChoice*" y "establecer el fondo *colorChoice*", donde * colorChoice* está seleccionado en un conjunto de colores. La gramática permite a los usuarios hablan varios nombres de color y devuelve información semántica sobre el nombre del color reconocido a la aplicación.  
  
 En el ejemplo se usa un único <xref:System.Speech.Recognition.SemanticResultKey> con que se puede recuperar el <xref:System.Speech.Recognition.SemanticValue> que está asociado con el color pronunciado por el usuario. Por ejemplo, si la entrada contiene la frase "Conjunto fondo rojo", el resultado de reconocimiento que contiene el valor semántica de "#ff0000", que puede recuperar mediante un controlador para el `SpeechRecognized` eventos.  
  
 El ejemplo se utiliza <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, y <xref:System.Speech.Recognition.GrammarBuilder> objetos que se va a crear las restricciones que se encuentran en los últimos <xref:System.Speech.Recognition.GrammarBuilder> objeto, `bothPhrases`. Por último, en el ejemplo se crea un <xref:System.Speech.Recognition.Grammar> objeto desde el completado <xref:System.Speech.Recognition.GrammarBuilder>.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices object for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the Grammar object from the GrammarBuilder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">El valor o el par de nombre y valor semántico.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" /> a partir de un valor semántico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se crea un <xref:System.Speech.Recognition.GrammarBuilder> de la instancia de un <xref:System.Speech.Recognition.SemanticResultValue> de objeto, agregue información semántica la gramática que se pueden devolver en el resultado del reconocimiento. Puede tener acceso a la información semántica en el resultado de reconocimiento mediante la <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> propiedad de <xref:System.Speech.Recognition.RecognizedPhrase>, que está disponible en el controlador para el `SpeechRecognized` eventos. Si el <xref:System.Speech.Recognition.GrammarBuilder> define un <xref:System.Speech.Recognition.SemanticResultKey>, esto puede usarse para recuperar la información semántica en un resultado de reconocimiento que está asociado a la clave. Vea el ejemplo de <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>y también vea <xref:System.Speech.Recognition.SemanticResultValue> y <xref:System.Speech.Recognition.SemanticResultKey>.  
  
> [!IMPORTANT]
>  Cuando se construyen <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias, asegúrese de que evita la creación de elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [utilizando SemanticResultKey y objetos de SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer las dos frases, "convertirla en fondo *colorChoice*" y "establecer el fondo *colorChoice*", donde * colorChoice* está seleccionado en un conjunto de colores. La gramática permite a los usuarios hablan varios nombres de color y devuelve información semántica sobre el nombre del color reconocido a la aplicación.  
  
 En el ejemplo se usa un único <xref:System.Speech.Recognition.SemanticResultKey> con que se puede recuperar el <xref:System.Speech.Recognition.SemanticValue> que está asociado con el color pronunciado por el usuario. Por ejemplo, si la entrada contiene la frase "Conjunto fondo rojo", el resultado de reconocimiento que contiene el valor semántica de "#ff0000", que puede recuperar mediante un controlador para el `SpeechRecognized` eventos.  
  
 El ejemplo se utiliza <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, y <xref:System.Speech.Recognition.GrammarBuilder> objetos que se va a crear las restricciones que se encuentran en los últimos <xref:System.Speech.Recognition.GrammarBuilder> objeto, `bothPhrases`. Por último, en el ejemplo se crea un <xref:System.Speech.Recognition.Grammar> objeto desde el completado <xref:System.Speech.Recognition.GrammarBuilder>.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the grammar from the grammar builder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder phrase" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">La secuencia de palabras.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" /> a partir de una secuencia de palabras.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La frase representa una frase exacta oral que pueda reconocer la gramática de reconocimiento de voz. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene las cadenas, vea [uso de cadenas para crear una gramática GrammarBuilder](http://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> objetos que permiten construir una gramática que pueda reconocer cualquiera de las dos frases, "convertirla en fondo *colorChoice*" o "establecer el fondo *colorChoice*".  
  
 Después de crear una lista de valores aceptables para *colorChoice* con un <xref:System.Speech.Recognition.Choices> objeto, en el ejemplo se inicializa dos <xref:System.Speech.Recognition.GrammarBuilder> objetos, `makePhrase` y `setPhrase`, mediante una cadena como argumento.  
  
 Por último se crea en el ejemplo un <xref:System.Speech.Recognition.Grammar> objeto de un <xref:System.Speech.Recognition.Choices> objeto se convierte en un <xref:System.Speech.Recognition.GrammarBuilder> objeto.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * System.Speech.Recognition.SubsetMatchingMode -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, subsetMatchingCriteria)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">La secuencia de palabras.</param>
        <param name="subsetMatchingCriteria">El modo coincidente que la gramática de reconocimiento de voz usa para reconocer la frase.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para un subconjunto de una secuencia de palabras.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `phrase` parámetro representa la frase que pueda reconocer la gramática de reconocimiento de voz. El `subsetMatchingMode` parámetro especifica un subconjunto de la frase que puede hablar para alcanzar el reconocimiento correcto de la frase completa. Ya puede utilizarla para crear una gramática con una lista de entradas que tienen nombres largos, sin requerir que los usuarios hablan un nombre completo para que coincida con un elemento.  
  
 Para obtener más información acerca de los modos de búsqueda de coincidencias, vea <xref:System.Speech.Recognition.SubsetMatchingMode>. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene las cadenas, vea [uso de cadenas para crear una gramática GrammarBuilder](http://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz para cada <xref:System.Speech.Recognition.SubsetMatchingMode> valor y una gramática para elegir entre las gramáticas de modo correspondiente. Si el valor de `phrase` es "uno dos tres cuatro cinco seis siete", a continuación, la gramática de subsecuencia reconoce la entrada "dos tres cuatro", pero no la entrada "uno tres cinco". Sin embargo, la gramática de subconjunto ordenado reconoce ambas de estas entradas.  
  
```csharp  
  
private static IEnumerable<Grammar>  
  CreateMatchingModeGrammars(string phrase)  
{  
  List<Grammar> grammars = new List<Grammar>(5);  
  
  Choices modeChoice = new Choices();  
  Type enumType = typeof(SubsetMatchingMode);  
  foreach (SubsetMatchingMode mode in Enum.GetValues(enumType))  
  {  
    string modeName = Enum.GetName(enumType, mode);  
    modeName = BreakAtCaps(modeName);  
  
    GrammarBuilder builder = new GrammarBuilder(phrase, mode);  
    Grammar modeGrammar = new Grammar(builder);  
    modeGrammar.Name = modeName;  
    modeGrammar.Enabled = false;  
    grammars.Add(modeGrammar);  
  
    modeChoice.Add(modeName);  
  }  
  
  Grammar choiceGrammar = new Grammar(modeChoice);  
  choiceGrammar.Name = "choice";  
  grammars.Add(choiceGrammar);  
  
  return grammars;  
}  
  
// Insert spaces preceding each uppercase letter in a string.   
private static string BreakAtCaps(string item)  
{  
  if (item == null || item.Length == 0)  
  {  
    return item;  
  }  
  
  StringBuilder sb = new StringBuilder(item[0].ToString());  
  for (int i = 1; i < item.Length; i++)  
  {  
    char c = item[i];  
    if (char.IsUpper(c))  
    {  
      sb.Append(" ");  
    }  
    sb.Append(c);  
  }  
  
  return sb.ToString();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.SubsetMatchingMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.GrammarBuilder * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (builder, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">Elemento repetido.</param>
        <param name="minRepeat">Número mínimo de veces que la entrada coincidente con el elemento definido por <c>builder</c> debe aparecer para que constituya una coincidencia.</param>
        <param name="maxRepeat">Número máximo de veces que la entrada coincidente con el elemento definido por <c>builder</c> puede aparecer para que constituya una coincidencia.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" /> a partir de un elemento repetido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor de `minRepeat` es 0, entonces la nueva <xref:System.Speech.Recognition.GrammarBuilder> representa un elemento opcional.  
  
 El valor de `minRepeat` debe ser mayor o igual que 0 y menor o igual que el valor de `maxRepeat`.  
  
> [!IMPORTANT]
>  Cuando se especifica se repite para <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias, asegúrese de que evita la creación de elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [utilizando SemanticResultKey y objetos de SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz para pedir una pizza. Empieza con una frase opcional, apertura, seguida de uno a cuatro ingredientes y se cierra con la palabra "pizza".  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object from a string array of alternative toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">La secuencia repetida de palabras.</param>
        <param name="minRepeat">El número mínimo de veces que la entrada coincidente con la frase debe aparecer para que constituya una coincidencia.</param>
        <param name="maxRepeat">El número máximo de veces que la entrada coincidente con la frase puede aparecer para que constituya una coincidencia.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Speech.Recognition.GrammarBuilder" /> a partir del flujo de palabras en un objeto <see cref="T:System.String" /> y especifica cuántas veces se puede repetir <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor de `minRepeat` es 0, entonces la nueva <xref:System.Speech.Recognition.GrammarBuilder> representa un elemento opcional.  
  
 El valor de `minRepeat` debe ser mayor o igual que 0 y menor o igual que el valor de `maxRepeat`. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene las cadenas, vea [uso de cadenas para crear una gramática GrammarBuilder](http://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz para pedir una pizza. Empieza con una frase opcional, apertura, seguida de uno a cuatro ingredientes y se cierra con la palabra "pizza".  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene una secuencia de dos elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método estático <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> métodos proporcionan otro mecanismo por el que se pueden combinar varios tipos para crear diversidad y flexibilidad en las gramáticas compilada con <xref:System.Speech.Recognition.GrammarBuilder>. Estos métodos se corresponden con el método estático <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> métodos, que también se definen en la <xref:System.Speech.Recognition.GrammarBuilder> clase. El orden de los parámetros determina el orden de los elementos en el nuevo <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 A <xref:System.Speech.Recognition.GrammarBuilder> también puede obtenerse de <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, y [cadena](http://go.microsoft.com/fwlink/?LinkId=159733) objetos. Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> y <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operadores.  
  
> [!IMPORTANT]
>  El reconocedor de voz puede producir una excepción cuando se usa una gramática de reconocimiento de voz que contiene los elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el valor del mismo elemento semántico. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [utilizando SemanticResultKey y objetos de SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
 Para obtener más información acerca de la creación y el uso de las gramáticas de reconocimiento de voz, consulte [el reconocimiento de voz](http://msdn.microsoft.com/library/6a7dc524-07fc-4862-8d48-8c10dc64b919) y [crear GrammarBuilder gramáticas](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (choices, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">El primer elemento grammar, que representa un conjunto de alternativas.</param>
        <param name="builder">El segundo elemento grammar.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene un objeto <see cref="T:System.Speech.Recognition.Choices" /> seguido por un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del elemento <paramref name="choices" /> seguido por el elemento <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> admite las conversiones implícitas de las siguientes clases:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder` parámetro.  
  
 Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> y <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operadores.  
  
> [!IMPORTANT]
>  Cuando se combinan <xref:System.Speech.Recognition.Choices> y <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias, asegúrese de que evita la creación de elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [agregar semántica a una gramática GrammarBuilder](https://msdn.microsoft.com/library/hh361581.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, choices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">El primer elemento de gramática.</param>
        <param name="choices">El segundo elemento de la gramática, que representa un conjunto de alternativas.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" /> seguido por un objeto <see cref="T:System.Speech.Recognition.Choices" />.</summary>
        <returns>Un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del elemento <paramref name="builder" /> seguido por el elemento <paramref name="choices" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> admite las conversiones implícitas de las siguientes clases:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder` parámetro.  
  
 Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> y <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operadores.  
  
> [!IMPORTANT]
>  Cuando se combinan <xref:System.Speech.Recognition.Choices> y <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias con otros elementos de la gramática, asegúrese de que evita la creación de elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que puede modificar varias veces la <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [utilizando SemanticResultKey y objetos de SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer las dos frases, "convertirla en fondo *color*" y "establecer el fondo *color*", donde *color* se selecciona de un conjunto de colores. Varios tipos se utilizan para compilar la gramática final, por ejemplo, [cadena](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, y <xref:System.Speech.Recognition.GrammarBuilder> objetos. Los operadores de conversión explícita en las llamadas a la <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> métodos son opcionales.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder1, builder2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">El primer elemento de gramática.</param>
        <param name="builder2">El segundo elemento grammar.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene una secuencia de dos objetos <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del elemento <paramref name="builder1" /> seguido por el elemento <paramref name="builder2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> admite las conversiones implícitas de las siguientes clases:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para la `builder1` o `builder2` parámetro.  
  
 Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> y <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operadores.  
  
> [!IMPORTANT]
>  Cuando se combinan <xref:System.Speech.Recognition.Choices> y <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias con otros elementos de la gramática, asegúrese de que evita la creación de elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que puede modificar varias veces la <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [utilizando SemanticResultKey y objetos de SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer las dos frases, "convertirla en fondo *color*" y "establecer el fondo *color*", donde *color* se selecciona de un conjunto de colores. Varios tipos se utilizan para compilar la gramática final, por ejemplo, [cadena](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, y <xref:System.Speech.Recognition.GrammarBuilder> objetos. Los operadores de conversión explícita en las llamadas a la <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> métodos son opcionales.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, phrase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">El primer elemento de gramática.</param>
        <param name="phrase">El segundo elemento de la gramática, que representa una secuencia de palabras.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" /> seguido de una frase.</summary>
        <returns>Un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del elemento <paramref name="builder" /> seguido por el elemento <paramref name="phrase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> admite las conversiones implícitas de las siguientes clases:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder` parámetro.  
  
 Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> y <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operadores.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer las dos frases, "convertirla en fondo *color*" y "establecer el fondo *color*", donde *color* se selecciona de un conjunto de colores. Varios tipos se utilizan para compilar la gramática final, por ejemplo, [cadena](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, y <xref:System.Speech.Recognition.GrammarBuilder> objetos. Los operadores de conversión explícita en las llamadas a la <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> métodos son opcionales.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (phrase, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">El primer elemento de la gramática, que representa una secuencia de palabras.</param>
        <param name="builder">El segundo elemento grammar.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene una frase seguida de un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del elemento <paramref name="phrase" /> seguido por el elemento <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> admite las conversiones implícitas de las siguientes clases:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder` parámetro.  
  
 Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> y <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operadores.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer las dos frases, "convertirla en fondo *color*" y "establecer el fondo *color*", donde *color* se selecciona de un conjunto de colores. Varios tipos se utilizan para compilar la gramática final, por ejemplo, [cadena](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, y <xref:System.Speech.Recognition.GrammarBuilder> objetos. Los operadores de conversión explícita en las llamadas a la <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> métodos son opcionales.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Anexa un elemento de gramática a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizar estos métodos para agregar elementos de la gramática a una existente <xref:System.Speech.Recognition.GrammarBuilder>. A medida que cree elementos de la gramática, se puede anexar al generador existente progresivamente desarrollar las restricciones para una gramática de reconocimiento de voz. Cada elemento se agrega al final de la secuencia actual de elementos.  
  
 Este método tiene sobrecargas para anexar <xref:System.Speech.Recognition.GrammarBuilder>, <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, y <xref:System.Speech.Recognition.SemanticResultValue> objetos.  
  
> [!IMPORTANT]
>  El reconocedor de voz puede producir una excepción cuando se usa una gramática de reconocimiento de voz que contiene los elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el valor del mismo elemento semántico. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [utilizando SemanticResultKey y objetos de SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
 Para obtener más información acerca de la creación y el uso de las gramáticas de reconocimiento de voz, consulte [el reconocimiento de voz](http://msdn.microsoft.com/library/6a7dc524-07fc-4862-8d48-8c10dc64b919) y [crear GrammarBuilder gramáticas](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.Choices -&gt; unit" Usage="grammarBuilder.Append alternateChoices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">El conjunto de alternativas para anexar.</param>
        <summary>Anexa un conjunto de alternativas a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `alternateChoices` se agrega al final de la secuencia actual de elementos.  
  
> [!IMPORTANT]
>  Al anexar <xref:System.Speech.Recognition.Choices> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias de un <xref:System.Speech.Recognition.GrammarBuilder> de objetos, asegúrese de que evita la creación de elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que puede realizar varias veces modificar el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [SemanticResultValue descripción y SemanticResultKey objetos](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz para frases como "James de llamada en el trabajo" y "Anne de llamada en su teléfono móvil", donde la palabra "teléfono" es opcional. En el ejemplo se resalta el uso de la <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> método.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder -&gt; unit" Usage="grammarBuilder.Append builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">El elemento de gramática para anexar.</param>
        <summary>Anexa un elemento de gramática a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `builder` se agrega al final de la secuencia de elementos de la gramática actual.  
  
> [!NOTE]
>  Al anexar <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias de un <xref:System.Speech.Recognition.GrammarBuilder> de objetos, asegúrese de que evita la creación de elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que puede realizar varias veces modificar el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [utilizando SemanticResultKey y objetos de SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz para frases como "James de llamada en el trabajo" y "Anne de llamada en su teléfono móvil", donde la palabra "teléfono" es opcional. <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> objetos utilizados para construir la gramática. En el ejemplo se resalta el uso de la <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> método.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultKey -&gt; unit" Usage="grammarBuilder.Append key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">La clave semántica para anexar.</param>
        <summary>Anexa una clave semántica a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `key` se agrega al final de la secuencia actual de elementos.  
  
> [!IMPORTANT]
>  Al anexar <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias de un <xref:System.Speech.Recognition.GrammarBuilder> de objetos, asegúrese de que evita la creación de elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [SemanticResultValue descripción y SemanticResultKey objetos](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 En el siguiente ejemplo es parte de una aplicación de consola para elegir ciudades de origen y destino de un vuelo. La aplicación reconoce frases como "desea Volar desde Miami a Chicago." El controlador para el <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> evento utiliza el <xref:System.Speech.Recognition.SemanticResultKey> para extraer el código de aeropuerto especificado en el <xref:System.Speech.Recognition.SemanticResultValue> para las ciudades de origen y destino.  
  
```csharp  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create a Choices object and add  cities and airport codes  
        // using SemanticResultValue objects.  
        Choices cities = new Choices();  
        cities.Add(new SemanticResultValue("Chicago", "ORD"));  
        cities.Add(new SemanticResultValue("Boston", "BOS"));  
        cities.Add(new SemanticResultValue("Miami", "MIA"));  
        cities.Add(new SemanticResultValue("Dallas", "DFW"));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultValue -&gt; unit" Usage="grammarBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">Valor semántico que se va a agregar.</param>
        <summary>Anexa un valor semántico a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` se agrega al final de la secuencia actual de elementos.  
  
> [!IMPORTANT]
>  Al anexar <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias de un <xref:System.Speech.Recognition.GrammarBuilder> de objetos, asegúrese de que evita la creación de elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [SemanticResultValue descripción y SemanticResultKey objetos](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 En el siguiente ejemplo es parte de una aplicación de consola para elegir ciudades de origen y destino de un vuelo. La aplicación reconoce frases como "desea Volar desde Miami a Chicago." El controlador para el <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> evento utiliza el <xref:System.Speech.Recognition.SemanticResultKey> para extraer el código de aeropuerto especificado en el <xref:System.Speech.Recognition.SemanticResultValue> para las ciudades de origen y destino.  
  
```csharp  
  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create GrammarBuilder objects and append SemanticResultValue objects   
        // that contain cities and airport codes.  
  
        GrammarBuilder chicago = new GrammarBuilder();  
        chicago.Append(new SemanticResultValue("Chicago", "ORD"));  
  
        GrammarBuilder boston = new GrammarBuilder();  
        boston.Append(new SemanticResultValue("Boston", "BOS"));  
  
        GrammarBuilder miami = new GrammarBuilder();  
        miami.Append(new SemanticResultValue("Miami", "MIA"));  
  
        GrammarBuilder dallas = new GrammarBuilder();  
        dallas.Append(new SemanticResultValue("Dallas", "DFW"));  
  
        // Create a Choices object and add the cities using implicit conversion from   
        // SemanticResultValue to GrammarBuilder.  
        Choices cities = new Choices();  
        cities.Add(new Choices(new GrammarBuilder[] { chicago, boston, miami, dallas }));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; unit" Usage="grammarBuilder.Append phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">La secuencia de palabras para anexar.</param>
        <summary>Anexa una frase a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase` se agrega al final de la secuencia actual de elementos.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="member this.Append : string * System.Speech.Recognition.SubsetMatchingMode -&gt; unit" Usage="grammarBuilder.Append (phrase, subsetMatchingCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">La secuencia de palabras para anexar.</param>
        <param name="subsetMatchingCriteria">El modo coincidente que la gramática usa para reconocer la frase.</param>
        <summary>Anexa un elemento para un subconjunto de una frase a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El elemento de subconjunto se agrega al final de la secuencia actual de elementos. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz con cadenas, vea [uso de cadenas para crear una gramática GrammarBuilder](http://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
 Para obtener información detallada sobre el uso de subconjunto coincidencia modos, consulte <xref:System.Speech.Recognition.SubsetMatchingMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz para cada <xref:System.Speech.Recognition.SubsetMatchingMode> valor. Por ejemplo, la gramática generada `OrderedSubset` reconoce las frases "tres cuatro cinco" y "uno tres cinco" y la gramática `Subsequence` reconoce la frase "tres cuatro cinco", pero no la frase "una tres cinco".  
  
```csharp  
  
private Grammar[] CreateSubsetMatchTest()  
{  
  List<Grammar> grammars = new List<Grammar>(4);  
  
  string phrase = "one two three four five six";  
  foreach (SubsetMatchingMode mode in  
    Enum.GetValues(typeof(SubsetMatchingMode)))  
  {  
    GrammarBuilder gb = new GrammarBuilder();  
    gb.Append(phrase, mode);  
  
    Grammar grammar = new Grammar(gb);  
    grammar.Name = mode.ToString();  
    grammars.Add(grammar);  
  }  
  
  return grammars.ToArray();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder * int * int -&gt; unit" Usage="grammarBuilder.Append (builder, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">El elemento de gramática repetido para anexar.</param>
        <param name="minRepeat">Número mínimo de veces que la entrada coincidente con el elemento definido por <c>builder</c> debe aparecer para que constituya una coincidencia.</param>
        <param name="maxRepeat">Número máximo de veces que la entrada coincidente con el elemento definido por <c>builder</c> puede aparecer para que constituya una coincidencia.</param>
        <summary>Anexa un elemento de gramática repetido a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de `minRepeat` debe ser mayor o igual que 0 y menor o igual que el valor de `maxRepeat`.  
  
> [!IMPORTANT]
>  Al anexar <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias de un <xref:System.Speech.Recognition.GrammarBuilder> de objetos, asegúrese de que evita la creación de elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que puede realizar varias veces modificar el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [SemanticResultValue descripción y SemanticResultKey objetos](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz para frases como "James de llamada en el trabajo" y "Anne de llamada en su teléfono móvil", donde la palabra "teléfono" es opcional. <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> objetos utilizados para construir la gramática. En el ejemplo se resalta el uso de la <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> método.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; unit" Usage="grammarBuilder.Append (phrase, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">La secuencia repetida de palabras para anexar.</param>
        <param name="minRepeat">Número mínimo de veces que la entrada coincidente con <c>phrase</c> debe aparecer para que constituya una coincidencia.</param>
        <param name="maxRepeat">Número máximo de veces que la entrada coincidente con <c>phrase</c> puede aparecer para que constituya una coincidencia.</param>
        <summary>Anexa una frase repetida a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de `minRepeat` debe ser mayor o igual que 0 y menor o igual que el valor de `maxRepeat`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz para frases como "James de llamada en el trabajo" y "Anne de llamada en su teléfono móvil", donde la palabra "teléfono" es opcional. <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> objetos utilizados para construir la gramática. En el ejemplo se resalta el uso de la <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> método.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendDictation">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Anexa una gramática de dictado a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A> métodos permiten anexar una gramática dictado como una regla a un <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 Para obtener más información acerca de las gramáticas de dictado, consulte <xref:System.Speech.Recognition.DictationGrammar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation();" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : unit -&gt; unit" Usage="grammarBuilder.AppendDictation " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anexa la gramática de dictado predeterminada a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de las gramáticas de dictado, consulte <xref:System.Speech.Recognition.DictationGrammar>.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que incorpora el dictado.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation();  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation (string category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation(string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation (category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation(System::String ^ category);" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : string -&gt; unit" Usage="grammarBuilder.AppendDictation category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="category">La categoría de la gramática de dictado para anexar.</param>
        <summary>Anexa la gramática de dictado especificada a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para utilizar la ortografía y gramática dictado, establezca `category` a `spelling`.  
  
 Para obtener más información acerca de las gramáticas de dictado, consulte <xref:System.Speech.Recognition.DictationGrammar>.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que incorpora las reglas de gramática de dictado de ortografía.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation("spelling");  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendRuleReference">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Anexa un archivo o una regla de gramática a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> métodos pueden anexar un archivo de gramática o una regla de gramática desde un archivo. Estos métodos permiten que las aplicaciones realizar el uso de reglas de gramática previamente implementado o disponible públicamente. La aplicación debe tener acceso de lectura a la ubicación de los archivos de gramática especificada.  
  
 Estos métodos pueden leer una gramática de reconocimiento de voz de los formatos siguientes.  
  
-   Archivos de formato XML que cumplen con el W3C [especificación de gramática de reconocimiento de voz (SRGS) versión 1.0](http://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   Archivos binarios que se ajustan a los Microsoft voz reconocimiento gramática formato binario (extensión de archivo .cfg)  
  
 Compilar un formato XML SRGS el archivo de gramática en un archivo de gramática binaria con la extensión .cfg puede reducir el tiempo consumido por busca una coincidencia, especialmente si la gramática requiere reconocimiento de un gran número de palabras y frases. Para obtener información acerca de la compilación de las gramáticas de SRGS para el formato binario de CFG, consulte <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string -&gt; unit" Usage="grammarBuilder.AppendRuleReference path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso o el identificador de recursos universal (URI) del archivo que describe una gramática de reconocimiento de voz en un formato admitido.</param>
        <summary>Anexa un archivo de definición de gramática a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El URI proporcionado por el `path` argumento puede ser local o remoto. La aplicación debe tener acceso de lectura a la ubicación de los archivos de gramática especificada.  
  
 Una representación de la especificación de gramática de reconocimiento de voz (SRGS) de W3C puede definir una regla de raíz. Este método anexa la gramática, a partir de las reglas de raíz, a la secuencia de elementos de la gramática actual. Para anexar una regla de gramática específicos, utilice la <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> método.  
  
   
  
## Examples  
 En el ejemplo de C# siguiente se crea una gramática de reconocimiento de voz que usa la regla denominada `Cities` en un archivo local de SRGS, cities.grxml. El contenido del archivo cities.grxml aparece a continuación el ejemplo de código de C#.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar1()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.AppendRuleReference("file://c:/temp/cities.grxml");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 1";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-16" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path, string rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path, string rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String, rule As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path, System::String ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string * string -&gt; unit" Usage="grammarBuilder.AppendRuleReference (path, rule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rule" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso o el identificador de recursos universal (URI) del archivo que describe una gramática de reconocimiento de voz en un formato compatible.</param>
        <param name="rule">El identificador de la regla para anexar, o <see langword="null" /> para anexar la regla raíz predeterminada del archivo de gramática.</param>
        <summary>Anexa la regla especificada de un archivo de definición de gramática a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El URI proporcionado por el `path` argumento puede ser local o remoto. La aplicación debe tener acceso de lectura a la ubicación de los archivos de gramática especificada.  
  
 Puede usar el <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> método para anexar una gramática archivo que empieza por las reglas de raíz.  
  
   
  
## Examples  
 En el ejemplo de C# siguiente se crea una gramática de reconocimiento de voz que usa la regla denominada `Cities` en un archivo local de SRGS, cities.grxml. El contenido del archivo cities.grxml aparece a continuación el ejemplo de código de C#.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar2()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.Append("Does");  
  builder.AppendRuleReference(@"c:\temp\cities.grxml", "Cities");  
  builder.Append("have a shuttle");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 2";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendWildcard">
      <MemberSignature Language="C#" Value="public void AppendWildcard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendWildcard() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendWildcard ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendWildcard();" />
      <MemberSignature Language="F#" Value="member this.AppendWildcard : unit -&gt; unit" Usage="grammarBuilder.AppendWildcard " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anexa un elemento de gramática de reconocimiento que coincide con cualquier entrada a la secuencia actual de elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se agrega el elemento de carácter comodín al final de la secuencia actual de elementos.  
  
 El elemento de carácter comodín coincide con cualquier palabra oral. No coincide con ruido de fondo o latencia.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática que acepta datos proporcionados por contraseña como un carácter comodín. En el ejemplo se asocia un <xref:System.Speech.Recognition.Grammar.SpeechRecognized?displayProperty=nameWithType> controlador de eventos a la gramática que valida la entrada de contraseña.  
  
```csharp  
private Grammar CreatePasswordGrammar()  
{  
  GrammarBuilder wildcardBuilder = new GrammarBuilder();  
  wildcardBuilder.AppendWildcard();  
  SemanticResultKey passwordKey =  
    new SemanticResultKey("Password", wildcardBuilder);  
  
  GrammarBuilder passwordBuilder =  
    new GrammarBuilder("My Password is");  
  passwordBuilder.Append(passwordKey);  
  
  Grammar passwordGrammar = new Grammar(passwordBuilder);  
  passwordGrammar.Name = "Password input";  
  
  passwordGrammar.SpeechRecognized +=  
    new EventHandler<SpeechRecognizedEventArgs>(  
      PasswordInputHandler);  
  
  return passwordGrammar;  
}  
  
// Handle the SpeechRecognized event for the password grammar.  
private void PasswordInputHandler(object sender, SpeechRecognizedEventArgs e)  
{  
  if (e.Result == null) return;  
  
  RecognitionResult result = e.Result;  
  SemanticValue semantics = e.Result.Semantics;  
  
  if (semantics.ContainsKey("Password"))  
  {  
    RecognizedAudio passwordAudio =  
      result.GetAudioForWordRange(  
        result.Words[3], result.Words[result.Words.Count - 1]);  
  
    if (IsValidPassword(passwordAudio))  
    {  
      Console.WriteLine("Password accepted.");  
  
      // Add code to handle a valid password here.  
    }  
    else  
    {  
      Console.WriteLine("Invalid password.");  
  
      // Add code to handle an invalid password here.  
    }  
  }  
}  
  
// Validate the password input.   
private bool IsValidPassword(RecognizedAudio passwordAudio)  
{  
  Console.WriteLine("Validating password.");  
  
  // Add password validation code here.  
  
  return false;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo with get, set" Usage="System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la referencia cultural de la gramática de reconocimiento de voz.</summary>
        <value>Referencia cultural de <see cref="T:System.Speech.Recognition.GrammarBuilder" />. El valor predeterminado es la propiedad <see cref="P:System.Threading.Thread.CurrentUICulture" /> del subproceso en ejecución.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Speech.Recognition.Grammar.%23ctor%2A> constructor crea un <xref:System.Speech.Recognition.Grammar> objeto que puede utilizarse por un reconocedor de voz de la referencia cultural correspondiente. Solo el <xref:System.Speech.Recognition.GrammarBuilder.Culture%2A> propiedad de la <xref:System.Speech.Recognition.GrammarBuilder> que se proporciona como parámetro al constructor de gramática se usa para establecer la referencia cultural de la gramática de reconocimiento de voz resultante.  
  
 Microsoft Windows y la API de System.Speech Aceptar todos los códigos de país de idioma válidos. Para realizar el reconocimiento de voz con el idioma especificado en el `Culture` propiedad, un motor de reconocimiento de voz que admite que se debe instalar el código de país de lenguaje. Los motores de reconocimiento de voz que se incluye con Microsoft Windows 7 trabajar con los siguientes códigos de país de lenguaje.  
  
-   en-GB. Inglés (Reino Unido)  
  
-   en-US. Inglés (Estados Unidos)  
  
-   de-DE. Alemán (Alemania)  
  
-   ES-es. Español (España)  
  
-   fr-FR. Francés (Francia)  
  
-   ja-JP. Japonés (Japón)  
  
-   zh-CN. Chino (China)  
  
-   zh-TW. Chino (Taiwán)  
  
 Códigos de idioma de dos letras como "es-es", "fr" o "es" también se permiten.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz para pedir una pizza con ingredientes hasta cuatro. Establece específicamente el <xref:System.Speech.Recognition.GrammarBuilder> referencia cultural del objeto para inglés (Estados Unidos).  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.RecognizerInfo" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
      </Docs>
    </Member>
    <Member MemberName="DebugShowPhrases">
      <MemberSignature Language="C#" Value="public string DebugShowPhrases { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DebugShowPhrases" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DebugShowPhrases As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DebugShowPhrases { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DebugShowPhrases : string" Usage="System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una cadena que muestra el contenido y la estructura de la gramática contenida por <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <value>El contenido y la estructura actuales de <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz para pedir una pizza con ingredientes hasta cuatro. Escribe el estado de la <xref:System.Speech.Recognition.GrammarBuilder> en la consola antes de crear la gramática. Este método genera el siguiente resultado:  
  
-   `GrammarBuilder status: I would like a [cheese,mushroom,tomato,onion,anchovy,chic ken,pepperoni] and [cheese,mushroom,tomato,onion,anchovy,chicken,pepperoni] pizza`  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Write the contents and structure of the GrammarBuilder to the console.  
  Console.WriteLine("Grammar content and structure: {0}", gb.DebugShowPhrases);  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Addition">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que corresponde a una secuencia de dos elementos de gramática.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El orden de los operandos determina el orden de los elementos en el nuevo <xref:System.Speech.Recognition.GrammarBuilder>.  
  
> [!IMPORTANT]
>  Se recomienda precaución al combinar <xref:System.Speech.Recognition.Choices> o <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias con otros elementos de la gramática. El reconocedor de voz puede producir una excepción cuando se usa una gramática de reconocimiento de voz que contiene los elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el valor del mismo elemento semántico. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [utilizando SemanticResultKey y objetos de SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
 Para obtener más información acerca de la creación y el uso de las gramáticas de reconocimiento de voz, consulte [el reconocimiento de voz](http://msdn.microsoft.com/library/6a7dc524-07fc-4862-8d48-8c10dc64b919) y [crear GrammarBuilder gramáticas](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="choices + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">El primer elemento grammar, que representa un conjunto de alternativas.</param>
        <param name="builder">El segundo elemento grammar.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene un objeto <see cref="T:System.Speech.Recognition.Choices" /> seguido por un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Devuelve <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del parámetro <paramref name="choices" /> seguido por el parámetro <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> admite conversiones de las siguientes clases.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder` parámetro. Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operadores.  
  
> [!IMPORTANT]
>  Cuando se combinan <xref:System.Speech.Recognition.Choices> y <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias, asegúrese de que evita la creación de elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [SemanticResultValue descripción y SemanticResultKey objetos](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
 El método equivalente para este operador es <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.Choices%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">El primer elemento de gramática.</param>
        <param name="choices">El segundo elemento de la gramática, que representa un conjunto de elementos alternativos.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> seguido de un <see cref="T:System.Speech.Recognition.Choices" />.</summary>
        <returns>Devuelve <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del parámetro <paramref name="builder" /> seguido por el parámetro <paramref name="choices" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> admite las conversiones de las siguientes clases:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder` parámetro. Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operadores.  
  
> [!IMPORTANT]
>  Cuando se combinan <xref:System.Speech.Recognition.Choices> y <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias, asegúrese de que evita la creación de elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [SemanticResultValue descripción y SemanticResultKey objetos](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
 El método equivalente para este operador es <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer las dos frases, "convertirla en fondo *color*" y "establecer el fondo *color*", donde *color* se selecciona de un conjunto de colores. Varios tipos se utilizan para compilar la gramática final, por ejemplo, [cadena](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, y <xref:System.Speech.Recognition.GrammarBuilder> objetos.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder1 + builder2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">El primer elemento de gramática.</param>
        <param name="builder2">El segundo elemento grammar.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene una secuencia de dos objetos <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Devuelve <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del parámetro <paramref name="builder1" /> seguido por el parámetro <paramref name="builder2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> admite conversiones de las siguientes clases.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para la `builder1` y `builder2` parámetros. Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operadores.  
  
> [!IMPORTANT]
>  Cuando se combinan <xref:System.Speech.Recognition.GrammarBuilder> objetos que contienen <xref:System.Speech.Recognition.SemanticResultValue> o <xref:System.Speech.Recognition.SemanticResultKey> instancias, asegúrese de que evita la creación de elementos semántica duplicados con el mismo nombre de clave o varios elementos semánticos que podrían modificar varias veces el <xref:System.Speech.Recognition.SemanticValue.Value%2A> propiedad de un <xref:System.Speech.Recognition.SemanticValue> objeto. El reconocedor de voz puede producir una excepción si encuentra estas circunstancias. Para obtener más información acerca de cómo generar una gramática de reconocimiento de voz que contiene información semántica, consulte [SemanticResultValue descripción y SemanticResultKey objetos](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
 El método equivalente para este operador es <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">El primer elemento de gramática.</param>
        <param name="phrase">El segundo elemento de la gramática, que representa una secuencia de palabras.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> seguido de una frase.</summary>
        <returns>Devuelve <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del parámetro <paramref name="builder" /> seguido por el parámetro <paramref name="phrase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> admite conversiones de las siguientes clases.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder` parámetro. Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operadores.  
  
 El método equivalente para este operador es <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.String%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="phrase + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">El primer elemento de la gramática, que representa una secuencia de palabras.</param>
        <param name="builder">El segundo elemento grammar.</param>
        <summary>Crea un nuevo <see cref="T:System.Speech.Recognition.GrammarBuilder" /> que contiene una frase seguida de un <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Devuelve <see cref="T:System.Speech.Recognition.GrammarBuilder" /> para la secuencia del parámetro <paramref name="phrase" /> seguido por el parámetro <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> admite conversiones de las siguientes clases.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Este método acepta los objetos enumerados anteriormente para el `builder` parámetro. Para obtener más información, consulte el <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operadores.  
  
 El método equivalente para este operador es <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.String%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>  
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer las dos frases, "convertirla en fondo *color*" y "establecer el fondo *color*", donde *color* se selecciona de un conjunto de colores. Varios tipos se utilizan para compilar la gramática final, por ejemplo, [cadena](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, y <xref:System.Speech.Recognition.GrammarBuilder> objetos.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte otro tipo en <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conversión implícita crea una nueva instancia de <xref:System.Speech.Recognition.GrammarBuilder>. Puede convertir cada una de las siguientes clases para un <xref:System.Speech.Recognition.GrammarBuilder>.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Cada una de las conversiones implícitas es equivalente a llamar al constructor.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="choices">El conjunto de alternativas para convertir.</param>
        <summary>Convierte un objeto <see cref="T:System.Speech.Recognition.Choices" /> en un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Objeto convertido <see cref="T:System.Speech.Recognition.Choices" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conversión implícita crea una nueva instancia de <xref:System.Speech.Recognition.GrammarBuilder>. Este operador de conversión es equivalente a llamar a <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> y la especificación de `choices` para el `alternateChoices`.  
  
 El método equivalente para este operador es <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer una respuesta a "yes" o "no" pregunta. El operador de conversión implícita se utiliza en la construcción de un <xref:System.Speech.Recognition.SemanticResultValue> objeto desde un <xref:System.Speech.Recognition.Choices> objeto, en la construcción de un <xref:System.Speech.Recognition.Choices> objeto de dos <xref:System.Speech.Recognition.SemanticResultValue> objetos y en la construcción de un <xref:System.Speech.Recognition.Grammar> objeto desde un <xref:System.Speech.Recognition.SemanticResultKey> objeto.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultKey semanticKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultKey semanticKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultKey)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticKey As SemanticResultKey) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultKey ^ semanticKey);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticKey" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="semanticKey">Clave semántica que se va a convertir.</param>
        <summary>Convierte un objeto <see cref="T:System.Speech.Recognition.SemanticResultKey" /> en un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Objeto convertido <see cref="T:System.Speech.Recognition.SemanticResultKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conversión implícita crea una nueva instancia de <xref:System.Speech.Recognition.GrammarBuilder>. Este operador de conversión es equivalente a llamar a <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> y la especificación de `semanticKey` para el `key`.  
  
 El método equivalente para este operador es <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultKey%29?displayProperty=nameWithType>  
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer una respuesta a "yes" o "no" pregunta. El operador de conversión implícita se utiliza en la construcción de un <xref:System.Speech.Recognition.SemanticResultValue> objeto desde un <xref:System.Speech.Recognition.Choices> objeto, en la construcción de un <xref:System.Speech.Recognition.Choices> objeto de dos <xref:System.Speech.Recognition.SemanticResultValue> objetos y en la construcción de un <xref:System.Speech.Recognition.Grammar> objeto desde un <xref:System.Speech.Recognition.SemanticResultKey> objeto.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultValue semanticValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultValue semanticValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultValue)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticValue As SemanticResultValue) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultValue ^ semanticValue);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticValue" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="semanticValue">Objeto <see cref="T:System.Speech.Recognition.SemanticResultValue" /> que se va a convertir.</param>
        <summary>Convierte un objeto <see cref="T:System.Speech.Recognition.SemanticResultValue" /> en un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Objeto convertido <see cref="T:System.Speech.Recognition.SemanticResultValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conversión implícita crea una nueva instancia de <xref:System.Speech.Recognition.GrammarBuilder>. Este operador de conversión es equivalente a llamar a <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> y la especificación de `semanticValue` para el `value`.  
  
 El método equivalente para este operador es <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultValue%29?displayProperty=nameWithType>  
  
## Examples  
 En el ejemplo siguiente se crea una gramática de reconocimiento de voz que puede reconocer una respuesta a "yes" o "no" pregunta. El operador de conversión implícita se utiliza en la construcción de un <xref:System.Speech.Recognition.SemanticResultValue> objeto desde un <xref:System.Speech.Recognition.Choices>objeto, en la construcción de un <xref:System.Speech.Recognition.Choices> objeto de dos <xref:System.Speech.Recognition.SemanticResultValue> objetos y en la construcción de un <xref:System.Speech.Recognition.Grammar> objeto desde un <xref:System.Speech.Recognition.SemanticResultKey> objeto.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.String)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Cadena que se va a convertir.</param>
        <summary>Convierte una cadena en un objeto <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Cadena convertida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conversión implícita crea una nueva instancia de <xref:System.Speech.Recognition.GrammarBuilder>. Este operador de conversión es equivalente a llamar a <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> y especificando el mismo `phrase`.  
  
 El método equivalente para este operador es <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.String%29?displayProperty=nameWithType>  
  
## Examples  
 En el ejemplo siguiente se utiliza <xref:System.Speech.Recognition.GrammarBuilder> y <xref:System.Speech.Recognition.Choices> objetos que permiten construir una gramática que pueda reconocer cualquiera de las dos frases, "convertirla en fondo *colorChoice*" o "establecer el fondo *colorChoice*".  
  
 Después de crear una lista de valores aceptables para *colorChoice* con un <xref:System.Speech.Recognition.Choices> objeto, en el ejemplo se inicializa dos <xref:System.Speech.Recognition.GrammarBuilder> objetos, `makePhrase` y `setPhrase`, mediante la conversión implícita de cadena objetos.  
  
 Por último se crea en el ejemplo un <xref:System.Speech.Recognition.Grammar> objeto de un <xref:System.Speech.Recognition.Choices> objeto se convierte en un <xref:System.Speech.Recognition.GrammarBuilder> objeto.  
  
```csharp  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
  </Members>
</Type>