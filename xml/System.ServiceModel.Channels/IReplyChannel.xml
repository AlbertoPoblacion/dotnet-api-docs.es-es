<Type Name="IReplyChannel" FullName="System.ServiceModel.Channels.IReplyChannel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="160c6657f10ed6ec444d5721a21779d9a3ea7b6b" />
    <Meta Name="ms.sourcegitcommit" Value="1afcc8f9041ff3093fd13fb0afda92ac188878a9" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="09/06/2018" />
    <Meta Name="ms.locfileid" Value="43850546" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IReplyChannel : System.ServiceModel.Channels.IChannel" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IReplyChannel implements class System.ServiceModel.Channels.IChannel, class System.ServiceModel.ICommunicationObject" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.IReplyChannel" />
  <TypeSignature Language="VB.NET" Value="Public Interface IReplyChannel&#xA;Implements IChannel" />
  <TypeSignature Language="C++ CLI" Value="public interface class IReplyChannel : System::ServiceModel::Channels::IChannel" />
  <TypeSignature Language="F#" Value="type IReplyChannel = interface&#xA;    interface IChannel&#xA;    interface ICommunicationObject" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Define la interfaz que un canal debe implementar para estar en el lado receptor de una comunicación de solicitud-respuesta entre los puntos de conexión de la mensajería.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-interface-note](~/includes/untrusted-data-interface-note.md)]

 La interfaz <xref:System.ServiceModel.Channels.IReplyChannel> incluye variantes sincrónicas y asincrónicas de un método <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> y devuelve un <xref:System.ServiceModel.Channels.RequestContext> que se puede utilizar para construir las respuestas a las solicitudes recibidas.  
  
 El contrato incluye variantes sincrónicas y asincrónicas de la funcionalidad de recepción, de intento de recepción y de espera por un mensaje.  
  
 Un <xref:System.ServiceModel.Channels.IReplyChannel> no está necesariamente enlazado a un remitente único. Otros canales e interfaces de canal proporcionan la correlación entre el remitente y el canal de la respuesta, pero el contrato base no hace ese tipo de restricción.  
  
 El modelo de extracción se utiliza con <xref:System.ServiceModel.Channels.IReplyChannel> para recibir los mensajes. Este modelo consiste en llamar a <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> (o a una de sus variantes) y a continuación esperar a que llegue un mensaje.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginReceiveRequest">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza una operación asincrónica para recibir una solicitud disponible.Comienza una operación asincrónica para recibir una solicitud disponible.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceiveRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveRequest (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceiveRequest(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveRequest (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveRequest(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReceiveRequest : AsyncCallback * obj -&gt; IAsyncResult" Usage="iReplyChannel.BeginReceiveRequest (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">El delegado <see cref="T:System.AsyncCallback" /> que recibe la notificación de la recepción asincrónica que completa una operación de solicitud.</param>
        <param name="state">Un objeto, especificado por la aplicación, que contiene información de estado asociada a la recepción asincrónica de una operación de solicitud.</param>
        <summary>Comienza una operación asincrónica para recibir una solicitud disponible con un tiempo de espera predeterminado.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la recepción asincrónica de una solicitud.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.AsyncCallback%2CSystem.Object%29> método implementa el patrón estándar para invocar <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest> asincrónicamente. El tiempo de espera predeterminado es 1 minuto. Si se establece un tiempo de espera de recepción en el enlace utilizado para configurar la conexión, se utiliza ese valor. Utilice <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> si desea especificar un tiempo de espera explícito con la llamada que invalida estos otros valores.  
  
 Si el mensaje de solicitud recibido es mayor que el tamaño del mensaje máximo permitido por el enlace utilizado, se produce una excepción de la clase <xref:System.ServiceModel.QuotaExceededException>. La propiedad <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> establece el tamaño del mensaje máximo. El valor predeterminado es 65536 bytes.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveRequest (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceiveRequest(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveRequest (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveRequest(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReceiveRequest : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iReplyChannel.BeginReceiveRequest (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que especifica el intervalo de tiempo que hay que esperar para recibir una solicitud disponible.</param>
        <param name="callback">El delegado <see cref="T:System.AsyncCallback" /> que recibe la notificación de la recepción asincrónica que completa una operación de solicitud.</param>
        <param name="state">Un objeto, especificado por la aplicación, que contiene información de estado asociada a la recepción asincrónica de una operación de solicitud.</param>
        <summary>Comienza una operación asincrónica para recibir una solicitud disponible con un tiempo de espera especificado.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la recepción asincrónica de una solicitud.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> método implementa el patrón estándar para invocar <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%28System.TimeSpan%29> asincrónicamente. El tiempo de espera establecido en este método invalida el tiempo de espera de recepción establecido en el enlace utilizado para configurar la conexión.  
  
 Si el mensaje de solicitud recibido es mayor que el tamaño del mensaje máximo permitido por el enlace utilizado, se produce una excepción de la clase <xref:System.ServiceModel.QuotaExceededException>. La propiedad <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> establece el tamaño del mensaje máximo. El valor predeterminado es 65536 bytes.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTryReceiveRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTryReceiveRequest (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginTryReceiveRequest(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTryReceiveRequest (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginTryReceiveRequest : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iReplyChannel.BeginTryReceiveRequest (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que especifica cuánto tiempo tiene una operación de solicitud de recepción antes de expirar y devolver <see langword="false" />.</param>
        <param name="callback">El delegado <see cref="T:System.AsyncCallback" /> que recibe la notificación de la recepción asincrónica que completa una operación de solicitud.</param>
        <param name="state">Un objeto, especificado por la aplicación, que contiene información de estado asociada a la recepción asincrónica de una operación de solicitud.</param>
        <summary>Comienza una operación asincrónica para recibir un mensaje de solicitud que tiene un tiempo de espera especificado y un objeto de estados asociados a él.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la operación asincrónica de una solicitud de recepción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si es necesario que la aplicación siga realizando sus procesos sin esperar, hay que utilizar el método asincrónico <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>. Utilice uno de los métodos <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> sincrónicos cuando sea aceptable bloquear el subproceso actual mientras este responde al mensaje de solicitud o hasta que se supere el intervalo del tiempo de espera.  
  
 Este método recibe una notificación, mediante una devolución de llamada, de la identidad del controlador de eventos de la operación. La operación no se completa hasta que haya un mensaje disponible en el canal o se agote el tiempo de espera.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La operación devuelve <see langword="false" /> si se supera el <paramref name="timeout" /> especificado.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginWaitForRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWaitForRequest (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWaitForRequest(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWaitForRequest (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWaitForRequest(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWaitForRequest : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iReplyChannel.BeginWaitForRequest (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que especifica el intervalo de tiempo que hay que esperar para recibir una solicitud disponible.</param>
        <param name="callback">El delegado <see cref="T:System.AsyncCallback" /> que recibe la notificación de la recepción asincrónica que completa una operación de solicitud.</param>
        <param name="state">Un objeto, especificado por la aplicación, que contiene información de estado asociada a la recepción asincrónica de una operación de solicitud.</param>
        <summary>Comienza una operación de solicitud asincrónica que tiene un tiempo de espera especificado y un objeto de estados asociados a él.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la operación asincrónica de espera a que llegue un mensaje de solicitud.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice el método sincrónico <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> cuando sea aceptable bloquear el subproceso actual mientras este espera a que llegue un mensaje de solicitud a la cola. El subproceso está bloqueado hasta el `timeout`especificado.  
  
 Este método recibe una notificación, mediante una devolución de llamada, de la identidad del controlador de eventos de la operación. La operación no se completa hasta que haya un mensaje de solicitud disponible en el canal o se agote el tiempo de espera.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#10)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La operación devuelve <see langword="false" /> si se supera el <paramref name="timeout" /> especificado.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveRequest">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext EndReceiveRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.RequestContext EndReceiveRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveRequest (result As IAsyncResult) As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::RequestContext ^ EndReceiveRequest(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReceiveRequest : IAsyncResult -&gt; System.ServiceModel.Channels.RequestContext" Usage="iReplyChannel.EndReceiveRequest result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">El <see cref="T:System.IAsyncResult" /> devuelto por una llamada al método <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" />.</param>
        <summary>Completa una operación asincrónica para recibir una solicitud disponible.Comienza una operación asincrónica para recibir una solicitud disponible.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> utilizado para construir una respuesta a la solicitud.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el mensaje de solicitud recibido es mayor que el tamaño del mensaje máximo permitido por el enlace utilizado, se produce una excepción de la clase <xref:System.ServiceModel.QuotaExceededException>. La propiedad <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> establece el tamaño del mensaje máximo. El valor predeterminado es 65536 bytes.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La operación debería iniciar <see cref="T:System.TimeoutException" /> si se supera el <paramref name="timeout" /> especificado antes de que se complete la operación.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndTryReceiveRequest">
      <MemberSignature Language="C#" Value="public bool EndTryReceiveRequest (IAsyncResult result, out System.ServiceModel.Channels.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndTryReceiveRequest(class System.IAsyncResult result, [out] class System.ServiceModel.Channels.RequestContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest(System.IAsyncResult,System.ServiceModel.Channels.RequestContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndTryReceiveRequest (result As IAsyncResult, ByRef context As RequestContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndTryReceiveRequest(IAsyncResult ^ result, [Runtime::InteropServices::Out] System::ServiceModel::Channels::RequestContext ^ % context);" />
      <MemberSignature Language="F#" Value="abstract member EndTryReceiveRequest : IAsyncResult *  -&gt; bool" Usage="iReplyChannel.EndTryReceiveRequest (result, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
        <Parameter Name="context" Type="System.ServiceModel.Channels.RequestContext" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">El <see cref="T:System.IAsyncResult" /> devuelto por una llamada al método <see cref="M:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />.</param>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> recibido.</param>
        <summary>Completa la operación asincrónica especificada para recibir un mensaje de solicitud.</summary>
        <returns>
          <see langword="true" /> si se recibe un mensaje de solicitud antes de que transcurra un intervalo de tiempo especificado; de lo contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWaitForRequest">
      <MemberSignature Language="C#" Value="public bool EndWaitForRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndWaitForRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWaitForRequest (result As IAsyncResult) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndWaitForRequest(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWaitForRequest : IAsyncResult -&gt; bool" Usage="iReplyChannel.EndWaitForRequest result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">El <see cref="T:System.IAsyncResult" /> que identifica la operación <see cref="M:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)" /> que va a terminar y de la que se va a recuperar un resultado final.</param>
        <summary>Completa la operación asincrónica especificada de espera por una solicitud.</summary>
        <returns>
          <see langword="true" /> si se recibe una solicitud antes de que transcurra un intervalo de tiempo especificado; de lo contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalAddress">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EndpointAddress LocalAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EndpointAddress LocalAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.IReplyChannel.LocalAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalAddress As EndpointAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EndpointAddress ^ LocalAddress { System::ServiceModel::EndpointAddress ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalAddress : System.ServiceModel.EndpointAddress" Usage="System.ServiceModel.Channels.IReplyChannel.LocalAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EndpointAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la dirección en la que este canal de respuesta recibe los mensajes.</summary>
        <value>
          <see cref="T:System.ServiceModel.EndpointAddress" /> en el que este canal de respuesta recibe los mensajes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El código siguiente muestra cómo implementar esta propiedad:  
  
 [!code-csharp[S_UE_MessageInterceptor#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#0)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveRequest">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el contexto de la solicitud recibida si está disponible</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveRequest">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext ReceiveRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.RequestContext ReceiveRequest() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveRequest () As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::RequestContext ^ ReceiveRequest();" />
      <MemberSignature Language="F#" Value="abstract member ReceiveRequest : unit -&gt; System.ServiceModel.Channels.RequestContext" Usage="iReplyChannel.ReceiveRequest " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el contexto de la solicitud recibida si está disponible. Si el contexto no está disponible, espera hasta que haya uno disponible.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> que se utiliza para construir respuestas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.RequestContext> encapsula el mensaje de solicitud y un mecanismo para responder a ese mensaje.  
  
 Se puede llamar <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> varias veces o simultáneamente. Sólo se completa una llamada <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> por solicitud recibida.  
  
 Si el mensaje de solicitud recibido es mayor que el tamaño del mensaje máximo permitido por el enlace utilizado, se produce una excepción de la clase <xref:System.ServiceModel.QuotaExceededException>. La propiedad <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> establece el tamaño del mensaje máximo. El valor predeterminado es 65536 bytes.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#7](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveRequest">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext ReceiveRequest (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.RequestContext ReceiveRequest(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveRequest (timeout As TimeSpan) As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::RequestContext ^ ReceiveRequest(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member ReceiveRequest : TimeSpan -&gt; System.ServiceModel.Channels.RequestContext" Usage="iReplyChannel.ReceiveRequest timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que especifica cuánto tiempo tiene una operación de solicitud antes de expirar y devolver <see langword="false" />.</param>
        <summary>Devuelve el contexto de la solicitud recibida si está disponible. Si el contexto no está disponible, espera hasta que haya uno disponible.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> que se utiliza para construir respuestas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.RequestContext> encapsula el mensaje de solicitud y un mecanismo para responder a ese mensaje.  
  
 Se puede llamar <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> varias veces o simultáneamente. Sólo se completa una llamada <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> por solicitud recibida.  
  
 Si el mensaje de solicitud recibido es mayor que el tamaño del mensaje máximo permitido por el enlace utilizado, se produce una excepción de la clase <xref:System.ServiceModel.QuotaExceededException>. La propiedad <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> establece el tamaño del mensaje máximo. El valor predeterminado es 65536 bytes.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceiveRequest">
      <MemberSignature Language="C#" Value="public bool TryReceiveRequest (TimeSpan timeout, out System.ServiceModel.Channels.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceiveRequest(valuetype System.TimeSpan timeout, [out] class System.ServiceModel.Channels.RequestContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest(System.TimeSpan,System.ServiceModel.Channels.RequestContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceiveRequest (timeout As TimeSpan, ByRef context As RequestContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReceiveRequest(TimeSpan timeout, [Runtime::InteropServices::Out] System::ServiceModel::Channels::RequestContext ^ % context);" />
      <MemberSignature Language="F#" Value="abstract member TryReceiveRequest : TimeSpan *  -&gt; bool" Usage="iReplyChannel.TryReceiveRequest (timeout, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="context" Type="System.ServiceModel.Channels.RequestContext" RefType="out" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que especifica cuánto tiempo tiene una operación de solicitud antes de expirar y devolver <see langword="false" />.</param>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> recibido.</param>
        <summary>Devuelve un valor que indica si una solicitud se recibe antes de que transcurra un intervalo de tiempo especificado.</summary>
        <returns>
          <see langword="true" /> si se recibe un mensaje de solicitud antes de que transcurra un intervalo de tiempo especificado; de lo contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> cuando sea aceptable bloquear el subproceso actual mientras se espera a que llegue un mensaje de solicitud a la cola. El subproceso está bloqueado hasta el `timeout`especificado. Si es necesario que la aplicación siga realizando sus procesos sin esperar, hay que utilizar el método asincrónico <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La operación devuelve <see langword="false" /> si se supera el <paramref name="timeout" /> especificado.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WaitForRequest">
      <MemberSignature Language="C#" Value="public bool WaitForRequest (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitForRequest(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.WaitForRequest(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForRequest (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForRequest(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitForRequest : TimeSpan -&gt; bool" Usage="iReplyChannel.WaitForRequest timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que especifica cuánto tiempo tiene una operación de solicitud antes de expirar y devolver <see langword="false" />.</param>
        <summary>Devuelve un valor que indica si un mensaje de solicitud se recibe antes de que transcurra un intervalo de tiempo especificado.</summary>
        <returns>
          <see langword="true" /> si se recibe una solicitud antes de que transcurra un intervalo de tiempo especificado; de lo contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> no resulta en un mensaje de solicitud recibido o procesado de forma alguna.  
  
 El método <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> existe principalmente para los escenarios con transacción donde donde el usuario desea recibir el mensaje mediante una transacción. Al utilizar normalmente <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> para esto, el usuario debe crear la transacción y, a continuación, llamar <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> y esperar que el mensaje llegue antes de que expire la transacción, lo que puede no ser posible.  
  
 En su lugar, el usuario puede llamar <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> y especificar el tiempo de espera (incluso infinito); a continuación, cuando llega un mensaje, puede abrir la transacción, llamar <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> y estar seguro que pueden recibir el mensaje antes de que la transacción expire.  
  
 Utilice <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> cuando se acepte bloquear el subproceso actual mientras se espera a que llegue un mensaje a la cola. El subproceso está bloqueado hasta el `timeout`especificado. Si es necesario que la aplicación siga realizando sus procesos sin esperar, hay que utilizar el método asincrónico <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#9](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#9)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La operación devuelve <see langword="false" /> si se supera el <paramref name="timeout" /> especificado.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>