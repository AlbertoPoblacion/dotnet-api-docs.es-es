<Type Name="OneWayBindingElement" FullName="System.ServiceModel.Channels.OneWayBindingElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="af12cdc6a6c4d69bba0e38e9a8b1c40fa43c2fab" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32692233" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class OneWayBindingElement : System.ServiceModel.Channels.BindingElement, System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OneWayBindingElement extends System.ServiceModel.Channels.BindingElement implements class System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.OneWayBindingElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OneWayBindingElement&#xA;Inherits BindingElement&#xA;Implements IPolicyExportExtension" />
  <TypeSignature Language="C++ CLI" Value="public ref class OneWayBindingElement sealed : System::ServiceModel::Channels::BindingElement, System::ServiceModel::Description::IPolicyExportExtension" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.BindingElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IPolicyExportExtension</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Habilita el enrutamiento de paquetes y el uso de métodos unidireccionales.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para habilitar el enrutamiento de paquetes un *conversión unidireccional* capa es necesaria, que proporciona esta clase. Esta clase es un enlace en la pila de enlaces que realiza un cambio de forma de nivel de mensaje llamado `OneWayBindingElement`. Este cambio de forma puede tomar <xref:System.ServiceModel.Channels.IDuplexSessionChannel> o <xref:System.ServiceModel.Channels.IRequestChannel> y exponerlo como <xref:System.ServiceModel.Channels.IInputChannel>o a la inversa puede tomar <xref:System.ServiceModel.Channels.IDuplexSessionChannel> o <xref:System.ServiceModel.Channels.IRequestChannel> y exponerlo como <xref:System.ServiceModel.Channels.IOutputChannel>. Un usuario puede crear un enlace personalizado que coloque este enlace en una capa a través de un transporte consciente de sesión o de solicitud/respuesta para que se pueda realizar el enrutamiento de paquetes.  
  
 Esta clase también es útil cuando desea exponer los métodos unidireccionales de una manera más nativa. Se pueden aplicar más transformaciones sobre esta capa, como Dúplex Compuesto y Mensajería de confianza.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OneWayBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OneWayBindingElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ServiceModel.Channels.OneWayBindingElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelFactory(Of TChannel) (context As BindingContext) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">El tipo de canal que compila el generador.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> que proporciona el contexto para el elemento de enlace.</param>
        <summary>Inicializa un generador de canales para generar canales unidireccionales a partir del contexto de enlace.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> de tipo <see cref="T:System.ServiceModel.Channels.IChannel" /> inicializado a partir de <paramref name="context" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea un generador de canales que se usa para crear un canal que procesa los mensajes salientes para este enlace.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El tipo de <paramref name="TChannel" /> no es <see cref="T:System.ServiceModel.Channels.IOutputChannel" />.</exception>
        <exception cref="T:System.InvalidOperationException">El elemento de enlace interno no admite <see cref="T:System.ServiceModel.Channels.IDuplexSessionChannel" /> o <see cref="T:System.ServiceModel.Channels.IRequestChannel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.BuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">El tipo de canal que acepta la escucha.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> que proporciona el contexto para el elemento de enlace.</param>
        <summary>Inicializa una escucha de canales para aceptar los canales unidireccionales.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> de tipo <see cref="T:System.ServiceModel.Channels.IChannel" /> inicializado a partir de <paramref name="context" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea una escucha de canal que se usa para crear un canal que procesa los mensajes entrantes para este enlace.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El tipo de <paramref name="TChannel" /> no es <see cref="T:System.ServiceModel.Channels.IInputChannel" />.</exception>
        <exception cref="T:System.InvalidOperationException">El elemento de enlace interno no admite <see cref="T:System.ServiceModel.Channels.IDuplexSessionChannel" /> o <see cref="T:System.ServiceModel.Channels.IRequestChannel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelFactory(Of TChannel) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override bool CanBuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">El tipo de generador de canales que se debe crear.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> que proporciona el contexto para el elemento de enlace.</param>
        <summary>Obtiene un valor que indica si se puede crear un generador de canales del tipo especificado.</summary>
        <returns>
          <see langword="true" /> si se puede crear el generador de canales del tipo especificado; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería llamar a este método antes de intentar crear un generador de canales.  
  
 Este método devuelve `true` cuando `TChannel` es <xref:System.ServiceModel.Channels.IOutputChannel>, y el enlace debajo del actual en la pila de enlace es <xref:System.ServiceModel.Channels.IDuplexSessionChannel> o <xref:System.ServiceModel.Channels.IRequestChannel>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.CanBuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override bool CanBuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">El tipo de escucha de canales que se debe crear.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> que proporciona el contexto para el elemento de enlace.</param>
        <summary>Obtiene un valor que indica si se puede crear una escucha del canal del tipo especificado.</summary>
        <returns>
          <see langword="true" /> si se puede crear una escucha de canal del tipo especificado; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería llamar a este método antes de intentar crear una escucha de canales.  
  
 Este método devuelve `true` cuando `TChannel` es <xref:System.ServiceModel.Channels.IInputChannel>, y el enlace debajo del actual en la pila de enlace es <xref:System.ServiceModel.Channels.IDuplexSessionChannel> o <xref:System.ServiceModel.Channels.IReplyChannel>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ChannelPoolSettings">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.ChannelPoolSettings ChannelPoolSettings { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.ChannelPoolSettings ChannelPoolSettings" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.OneWayBindingElement.ChannelPoolSettings" />
      <MemberSignature Language="VB.NET" Value="Public Property ChannelPoolSettings As ChannelPoolSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::ChannelPoolSettings ^ ChannelPoolSettings { System::ServiceModel::Channels::ChannelPoolSettings ^ get(); void set(System::ServiceModel::Channels::ChannelPoolSettings ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.ChannelPoolSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la configuración del grupo de canales.</summary>
        <value>Un objeto <see cref="T:System.ServiceModel.Channels.ChannelPoolSettings" /> que contiene propiedades del grupo de canales asociado a este elemento de enlace.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElement Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElement Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Clone () As BindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ServiceModel::Channels::BindingElement ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clona una instancia de esta clase.</summary>
        <returns>Una copia clonada de esta instancia de esta clase.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperty(Of T As Class) (context As BindingContext) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class override T GetProperty(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de propiedad.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> que proporciona el contexto para el elemento de enlace.</param>
        <summary>Obtiene las propiedades de la pila de enlace, si está presente.</summary>
        <returns>Un objeto <paramref name="T" /> de la pila de enlace, si está presente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método recibe un contexto de enlace como un parámetro de entrada, que representa la pila de elementos de enlace.  
  
 Cada elemento de enlace en la pila puede administrar la solicitud él mismo o delegar la solicitud o una combinación de ambos. Cada elemento de enlace puede modificar el contexto si delega la solicitud. Sin embargo, un elemento de enlace del transporte administra la solicitud él mismo.  
  
 Los elementos de enlace, así como los objetos en tiempo de ejecución como <xref:System.ServiceModel.Channels.IChannelFactory>, <xref:System.ServiceModel.Channels.IChannelListener>y <xref:System.ServiceModel.Channels.IChannel> implementan este método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxAcceptedChannels">
      <MemberSignature Language="C#" Value="public int MaxAcceptedChannels { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxAcceptedChannels" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.OneWayBindingElement.MaxAcceptedChannels" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxAcceptedChannels As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxAcceptedChannels { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(10)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número máximo de canales que se pueden aceptar.</summary>
        <value>El número máximo de canales que se pueden aceptar. El valor predeterminado es 10.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PacketRoutable">
      <MemberSignature Language="C#" Value="public bool PacketRoutable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PacketRoutable" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.OneWayBindingElement.PacketRoutable" />
      <MemberSignature Language="VB.NET" Value="Public Property PacketRoutable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PacketRoutable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si está habilitado el enrutamiento de paquetes.</summary>
        <value>
          <see langword="true" /> si está habilitado el enrutamiento de paquetes; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta clase puede utilizar opcionalmente un protocolo de nivel de mensaje que transforma un `DuplexSessionChannel` / `RequestChannel` / `ReplyChannel` en un canal unidireccional y permite enrutar los mensajes del canal transformado. El uso de este protocolo está controlado por la propiedad <xref:System.ServiceModel.Channels.OneWayBindingElement.PacketRoutable%2A>.  
  
 Cuando esta propiedad es `true`, tras `DuplexSessionChannel` inicio (por ejemplo, en el búfer TCP y canalizaciones con nombre), esta clase agrega un encabezado de mensaje (MustUnderstand = `false`, firmar, si está habilitada la seguridad) que semánticamente significa "puede realizar el enrutamiento de paquetes este canal". En el lado del aceptador, cuando esta propiedad es `true`, esta clase busca este encabezado en el primer mensaje recibido en el canal. Si este encabezado no existe, WCF produce un error en el canal. Si no existe el encabezado, WCF canaliza el nuevo canal en un canal de entrada compartido.  
  
 Para transformar un canal de solicitud y respuesta (por ejemplo, transmisión por secuencias de TCP o HTTP) cuando esta propiedad es `true`, este encabezado se agrega a cada solicitud para indicar que la solicitud puede enrutado el paquete. WCF también comprueba que `SendRequest` devuelve `null` y responde con `null` en el servidor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeChannelPoolSettings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeChannelPoolSettings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeChannelPoolSettings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.ShouldSerializeChannelPoolSettings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeChannelPoolSettings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeChannelPoolSettings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor si se deben serializar las propiedades del grupo de canales asociadas con este elemento de enlace.</summary>
        <returns>
          Es <see langword="true" /> si se debe serializar la configuración del grupo de canales; de lo contrario, es false <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy">
      <MemberSignature Language="C#" Value="void IPolicyExportExtension.ExportPolicy (System.ServiceModel.Description.MetadataExporter exporter, System.ServiceModel.Description.PolicyConversionContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(class System.ServiceModel.Description.MetadataExporter exporter, class System.ServiceModel.Description.PolicyConversionContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.System#ServiceModel#Description#IPolicyExportExtension#ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)" />
      <MemberSignature Language="VB.NET" Value="Sub ExportPolicy (exporter As MetadataExporter, context As PolicyConversionContext) Implements IPolicyExportExtension.ExportPolicy" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System::ServiceModel::Description::MetadataExporter ^ exporter, System::ServiceModel::Description::PolicyConversionContext ^ context) = System::ServiceModel::Description::IPolicyExportExtension::ExportPolicy;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.MetadataExporter" />
        <Parameter Name="context" Type="System.ServiceModel.Description.PolicyConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter">La clase <see cref="T:System.ServiceModel.Description.MetadataExporter" /> que puede usar para modificar el proceso de exportación.</param>
        <param name="context">
          <see cref="T:System.ServiceModel.Description.PolicyConversionContext" /> que puede usar para insertar su aserción de directiva personalizada.</param>
        <summary>Exporta una aserción de directiva personalizada que representa el elemento de enlace unidireccional.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método escribe instrucciones relacionadas con el enlace en la información WSDL expuesta por un contrato determinado y WCF lo utiliza para comunicarse con los clientes la existencia de este elemento de enlace personalizado en la pila de enlace.  
  
 Este método toma dos parámetros: los objetos <xref:System.ServiceModel.Description.MetadataExporter> y <xref:System.ServiceModel.Description.PolicyConversionContext>. Utilice <xref:System.ServiceModel.Description.PolicyConversionContext.GetBindingAssertions%2A>, <xref:System.ServiceModel.Description.PolicyConversionContext.GetMessageBindingAssertions%2A>, y los métodos <xref:System.ServiceModel.Description.PolicyConversionContext.GetOperationBindingAssertions%2A> para obtener colecciones de aserciones de directiva que ya se han exportado a varios ámbitos. A continuación, use este método para agregar sus propias aserciones de directiva a la colección adecuada.  
  
 La propiedad <xref:System.ServiceModel.Description.PolicyConversionContext.Contract%2A> expone <xref:System.ServiceModel.Description.ContractDescription> para el extremo que se exporta. Esto permite a este método definir correctamente el ámbito de las aserciones de directiva exportadas. Por ejemplo, los atributos de seguridad del código pueden agregar comportamientos a <xref:System.ServiceModel.Description.ContractDescription> que indiquen donde deben agregarse las aserciones de la directiva de seguridad.  
  
 Una vez que se asocian las aserciones de directiva personalizadas a la información de WSDL, los clientes pueden detectar e importar las aserciones de enlace personalizadas mediante la implementación de una interfaz <xref:System.ServiceModel.Description.IPolicyImportExtension>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>