<Type Name="CommunicationObject" FullName="System.ServiceModel.Channels.CommunicationObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="76d6bb212f753b13200ad9043dd30afc254488c8" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49138862" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CommunicationObject : System.ServiceModel.ICommunicationObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CommunicationObject extends System.Object implements class System.ServiceModel.ICommunicationObject" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.CommunicationObject" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CommunicationObject&#xA;Implements ICommunicationObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class CommunicationObject abstract : System::ServiceModel::ICommunicationObject" />
  <TypeSignature Language="F#" Value="type CommunicationObject = class&#xA;    interface ICommunicationObject" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.ICommunicationObject</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Proporciona una implementación base común para la máquina de estados básicos común a todos los objetos orientados a la comunicación en el sistema, incluyendo canales, escuchas y los generadores de canales y escuchas.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ServiceModel.Channels.CommunicationObject> la clase implementa la <xref:System.ServiceModel.ICommunicationObject> interfaz para todos los objetos de comunicación de Windows Communication Foundation (WCF). Las implementaciones de método administran la validación de parámetros, generan eventos que notifican la aparición de transiciones de estado, proporcionan los medios al procesamiento adicional asociado a estas transiciones de estado y garantizan que se coordinen tales cambios de estado.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ServiceModel.Channels.CommunicationObject" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CommunicationObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CommunicationObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ServiceModel.Channels.CommunicationObject" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CommunicationObject (object mutex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object mutex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (mutex As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CommunicationObject(System::Object ^ mutex);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Channels.CommunicationObject : obj -&gt; System.ServiceModel.Channels.CommunicationObject" Usage="new System.ServiceModel.Channels.CommunicationObject mutex" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mutex" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="mutex">El bloqueo mutuamente excluyente que protege la instancia de clase durante una transición de estado.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ServiceModel.Channels.CommunicationObject" /> con el bloqueo mutuamente excluyente para proteger las transiciones de estado especificadas.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Abort();" />
      <MemberSignature Language="F#" Value="abstract member Abort : unit -&gt; unit&#xA;override this.Abort : unit -&gt; unit" Usage="communicationObject.Abort " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.Abort</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provoca que un objeto de comunicación pase inmediatamente de su estado actual al estado de cierre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método indica que se debería omitir o terminar de forma discreta cualquier trabajo inacabado antes de devolverse. El método <xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A> se puede usar para cancelar cualquier operación pendiente, incluidas las llamadas pendientes a <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A>.  
  
 Para realizar correctamente una transición de <xref:System.ServiceModel.Channels.CommunicationObject> desde cualquier estado distinto de <xref:System.ServiceModel.CommunicationState.Closed> al estado <xref:System.ServiceModel.CommunicationState.Closed>, llame a <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> o una de sus versiones asincrónicas, <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginClose">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza una operación asincrónica para cerrar un objeto de comunicación.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginClose">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginClose (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginClose(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.BeginClose(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginClose (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginClose(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginClose : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginClose : AsyncCallback * obj -&gt; IAsyncResult" Usage="communicationObject.BeginClose (callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.BeginClose(System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación de cierre asincrónica.</param>
        <param name="state">Objeto, especificado por la aplicación, que contiene la información de estado asociada a la operación de cierre asincrónica.</param>
        <summary>Comienza una operación asincrónica para cerrar un objeto de comunicación.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la operación de cierre asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método provoca que <xref:System.ServiceModel.Channels.CommunicationObject> realice correctamente la transición de cualquier estado distinto a <xref:System.ServiceModel.CommunicationState.Closed>, al estado <xref:System.ServiceModel.CommunicationState.Closed> dentro de un intervalo de tiempo predeterminado. El método <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A> permite completar cualquier trabajo inacabado antes de devolverse. Por ejemplo, terminar de enviar cualquier mensaje almacenado en búfer. Este método llama a <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> si el objeto de comunicación estaba inicialmente en el estado <xref:System.ServiceModel.CommunicationState.Opened>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación no está en un estado <see cref="F:System.ServiceModel.CommunicationState.Opened" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
        <exception cref="T:System.TimeoutException">El intervalo de tiempo predeterminado asignado a la operación se ha superado antes de completarse la operación.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginClose">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginClose (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginClose(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.BeginClose(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginClose (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginClose(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginClose : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginClose : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="communicationObject.BeginClose (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.BeginClose(System.TimeSpan,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">El <see cref="T:System.TimeSpan" /> que especifica el tiempo con el que cuenta la operación de cierre para completarse antes de que se agote el tiempo de espera.</param>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación de cierre asincrónica.</param>
        <param name="state">Objeto, especificado por la aplicación, que contiene la información de estado asociada a la operación de cierre asincrónica.</param>
        <summary>Comienza una operación asincrónica para cerrar un objeto de comunicación con un tiempo de espera especificado.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la operación de cierre asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método provoca que <xref:System.ServiceModel.Channels.CommunicationObject> realice correctamente la transición de cualquier estado distinto a <xref:System.ServiceModel.CommunicationState.Closed> al estado <xref:System.ServiceModel.CommunicationState.Closed> en un intervalo de tiempo especificado.  El método <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A> permite completar cualquier trabajo inacabado antes de devolverse. Por ejemplo, terminar de enviar cualquier mensaje almacenado en búfer. Este método llama a <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginClose%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> si el objeto de comunicación estaba inicialmente en el estado <xref:System.ServiceModel.CommunicationState.Opened>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación no está en un estado <see cref="F:System.ServiceModel.CommunicationState.Opened" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
        <exception cref="T:System.TimeoutException">El intervalo de tiempo predeterminado asignado a la operación se ha superado antes de completarse la operación.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginOpen">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza una operación asincrónica para abrir un objeto de comunicación.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginOpen">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginOpen (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginOpen(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.BeginOpen(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginOpen (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginOpen(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginOpen : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginOpen : AsyncCallback * obj -&gt; IAsyncResult" Usage="communicationObject.BeginOpen (callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.BeginOpen(System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación de apertura asincrónica.</param>
        <param name="state">Un objeto, especificado por la aplicación, que contiene información de estado asociada a la operación de apertura asincrónica.</param>
        <summary>Comienza una operación asincrónica para abrir un objeto de comunicación.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" />, que hace referencia a la operación de apertura asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> llama a <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A> y <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>si el objeto de comunicación está inicialmente en el estado <xref:System.ServiceModel.CommunicationState.Created>.  
  
 Para insertar procesamiento después de que un objeto de comunicación realice la transición a un estado de cierre debido a la invocación de una operación sincrónica <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A>, utilice el método <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación no está en un estado <see cref="F:System.ServiceModel.CommunicationState.Opened" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
        <exception cref="T:System.TimeoutException">El intervalo de tiempo predeterminado asignado a la operación se ha superado antes de completarse la operación.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginOpen">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginOpen (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginOpen(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.BeginOpen(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginOpen (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginOpen(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginOpen : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginOpen : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="communicationObject.BeginOpen (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.BeginOpen(System.TimeSpan,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">El objeto <see cref="T:System.TimeSpan" /> que especifica el tiempo con el que cuenta la operación de envío para completarse antes de que se agote el tiempo de espera.</param>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación de apertura asincrónica.</param>
        <param name="state">Un objeto, especificado por la aplicación, que contiene información de estado asociada a la operación de apertura asincrónica.</param>
        <summary>Comienza una operación asincrónica para abrir un objeto de comunicación dentro de un intervalo de tiempo especificado.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" />, que hace referencia a la operación de apertura asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> llama a <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A> y <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>si el objeto de comunicación está inicialmente en el estado <xref:System.ServiceModel.CommunicationState.Created>.  
  
 Para insertar procesamiento después de que un objeto de comunicación realice la transición a un estado de cierre debido a la invocación de una operación sincrónica <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A>, utilice el método <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación no está en un estado <see cref="F:System.ServiceModel.CommunicationState.Opened" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
        <exception cref="T:System.TimeoutException">El intervalo de tiempo predeterminado asignado a la operación se ha superado antes de completarse la operación.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Provoca que un objeto de comunicación pase de su estado actual al estado cerrado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="communicationObject.Close " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provoca que un objeto de comunicación pase de su estado actual al estado cerrado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método provoca que <xref:System.ServiceModel.Channels.CommunicationObject> realice correctamente la transición desde cualquier estado distinto a <xref:System.ServiceModel.CommunicationState.Closed> al estado <xref:System.ServiceModel.CommunicationState.Closed>. El método <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> permite completar cualquier trabajo inacabado antes de devolverse. Por ejemplo, terminar de enviar cualquier mensaje almacenado en búfer.  
  
 <xref:System.ServiceModel.Channels.CommunicationObject> entra en el estado <xref:System.ServiceModel.CommunicationState.Closing> y permanece en él después de que se llame al método <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> hasta que finaliza la transición al estado <xref:System.ServiceModel.CommunicationState.Closed>. La transición consiste en realizar llamadas sucesivas a <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%28System.TimeSpan%29>y <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A>.  
  
 También existe una versión asincrónica del método de cierre que se inicia llamando a <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación no está en un estado <see cref="F:System.ServiceModel.CommunicationState.Opened" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
        <exception cref="T:System.TimeoutException">El intervalo de tiempo predeterminado asignado a la operación se ha superado antes de completarse la operación.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Close(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member Close : TimeSpan -&gt; unit&#xA;override this.Close : TimeSpan -&gt; unit" Usage="communicationObject.Close timeout" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.Close(System.TimeSpan)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">El <see cref="T:System.TimeSpan" /> que especifica el tiempo con el que cuenta la operación de cierre para completarse antes de que se agote el tiempo de espera.</param>
        <summary>Provoca que un objeto de comunicación pase su estado actual al estado cerrado dentro de un intervalo de tiempo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método provoca que <xref:System.ServiceModel.Channels.CommunicationObject> realice correctamente la transición de cualquier estado distinto a <xref:System.ServiceModel.CommunicationState.Closed> al estado <xref:System.ServiceModel.CommunicationState.Closed> en un intervalo de tiempo especificado. El método <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> permite completar cualquier trabajo inacabado antes de devolverse. Por ejemplo, terminar de enviar cualquier mensaje almacenado en búfer.  
  
 <xref:System.ServiceModel.Channels.CommunicationObject> entra en el estado <xref:System.ServiceModel.CommunicationState.Closing> y permanece en él después de que se llame al método <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> hasta que finaliza la transición al estado <xref:System.ServiceModel.CommunicationState.Closed>. La transición consiste en realizar llamadas sucesivas a <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%28System.TimeSpan%29>y <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A>.  
  
 También existe una versión asincrónica del método de cierre que se inicia llamando a <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación no está en un estado <see cref="F:System.ServiceModel.CommunicationState.Opened" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
        <exception cref="T:System.TimeoutException">El intervalo de tiempo predeterminado asignado a la operación se ha superado antes de completarse la operación.</exception>
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.Channels.CommunicationObject.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ServiceModel.ICommunicationObject.Closed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un objeto de comunicación realiza una transición al estado de cerrado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El evento <xref:System.ServiceModel.Channels.CommunicationObject.Closed> es producido por el método <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A> que es llamado por los métodos <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> y <xref:System.ServiceModel.Channels.CommunicationObject.EndClose%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event EventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.Channels.CommunicationObject.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : EventHandler " Usage="member this.Closing : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ServiceModel.ICommunicationObject.Closing</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un objeto de comunicación realiza una transición al estado de cerrando.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El evento <xref:System.ServiceModel.Channels.CommunicationObject.Closing> es producido por el método <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A> que es llamado por los métodos <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> y <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCloseTimeout">
      <MemberSignature Language="C#" Value="protected internal abstract TimeSpan DefaultCloseTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan DefaultCloseTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride ReadOnly Property DefaultCloseTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract property TimeSpan DefaultCloseTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCloseTimeout : TimeSpan" Usage="System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el intervalo de tiempo predeterminado proporcionado para que se complete una operación de cierre.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> predeterminado que especifica el tiempo con el que cuenta la operación de cierre para completarse antes de que se agote el tiempo de espera.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultOpenTimeout">
      <MemberSignature Language="C#" Value="protected internal abstract TimeSpan DefaultOpenTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan DefaultOpenTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride ReadOnly Property DefaultOpenTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract property TimeSpan DefaultOpenTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultOpenTimeout : TimeSpan" Usage="System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el intervalo de tiempo predeterminado proporcionado para que se complete una operación de apertura.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> predeterminado que especifica el tiempo con el que cuenta la operación de apertura para completarse antes de que se agote el tiempo de espera.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndClose">
      <MemberSignature Language="C#" Value="public void EndClose (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndClose(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.EndClose(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndClose (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndClose(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndClose : IAsyncResult -&gt; unit&#xA;override this.EndClose : IAsyncResult -&gt; unit" Usage="communicationObject.EndClose result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.EndClose(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> que se devuelve al llamar al método <see cref="Overload:System.ServiceModel.Channels.CommunicationObject.BeginClose" />.</param>
        <summary>Completa una operación asincrónica para cerrar un objeto de comunicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> proporciona una versión sincrónica de este método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación no está en un estado <see cref="F:System.ServiceModel.CommunicationState.Opened" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
        <exception cref="T:System.TimeoutException">El intervalo de tiempo predeterminado asignado a la operación se ha superado antes de completarse la operación.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndOpen">
      <MemberSignature Language="C#" Value="public void EndOpen (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndOpen(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.EndOpen(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndOpen (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndOpen(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndOpen : IAsyncResult -&gt; unit&#xA;override this.EndOpen : IAsyncResult -&gt; unit" Usage="communicationObject.EndOpen result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.EndOpen(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> que se devuelve al llamar al método <see cref="Overload:System.ServiceModel.Channels.CommunicationObject.BeginClose" />.</param>
        <summary>Completa una operación asincrónica para abrir un objeto de comunicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> proporciona una versión sincrónica de este método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación no está en un estado <see cref="F:System.ServiceModel.CommunicationState.Opened" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
        <exception cref="T:System.TimeoutException">El intervalo de tiempo predeterminado asignado a la operación se ha superado antes de completarse la operación.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fault">
      <MemberSignature Language="C#" Value="protected void Fault ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Fault() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Fault" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Fault ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Fault();" />
      <MemberSignature Language="F#" Value="member this.Fault : unit -&gt; unit" Usage="communicationObject.Fault " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provoca que un objeto de comunicación pase de su estado actual al estado de error.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El evento <xref:System.ServiceModel.Channels.CommunicationObject.Faulted> es provocado por el método <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A> que es llamado por el método <xref:System.ServiceModel.Channels.CommunicationObject.Fault%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Faulted">
      <MemberSignature Language="C#" Value="public event EventHandler Faulted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Faulted" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.Channels.CommunicationObject.Faulted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Faulted As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Faulted;" />
      <MemberSignature Language="F#" Value="member this.Faulted : EventHandler " Usage="member this.Faulted : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ServiceModel.ICommunicationObject.Faulted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un objeto de comunicación realiza una transición al estado de error.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El evento <xref:System.ServiceModel.Channels.CommunicationObject.Faulted> es provocado por el método <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A> que es llamado por el método <xref:System.ServiceModel.Channels.CommunicationObject.Fault%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCommunicationObjectType">
      <MemberSignature Language="C#" Value="protected virtual Type GetCommunicationObjectType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetCommunicationObjectType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.GetCommunicationObjectType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetCommunicationObjectType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetCommunicationObjectType();" />
      <MemberSignature Language="F#" Value="abstract member GetCommunicationObjectType : unit -&gt; Type&#xA;override this.GetCommunicationObjectType : unit -&gt; Type" Usage="communicationObject.GetCommunicationObjectType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el tipo de objeto de comunicación.</summary>
        <returns>El tipo de objeto de comunicación.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="protected bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CommunicationObject.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.ServiceModel.Channels.CommunicationObject.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto de comunicación se ha eliminado.</summary>
        <value>
          <see langword="true" /> si el objeto de comunicación está en un estado cerrado; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un objeto se considera eliminado cuando se produce el evento <xref:System.ServiceModel.Channels.CommunicationObject.Closed>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAbort">
      <MemberSignature Language="C#" Value="protected abstract void OnAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnAbort" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnAbort ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnAbort();" />
      <MemberSignature Language="F#" Value="abstract member OnAbort : unit -&gt; unit" Usage="communicationObject.OnAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserta el procesamiento en un objeto de comunicación después de que éste pase al estado de cierre debido a la invocación de una operación sincrónica de interrupción.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A> llama a <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A> si el objeto de comunicación aún no está en un estado <xref:System.ServiceModel.CommunicationState.Closed>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginClose">
      <MemberSignature Language="C#" Value="protected abstract IAsyncResult OnBeginClose (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult OnBeginClose(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnBeginClose(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function OnBeginClose (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract IAsyncResult ^ OnBeginClose(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member OnBeginClose : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="communicationObject.OnBeginClose (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que especifica el tiempo con el que cuenta la operación de cierre para completarse antes de que se agote el tiempo de espera.</param>
        <param name="callback">El delegado <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización asincrónica de la operación de cierre.</param>
        <param name="state">Objeto, especificado por la aplicación, que contiene información de estado asociada a la operación de cierre asincrónica.</param>
        <summary>Inserta el procesamiento después de que un objeto de comunicación pase al estado de cierre debido a la invocación de una operación asincrónica de cierre.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la operación de cierre asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A> llama a <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginClose%2A> si el objeto de comunicación está inicialmente en el estado <xref:System.ServiceModel.CommunicationState.Opened>.  
  
 Para insertar procesamiento después de que un objeto de comunicación realice la transición a un estado de cierre debido a la invocación de una operación sincrónica <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A>, utilice el método <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%28System.TimeSpan%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación no está en un estado <see cref="F:System.ServiceModel.CommunicationState.Opened" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
        <exception cref="T:System.TimeoutException">El intervalo de tiempo predeterminado asignado a la operación se ha superado antes de completarse la operación.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnBeginOpen">
      <MemberSignature Language="C#" Value="protected abstract IAsyncResult OnBeginOpen (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult OnBeginOpen(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function OnBeginOpen (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract IAsyncResult ^ OnBeginOpen(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member OnBeginOpen : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="communicationObject.OnBeginOpen (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que especifica el tiempo con el que cuenta la operación de apertura para completarse antes de que se agote el tiempo de espera.</param>
        <param name="callback">El delegado <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación de apertura asincrónica.</param>
        <param name="state">Un objeto, especificado por la aplicación, que contiene información de estado asociada a la operación de apertura asincrónica.</param>
        <summary>Inserta el procesamiento en un objeto de comunicación después de que éste pase al estado de apertura debido a la invocación de una operación asincrónica de apertura.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la operación de apertura asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para insertar procesamiento después de que un objeto de comunicación realice la transición a un estado de apertura debido a la invocación de una operación sincrónica <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A>, utilice el método <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación no está en un estado <see cref="F:System.ServiceModel.CommunicationState.Opened" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
        <exception cref="T:System.TimeoutException">El intervalo de tiempo predeterminado asignado a la operación se ha superado antes de completarse la operación.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnClose">
      <MemberSignature Language="C#" Value="protected abstract void OnClose (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClose(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnClose(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnClose (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnClose(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member OnClose : TimeSpan -&gt; unit" Usage="communicationObject.OnClose timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que especifica el tiempo con el que cuenta la operación de cierre para completarse antes de que se agote el tiempo de espera.</param>
        <summary>Inserta el procesamiento en un objeto de comunicación después de que éste pase al estado de cierre debido a la invocación de una operación sincrónica de cierre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> llama a <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A> si el objeto de comunicación está inicialmente en el estado <xref:System.ServiceModel.CommunicationState.Opened>.  
  
 Para insertar procesamiento después de que un objeto de comunicación realice la transición a un estado de cierre debido a la invocación de una operación asincrónica <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A>, utilice el método <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Se llamó a <see cref="Overload:System.ServiceModel.Channels.CommunicationObject.Close" /> en un objeto con el estado <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
        <exception cref="T:System.TimeoutException">El intervalo de tiempo predeterminado asignado a la operación se ha superado antes de completarse la operación.</exception>
        <exception cref="T:System.ServiceModel.CommunicationException">Error de comunicación al cerrar el objeto.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnClosed" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed();" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : unit -&gt; unit&#xA;override this.OnClosed : unit -&gt; unit" Usage="communicationObject.OnClosed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se invoca durante la transición de un objeto de comunicación al estado de cierre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> llama a <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A> si el objeto de comunicación está inicialmente en el estado <xref:System.ServiceModel.CommunicationState.Opened>.  
  
 El método <xref:System.ServiceModel.Channels.CommunicationObject.EndClose%2A> llama a <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A> (y <xref:System.ServiceModel.Channels.CommunicationObject.OnEndClose%28System.IAsyncResult%29>si el objeto de comunicación aún no está en un estado <xref:System.ServiceModel.CommunicationState.Closed>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnClosing" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing();" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : unit -&gt; unit&#xA;override this.OnClosing : unit -&gt; unit" Usage="communicationObject.OnClosing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se invoca durante la transición de un objeto de comunicación al estado de cierre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> llama a <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A> si el objeto de comunicación está inicialmente en el estado <xref:System.ServiceModel.CommunicationState.Opened>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndClose">
      <MemberSignature Language="C#" Value="protected abstract void OnEndClose (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEndClose(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnEndClose(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnEndClose (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnEndClose(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member OnEndClose : IAsyncResult -&gt; unit" Usage="communicationObject.OnEndClose result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> que se devuelve al llamar al método <see cref="M:System.ServiceModel.Channels.CommunicationObject.OnEndClose(System.IAsyncResult)" />.</param>
        <summary>Completa una operación asincrónica al cerrar un objeto de comunicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.ServiceModel.Channels.CommunicationObject.EndClose%28System.IAsyncResult%29> llama a <xref:System.ServiceModel.Channels.CommunicationObject.OnEndClose%28System.IAsyncResult%29> si el objeto de comunicación aún no está en un estado <xref:System.ServiceModel.CommunicationState.Closed>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación no está en un estado <see cref="F:System.ServiceModel.CommunicationState.Opened" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
        <exception cref="T:System.TimeoutException">El intervalo de tiempo predeterminado asignado a la operación se ha superado antes de completarse la operación.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnEndOpen">
      <MemberSignature Language="C#" Value="protected abstract void OnEndOpen (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEndOpen(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnEndOpen(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnEndOpen (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnEndOpen(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member OnEndOpen : IAsyncResult -&gt; unit" Usage="communicationObject.OnEndOpen result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> que se devuelve al llamar al método <see cref="M:System.ServiceModel.Channels.CommunicationObject.OnEndOpen(System.IAsyncResult)" />.</param>
        <summary>Completa una operación asincrónica al abrir un objeto de comunicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.ServiceModel.Channels.CommunicationObject.EndOpen%2A> llama a <xref:System.ServiceModel.Channels.CommunicationObject.OnEndOpen%2A> (y <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación no está en un estado <see cref="F:System.ServiceModel.CommunicationState.Opened" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
        <exception cref="T:System.TimeoutException">El intervalo de tiempo predeterminado asignado a la operación se ha superado antes de completarse la operación.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnFaulted">
      <MemberSignature Language="C#" Value="protected virtual void OnFaulted ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFaulted() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnFaulted" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFaulted ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFaulted();" />
      <MemberSignature Language="F#" Value="abstract member OnFaulted : unit -&gt; unit&#xA;override this.OnFaulted : unit -&gt; unit" Usage="communicationObject.OnFaulted " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserta el procesamiento en un objeto de comunicación después de que éste pase al estado de error debido a la invocación de una operación sincrónica de error.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El evento <xref:System.ServiceModel.Channels.CommunicationObject.Faulted> es provocado por el método <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A> que es llamado por el método <xref:System.ServiceModel.Channels.CommunicationObject.Fault%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnOpen">
      <MemberSignature Language="C#" Value="protected abstract void OnOpen (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnOpen(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnOpen(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnOpen (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnOpen(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member OnOpen : TimeSpan -&gt; unit" Usage="communicationObject.OnOpen timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que especifica el tiempo con el que cuenta la operación de apertura para completarse antes de que se agote el tiempo de espera.</param>
        <summary>Inserta el procesamiento en un objeto de comunicación después que éste pase al estado de apertura que debe completarse dentro de un intervalo de tiempo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> llama a <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%28System.TimeSpan%29> (después de llamar a <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A> y antes de llamar a <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A>) si el objeto de comunicación está inicialmente en el estado <xref:System.ServiceModel.CommunicationState.Created>.  
  
 Para insertar procesamiento cuando un objeto de comunicación realiza la transición a un estado de apertura debido a la invocación de una operación asincrónica <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>, utilice el método <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación no está en un estado <see cref="F:System.ServiceModel.CommunicationState.Opened" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
        <exception cref="T:System.TimeoutException">El intervalo de tiempo predeterminado asignado a la operación se ha superado antes de completarse la operación.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnOpened">
      <MemberSignature Language="C#" Value="protected virtual void OnOpened ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnOpened() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnOpened" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnOpened ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnOpened();" />
      <MemberSignature Language="F#" Value="abstract member OnOpened : unit -&gt; unit&#xA;override this.OnOpened : unit -&gt; unit" Usage="communicationObject.OnOpened " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se invoca durante la transición de un objeto de comunicación al estado de abierto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esto proporciona una manera de agregar el procesamiento cuando es llamado por los métodos <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> y <xref:System.ServiceModel.Channels.CommunicationObject.EndOpen%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnOpening ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnOpening() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnOpening" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnOpening ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnOpening();" />
      <MemberSignature Language="F#" Value="abstract member OnOpening : unit -&gt; unit&#xA;override this.OnOpening : unit -&gt; unit" Usage="communicationObject.OnOpening " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se invoca durante la transición de un objeto de comunicación al estado de abriendo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esto proporciona una manera de agregar el procesamiento cuando es llamado por los métodos <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> y <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Hace que un objeto de comunicación pase del estado creado al estado abierto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama, el método <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> provoca que <xref:System.ServiceModel.Channels.CommunicationObject> entre en el estado <xref:System.ServiceModel.CommunicationState.Opening> y llama a <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A>, <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A>, y <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A>.  El método <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A> completa el método <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> estableciendo el estado del objeto en el estado <xref:System.ServiceModel.CommunicationState.Opened>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public void Open ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Open() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Open" />
      <MemberSignature Language="VB.NET" Value="Public Sub Open ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Open();" />
      <MemberSignature Language="F#" Value="abstract member Open : unit -&gt; unit&#xA;override this.Open : unit -&gt; unit" Usage="communicationObject.Open " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.Open</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hace que un objeto de comunicación pase del estado creado al estado abierto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se crea una instancia de <xref:System.ServiceModel.Channels.CommunicationObject>, comienza en el estado <xref:System.ServiceModel.CommunicationState.Created>. En el estado <xref:System.ServiceModel.CommunicationState.Created>, el objeto se puede configurar (por ejemplo, se pueden establecer las propiedades o registrar los eventos), pero no se puede usar todavía para enviar o recibir mensajes. Cuando se llama, el método <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> provoca que <xref:System.ServiceModel.Channels.CommunicationObject> entre en el estado <xref:System.ServiceModel.CommunicationState.Opening> y llama a <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A>, <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A>, y <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A>. El método <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A> completa el método <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> estableciendo el estado del objeto en el estado <xref:System.ServiceModel.CommunicationState.Opened>.  
  
 En el campo   
  
 estado <xref:System.ServiceModel.CommunicationState.Opened>, se puede utilizar <xref:System.ServiceModel.Channels.CommunicationObject> (por ejemplo, se pueden recibir los mensajes), pero ya no se pueden configurar.  
  
 Existe también una versión asincrónica del método de apertura que se inicia llamando a <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> y se completa llamando a <xref:System.ServiceModel.Channels.CommunicationObject.EndOpen%2A>.  
  
### <a name="credentials-capture-with-windows-authentication"></a>Captura de credenciales con autenticación de Windows  
 Al utilizar la autenticación de Windows, las credenciales utilizadas por el servicio están basadas en el subproceso del contexto actual. Se obtienen las credenciales cuando se llama al método `Open`.  
  
> [!NOTE]
>  Para las llamadas asincrónicas, las credenciales se capturan cuando se invoca <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A>. Sin embargo, no se pueden garantizar las credenciales actuales. Es decir, las credenciales del llamador se pueden cambiar a otra identidad. Para obtener más información, consulte [seguridad de mensajes con un cliente de Windows](~/docs/framework/wcf/feature-details/message-security-with-a-windows-client.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación no está en un estado <see cref="F:System.ServiceModel.CommunicationState.Opened" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
        <exception cref="T:System.TimeoutException">El intervalo de tiempo predeterminado asignado a la operación se ha superado antes de completarse la operación.</exception>
        <altmember cref="M:System.ServiceModel.Channels.CommunicationObject.BeginOpen(System.AsyncCallback,System.Object)" />
        <related type="Article" href="http://msdn.microsoft.com/library/01e7d0b8-10f9-45c3-a4c5-53d44dc61eb8">Seguridad del mensaje con un cliente de Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public void Open (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Open(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Open(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Open (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Open(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member Open : TimeSpan -&gt; unit&#xA;override this.Open : TimeSpan -&gt; unit" Usage="communicationObject.Open timeout" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.Open(System.TimeSpan)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">El <see cref="T:System.TimeSpan" /> que especifica el tiempo con el que cuenta la operación de apertura para completarse antes de que se agote el tiempo de espera.</param>
        <summary>Hace que un objeto de comunicación pase del estado creado al estado abierto dentro de un intervalo de tiempo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se crea una instancia de <xref:System.ServiceModel.Channels.CommunicationObject>, comienza en el estado <xref:System.ServiceModel.CommunicationState.Created>. En el estado <xref:System.ServiceModel.CommunicationState.Created>, el objeto se puede configurar (por ejemplo, se pueden establecer las propiedades o registrar los eventos), pero no se puede usar todavía para enviar o recibir mensajes. Cuando se llama, el método <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> provoca que <xref:System.ServiceModel.Channels.CommunicationObject> entre en el estado <xref:System.ServiceModel.CommunicationState.Opening> y llama a <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A>, <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A>, y <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A>.  El método <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A> completa el método <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> estableciendo el estado del objeto en el estado <xref:System.ServiceModel.CommunicationState.Opened>.  
  
 En el campo   
  
 estado <xref:System.ServiceModel.CommunicationState.Opened>, se puede utilizar <xref:System.ServiceModel.Channels.CommunicationObject> (por ejemplo, se pueden recibir los mensajes), pero ya no se pueden configurar.  
  
 Existe también una versión asincrónica del método de apertura que se inicia llamando a <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> y se completa llamando a <xref:System.ServiceModel.Channels.CommunicationObject.EndOpen%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación no está en un estado <see cref="F:System.ServiceModel.CommunicationState.Opened" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
        <exception cref="T:System.TimeoutException">El intervalo de tiempo predeterminado asignado a la operación se ha superado antes de completarse la operación.</exception>
      </Docs>
    </Member>
    <Member MemberName="Opened">
      <MemberSignature Language="C#" Value="public event EventHandler Opened;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Opened" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.Channels.CommunicationObject.Opened" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Opened As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Opened;" />
      <MemberSignature Language="F#" Value="member this.Opened : EventHandler " Usage="member this.Opened : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ServiceModel.ICommunicationObject.Opened</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un objeto de comunicación realiza una transición al estado de abierto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El evento <xref:System.ServiceModel.Channels.CommunicationObject.Opened> es producido por el método <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A> que es llamado por los métodos <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> y <xref:System.ServiceModel.Channels.CommunicationObject.EndOpen%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Opening">
      <MemberSignature Language="C#" Value="public event EventHandler Opening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Opening" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.Channels.CommunicationObject.Opening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Opening As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Opening;" />
      <MemberSignature Language="F#" Value="member this.Opening : EventHandler " Usage="member this.Opening : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ServiceModel.ICommunicationObject.Opening</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un objeto de comunicación realiza una transición al estado de abriendo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El evento <xref:System.ServiceModel.Channels.CommunicationObject.Opening> es producido por el método <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A> que es llamado por los métodos <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> y <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="State">
      <MemberSignature Language="C#" Value="public System.ServiceModel.CommunicationState State { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.CommunicationState State" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CommunicationObject.State" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property State As CommunicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::CommunicationState State { System::ServiceModel::CommunicationState get(); };" />
      <MemberSignature Language="F#" Value="member this.State : System.ServiceModel.CommunicationState" Usage="System.ServiceModel.Channels.CommunicationObject.State" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.ICommunicationObject.State</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.CommunicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica el estado actual del objeto de comunicación.</summary>
        <value>Un valor de la enumeración <see cref="T:System.ServiceModel.CommunicationState" /> que indica el estado actual del objeto.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThisLock">
      <MemberSignature Language="C#" Value="protected object ThisLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ThisLock" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CommunicationObject.ThisLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ThisLock As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ ThisLock { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ThisLock : obj" Usage="System.ServiceModel.Channels.CommunicationObject.ThisLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el bloqueo mutuamente excluyente que protege la instancia de clase durante una transición de estado.</summary>
        <value>El bloqueo mutuamente excluyente que protege la instancia de clase durante una transición de estado.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfDisposed">
      <MemberSignature Language="C#" Value="protected void ThrowIfDisposed ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ThrowIfDisposed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposed" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ThrowIfDisposed ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ThrowIfDisposed();" />
      <MemberSignature Language="F#" Value="member this.ThrowIfDisposed : unit -&gt; unit" Usage="communicationObject.ThrowIfDisposed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Produce una excepción si se elimina el objeto de comunicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se produce ninguna excepción si el objeto de comunicación está en un estado <xref:System.ServiceModel.CommunicationState.Created>, <xref:System.ServiceModel.CommunicationState.Opening> o <xref:System.ServiceModel.CommunicationState.Opened>. Se elimina un objeto de comunicación una vez se llama a <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> en él.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfDisposedOrImmutable">
      <MemberSignature Language="C#" Value="protected void ThrowIfDisposedOrImmutable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ThrowIfDisposedOrImmutable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrImmutable" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ThrowIfDisposedOrImmutable ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ThrowIfDisposedOrImmutable();" />
      <MemberSignature Language="F#" Value="member this.ThrowIfDisposedOrImmutable : unit -&gt; unit" Usage="communicationObject.ThrowIfDisposedOrImmutable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Produce una excepción si en el objeto de comunicación la propiedad <see cref="P:System.ServiceModel.Channels.CommunicationObject.State" /> no está establecida en el estado <see cref="F:System.ServiceModel.CommunicationState.Created" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puesto que un objeto es inmutable después de llamar a <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A>en él, el único estado que es mutable y que no está eliminado es el estado <xref:System.ServiceModel.CommunicationState.Created>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Opening" /> o <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfDisposedOrNotOpen">
      <MemberSignature Language="C#" Value="protected void ThrowIfDisposedOrNotOpen ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ThrowIfDisposedOrNotOpen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrNotOpen" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ThrowIfDisposedOrNotOpen ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ThrowIfDisposedOrNotOpen();" />
      <MemberSignature Language="F#" Value="member this.ThrowIfDisposedOrNotOpen : unit -&gt; unit" Usage="communicationObject.ThrowIfDisposedOrNotOpen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Produce una excepción si el objeto de comunicación no está en el estado <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">El objeto de comunicación no está en un estado <see cref="F:System.ServiceModel.CommunicationState.Created" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> y no se puede utilizar.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Closing" /> o <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El objeto de comunicación está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
      </Docs>
    </Member>
  </Members>
</Type>