<Type Name="ReliableSessionBindingElement" FullName="System.ServiceModel.Channels.ReliableSessionBindingElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="35b53ab1fd9a9f44c62055447ab53bd929afbad1" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39784276" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ReliableSessionBindingElement : System.ServiceModel.Channels.BindingElement, System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReliableSessionBindingElement extends System.ServiceModel.Channels.BindingElement implements class System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.ReliableSessionBindingElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReliableSessionBindingElement&#xA;Inherits BindingElement&#xA;Implements IPolicyExportExtension" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReliableSessionBindingElement sealed : System::ServiceModel::Channels::BindingElement, System::ServiceModel::Description::IPolicyExportExtension" />
  <TypeSignature Language="F#" Value="type ReliableSessionBindingElement = class&#xA;    inherit BindingElement&#xA;    interface IPolicyExportExtension" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.BindingElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IPolicyExportExtension</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa el elemento de enlace que puede generar los canales de envío y recepción requeridos para una sesión confiable entre los puntos de conexión.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Proporciona las sesiones y puede permitir, si se desea, la entrega ordenada de mensajes. Esta sesión implementada puede cruzar SOAP y los intermediarios de transporte.  
  
 Cada elemento de enlace representa un paso del procesamiento al enviar y recibir mensajes. En tiempo de ejecución, los elementos de enlace crean los generadores de canales y las escuchas que son necesarios para compilar pilas de canal entrantes y salientes necesarias para enviar y recibir los mensajes. <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> proporciona un nivel opcional en la pila que puede establecer una sesión confiable entre los extremos y configurar el comportamiento de esta sesión.  
  
 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> se proporciona en los enlaces estándar en la tabla siguiente.  
  
|Enlaces|Default|  
|-------------|-------------|  
|<xref:System.ServiceModel.NetTcpBinding>|Desactivado|  
|<xref:System.ServiceModel.WSHttpBinding>|Desactivado|  
|<xref:System.ServiceModel.WSDualHttpBinding>|On (se requiere)|  
  
   
  
## Examples  
 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> se puede agregar a cualquier enlace personalizado. Esto se hace utilizando los elementos de configuración siguientes.  
  
```  
<bindings>  
    <customBinding>  
        <binding configurationName="ReliabilityHTTP">  
            <reliableSession/>  
        </binding>  
    </customBinding>  
</bindings>  
```  
  
 En el ejemplo de código siguiente se muestra cómo usar <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> en el código.  
  
 [!code-csharp[S_Imperative#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_imperative/cs/service.cs#1)]
 [!code-vb[S_Imperative#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_imperative/vb/service.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReliableSessionBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReliableSessionBindingElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReliableSessionBindingElement (bool ordered);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool ordered) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ordered As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReliableSessionBindingElement(bool ordered);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Channels.ReliableSessionBindingElement : bool -&gt; System.ServiceModel.Channels.ReliableSessionBindingElement" Usage="new System.ServiceModel.Channels.ReliableSessionBindingElement ordered" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ordered" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ordered">
          <see langword="true" /> si los mensajes se deben entregar en el orden en el que se envían; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" /> que especifica si la entrega del mensaje debe conservar el orden en el que se envían los mensajes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcknowledgementInterval">
      <MemberSignature Language="C#" Value="public TimeSpan AcknowledgementInterval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan AcknowledgementInterval" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgementInterval As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan AcknowledgementInterval { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgementInterval : TimeSpan with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.TimeSpan), "00:00:00.2")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el intervalo de tiempo que un destino espera antes de enviar una confirmación al origen del mensaje en canales de confianza creados por el generador.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> que especifica el intervalo de tiempo que un servicio espera hasta enviar una confirmación al origen del mensaje. El valor predeterminado es 2 segundos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El destino que recibe los mensajes en un canal confiable agrupa las confirmaciones para estos mensajes en un mensaje único para reducir el tráfico de red y aumentar la densidad de la información en los mensajes. Agrupar mejor las escalas como aumentos del tráfico. No intenta enviar una confirmación por cada mensaje que recibe lo antes posible, sino que espera un intervalo de tiempo, se agrupa las confirmaciones que han llegado durante ese intervalo y, a continuación, las envía todo juntas. El primer mensaje que se recibe es la excepción; se confirma en cuanto se entrega. Asimismo, si las sesiones confiables se utilizan con conexiones HTTP únicas, como es el caso con <xref:System.ServiceModel.WSHttpBinding> pero no <xref:System.ServiceModel.WSDualHttpBinding>, este valor no se utiliza.  
  
 El valor que se establece con la propiedad <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval%2A> es una recomendación para la infraestructura y no un límite estricto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor establecido es menor o igual que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelFactory(Of TChannel) (context As BindingContext) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelFactory&lt;'Channel&gt;" Usage="reliableSessionBindingElement.BuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">El tipo de canal que compila el generador.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> que contiene la información necesaria para crear los generadores que pueden producir canales de tipo <c>TChannel</c>.</param>
        <summary>Devuelve un generador que crea un canal de un tipo especificado que admite una sesión confiable.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> de tipo <see cref="T:System.ServiceModel.Channels.IChannel" /> inicializado a partir de <paramref name="context" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ServiceModel.Channels.IChannel> que produce el generador es del tipo `TChannel`. Los tipos de `TChannel` admitidos en el cliente son dependientes de los tipos de canales subyacentes que conectan con el servicio. La tabla siguiente indica qué tipos de canal de sesión confiable se admiten como una función de los canales subyacentes.  
  
|Compatibilidad con los tipos `TChannel` de sesiones confiables por parte de los tipos de canales subyacentes|IRequestChannel|IRequestSessionChannel|IDuplexChannel|IDuplexSessionChannel|  
|-------------------------------------------------------------------------------|---------------------|----------------------------|--------------------|---------------------------|  
|IOutputSessionChannel|Sí|Sí|Sí|Sí|  
|IRequestSessionChannel|Sí|Sí|No|No|  
|IDuplexSessionChannel|No|No|Sí|Sí|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No se admite <paramref name="TChannel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelListener&lt;'Channel (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)&gt; (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="reliableSessionBindingElement.BuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">
          <see cref="T:System.ServiceModel.Channels.IChannel" /> que el agente de escucha puede aceptar.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> que contiene la información necesaria para crear las escuchas que pueden aceptar canales de tipo <c>TChannel</c>.</param>
        <summary>Devuelve un tipo de escucha que acepta un canal de un tipo especificado que admite una sesión confiable.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> de tipo <see cref="T:System.ServiceModel.Channels.IChannel" /> inicializado a partir de <paramref name="context" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ServiceModel.Channels.IChannel> aceptado por la escucha es del tipo `TChannel`. Los tipos de `TChannel` admitidos en el servidor que hospeda el servicio son dependientes de los tipos de canales subyacentes que se usan para conectar con el cliente. La tabla siguiente indica qué tipos de canal de sesión confiable se admiten como una función de los canales subyacentes.  
  
|Compatibilidad con los tipos `TChannel` de sesiones confiables por parte de los tipos de canales subyacentes|IReplyChannel|IReplySessionChannel|IDuplexChannel|IDuplexSessionChannel|  
|-------------------------------------------------------------------------------|-------------------|--------------------------|--------------------|---------------------------|  
|IInputSessionChannel|Sí|Sí|Sí|Sí|  
|IReplySessionChannel|Sí|Sí|No|No|  
|IDuplexSessionChannel|No|No|Sí|Sí|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No se admite <paramref name="TChannel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelFactory(Of TChannel) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override bool CanBuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.CanBuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; bool" Usage="reliableSessionBindingElement.CanBuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">El tipo de canal que compila el generador.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> que contiene la información necesaria para crear los generadores que pueden producir canales de tipo <c>TChannel</c>.</param>
        <summary>Devuelve un valor que indica si el generador de canales se puede compilar para el canal y el contexto siempre que pueda admitir una sesión confiable.</summary>
        <returns>
          <see langword="true" /> si el <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> del tipo <paramref name="TChannel" /> se puede crear; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve `true` o `false` para `TChannel` de acuerdo con la tabla de valores proporcionada en <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelFactory%60%601%28System.ServiceModel.Channels.BindingContext%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.CanBuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override bool CanBuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.CanBuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; bool (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="reliableSessionBindingElement.CanBuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">El <see cref="T:System.ServiceModel.Channels.IChannel" /> que el agente de escucha del canal, si de compilación, se acepta.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> que contiene la información necesaria para crear las escuchas que pueden aceptar canales de tipo <c>TChannel</c>.</param>
        <summary>Devuelve un valor que indica si la escucha de canales se puede crear para el canal y el contexto siempre que pueda admitir una sesión confiable.</summary>
        <returns>
          <see langword="true" /> si <see cref="T:System.ServiceModel.Channels.ChannelListenerBase`1" /> que puede producir un <see cref="T:System.ServiceModel.Channels.IChannel" /> del tipo <paramref name="TChannel" /> puede ser creado por el elemento de enlace; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las pilas de canales se suelen crear con un modelo de generador en el que un enlace crea la pila de canales. Al enviar mensajes, se utiliza un enlace para compilar un generador de canales, que a su vez compila una pila de canales y devuelve una referencia al canal superior en la pila. La aplicación puede utilizar a continuación este canal para enviar los mensajes. De igual forma, al recibir los mensajes, se utiliza un enlace para compilar una escucha del canal que realiza escuchas para los mensajes entrantes. La escucha de canal proporciona mensajes a la aplicación de escucha creando pilas de canales y llevando a la aplicación una referencia al canal superior.  
  
 Este método devuelve `true` o `false` para `TChannel` de acuerdo con la tabla de valores proporcionada en <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelListener%60%601%28System.ServiceModel.Channels.BindingContext%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElement Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElement Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Clone () As BindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ServiceModel::Channels::BindingElement ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.ServiceModel.Channels.BindingElement" Usage="reliableSessionBindingElement.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia del elemento de enlace de la sesión confiable actual.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.BindingElement" /> que es un clon del elemento de enlace actual.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowControlEnabled">
      <MemberSignature Language="C#" Value="public bool FlowControlEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FlowControlEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.FlowControlEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowControlEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool FlowControlEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.FlowControlEnabled : bool with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.FlowControlEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la sesión confiable tiene habilitado el control de flujo.</summary>
        <value>
          <see langword="true" /> si la sesión confiable tiene habilitado el control de flujo; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El control de flujo es un mecanismo que las sesiones confiables implementan para garantizar que los remitentes no envíen más mensajes de los que un receptor puede administrar. Los receptores tienen un búfer de mensajes que se utiliza para alojar ráfagas de mensajes y los mensajes fuera de secuencia. Los receptores anuncian a los remitentes la cantidad de espacio que permanece en este búfer en cada una de sus confirmaciones. Los remitentes pueden utilizar esta información para dejar de enviar mensajes nuevos cuando el receptor no tenga espacio en el búfer.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperty(Of T As Class) (context As BindingContext) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class override T GetProperty(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.GetProperty : System.ServiceModel.Channels.BindingContext -&gt; 'T (requires 'T : null)" Usage="reliableSessionBindingElement.GetProperty context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de propiedad recuperada.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> que contiene la información requerida para recuperar el canal de tipo <c>T</c>.</param>
        <summary>Obtiene una propiedad del tipo especificado de su contexto de enlace.</summary>
        <returns>Propiedad de tipo <paramref name="T" /> con el <paramref name="context" /> especificado o <see langword="null" /> si se encuentra ninguna propiedad de tipo <paramref name="T" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InactivityTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan InactivityTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan InactivityTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property InactivityTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan InactivityTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.InactivityTimeout : TimeSpan with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.TimeSpan), "00:10:00")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un intervalo de tiempo durante el que un servicio permanece inactivo antes de cerrarse.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> que especifica el intervalo de tiempo durante el que un servicio permanece inactivo antes de cerrarse. El valor predeterminado son 10 minutos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La actividad en un canal se define como la recepción de una aplicación o mensaje de infraestructura. El parámetro de tiempo de espera de inactividad controla el tiempo máximo para mantener activa una sesión inactiva. Si transcurren más de <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout%2A> intervalos de tiempo sin actividad, los errores del canal y la infraestructura anulan la sesión. La sesión de confianza se cierra unilateralmente.  
  
 Si la aplicación emisora no tiene ningún mensaje para enviar, la sesión de confianza normalmente no registra un error debido a inactividad; en su lugar un mecanismo Keep-Alive mantiene la sesión indefinidamente activa. Observe que el distribuidor puede anular independientemente la sesión confiable si no se envía ni se recibe ningún mensaje de la aplicación. Por consiguiente, el tiempo de espera de inactividad expira normalmente si las condiciones de la red son tales que no se recibe ningún mensaje o si hay un error en el remitente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor es menor o igual que cero, o mayor que <see cref="F:System.Int32.MaxValue" /> o <see cref="F:System.TimeSpan.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxPendingChannels">
      <MemberSignature Language="C#" Value="public int MaxPendingChannels { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPendingChannels" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxPendingChannels" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPendingChannels As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxPendingChannels { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxPendingChannels : int with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.MaxPendingChannels" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(4)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número máximo de canales que pueden estar pendientes durante la sesión confiable.</summary>
        <value>Número máximo de canales que pueden estar pendientes. El valor predeterminado es 4.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los canales están pendientes cuando esperan a ser aceptados. Una vez alcanzado ese límite, ningún canal se crea y se coloca en modo pendiente hasta que este número baje (aceptando los canales pendientes). Es un límite para cada agente de escucha.  
  
 Cuando se alcanza el umbral y una aplicación remota intenta establecer una nueva sesión fiable, se deniega la solicitud y falla la operación abierta que pidió confirmación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor establecido es menor o igual que cero o mayor que 16384.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxRetryCount">
      <MemberSignature Language="C#" Value="public int MaxRetryCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxRetryCount" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxRetryCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxRetryCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxRetryCount : int with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número máximo de veces que se intenta transferir un mensaje durante la sesión confiable.</summary>
        <value>Número máximo de veces que se intenta reenviar un mensaje. El valor mínimo es 1; el máximo es <see cref="F:System.Int32.MaxValue" />; y el valor predeterminado es 8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se considera que un mensaje es transferido si el destinatario ha confirmado su entrega.  
  
 Si no se ha recibido reconocimiento tras un cierto tiempo de un mensaje que se ha transmitido, la infraestructura retransmite automáticamente el mensaje. La infraestructura intenta enviar el mensaje, como máximo, un número <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount%2A> de veces. Si no se recibe una confirmación antes de que se alcance este límite, se considera que se ha producido un error de comunicación grave y se produce un evento de canal erróneo.  
  
 La infraestructura utiliza un algoritmo de espera exponencial para determinar cuándo retransmitir, en función del tiempo medio calculado de ida y vuelta. El tiempo de reintento inicial se calcula en función del tiempo de recorrido de ida y vuelta medido para establecer la sesión. El algoritmo de retransmisión duplica el retraso en cada intento, lo que provoca aproximadamente un intervalo de 8,5 minutos entre el primer intento de transmisión y el último intento de retransmisión. El tiempo del primer intento de retransmisión se ajusta al cálculo del tiempo de ida y vuelta y varía según el período de tiempo adicional que resulta del número de intentos que se necesitan. Esto permite que el tiempo de retransmisión se adapte dinámicamente a las condiciones variantes de la red.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor establecido es menor o igual que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxTransferWindowSize">
      <MemberSignature Language="C#" Value="public int MaxTransferWindowSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxTransferWindowSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxTransferWindowSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxTransferWindowSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxTransferWindowSize : int with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece o el número máximo de mensajes que pueden existir en el búfer de envío o en el búfer de recepción.</summary>
        <value>Número máximo de mensajes que pueden estar almacenados en búfer. El valor mínimo es 1; el valor máximo es 4096; y el valor predeterminado es 32.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de la propiedad <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize%2A> se puede establecer en el remitente y el receptor. Este valor se incluye en la directiva de enlace de WSDL, por lo que si usas el [ServiceModel Metadata Utility Tool (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) para construir su cliente, tiene el mismo valor. De lo contrario, este valor es el que establezca en el cliente.  
  
 Cuando este límite se alcanza en el remitente, se impide que se envíen llamadas adicionales. Cuando este límite se alcanza en el receptor, no se aceptan los mensajes nuevos que llegan en el canal subyacente.  
  
 Una sesión confiable utiliza un protocolo basado en ventanas para ayudar a mejorar la utilización de la red. La cantidad de almacenamiento en búfer necesario se deduce directamente del tamaño de la ventana de transmisión. Al ajustar este valor, observe que la ventana de transmisión óptima está relacionada con el ancho de banda y la latencia de una manera directa. El tamaño máximo ideal de la ventana es el ancho banda multiplicado por la latencia. Cualquier valor menor supone una utilización de la red menor del 100%; cualquier valor mayor es sólo espacio desaprovechado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor se establece en una cifra menor o igual que uno o mayor que 4096.</exception>
      </Docs>
    </Member>
    <Member MemberName="Ordered">
      <MemberSignature Language="C#" Value="public bool Ordered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Ordered" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.Ordered" />
      <MemberSignature Language="VB.NET" Value="Public Property Ordered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Ordered { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Ordered : bool with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.Ordered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la entrega del mensaje debe conservar el orden en el que se envían los mensajes.</summary>
        <value>
          <see langword="true" /> si los mensajes se deben entregar en el orden en el que se envían; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener los mensajes enviados en orden, debe establecer también <xref:System.ServiceModel.ConcurrencyMode> en <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReliableMessagingVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ReliableMessagingVersion ReliableMessagingVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.ReliableMessagingVersion ReliableMessagingVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.ReliableMessagingVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ReliableMessagingVersion As ReliableMessagingVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ReliableMessagingVersion ^ ReliableMessagingVersion { System::ServiceModel::ReliableMessagingVersion ^ get(); void set(System::ServiceModel::ReliableMessagingVersion ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReliableMessagingVersion : System.ServiceModel.ReliableMessagingVersion with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.ReliableMessagingVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.ServiceModel.ReliableMessagingVersion), "WSReliableMessagingFebruary2005")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ReliableMessagingVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la versión de WS-ReliableMessaging especificada por el elemento de enlace.</summary>
        <value>Una instancia derivada de <see cref="T:System.ServiceModel.ReliableMessagingVersion" /> que representa la versión del protocolo WS-ReliableMessaging utilizada por el elemento de configuración.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actualmente hay dos versiones del protocolo WS-ReliableMessaging admitidos por Windows Communication Foundation (WCF): WS-ReliableMessaging1.1 y WS-ReliableMessagingFebruary2005. La versión predeterminada es WS-ReliableMessagingFebruary2005.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy">
      <MemberSignature Language="C#" Value="void IPolicyExportExtension.ExportPolicy (System.ServiceModel.Description.MetadataExporter exporter, System.ServiceModel.Description.PolicyConversionContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(class System.ServiceModel.Description.MetadataExporter exporter, class System.ServiceModel.Description.PolicyConversionContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.System#ServiceModel#Description#IPolicyExportExtension#ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)" />
      <MemberSignature Language="VB.NET" Value="Sub ExportPolicy (exporter As MetadataExporter, context As PolicyConversionContext) Implements IPolicyExportExtension.ExportPolicy" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System::ServiceModel::Description::MetadataExporter ^ exporter, System::ServiceModel::Description::PolicyConversionContext ^ context) = System::ServiceModel::Description::IPolicyExportExtension::ExportPolicy;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.MetadataExporter" />
        <Parameter Name="context" Type="System.ServiceModel.Description.PolicyConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter">
          <see cref="T:System.ServiceModel.Description.MetadataExporter" /> que exporta la información de enlace en el elemento de enlace de la sesión confiable a los elementos de WSDL.</param>
        <param name="context">
          <see cref="T:System.ServiceModel.Description.PolicyConversionContext" /> que proporciona la asignación de elementos de WSDL exportados a la descripción del extremo.</param>
        <summary>Asigna la información contenida en el elemento de enlace de la sesión confiable en los elementos de WSDL que permiten a un punto de conexión remoto tener acceso al servicio con una sesión confiable.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>