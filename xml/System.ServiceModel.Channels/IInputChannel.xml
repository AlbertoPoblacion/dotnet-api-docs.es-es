<Type Name="IInputChannel" FullName="System.ServiceModel.Channels.IInputChannel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ae2783ef0e1dc2a8edab76bbc1b170bd2b36497e" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39978811" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IInputChannel : System.ServiceModel.Channels.IChannel" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IInputChannel implements class System.ServiceModel.Channels.IChannel, class System.ServiceModel.ICommunicationObject" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.IInputChannel" />
  <TypeSignature Language="VB.NET" Value="Public Interface IInputChannel&#xA;Implements IChannel" />
  <TypeSignature Language="C++ CLI" Value="public interface class IInputChannel : System::ServiceModel::Channels::IChannel" />
  <TypeSignature Language="F#" Value="type IInputChannel = interface&#xA;    interface IChannel&#xA;    interface ICommunicationObject" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Define la interfaz que un canal debe implementar para recibir un mensaje.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El contrato <xref:System.ServiceModel.Channels.IInputChannel> incluye variantes sincrónicas y asincrónicas de la funcionalidad de recepción, de intento de recepción y de espera por un mensaje.  
  
 El modelo de extracción se utiliza normalmente con <xref:System.ServiceModel.Channels.IInputChannel> para recibir los mensajes: llama a <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> (para "extraer" un mensaje del canal) y, a continuación, espera a que llegue un mensaje. Un modelo del uso alternativo es llamar a <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> o a <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>y, a continuación, llamar a <xref:System.ServiceModel.Channels.IInputChannel.Receive%28System.TimeSpan%29>. Este enfoque es común para los usos transaccionales donde se inicia la transacción entre las llamadas a <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> y a <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>.  
  
 Un <xref:System.ServiceModel.Channels.IInputChannel> no está necesariamente enlazado a un remitente único. Otros canales e interfaces de canal pueden proporcionar una correlación entre los remitentes determinados y <xref:System.ServiceModel.Channels.IInputChannel>, pero el contrato base no hace ninguna restricción así. Una implementación puede crear un <xref:System.ServiceModel.Channels.IInputChannel> nuevo para cada mensaje o reutilizar el mismo <xref:System.ServiceModel.Channels.IInputChannel> para varios mensajes y remitentes.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza una operación de recepción asincrónica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si desea que la aplicación siga realizando sus procesos sin esperar a recibir la solicitud, hay que utilizar el método asincrónico <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>. Utilice el método <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> sincrónico cuando sea aceptable bloquear el subproceso actual hasta que se reciba el mensaje de solicitud o se haya superado el intervalo de tiempo especificado por `timeout`. La operación asincrónica está disponible con o sin un tiempo de espera explícito.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceive(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginReceive(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReceive : AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginReceive (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">El delegado <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación asincrónica.</param>
        <param name="state">Objeto, especificado por la aplicación, que contiene información de estado asociada a la operación asincrónica.</param>
        <summary>Comienza una operación asincrónica para recibir un mensaje que tiene un objeto de estados asociado a él.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la recepción asincrónica de un mensaje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si desea que la aplicación siga realizando sus procesos sin esperar a recibir la solicitud, hay que utilizar el método asincrónico <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>. Utilice el método <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> sincrónico cuando sea aceptable bloquear el subproceso actual hasta que se reciba el mensaje de solicitud o se haya superado el intervalo de tiempo especificado por `timeout`. La operación asincrónica está disponible con o sin un tiempo de espera explícito.  
  
 Este método recibe una notificación, mediante una devolución de llamada, de la identidad del controlador de eventos de la operación. La operación no se completa hasta que haya un mensaje disponible en el canal.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#15](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginReceive(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReceive : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginReceive (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que especifica el intervalo de tiempo que hay que esperar a que haya un mensaje disponible.</param>
        <param name="callback">El delegado <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación asincrónica.</param>
        <param name="state">Objeto, especificado por la aplicación, que contiene información de estado asociada a la operación asincrónica.</param>
        <summary>Comienza una operación asincrónica para recibir un mensaje que tiene un tiempo de espera especificado y un objeto de estados asociados a él.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la operación de recepción asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si desea que la aplicación siga realizando sus procesos sin esperar a recibir la solicitud, hay que utilizar el método asincrónico <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>. Utilice el método <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> sincrónico cuando sea aceptable bloquear el subproceso actual hasta que se reciba el mensaje de solicitud o se haya superado el intervalo de tiempo especificado por `timeout`. La operación asincrónica está disponible con o sin un tiempo de espera explícito.  
  
 La operación no se completa hasta que haya un mensaje disponible en el canal o se agote el tiempo de espera.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#16](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Se supera el <paramref name="timeout" /> especificado antes de que se complete la operación.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El tiempo de espera especificado es menor que cero.</exception>
        <block subset="none" type="overrides">
          <para>La operación produce un <see cref="T:System.TimeoutException" /> si especificado <paramref name="timeout" /> se supera antes de que finalice.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginTryReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTryReceive (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginTryReceive(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTryReceive (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTryReceive(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginTryReceive : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginTryReceive (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que especifica el intervalo de tiempo que hay que esperar a que haya un mensaje disponible.</param>
        <param name="callback">El delegado <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación asincrónica.</param>
        <param name="state">Objeto, especificado por la aplicación, que contiene información de estado asociada a la operación asincrónica.</param>
        <summary>Comienza una operación asincrónica para recibir un mensaje que tiene un tiempo de espera especificado y un objeto de estados asociados a él.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la operación de recepción asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si desea que la aplicación siga realizando sus procesos sin esperar, hay que utilizar el método asincrónico <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>. Utilice el método <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> sincrónico cuando sea aceptable bloquear el subproceso actual mientras este responde al mensaje de solicitud o hasta que se supere el intervalo del tiempo de espera.  
  
 La operación no se completa hasta que haya un mensaje disponible en el canal o se agote el tiempo de espera.  
  
 Si va a administrar los tiempos de espera y no sólo reiniciar o encapsular <xref:System.TimeoutException>, debería llamar a <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> en lugar de <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>.  
  
 Si no va a tratar especialmente los tiempos de espera, llame a <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>, de lo contrario perderá información de error.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#19](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Se supera el <paramref name="timeout" /> especificado antes de que se complete la operación.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El tiempo de espera especificado es menor que cero.</exception>
        <block subset="none" type="overrides">
          <para>La operación devuelve <see langword="false" /> desde <see cref="M:System.ServiceModel.Channels.IInputChannel.EndTryReceive(System.IAsyncResult,System.ServiceModel.Channels.Message@)" /> si especificado <paramref name="timeout" /> se supera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginWaitForMessage">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWaitForMessage (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWaitForMessage(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWaitForMessage (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWaitForMessage(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWaitForMessage : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginWaitForMessage (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que especifica el intervalo de tiempo que hay que esperar a que haya un mensaje disponible.</param>
        <param name="callback">El delegado <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación asincrónica.</param>
        <param name="state">Objeto, especificado por la aplicación, que contiene información de estado asociada a la operación asincrónica.</param>
        <summary>Comienza una operación asincrónica para esperar a que llegue un mensaje que tiene un tiempo de espera especificado y un objeto de estados asociados a él.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la operación asincrónica de espera a que llegue un mensaje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si es necesario que la aplicación siga realizando sus procesos sin esperar a que llegue el mensaje, hay que utilizar el método asincrónico <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>. Utilice el método sincrónico <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> cuando sea aceptable bloquear el subproceso actual mientras espera a que llegue un mensaje de solicitud a la cola. El subproceso está bloqueado hasta el `timeout`especificado.  
  
 Este método recibe una notificación, mediante una devolución de llamada, de la identidad del controlador de eventos de la operación. La operación no se completa hasta que haya un mensaje disponible en el canal o se agote el tiempo de espera.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#22](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Se supera el <paramref name="timeout" /> especificado antes de que se complete la operación.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El tiempo de espera especificado es menor que cero.</exception>
        <block subset="none" type="overrides">
          <para>La operación devuelve <see langword="false" /> si especificado <paramref name="timeout" /> se supera, no una excepción de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message EndReceive (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message EndReceive(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ EndReceive(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReceive : IAsyncResult -&gt; System.ServiceModel.Channels.Message" Usage="iInputChannel.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> devuelto por una llamada a uno de los métodos <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" />.</param>
        <summary>Completa una operación asincrónica para recibir un mensaje.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.Message" /> recibido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#17](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndTryReceive">
      <MemberSignature Language="C#" Value="public bool EndTryReceive (IAsyncResult result, out System.ServiceModel.Channels.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndTryReceive(class System.IAsyncResult result, [out] class System.ServiceModel.Channels.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.EndTryReceive(System.IAsyncResult,System.ServiceModel.Channels.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndTryReceive (result As IAsyncResult, ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndTryReceive(IAsyncResult ^ result, [Runtime::InteropServices::Out] System::ServiceModel::Channels::Message ^ % message);" />
      <MemberSignature Language="F#" Value="abstract member EndTryReceive : IAsyncResult *  -&gt; bool" Usage="iInputChannel.EndTryReceive (result, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">El <see cref="T:System.IAsyncResult" /> devuelto por una llamada al método <see cref="M:System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)" />.</param>
        <param name="message">
          <see cref="T:System.ServiceModel.Channels.Message" /> recibido.</param>
        <summary>Completa la operación asincrónica especificada para recibir un mensaje.</summary>
        <returns>
          <see langword="true" /> si se recibe un mensaje antes de que transcurra un intervalo de tiempo especificado; de lo contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#20](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWaitForMessage">
      <MemberSignature Language="C#" Value="public bool EndWaitForMessage (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndWaitForMessage(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.EndWaitForMessage(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWaitForMessage (result As IAsyncResult) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndWaitForMessage(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWaitForMessage : IAsyncResult -&gt; bool" Usage="iInputChannel.EndWaitForMessage result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">El <see cref="T:System.IAsyncResult" /> que identifica la operación <see cref="M:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)" /> que va a terminar y de la que se va a recuperar un resultado final.</param>
        <summary>Completa la operación asincrónica especificada de espera por un mensaje.</summary>
        <returns>
          <see langword="true" /> si llega un mensaje antes de que se haya superado <paramref name="timeout" />; de lo contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#23](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalAddress">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EndpointAddress LocalAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EndpointAddress LocalAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.IInputChannel.LocalAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalAddress As EndpointAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EndpointAddress ^ LocalAddress { System::ServiceModel::EndpointAddress ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalAddress : System.ServiceModel.EndpointAddress" Usage="System.ServiceModel.Channels.IInputChannel.LocalAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EndpointAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la dirección en la que este canal de entrada recibe los mensajes.</summary>
        <value>
          <see cref="T:System.ServiceModel.EndpointAddress" /> en el que el canal de entrada recibe los mensajes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este canal de entrada no tiene una dirección independiente (por ejemplo, es el lado de entrada de un canal TCP iniciado por cliente), esta propiedad es `null`.  
  
 Canales del nivel más alto pueden utilizar esta propiedad a efectos de la correlación. Por ejemplo, si un canal de nivel más alto implementa la solicitud-respuesta sobre <xref:System.ServiceModel.Channels.IDuplexChannel>, puede utilizar la propiedad <xref:System.ServiceModel.Channels.IInputChannel.LocalAddress%2A> en el encabezado de WS-Addressing ReplyTo.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar esta propiedad:  
  
 [!code-csharp[S_UE_MessageInterceptor#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.ServiceProcess.TimeoutException">La operación no se completó en el intervalo de tiempo de espera.</exception>
        <exception cref="T:System.ServiceModel.CommunicationException">Se ha producido un error en el canal de entrada.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectAbortedException">Se ha anulado el canal de entrada.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Se ha generado un error en el canal de entrada.</exception>
        <summary>Devuelve un mensaje recibido por el canal de entrada si está disponible con un intervalo de tiempo definido de forma explícita o implícita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice el método <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> sincrónico cuando sea aceptable bloquear el subproceso actual hasta que reciba el mensaje de solicitud o supere el intervalo de tiempo especificado por `timeout`. Si es necesario que la aplicación siga realizando sus procesos sin esperar a recibir la solicitud, hay que utilizar el método asincrónico <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>.  
  
 La operación <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> sincrónica está disponible con o sin un tiempo de espera explícito.  
  
 Si no hay un mensaje disponible, se bloquea hasta que uno esté disponible o hasta que se supere el tiempo de espera.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="abstract member Receive : unit -&gt; System.ServiceModel.Channels.Message" Usage="iInputChannel.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el mensaje recibido si está disponible. Si no hay un mensaje disponible, se bloquea durante un intervalo de tiempo predeterminado.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.Message" /> recibido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice el método <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> sincrónico cuando sea aceptable bloquear el subproceso actual hasta que reciba el mensaje de solicitud o supere el intervalo de tiempo especificado por `timeout`. Si desea que la aplicación siga realizando sus procesos sin esperar a recibir la solicitud, hay que utilizar el método asincrónico <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>.  
  
 La operación <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> sincrónica está disponible con o sin un tiempo de espera explícito.  
  
 Si no hay un mensaje disponible, se bloquea hasta que uno esté disponible o hasta que se supere el tiempo de espera.  
  
 Se puede llamar <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> varias veces o simultáneamente. Sólo se puede completar una llamada <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> por cada mensaje recibido.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member Receive : TimeSpan -&gt; System.ServiceModel.Channels.Message" Usage="iInputChannel.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que especifica cuánto tiempo tiene una operación de recepción antes de expirar e iniciar <see cref="T:System.TimeoutException" />.</param>
        <summary>Devuelve el mensaje recibido si está disponible. Si no hay un mensaje disponible, se bloquea durante un intervalo de tiempo especificado.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.Message" /> recibido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice el método <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> sincrónico cuando sea aceptable bloquear el subproceso actual hasta que reciba el mensaje de solicitud o supere el intervalo de tiempo especificado por `timeout`. Si desea que la aplicación siga realizando sus procesos sin esperar a recibir la solicitud, hay que utilizar el método asincrónico <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>.  
  
 La operación <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> sincrónica está disponible con o sin un tiempo de espera explícito.  
  
 Si no hay un mensaje disponible, se bloquea hasta que uno esté disponible o hasta que se supere el tiempo de espera.  
  
 Se puede llamar <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> varias veces o simultáneamente. Sólo se puede completar una llamada <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> por cada mensaje recibido.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#14](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Se supera el <paramref name="timeout" /> especificado antes de que se complete la operación.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El tiempo de espera especificado es menor que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReceive">
      <MemberSignature Language="C#" Value="public bool TryReceive (TimeSpan timeout, out System.ServiceModel.Channels.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceive(valuetype System.TimeSpan timeout, [out] class System.ServiceModel.Channels.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.TryReceive(System.TimeSpan,System.ServiceModel.Channels.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceive (timeout As TimeSpan, ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReceive(TimeSpan timeout, [Runtime::InteropServices::Out] System::ServiceModel::Channels::Message ^ % message);" />
      <MemberSignature Language="F#" Value="abstract member TryReceive : TimeSpan *  -&gt; bool" Usage="iInputChannel.TryReceive (timeout, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" RefType="out" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.IAsyncResult" /> devuelto por una llamada a uno de los métodos <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" />.</param>
        <param name="message">
          <see cref="T:System.ServiceModel.Channels.Message" /> recibido.</param>
        <summary>Intenta recibir un mensaje dentro de un intervalo de tiempo especificado.</summary>
        <returns>
          <see langword="true" /> si se recibe un mensaje antes de que se haya superado <paramref name="timeout" />; de lo contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si va a administrar los tiempos de espera y no sólo reiniciar o encapsular <xref:System.TimeoutException>, debería llamar a <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> en lugar de <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>.  
  
 Si no va a tratar especialmente los tiempos de espera, llame a <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>, de lo contrario perderá información de error.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#18](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Se supera el <paramref name="timeout" /> especificado antes de que se complete la operación.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El tiempo de espera especificado es menor que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitForMessage">
      <MemberSignature Language="C#" Value="public bool WaitForMessage (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitForMessage(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.WaitForMessage(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForMessage (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForMessage(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitForMessage : TimeSpan -&gt; bool" Usage="iInputChannel.WaitForMessage timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> especifica el intervalo de tiempo máximo para esperar a que llegue un mensaje antes de expirar.</param>
        <summary>Devuelve un valor que indica si un mensaje ha llegado dentro de un intervalo especificado de hora.</summary>
        <returns>
          <see langword="true" /> si llega un mensaje antes de que se haya superado <paramref name="timeout" />; de lo contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> no resulta en un mensaje recibido o procesado de otra forma.  
  
 El método <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> existe principalmente para los escenarios con transacción donde donde el usuario desea recibir el mensaje mediante una transacción. Al utilizar normalmente sólo <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> para esto, el usuario debe crear la transacción y, a continuación, llamar a <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> y esperar que el mensaje llegue antes de que expire la transacción, lo que puede no ser posible.  
  
 Si no, el usuario puede llamar a <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> y especificar el tiempo de espera deseado (incluso infinito); a continuación, cuando llega un mensaje, puede abrir la transacción, llamar a <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> y estar seguro que pueden recibir el mensaje antes de que la transacción expire.  
  
 Este método es sincrónico, por lo que se bloquea el subproceso actual hasta que haya un mensaje disponible o hasta que finalice el tiempo de espera especificado. Utilice <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> cuando se acepte bloquear el subproceso actual mientras se espera a que llegue un mensaje a la cola. El subproceso está bloqueado hasta el `timeout`especificado. Si es necesario que la aplicación siga realizando sus procesos sin esperar, hay que utilizar el método asincrónico <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar este método:  
  
 [!code-csharp[S_UE_MessageInterceptor#21](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Se supera el <paramref name="timeout" /> especificado antes de que se complete la operación.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El tiempo de espera especificado es menor que cero.</exception>
        <block subset="none" type="overrides">
          <para>La operación devuelve <see langword="false" /> si especificado <paramref name="timeout" /> se supera, no una excepción de tiempo de espera.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>