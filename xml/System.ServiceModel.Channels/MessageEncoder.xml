<Type Name="MessageEncoder" FullName="System.ServiceModel.Channels.MessageEncoder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1faab4ec52f91ba9eb6ca4279bb45cf733ac71a9" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57951284" /></Metadata><TypeSignature Language="C#" Value="public abstract class MessageEncoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MessageEncoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.MessageEncoder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MessageEncoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEncoder abstract" />
  <TypeSignature Language="F#" Value="type MessageEncoder = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.5.0.1</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>El codificador es el componente que se utiliza para escribir los mensajes en una secuencia y leerlos de una secuencia.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.MessageEncoder> es una clase base que proporciona implementaciones que admiten un tipo de contenido MIME y una versión del mensaje, y define la interfaz para la serialización y deserialización de los mensajes según ese tipo de contenido. Utilícelo como clase base para escribir su propio codificador personalizado.  
  
 Utilice esta clase si desea implementar un codificador del mensaje personalizado. Para implementar su propio codificador de mensajes personalizado, debe proporcionar implementaciones personalizadas de las siguientes tres clases base abstractas:  
  
-   <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>  
  
-   <xref:System.ServiceModel.Channels.MessageEncoderFactory>  
  
-   <xref:System.ServiceModel.Channels.MessageEncoder>  
  
 Invalide <xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A> para devolver una instancia de su <xref:System.ServiceModel.Channels.MessageEncoder> personalizado. A continuación, conecte su <xref:System.ServiceModel.Channels.MessageEncoderFactory> personalizado a la pila del elemento de enlace que se usa para configurar el servicio o el cliente invalidando el método <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A> para devolver una instancia de este generador.  
  
 La tarea de convertir entre la representación en memoria de un mensaje y una representación de un conjunto de información XML (Infoset) que se puede escribir en una secuencia se encapsula dentro de la clase <xref:System.ServiceModel.Channels.MessageEncoder>, que normalmente actúa como un generador para los lectores XML y los escritores XML que admiten tipos específicos de codificaciones de XML.  
  
 Los métodos clave de <xref:System.ServiceModel.Channels.MessageEncoder> son <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> y <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A>. <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> toma un objeto <xref:System.ServiceModel.Channels.Message> y lo escribe en un objeto <xref:System.IO.Stream>. <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> toma un objeto <xref:System.IO.Stream> y un tamaño de encabezado máximo, y devuelve un objeto <xref:System.ServiceModel.Channels.Message>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra un ejemplo de una clase derivada de <xref:System.ServiceModel.Channels.MessageEncoder>.  
  
 [!code-csharp[S_UE_CustomTextMessageEncoder#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MessageEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MessageEncoder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ServiceModel.Channels.MessageEncoder" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteMessage">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginWriteMessage (System.ServiceModel.Channels.Message message, System.IO.Stream stream, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteMessage(class System.ServiceModel.Channels.Message message, class System.IO.Stream stream, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.BeginWriteMessage(System.ServiceModel.Channels.Message,System.IO.Stream,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteMessage(System::ServiceModel::Channels::Message ^ message, System::IO::Stream ^ stream, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteMessage : System.ServiceModel.Channels.Message * System.IO.Stream * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteMessage : System.ServiceModel.Channels.Message * System.IO.Stream * AsyncCallback * obj -&gt; IAsyncResult" Usage="messageEncoder.BeginWriteMessage (message, stream, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="stream" Type="System.IO.Stream" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="message">Mensaje.</param>
        <param name="stream">La secuencia.</param>
        <param name="callback">La devolución de llamada.</param>
        <param name="state">El estado.</param>
        <summary>Inicia la escritura de mensajes para el codificador de mensajes con el mensaje, la secuencia, la devolución de llamada y el estado especificados.</summary>
        <returns>Resultado asincrónico de la operación.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public abstract string ContentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MessageEncoder.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ ContentType { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string" Usage="System.ServiceModel.Channels.MessageEncoder.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el tipo de contenido de MIME que usa el codificador.</summary>
        <value>Tipo de contenido que admite el codificador del mensaje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo de contenido es un encabezado MIME que aparece al principio de un mensaje MIME así como dentro de las partes del cuerpo independientes. Los encabezados de tipo de contenido se usan para especificar el tipo de medio y el subtipo de datos, así como para especificar la codificación de caracteres (opcional) de los datos. Un ejemplo de MIME de contenido de tipo admitido: "application/SOAP+XML; CharSet = 'utf8' ".  
  
 Se describe una gramática que detalla la sintaxis del encabezado content-type en [RFC 2045](https://go.microsoft.com/fwlink/?LinkId=95945), sección 5.1. [RFC 2046](https://go.microsoft.com/fwlink/?LinkId=95944) proporciona información detallada sobre los tipos de medios MIME y sus parámetros.  
  
   
  
## Examples  
 [!code-csharp[S_UE_CustomTextMessageEncoder#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWriteMessage">
      <MemberSignature Language="C#" Value="public virtual void EndWriteMessage (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWriteMessage(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.EndWriteMessage(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWriteMessage (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWriteMessage(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteMessage : IAsyncResult -&gt; unit&#xA;override this.EndWriteMessage : IAsyncResult -&gt; unit" Usage="messageEncoder.EndWriteMessage result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="result">Resultado de la operación.</param>
        <summary>Finaliza la escritura de los mensajes para el codificador de mensajes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public virtual T GetProperty&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !!T GetProperty&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.GetProperty``1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetProperty(Of T As Class) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class virtual T GetProperty();" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : unit -&gt; 'T (requires 'T : null)&#xA;override this.GetProperty : unit -&gt; 'T (requires 'T : null)" Usage="messageEncoder.GetProperty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">El objeto con tipo que está consultando el método.</typeparam>
        <summary>Devuelve un objeto escrito solicitado de la capa adecuada en la pila del canal si está presente.</summary>
        <returns>El objeto escrito solicitado <paramref name="T" />, si está presente, o <see langword="null" /> si no lo está.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esto para solicitar un objeto escrito como una interfaz para establecer propiedades o recibir el estado de la capa adecuada en la pila del canal. Si una capa permite devolver el objeto solicitado, lo devuelve. Si no, delega la llamada bajando a la capa siguiente de la pila. Si se llega a la parte inferior de la pila y ninguna capa del canal permite el objeto solicitado, a continuación, el método devuelve `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContentTypeSupported">
      <MemberSignature Language="C#" Value="public virtual bool IsContentTypeSupported (string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsContentTypeSupported(string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.IsContentTypeSupported(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsContentTypeSupported (contentType As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsContentTypeSupported(System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="abstract member IsContentTypeSupported : string -&gt; bool&#xA;override this.IsContentTypeSupported : string -&gt; bool" Usage="messageEncoder.IsContentTypeSupported contentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="contentType">El tipo de contenido del nivel de mensaje que se está probando.</param>
        <summary>Devuelve un valor que indica si el codificador del mensaje admite el valor especificado para el tipo de contenido de nivel de mensaje.</summary>
        <returns><see langword="true" /> si se admite el tipo de contenido especificado del nivel de mensaje; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza para determinar si el codificador del mensaje se puede utilizar para leer un estilo determinado de mensaje, basado en su tipo de contenido. La información de la clase <xref:System.Net.Mime.ContentType> se utiliza para describir los datos que contiene un mensaje y para determinar si hay una coincidencia del tipo de contenido.  
  
 Se describe una gramática que detalla la sintaxis del encabezado content-type en [RFC 2045](https://go.microsoft.com/fwlink/?LinkId=95945) sección 5.1. [RFC 2046](https://go.microsoft.com/fwlink/?LinkId=95944) proporciona información detallada sobre los tipos de medios de extensiones multipropósito de correo Internet (MIME) y sus parámetros.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo invalidar este método para administrar los tipos de contenido diferentes con el mismo tipo de medio.  
  
 [!code-csharp[S_UE_CustomTextMessageEncoder#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#8)]
 [!code-csharp[S_UE_CustomTextMessageEncoder#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoderfactory.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public abstract string MediaType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MessageEncoder.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ MediaType { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string" Usage="System.ServiceModel.Channels.MessageEncoder.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el valor del tipo de medio que usa el codificador.</summary>
        <value>Tipo de medio que admite el codificador del mensaje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo de medio forma parte del encabezado de tipo de contenido.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar la propiedad `MediaType`:  
  
 [!code-csharp[S_UE_CustomTextMessageEncoder#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageVersion">
      <MemberSignature Language="C#" Value="public abstract System.ServiceModel.Channels.MessageVersion MessageVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.MessageVersion MessageVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MessageEncoder.MessageVersion" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MessageVersion As MessageVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::ServiceModel::Channels::MessageVersion ^ MessageVersion { System::ServiceModel::Channels::MessageVersion ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageVersion : System.ServiceModel.Channels.MessageVersion" Usage="System.ServiceModel.Channels.MessageEncoder.MessageVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.MessageVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el valor de la versión de los mensajes que utiliza el codificador.</summary>
        <value><see cref="T:System.ServiceModel.Channels.MessageVersion" /> que utiliza el codificador.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especifica las versiones de SOAP y WS-Addressing asociadas a un mensaje y a su intercambio. Si no se van a utilizar versiones SOAP, esta propiedad se debería invalidar para devolver <xref:System.ServiceModel.Channels.MessageVersion.None%2A>.  
  
   
  
## Examples  
 El código siguiente muestra cómo implementar la propiedad <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>:  
  
 [!code-csharp[S_UE_CustomTextMessageEncoder#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadMessage">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, lee un mensaje de la secuencia especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadMessage">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message ReadMessage (ArraySegment&lt;byte&gt; buffer, System.ServiceModel.Channels.BufferManager bufferManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Channels.Message ReadMessage(valuetype System.ArraySegment`1&lt;unsigned int8&gt; buffer, class System.ServiceModel.Channels.BufferManager bufferManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.ReadMessage(System.ArraySegment{System.Byte},System.ServiceModel.Channels.BufferManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ ReadMessage(ArraySegment&lt;System::Byte&gt; buffer, System::ServiceModel::Channels::BufferManager ^ bufferManager);" />
      <MemberSignature Language="F#" Value="member this.ReadMessage : ArraySegment&lt;byte&gt; * System.ServiceModel.Channels.BufferManager -&gt; System.ServiceModel.Channels.Message" Usage="messageEncoder.ReadMessage (buffer, bufferManager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="bufferManager" Type="System.ServiceModel.Channels.BufferManager" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.ArraySegment`1" /> de tipo <see cref="T:System.Byte" /> que proporciona el búfer desde donde se deserializa el mensaje.</param>
        <param name="bufferManager"><see cref="T:System.ServiceModel.Channels.BufferManager" /> que administra el búfer desde donde se deserializa el mensaje.</param>
        <summary>Cuando se invalida en una clase derivada, lee un mensaje del búfer especificado.</summary>
        <returns><see cref="T:System.ServiceModel.Channels.Message" /> que se lee del búfer especificado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadMessage">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message ReadMessage (System.IO.Stream stream, int maxSizeOfHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Channels.Message ReadMessage(class System.IO.Stream stream, int32 maxSizeOfHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.ReadMessage(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ ReadMessage(System::IO::Stream ^ stream, int maxSizeOfHeaders);" />
      <MemberSignature Language="F#" Value="member this.ReadMessage : System.IO.Stream * int -&gt; System.ServiceModel.Channels.Message" Usage="messageEncoder.ReadMessage (stream, maxSizeOfHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="maxSizeOfHeaders" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">Objeto <see cref="T:System.IO.Stream" /> desde el que se lee el mensaje.</param>
        <param name="maxSizeOfHeaders">Tamaño máximo de los encabezados que se pueden leer del mensaje.</param>
        <summary>Cuando se invalida en una clase derivada, lee un mensaje de la secuencia especificada.</summary>
        <returns><see cref="T:System.ServiceModel.Channels.Message" /> que se lee de la secuencia especificada.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadMessage">
      <MemberSignature Language="C#" Value="public abstract System.ServiceModel.Channels.Message ReadMessage (ArraySegment&lt;byte&gt; buffer, System.ServiceModel.Channels.BufferManager bufferManager, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message ReadMessage(valuetype System.ArraySegment`1&lt;unsigned int8&gt; buffer, class System.ServiceModel.Channels.BufferManager bufferManager, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.ReadMessage(System.ArraySegment{System.Byte},System.ServiceModel.Channels.BufferManager,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::ServiceModel::Channels::Message ^ ReadMessage(ArraySegment&lt;System::Byte&gt; buffer, System::ServiceModel::Channels::BufferManager ^ bufferManager, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="abstract member ReadMessage : ArraySegment&lt;byte&gt; * System.ServiceModel.Channels.BufferManager * string -&gt; System.ServiceModel.Channels.Message" Usage="messageEncoder.ReadMessage (buffer, bufferManager, contentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="bufferManager" Type="System.ServiceModel.Channels.BufferManager" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.ArraySegment`1" /> de tipo <see cref="T:System.Byte" /> que proporciona el búfer desde donde se deserializa el mensaje.</param>
        <param name="bufferManager"><see cref="T:System.ServiceModel.Channels.BufferManager" /> que administra el búfer desde donde se deserializa el mensaje.</param>
        <param name="contentType">Tipo de contenido de nivel de mensaje MIME.</param>
        <summary>Cuando se invalida en una clase derivada, lee un mensaje de la secuencia especificada.</summary>
        <returns><see cref="T:System.ServiceModel.Channels.Message" /> que se lee de la secuencia especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el siguiente ejemplo de código se muestra cómo implementar el método <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%28System.ArraySegment%7BSystem.Byte%7D%2CSystem.ServiceModel.Channels.BufferManager%2CSystem.String%29>.  
  
 [!code-csharp[S_UE_CustomTextMessageEncoder#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadMessage">
      <MemberSignature Language="C#" Value="public abstract System.ServiceModel.Channels.Message ReadMessage (System.IO.Stream stream, int maxSizeOfHeaders, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message ReadMessage(class System.IO.Stream stream, int32 maxSizeOfHeaders, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.ReadMessage(System.IO.Stream,System.Int32,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::ServiceModel::Channels::Message ^ ReadMessage(System::IO::Stream ^ stream, int maxSizeOfHeaders, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="abstract member ReadMessage : System.IO.Stream * int * string -&gt; System.ServiceModel.Channels.Message" Usage="messageEncoder.ReadMessage (stream, maxSizeOfHeaders, contentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="maxSizeOfHeaders" Type="System.Int32" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stream">Objeto <see cref="T:System.IO.Stream" /> desde el que se lee el mensaje.</param>
        <param name="maxSizeOfHeaders">Tamaño máximo de los encabezados que se pueden leer del mensaje.</param>
        <param name="contentType">Tipo de contenido de nivel de mensaje MIME.</param>
        <summary>Cuando se invalida en una clase derivada, lee un mensaje de la secuencia especificada.</summary>
        <returns><see cref="T:System.ServiceModel.Channels.Message" /> que se lee de la secuencia especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el siguiente ejemplo de código se muestra cómo implementar el método <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%28System.IO.Stream%2CSystem.Int32%2CSystem.String%29>.  
  
 [!code-csharp[S_UE_CustomTextMessageEncoder#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="messageEncoder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el tipo de contenido que usa el codificador del mensaje.</summary>
        <returns>Tipo de contenido que usa el codificador del mensaje.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteMessage">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, escribe un mensaje a una secuencia o búfer especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteMessage">
      <MemberSignature Language="C#" Value="public abstract void WriteMessage (System.ServiceModel.Channels.Message message, System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteMessage(class System.ServiceModel.Channels.Message message, class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.WriteMessage(System.ServiceModel.Channels.Message,System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteMessage(System::ServiceModel::Channels::Message ^ message, System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="abstract member WriteMessage : System.ServiceModel.Channels.Message * System.IO.Stream -&gt; unit" Usage="messageEncoder.WriteMessage (message, stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="message"><see cref="T:System.ServiceModel.Channels.Message" /> para escribir en <paramref name="stream" />.</param>
        <param name="stream">Objeto <see cref="T:System.IO.Stream" /> donde se escribe <paramref name="message" />.</param>
        <summary>Cuando se invalida en una clase derivada, escribe un mensaje a una secuencia especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el código siguiente se muestra cómo implementar el método <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%28System.ServiceModel.Channels.Message%2CSystem.IO.Stream%29>.  
  
 [!code-csharp[S_UE_CustomTextMessageEncoder#7](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteMessage">
      <MemberSignature Language="C#" Value="public ArraySegment&lt;byte&gt; WriteMessage (System.ServiceModel.Channels.Message message, int maxMessageSize, System.ServiceModel.Channels.BufferManager bufferManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ArraySegment`1&lt;unsigned int8&gt; WriteMessage(class System.ServiceModel.Channels.Message message, int32 maxMessageSize, class System.ServiceModel.Channels.BufferManager bufferManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.WriteMessage(System.ServiceModel.Channels.Message,System.Int32,System.ServiceModel.Channels.BufferManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArraySegment&lt;System::Byte&gt; WriteMessage(System::ServiceModel::Channels::Message ^ message, int maxMessageSize, System::ServiceModel::Channels::BufferManager ^ bufferManager);" />
      <MemberSignature Language="F#" Value="member this.WriteMessage : System.ServiceModel.Channels.Message * int * System.ServiceModel.Channels.BufferManager -&gt; ArraySegment&lt;byte&gt;" Usage="messageEncoder.WriteMessage (message, maxMessageSize, bufferManager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ArraySegment&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="maxMessageSize" Type="System.Int32" />
        <Parameter Name="bufferManager" Type="System.ServiceModel.Channels.BufferManager" />
      </Parameters>
      <Docs>
        <param name="message"><see cref="T:System.ServiceModel.Channels.Message" /> para escribir en el búfer de mensajes.</param>
        <param name="maxMessageSize">Tamaño máximo de los mensajes que se puede escribir.</param>
        <param name="bufferManager"><see cref="T:System.ServiceModel.Channels.BufferManager" /> que administra el búfer en el que se escribe el mensaje.</param>
        <summary>Escribe un mensaje menor que un tamaño especificado en un búfer de la matriz de bytes.</summary>
        <returns><see cref="T:System.ArraySegment`1" /> de tipo <see langword="byte" /> que proporciona el búfer al que se serializa el mensaje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método llama al método abstracto <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%28System.ServiceModel.Channels.Message%2CSystem.Int32%2CSystem.ServiceModel.Channels.BufferManager%2CSystem.Int32%29> con `messageOffset` = 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteMessage">
      <MemberSignature Language="C#" Value="public abstract ArraySegment&lt;byte&gt; WriteMessage (System.ServiceModel.Channels.Message message, int maxMessageSize, System.ServiceModel.Channels.BufferManager bufferManager, int messageOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.ArraySegment`1&lt;unsigned int8&gt; WriteMessage(class System.ServiceModel.Channels.Message message, int32 maxMessageSize, class System.ServiceModel.Channels.BufferManager bufferManager, int32 messageOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.WriteMessage(System.ServiceModel.Channels.Message,System.Int32,System.ServiceModel.Channels.BufferManager,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract ArraySegment&lt;System::Byte&gt; WriteMessage(System::ServiceModel::Channels::Message ^ message, int maxMessageSize, System::ServiceModel::Channels::BufferManager ^ bufferManager, int messageOffset);" />
      <MemberSignature Language="F#" Value="abstract member WriteMessage : System.ServiceModel.Channels.Message * int * System.ServiceModel.Channels.BufferManager * int -&gt; ArraySegment&lt;byte&gt;" Usage="messageEncoder.WriteMessage (message, maxMessageSize, bufferManager, messageOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ArraySegment&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="maxMessageSize" Type="System.Int32" />
        <Parameter Name="bufferManager" Type="System.ServiceModel.Channels.BufferManager" />
        <Parameter Name="messageOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message"><see cref="T:System.ServiceModel.Channels.Message" /> para escribir en el búfer de mensajes.</param>
        <param name="maxMessageSize">Tamaño máximo de los mensajes que se puede escribir.</param>
        <param name="bufferManager"><see cref="T:System.ServiceModel.Channels.BufferManager" /> que administra el búfer en el que se escribe el mensaje.</param>
        <param name="messageOffset">Posición del segmento que comienza en el inicio de la matriz de bytes que proporciona el búfer.</param>
        <summary>Cuando se invalida en una clase derivada, escribe un mensaje menor de un tamaño especificado en un búfer de una matriz de bytes en la posición especificada.</summary>
        <returns><see cref="T:System.ArraySegment`1" /> de tipo <see langword="byte" /> que proporciona el búfer al que se serializa el mensaje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%28System.ServiceModel.Channels.Message%2CSystem.Int32%2CSystem.ServiceModel.Channels.BufferManager%2CSystem.Int32%29> llama a este método.  
  
   
  
## Examples  
 En el código siguiente se muestra cómo implementar el método <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%28System.ServiceModel.Channels.Message%2CSystem.Int32%2CSystem.ServiceModel.Channels.BufferManager%2CSystem.Int32%29>.  
  
 [!code-csharp[S_UE_CustomTextMessageEncoder#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>