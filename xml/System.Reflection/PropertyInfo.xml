<Type Name="PropertyInfo" FullName="System.Reflection.PropertyInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d4d295c3e203775c62a6da9a20099ea9d809e65d" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53233372" /></Metadata><TypeSignature Language="C#" Value="public abstract class PropertyInfo : System.Reflection.MemberInfo, System.Runtime.InteropServices._PropertyInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit PropertyInfo extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._PropertyInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.PropertyInfo" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PropertyInfo&#xA;Inherits MemberInfo&#xA;Implements _PropertyInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyInfo abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_PropertyInfo" />
  <TypeSignature Language="F#" Value="type PropertyInfo = class&#xA;    inherit MemberInfo&#xA;    interface _PropertyInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._PropertyInfo</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._PropertyInfo))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Detecta los atributos de una propiedad y proporciona acceso a sus metadatos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propiedades lógicamente son los mismos que los campos. Una propiedad es un aspecto con nombre del estado de un objeto cuyo valor es normalmente accesible a través de `get` y `set` descriptores de acceso. Propiedades pueden ser de solo lectura, en cuyo caso no se admite una rutina de conjunto.  
  
> [!NOTE]
>  Para determinar si es una propiedad `static`, debe obtener el <xref:System.Reflection.MethodInfo> para el `get` o `set` descriptor de acceso, mediante una llamada a la <xref:System.Reflection.PropertyInfo.GetGetMethod%2A> o <xref:System.Reflection.PropertyInfo.GetSetMethod%2A> método y examine su <xref:System.Reflection.MethodBase.IsStatic%2A> propiedad.  
  
 Varios métodos de esta clase asume que el `get` descriptor de acceso y `set` métodos de descriptor de acceso de una propiedad tienen un formato determinado. Las firmas de los `get` y `set` métodos deben coincidir con la convención siguiente:  
  
-   El tipo de valor devuelto de la `get` método y el último argumento de la `set` método debe ser idéntico. Este es el tipo de la propiedad.  
  
-   El `get` y `set` métodos deben tener el mismo número, tipo y orden de índices.  
  
 Si no sigue este formato, el comportamiento de la `GetValue` y `SetValue` métodos es indefinido.  
  
 Una llamada a <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A?displayProperty=nameWithType> en `PropertyInfo` cuando el `inherit` parámetro de `GetCustomAttributes` es `true` , no se recorre la jerarquía de tipos. Use <xref:System.Attribute?displayProperty=nameWithType> para heredar los atributos personalizados.  
  
   
  
## Examples  
 En este ejemplo se muestra cómo usar varias clases de reflexión para analizar los metadatos contenidos en un ensamblado.  
  
> [!NOTE]
>  En este ejemplo genera aproximadamente 55.000 líneas de datos, que se pueden redirigir a un archivo de texto en el símbolo del sistema, como sigue: **example.exe > infopropiedad.txt**  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">para plena confianza para los herederos. No se puede heredar esta clase por código de confianza parcial.</permission>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <block subset="none" type="overrides"><para>Al heredar de <see cref="T:System.Reflection.PropertyInfo" />, debe reemplazar los miembros siguientes: <see cref="M:System.Reflection.PropertyInfo.GetValue(System.Object,System.Object[])" />, <see cref="M:System.Reflection.PropertyInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.PropertyInfo.GetAccessors(System.Boolean)" />, <see cref="M:System.Reflection.PropertyInfo.GetGetMethod(System.Boolean)" />, <see cref="M:System.Reflection.PropertyInfo.GetSetMethod(System.Boolean)" />, y <see cref="M:System.Reflection.PropertyInfo.GetIndexParameters" />.</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PropertyInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PropertyInfo();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.PropertyInfo" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.PropertyAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PropertyInfo.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As PropertyAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::PropertyAttributes Attributes { System::Reflection::PropertyAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.PropertyAttributes" Usage="System.Reflection.PropertyInfo.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._PropertyInfo.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los atributos de esta propiedad.</summary>
        <value>Atributos de esta propiedad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.PropertyInfo.Attributes%2A> propiedad devuelve los atributos asociados con la propiedad representada por este <xref:System.Reflection.PropertyInfo> objeto.  Los atributos son principalmente los modificadores que se aplica mediante un compilador al crear una propiedad; indican si una propiedad es la propiedad predeterminada, un `SpecialName` propiedad y así sucesivamente. Tenga en cuenta que, para casi todas las propiedades que se encuentra en tipos en la biblioteca de clases de .NET Framework, el valor de la <xref:System.Reflection.PropertyInfo.Attributes%2A> propiedad es <xref:System.Reflection.PropertyAttributes.None?displayProperty=nameWithType>.  
  
> [!TIP]
>  En la mayoría de los casos, probablemente desee recuperar los atributos personalizados asociados con una propiedad. Para ello, recupere el valor de la <xref:System.Reflection.MemberInfo.CustomAttributes%2A> propiedad o llamada a una de las sobrecargas de los <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método.  
  
 Para obtener el <xref:System.Reflection.PropertyInfo.Attributes%2A> propiedad:  
  
1.  Obtener un <xref:System.Type> objeto que representa el tipo al que pertenece la propiedad.  
  
2.  Obtener el <xref:System.Reflection.PropertyInfo> objeto mediante una llamada a una sobrecarga de la <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> método.  
  
3.  Recuperar los atributos de la propiedad de la <xref:System.Reflection.PropertyInfo.Attributes%2A> propiedad.  
  
 Puede definir los atributos de una propiedad para un tipo creado dinámicamente mediante la reflexión emite mediante una llamada a una sobrecarga de la <xref:System.Reflection.Emit.TypeBuilder.DefineProperty%2A> método y proporciona un valor para el `attributes` argumento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MemberInfo.CustomAttributes" />
        <altmember cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public abstract bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PropertyInfo.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Reflection.PropertyInfo.CanRead" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._PropertyInfo.CanRead</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se puede leer la propiedad.</summary>
        <value>Es <see langword="true" /> si se puede leer esta propiedad; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la propiedad no tiene un `get` descriptor de acceso, no se puede leer.  
  
 Para obtener el `CanRead` propiedad, obtenga primero la clase `Type`. Desde el `Type`, obtener el `PropertyInfo`. Desde el `PropertyInfo`, obtener el `CanRead` valor.  
  
   
  
## Examples  
 El siguiente ejemplo define dos propiedades. La primera propiedad es legible y `CanRead` propiedad es `true`. La segunda propiedad no es legible (no hay ningún descriptor de acceso get) y el `CanRead` propiedad es `false`.  
  
 [!code-cpp[Classic PropertyInfo.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PropertyInfo.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PropertyInfo.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PropertyInfo.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic PropertyInfo.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PropertyInfo.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public abstract bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PropertyInfo.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Reflection.PropertyInfo.CanWrite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._PropertyInfo.CanWrite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se puede escribir en la propiedad.</summary>
        <value>Es <see langword="true" /> si se puede escribir en esta propiedad; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.PropertyInfo.CanWrite%2A> Devuelve `true` si la propiedad tiene un `set` descriptor de acceso, incluso si el descriptor de acceso es `private`, `internal` (o `Friend` en Visual Basic), o `protected`.   Si la propiedad no tiene un `set` descriptor de acceso, el método devuelve `false`.  
  
 Para obtener el valor de la <xref:System.Reflection.PropertyInfo.CanWrite%2A> propiedad:  
  
1.  Obtener el <xref:System.Type> objeto del tipo que incluye la propiedad.  
  
2.  Llame a la <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> para obtener el <xref:System.Reflection.PropertyInfo> objeto que representa la propiedad.  
  
3.  Recuperar el valor de la <xref:System.Reflection.PropertyInfo.CanWrite%2A> propiedad.  
  
   
  
## Examples  
 El siguiente ejemplo define dos propiedades. La primera propiedad es grabable y `CanWrite` propiedad es `true`. La segunda propiedad no es modificable (no hay ningún `set` descriptor de acceso) y el `CanWrite` propiedad es `false`.  
  
 [!code-cpp[Classic PropertyInfo.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PropertyInfo.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PropertyInfo.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PropertyInfo.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic PropertyInfo.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PropertyInfo.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="propertyInfo.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar con esta instancia o <see langword="null" />.</param>
        <summary>Devuelve un valor que indica si esta instancia es igual que un objeto especificado.</summary>
        <returns>Es <see langword="true" /> si <paramref name="obj" /> es igual al tipo y valor de esta instancia; en caso contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessors">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una matriz de los descriptores de acceso <see langword="get" /> y <see langword="set" /> en esta propiedad.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessors">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetAccessors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetAccessors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetAccessors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessors () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetAccessors();" />
      <MemberSignature Language="F#" Value="abstract member GetAccessors : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetAccessors : unit -&gt; System.Reflection.MethodInfo[]" Usage="propertyInfo.GetAccessors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetAccessors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz cuyos elementos reflejan los descriptores de acceso públicos <see langword="get" /> y <see langword="set" /> de la propiedad que refleja la instancia actual.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> que refleja los descriptores de acceso públicos <see langword="get" /> y <see langword="set" /> de la propiedad que refleja la instancia actual, si se encuentran; en caso contrario, este método devuelve una matriz con cero (0) elementos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para llamar a la <xref:System.Reflection.PropertyInfo.GetAccessors%2A> método:  
  
1.  Obtener un <xref:System.Type> objeto que representa la clase.  
  
2.  Desde el <xref:System.Type> de objeto, obtener el <xref:System.Reflection.PropertyInfo> objeto.  
  
3.  Desde el <xref:System.Reflection.PropertyInfo> de objeto, llame a la <xref:System.Reflection.PropertyInfo.GetAccessors%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se recuperan los descriptores de acceso públicos de la `ClassWithProperty.Caption` propiedad y muestra información sobre ellos. También llama a la <xref:System.Reflection.MethodBase.Invoke%2A> método Get para recuperar el valor de propiedad y el establecedor para establecer el valor de propiedad.  
  
 [!code-csharp[System.Reflection.PropertyInfo.GetAccessors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.propertyinfo.getaccessors/cs/source.cs#1)]
 [!code-vb[System.Reflection.PropertyInfo.GetAccessors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.propertyinfo.getaccessors/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetAccessors (bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetAccessors(bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetAccessors(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAccessors (nonPublic As Boolean) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetAccessors(bool nonPublic);" />
      <MemberSignature Language="F#" Value="abstract member GetAccessors : bool -&gt; System.Reflection.MethodInfo[]" Usage="propertyInfo.GetAccessors nonPublic" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetAccessors(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nonPublic">Indica si se deben devolver métodos no públicos en la matriz devuelta. <see langword="true" /> si los métodos no públicos deben incluirse; de lo contrario, <see langword="false" />.</param>
        <summary>Devuelve una matriz cuyos elementos reflejan los descriptores de acceso públicos y, si se especifica, no públicos, <see langword="get" /> y <see langword="set" /> de la propiedad que refleja la instancia actual.</summary>
        <returns>Matriz cuyos elementos reflejan los descriptores de acceso <see langword="get" /> y <see langword="set" /> de la propiedad que refleja la instancia actual. Si <paramref name="nonPublic" /> es <see langword="true" />, esta matriz contiene los descriptores de acceso públicos y no públicos <see langword="get" /> y <see langword="set" />. Si <paramref name="nonPublic" /> es <see langword="false" />, esta matriz contiene solo los descriptores de acceso públicos <see langword="get" /> y <see langword="set" />. Si no se encuentran descriptores de acceso con la visibilidad especificada, este método devuelve una matriz con cero (0) elementos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para llamar a la <xref:System.Reflection.PropertyInfo.GetAccessors%2A> método:  
  
1.  Obtener un <xref:System.Type> objeto que representa la clase.  
  
2.  Desde el <xref:System.Type> de objeto, obtener el <xref:System.Reflection.PropertyInfo> objeto.  
  
3.  Desde el <xref:System.Reflection.PropertyInfo> de objeto, llame a la <xref:System.Reflection.PropertyInfo.GetAccessors%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se recuperan los descriptores de acceso de la `ClassWithProperty.Caption` propiedad y muestra información sobre ellos. También llama a la <xref:System.Reflection.MethodBase.Invoke%2A> método Get para recuperar el valor de propiedad y el establecedor para establecer el valor de propiedad.  
  
 [!code-csharp[Classic PropertyInfo.GetAccessors1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PropertyInfo.GetAccessors1 Example/CS/source.cs#1)]
 [!code-vb[Classic PropertyInfo.GetAccessors1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PropertyInfo.GetAccessors1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetConstantValue">
      <MemberSignature Language="C#" Value="public virtual object GetConstantValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetConstantValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetConstantValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConstantValue () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetConstantValue();" />
      <MemberSignature Language="F#" Value="abstract member GetConstantValue : unit -&gt; obj&#xA;override this.GetConstantValue : unit -&gt; obj" Usage="propertyInfo.GetConstantValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor literal asociado a la propiedad mediante un compilador.</summary>
        <returns><see cref="T:System.Object" /> que contiene el valor literal asociado a la propiedad. Si el valor literal es un tipo de clase con un valor de elemento de cero, el valor devuelto es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para los diseñadores de compiladores administrados y analizadores de código.  
  
> [!NOTE]
>  No utilice este método en el contexto de solo reflexión, puesto que podría provocar la ejecución de código. Use el método <xref:System.Reflection.PropertyInfo.GetRawConstantValue%2A> en su lugar.  
  
 En los metadatos no administrados, la tabla de constantes se utiliza para almacenar valores constantes para los campos, parámetros y propiedades. Constante de información no afecta directamente al comportamiento en tiempo de ejecución. Los compiladores inspeccionan esta información en tiempo de compilación, al importar los metadatos. Si se utiliza, el valor de una constante se incrusta en la secuencia del lenguaje intermedio (MSIL) de Microsoft que el compilador emite. No hay ninguna instrucción MSIL que se puede usar para tener acceso a la tabla de constantes en tiempo de ejecución.  
  
> [!NOTE]
>  Para obtener más información sobre valores constantes y la tabla de constantes, consulte la documentación de ECMA Partition II. La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La tabla de constantes de metadatos no administrados no contiene un valor de constante para la propiedad actual.</exception>
        <exception cref="T:System.FormatException">El tipo del valor no es uno de los tipos permitidos por la Common Language Specification (CLS). Consulte la especificación de ECMA Partition II, metadatos.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGetMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve <see langword="MethodInfo" /> que representa el descriptor de acceso <see langword="get" /> de esta propiedad.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetGetMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetGetMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetGetMethod" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGetMethod () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetGetMethod();" />
      <MemberSignature Language="F#" Value="abstract member GetGetMethod : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetGetMethod : unit -&gt; System.Reflection.MethodInfo" Usage="propertyInfo.GetGetMethod " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetGetMethod</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el descriptor de acceso <see langword="get" /> público de esta propiedad.</summary>
        <returns>Objeto <see langword="MethodInfo" /> que representa el descriptor de acceso <see langword="get" /> público de esta propiedad, o <see langword="null" /> si el descriptor de acceso <see langword="get" /> no es público o no existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de un método de conveniencia que proporciona una implementación abstracta `GetGetMethod` método con el `nonPublic` parámetro establecido en `false`.  
  
 Para usar el `GetGetMethod` método, obtenga primero la clase `Type`. Desde el `Type`, obtener el <xref:System.Reflection.PropertyInfo>. Desde el <xref:System.Reflection.PropertyInfo>, utilice el `GetGetMethod` método.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetGetMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo GetGetMethod (bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetGetMethod(bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetGetMethod(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetGetMethod (nonPublic As Boolean) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodInfo ^ GetGetMethod(bool nonPublic);" />
      <MemberSignature Language="F#" Value="abstract member GetGetMethod : bool -&gt; System.Reflection.MethodInfo" Usage="propertyInfo.GetGetMethod nonPublic" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetGetMethod(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nonPublic">Indica si un descriptor de acceso no público <see langword="get" /> se debe devolver. <see langword="true" /> si se debe devolver un descriptor de acceso no público; de lo contrario, <see langword="false" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, devuelve el descriptor de acceso <see langword="get" /> público o no público de esta propiedad.</summary>
        <returns>Objeto <see langword="MethodInfo" /> que representa el descriptor de acceso <see langword="get" /> de esta propiedad si <paramref name="nonPublic" /> es <see langword="true" />. Devuelve <see langword="null" /> si <paramref name="nonPublic" /> es <see langword="false" /> y el descriptor de acceso <see langword="get" /> es no público, o si <paramref name="nonPublic" /> es <see langword="true" /> pero no existe ningún descriptor de acceso <see langword="get" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es el <xref:System.Reflection.MethodInfo> que representa el descriptor de acceso get.  
  
 Para usar el `GetGetMethod` método, obtenga primero la clase `Type`. Desde el `Type`, obtener el <xref:System.Reflection.PropertyInfo>. Desde el <xref:System.Reflection.PropertyInfo>, utilice el `GetGetMethod` método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el público o no público `get` descriptor de acceso para la propiedad especificada.  
  
 [!code-cpp[Classic PropertyInfo.GetGetMethod1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PropertyInfo.GetGetMethod1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PropertyInfo.GetGetMethod1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PropertyInfo.GetGetMethod1 Example/CS/source.cs#1)]
 [!code-vb[Classic PropertyInfo.GetGetMethod1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PropertyInfo.GetGetMethod1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El método solicitado no es público y el autor de llamada no tiene <see cref="T:System.Security.Permissions.ReflectionPermission" /> para reflejar en este método no público.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="propertyInfo.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de esta instancia.</summary>
        <returns>Código hash de un entero de 32 bits con signo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIndexParameters">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ParameterInfo[] GetIndexParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ParameterInfo[] GetIndexParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetIndexParameters" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetIndexParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetIndexParameters();" />
      <MemberSignature Language="F#" Value="abstract member GetIndexParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="propertyInfo.GetIndexParameters " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetIndexParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, devuelve una matriz de todos los parámetros de índice de la propiedad.</summary>
        <returns>Matriz de tipo <see langword="ParameterInfo" /> que contiene los parámetros de los índices. Si la propiedad no se indiza, la matriz tiene 0 (cero) elementos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Extraer toda la información necesaria de parámetros de la matriz devuelta.  
  
 Para usar el `GetIndexParameters` método, obtenga primero la clase `Type`. Desde el `Type`, obtener el `PropertyInfo`. Desde el `PropertyInfo`, utilice el `GetIndexParameters` método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra los parámetros de índice de la propiedad especificada.  
  
 [!code-cpp[Classic PropertyInfo.GetIndexParameters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PropertyInfo.GetIndexParameters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PropertyInfo.GetIndexParameters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PropertyInfo.GetIndexParameters Example/CS/source.cs#1)]
 [!code-vb[Classic PropertyInfo.GetIndexParameters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PropertyInfo.GetIndexParameters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo GetMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo GetMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PropertyInfo.GetMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GetMethod As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ GetMethod { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GetMethod : System.Reflection.MethodInfo" Usage="System.Reflection.PropertyInfo.GetMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el descriptor de acceso <see langword="get" /> de esta propiedad.</summary>
        <value>Descriptor de acceso <see langword="get" /> de esta propiedad.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOptionalCustomModifiers">
      <MemberSignature Language="C#" Value="public virtual Type[] GetOptionalCustomModifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetOptionalCustomModifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetOptionalCustomModifiers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOptionalCustomModifiers () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetOptionalCustomModifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetOptionalCustomModifiers : unit -&gt; Type[]&#xA;override this.GetOptionalCustomModifiers : unit -&gt; Type[]" Usage="propertyInfo.GetOptionalCustomModifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz de tipos que representan los modificadores personalizados opcionales de la propiedad.</summary>
        <returns>Matriz de objetos <see cref="T:System.Type" /> que identifican los modificadores personalizados opcionales de la propiedad actual, como <see cref="T:System.Runtime.CompilerServices.IsConst" /> o <see cref="T:System.Runtime.CompilerServices.IsImplicitlyDereferenced" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.PropertyInfo.GetOptionalCustomModifiers%2A> y <xref:System.Reflection.PropertyInfo.GetRequiredCustomModifiers%2A> se proporcionan métodos para los diseñadores de compiladores administrados. Para obtener más información sobre los modificadores personalizados, vea <xref:System.Runtime.CompilerServices.IsBoxed> y clases relacionadas del <xref:System.Runtime.CompilerServices> espacio de nombres y la especificación de metadatos en la documentación de ECMA Partition II. La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRawConstantValue">
      <MemberSignature Language="C#" Value="public virtual object GetRawConstantValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetRawConstantValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetRawConstantValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRawConstantValue () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetRawConstantValue();" />
      <MemberSignature Language="F#" Value="abstract member GetRawConstantValue : unit -&gt; obj&#xA;override this.GetRawConstantValue : unit -&gt; obj" Usage="propertyInfo.GetRawConstantValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor literal asociado a la propiedad mediante un compilador.</summary>
        <returns><see cref="T:System.Object" /> que contiene el valor literal asociado a la propiedad. Si el valor literal es un tipo de clase con un valor de elemento de cero, el valor devuelto es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para los diseñadores de compiladores administrados y analizadores de código.  
  
 Este método puede utilizarse en el contexto de ejecución y el contexto de solo reflexión.  
  
 En los metadatos no administrados, la tabla de constantes se utiliza para almacenar valores constantes para los campos, parámetros y propiedades. Constante de información no afecta directamente al comportamiento en tiempo de ejecución. Los compiladores inspeccionan esta información en tiempo de compilación, al importar los metadatos. Si se utiliza, el valor de una constante se incrusta en la secuencia del lenguaje intermedio (MSIL) de Microsoft que el compilador emite. No hay ninguna instrucción MSIL que se puede usar para tener acceso a la tabla de constantes en tiempo de ejecución.  
  
> [!NOTE]
>  Para obtener más información sobre valores constantes y la tabla de constantes, consulte la documentación de ECMA Partition II. La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La tabla de constantes de metadatos no administrados no contiene un valor de constante para la propiedad actual.</exception>
        <exception cref="T:System.FormatException">El tipo del valor no es uno de los tipos permitidos por la Common Language Specification (CLS). Vea la especificación de ECMA Partition II Metadata Logical Format: Other Structures, Element Types used in Signatures (Formato lógico de metadatos: Otras estructuras, tipos de elementos usados en las firmas).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequiredCustomModifiers">
      <MemberSignature Language="C#" Value="public virtual Type[] GetRequiredCustomModifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetRequiredCustomModifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetRequiredCustomModifiers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRequiredCustomModifiers () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetRequiredCustomModifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetRequiredCustomModifiers : unit -&gt; Type[]&#xA;override this.GetRequiredCustomModifiers : unit -&gt; Type[]" Usage="propertyInfo.GetRequiredCustomModifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz de tipos que representan los modificadores personalizados necesarios de la propiedad.</summary>
        <returns>Matriz de objetos <see cref="T:System.Type" /> que identifican los modificadores personalizados necesarios de la propiedad actual, como <see cref="T:System.Runtime.CompilerServices.IsConst" /> o <see cref="T:System.Runtime.CompilerServices.IsImplicitlyDereferenced" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.PropertyInfo.GetOptionalCustomModifiers%2A> y <xref:System.Reflection.PropertyInfo.GetRequiredCustomModifiers%2A> se proporcionan métodos para los diseñadores de compiladores administrados. Para obtener más información sobre los modificadores personalizados, vea <xref:System.Runtime.CompilerServices.IsBoxed> y clases relacionadas del <xref:System.Runtime.CompilerServices> espacio de nombres y la especificación de metadatos en la documentación de ECMA Partition II. La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSetMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve <see cref="T:System.Reflection.MethodInfo" /> que representa el descriptor de acceso <see langword="set" /> de esta propiedad.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetSetMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetSetMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetSetMethod" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSetMethod () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetSetMethod();" />
      <MemberSignature Language="F#" Value="abstract member GetSetMethod : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetSetMethod : unit -&gt; System.Reflection.MethodInfo" Usage="propertyInfo.GetSetMethod " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetSetMethod</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el descriptor de acceso <see langword="set" /> público de esta propiedad.</summary>
        <returns>Objeto <see langword="MethodInfo" /> que representa el método <see langword="Set" /> de esta propiedad si el descriptor de acceso <see langword="set" /> es público, o <see langword="null" /> si el descriptor de acceso <see langword="set" /> no es público.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de un método de conveniencia que proporciona una implementación abstracta `GetSetMethod` método con el `nonPublic` parámetro establecido en `false`.  
  
 Para usar el `GetSetMethod` método, obtenga primero la clase `Type`. Desde el `Type`, obtener el <xref:System.Reflection.PropertyInfo>. Desde el `PropertyInfo`, utilice el `GetSetMethod` método.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetSetMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo GetSetMethod (bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetSetMethod(bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetSetMethod(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetSetMethod (nonPublic As Boolean) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodInfo ^ GetSetMethod(bool nonPublic);" />
      <MemberSignature Language="F#" Value="abstract member GetSetMethod : bool -&gt; System.Reflection.MethodInfo" Usage="propertyInfo.GetSetMethod nonPublic" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetSetMethod(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nonPublic">Indica si se debe devolver el descriptor de acceso si es no público. <see langword="true" /> si se debe devolver un descriptor de acceso no público; de lo contrario, <see langword="false" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, devuelve el descriptor de acceso <see langword="set" /> de esta propiedad.</summary>
        <returns>El método <see langword="Set" /> de esta propiedad, o <see langword="null" />, como se muestra en la tabla siguiente.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condición 
 </description></listheader><item><term> El método <see langword="Set" /> de esta propiedad.  
  
 </term><description> El descriptor de acceso <see langword="set" /> es público.  
  
O bien 
 El valor de <paramref name="nonPublic" /> es <see langword="true" /> y el descriptor de acceso <see langword="set" /> no es público.  
  
 </description></item><item><term><see langword="null" /></term><description><paramref name="nonPublic" /> es <see langword="true" />, pero la propiedad es de sólo lectura.  
  
O bien 
 El valor de <paramref name="nonPublic" /> es <see langword="false" /> y el descriptor de acceso <see langword="set" /> no es público.  
  
O bien 
No hay descriptor de acceso <see langword="set" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar el `GetSetMethod` método, obtenga primero la clase `Type`. Desde el `Type`, obtener el <xref:System.Reflection.PropertyInfo>. Desde el `PropertyInfo`, utilice el `GetSetMethod` método.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra el `set` descriptor de acceso para la propiedad especificada.  
  
 [!code-cpp[Classic PropertyInfo.GetSetMethod1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PropertyInfo.GetSetMethod1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PropertyInfo.GetSetMethod1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PropertyInfo.GetSetMethod1 Example/CS/source.cs#1)]
 [!code-vb[Classic PropertyInfo.GetSetMethod1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PropertyInfo.GetSetMethod1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El método solicitado no es público y el autor de llamada no tiene <see cref="T:System.Security.Permissions.ReflectionPermission" /> para reflejar en este método no público.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="propertyInfo.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el valor de propiedad de un objeto especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (obj As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.GetValue : obj -&gt; obj" Usage="propertyInfo.GetValue obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto cuyo valor de propiedad se va a devolver.</param>
        <summary>Devuelve el valor de propiedad de un objeto especificado.</summary>
        <returns>Valor de propiedad del objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama a la <xref:System.Reflection.PropertyInfo.GetValue%28System.Object%29> sobrecarga para recuperar el valor de una propiedad no indizada; Si se intenta recuperar el valor de una propiedad indizada, el método produce una <xref:System.Reflection.TargetParameterCountException> excepción. Puede determinar si una propiedad está indizada, o no mediante una llamada a la <xref:System.Reflection.PropertyInfo.GetIndexParameters%2A> método. Si la longitud de devuelto <xref:System.Reflection.ParameterInfo> matriz es cero, la propiedad no está indizada.  
  
 Se trata de un método de conveniencia que proporciona una implementación abstracta <xref:System.Reflection.PropertyInfo.GetValue%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> método con el <xref:System.Reflection.BindingFlags> parámetro establecido en <xref:System.Reflection.BindingFlags.Default?displayProperty=nameWithType>, el <xref:System.Reflection.Binder> establecido en `null`, la matriz de objetos de los valores de índice establecido en `null`, y el <xref:System.Globalization.CultureInfo> establecido en `null`.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `Planet` clase que tiene dos propiedades: `Name`, el nombre del planeta; y `Distance`, distancia del planeta de tierra. El ejemplo crea un `Planet` objeto que representa el planeta Júpiter y lo pasa a un `GetPropertyValues` método que muestra información acerca de las propiedades y usa el <xref:System.Reflection.PropertyInfo.GetValue%2A> método para obtener el valor de cada `Planet` propiedad.  
  
 [!code-csharp[System.Reflection.PropertyInfo.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.propertyinfo.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Reflection.PropertyInfo.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.propertyinfo.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public virtual object GetValue (object obj, object[] index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetValue(object obj, object[] index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetValue(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValue (obj As Object, index As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetValue(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ index);" />
      <MemberSignature Language="F#" Value="abstract member GetValue : obj * obj[] -&gt; obj&#xA;override this.GetValue : obj * obj[] -&gt; obj" Usage="propertyInfo.GetValue (obj, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetValue(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="index" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto cuyo valor de propiedad se va a devolver.</param>
        <param name="index">Valores de índice opcionales para propiedades indizadas. Los índices de las propiedades indizadas son de base cero. Este valor debe ser <see langword="null" /> para propiedades no indizadas.</param>
        <summary>Devuelve el valor de propiedad de un objeto especificado con valores de índice opcionales para las propiedades indizadas.</summary>
        <returns>Valor de propiedad del objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar si una propiedad está indizada, use el <xref:System.Reflection.PropertyInfo.GetIndexParameters%2A> método. Si la matriz resultante tiene 0 (cero) elementos, la propiedad no está indizado.  
  
 Se trata de un método de conveniencia que proporciona una implementación abstracta `GetValue` método con un `BindingFlags` parámetro de `Default`, el `Binder` establecido en `null`y el `CultureInfo` establecido en `null`.  
  
 Dado que las propiedades estáticas pertenecen al tipo, los objetos no individuales, obtener propiedades estáticas, pasando `null` como argumento del objeto. Por ejemplo, use el código siguiente para obtener estático `CurrentCulture` propiedad de `CultureInfo` :  
  
```csharp  
PropertyInfo CurCultProp =   
    (typeof(CultureInfo)).GetProperty("CurrentCulture");   
Console.WriteLine("CurrCult: " +  
    CurCultProp.GetValue(null,null));  
```  
  
 Para usar el `GetValue` método, obtenga primero la clase `Type`. Desde el `Type`, obtener el `PropertyInfo`. Desde el `PropertyInfo`, utilice el `GetValue` método.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a miembros no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los miembros no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo obtener el valor de una propiedad indizada. El <xref:System.String.Chars%2A?displayProperty=nameWithType> es la propiedad predeterminada (el indizador en C#) de la <xref:System.String> clase.  
  
 [!code-csharp[System.Reflection.PropertyInfo.GetValue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.PropertyInfo.GetValue Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.PropertyInfo.GetValue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.PropertyInfo.GetValue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="index" /> no contiene el tipo de argumentos necesario.  
  
O bien 
No se encuentra el descriptor de acceso <see langword="get" /> de la propiedad.</exception>
        <exception cref="T:System.Reflection.TargetException"><block subset="none" type="note">
            <para>  
 En <see href="https://msdn.microsoft.com/library/windows/apps/br230232(v=vs.110).aspx">.NET para aplicaciones de la Tienda Windows</see> o la <see href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md">Biblioteca de clases portable</see>, capture <see cref="T:System.Exception" /> en su lugar.  
  
</para>
          </block>  
  
 El objeto no coincide con el tipo de destino o una propiedad es una propiedad de instancia pero <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">El número de parámetros de <paramref name="index" /> no coincide con el número de parámetros que toma la propiedad indexada.</exception>
        <exception cref="T:System.MethodAccessException"><block subset="none" type="note">
            <para>  
 En <see href="https://msdn.microsoft.com/library/windows/apps/br230232(v=vs.110).aspx">.NET para aplicaciones de la Tienda Windows</see> o la <see href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.MemberAccessException" />.  
  
</para>
          </block>  
  
 Hubo un intento no válido de obtener acceso a un método privado o protegido dentro de una clase.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Error al recuperar el valor de la propiedad. Por ejemplo, un valor de índice especificado para una propiedad indizada está fuera del intervalo. La propiedad <see cref="P:System.Exception.InnerException" /> indica el motivo del error.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public abstract object GetValue (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetValue(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] index, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetValue(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ GetValue(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ index, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetValue : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="propertyInfo.GetValue (obj, invokeAttr, binder, index, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetValue(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="index" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto cuyo valor de propiedad se va a devolver.</param>
        <param name="invokeAttr">Una combinación bit a bit de los miembros de enumeración siguientes que especifican el atributo de invocación: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> y <see langword="SetProperty" />. Debe especificarse un atributo de invocación apropiado. Por ejemplo, para llamar a un miembro estático, establezca la marca <see langword="Static" />.</param>
        <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la llamada de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante reflexión. Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</param>
        <param name="index">Valores de índice opcionales para propiedades indizadas. Este valor debe ser <see langword="null" /> para propiedades no indizadas.</param>
        <param name="culture">Referencia cultural para la que se va a localizar el recurso. Si no se encuentra el recurso correspondiente a esta referencia cultural, se llamará sucesivamente a la propiedad <see cref="P:System.Globalization.CultureInfo.Parent" /> para buscar una coincidencia. Si este valor es <see langword="null" />, la información específica de la referencia cultural se obtiene de la propiedad <see cref="P:System.Globalization.CultureInfo.CurrentUICulture" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, devuelve el valor de propiedad de un objeto especificado que tiene el enlace, el índice y la información específica de la referencia cultural especificados.</summary>
        <returns>Valor de propiedad del objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar si una propiedad está indizada, use el <xref:System.Reflection.PropertyInfo.GetIndexParameters%2A> método. Si la matriz resultante tiene 0 (cero) elementos, la propiedad no está indizado.  
  
 Dado que las propiedades estáticas pertenecen al tipo, los objetos no individuales, obtener propiedades estáticas, pasando `null` como argumento del objeto. Por ejemplo, use el código siguiente para obtener estático `CurrentCulture` propiedad de `CultureInfo` :  
  
```csharp  
PropertyInfo CurCultProp =   
       (typeof(CultureInfo)).GetProperty("CurrentCulture");   
Console.WriteLine("CurrCult: " +  
       CurCultProp.GetValue(null,null));  
```  
  
 Para usar el `GetValue` método, obtenga primero la clase `Type`. Desde el `Type`, obtener el `PropertyInfo`. Desde el `PropertyInfo`, utilice el `GetValue` método.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a miembros no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los miembros no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="index" /> no contiene el tipo de argumentos necesario.  
  
O bien 
No se encuentra el descriptor de acceso <see langword="get" /> de la propiedad.</exception>
        <exception cref="T:System.Reflection.TargetException">El objeto no coincide con el tipo de destino o una propiedad es una propiedad de instancia pero <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">El número de parámetros de <paramref name="index" /> no coincide con el número de parámetros que toma la propiedad indexada.</exception>
        <exception cref="T:System.MethodAccessException">Hubo un intento no válido de obtener acceso a un método privado o protegido dentro de una clase.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Error al recuperar el valor de la propiedad. Por ejemplo, un valor de índice especificado para una propiedad indizada está fuera del intervalo. La propiedad <see cref="P:System.Exception.InnerException" /> indica el motivo del error.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PropertyInfo.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Reflection.PropertyInfo.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._PropertyInfo.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la propiedad es el nombre especial.</summary>
        <value>Es <see langword="true" /> si esta propiedad es el nombre especial; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `SpecialName` bit se establece para marcar los miembros que se tratarán de una manera especial algunos compiladores (por ejemplo, los descriptores de acceso de propiedad y métodos de sobrecarga de operadores).  
  
 Para obtener el `IsSpecialName` propiedad, obtenga primero la clase `Type`. Desde el `Type`, obtener el `PropertyInfo`. Desde el `PropertyInfo`, obtener el `IsSpecialName` valor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PropertyInfo.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Reflection.PropertyInfo.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._PropertyInfo.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor <see cref="T:System.Reflection.MemberTypes" /> que indica que este miembro es una propiedad.</summary>
        <value>Valor <see cref="T:System.Reflection.MemberTypes" /> que indica que este miembro es una propiedad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad invalida <xref:System.Reflection.MemberInfo.MemberType%2A>. Por lo tanto, cuando se examina un conjunto de <xref:System.Reflection.MemberInfo> objetos: por ejemplo, la matriz devuelta por <xref:System.Type.GetMembers%2A> : la <xref:System.Reflection.MemberInfo.MemberType%2A> propiedad devuelve <xref:System.Reflection.MemberTypes.Property> sólo cuando un miembro determinado es una propiedad.  
  
 `MemberType` es una clase derivada de `MemberInfo` y especifica el tipo de miembro. Tipos de miembro son constructores, propiedades, campos y métodos. Puesto que se trata de un `PropertyInfo` , el tipo devuelto es una propiedad.  
  
 Para obtener el `MemberType` propiedad, obtenga primero la clase `Type`. Desde el `Type`, obtener el `PropertyInfo`. Desde el `PropertyInfo`, obtener el `MemberType` valor.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el tipo del miembro especificado.  
  
 [!code-cpp[Classic PropertyInfo.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PropertyInfo.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PropertyInfo.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PropertyInfo.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic PropertyInfo.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PropertyInfo.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.PropertyInfo left, System.Reflection.PropertyInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.PropertyInfo left, class System.Reflection.PropertyInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.op_Equality(System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As PropertyInfo, right As PropertyInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::PropertyInfo ^ left, System::Reflection::PropertyInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.PropertyInfo * System.Reflection.PropertyInfo -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="right" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="left">Primer objeto que se va a comparar.</param>
        <param name="right">Segundo objeto que se va a comparar.</param>
        <summary>Indica si dos objetos <see cref="T:System.Reflection.PropertyInfo" /> son iguales.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> es igual a <paramref name="right" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.PropertyInfo left, System.Reflection.PropertyInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.PropertyInfo left, class System.Reflection.PropertyInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.op_Inequality(System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As PropertyInfo, right As PropertyInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::PropertyInfo ^ left, System::Reflection::PropertyInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.PropertyInfo * System.Reflection.PropertyInfo -&gt; bool" Usage="System.Reflection.PropertyInfo.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="right" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="left">Primer objeto que se va a comparar.</param>
        <param name="right">Segundo objeto que se va a comparar.</param>
        <summary>Indica si dos objetos <see cref="T:System.Reflection.PropertyInfo" /> no son iguales.</summary>
        <returns>Es <see langword="true" /> si <paramref name="left" /> no es igual a <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public abstract Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PropertyInfo.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Reflection.PropertyInfo.PropertyType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._PropertyInfo.PropertyType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo de esta propiedad.</summary>
        <value>Tipo de esta propiedad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar el tipo de una propiedad determinada, realice lo siguiente:  
  
1.  Obtener un <xref:System.Type> objeto que representa el tipo (la clase o estructura) que contiene la propiedad. Si está trabajando con un objeto (una instancia de un tipo), puede llamar a su <xref:System.Object.GetType%2A> método. En caso contrario, se puede utilizar el operador de C# o el operador de Visual Basic, como en el ejemplo se muestra.  
  
2.  Obtener un <xref:System.Reflection.PropertyInfo> objeto que representa la propiedad en el que está interesado. Puede hacerlo mediante la obtención de una matriz de todas las propiedades de la <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> método y, a continuación, recorrer en iteración los elementos de la matriz, o se pueden recuperar el <xref:System.Reflection.PropertyInfo> objeto que representa la propiedad directamente mediante una llamada a la <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> método y especificar el nombre de propiedad.  
  
3.  Recuperar el valor de la <xref:System.Reflection.PropertyInfo.PropertyType%2A> propiedad desde la <xref:System.Reflection.PropertyInfo> objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `Employee` clase que tiene cinco propiedades. , A continuación, usa recupera una matriz de <xref:System.Reflection.PropertyInfo> objetos que representan las propiedades y muestran el nombre y tipo de cada uno.  
  
 [!code-csharp[System.Reflection.PropertyInfo.PropertyType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.propertyinfo.propertytype/cs/propertytype1.cs#1)]
 [!code-vb[System.Reflection.PropertyInfo.PropertyType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.propertyinfo.propertytype/vb/propertytype1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo SetMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo SetMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PropertyInfo.SetMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SetMethod As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ SetMethod { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetMethod : System.Reflection.MethodInfo" Usage="System.Reflection.PropertyInfo.SetMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el descriptor de acceso <see langword="set" /> de esta propiedad.</summary>
        <value>Descriptor de acceso <see langword="set" /> para esta propiedad o <see langword="null" /> si la propiedad es de solo lectura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar el valor de la <xref:System.Reflection.PropertyInfo.SetMethod%2A> propiedad es equivalente a llamar a la <xref:System.Reflection.PropertyInfo.GetSetMethod%28System.Boolean%29> método con un valor de `true` para el `nonPublic` argumento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.PropertyInfo.GetMethod" />
        <altmember cref="P:System.Reflection.PropertyInfo.CanWrite" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece el valor de propiedad para un objeto especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object obj, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object obj, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.SetValue(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (obj As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ obj, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * obj -&gt; unit" Usage="propertyInfo.SetValue (obj, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto cuyo valor de propiedad se va a establecer.</param>
        <param name="value">Nuevo valor de propiedad.</param>
        <summary>Establece el valor de propiedad de un objeto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.PropertyInfo.SetValue%28System.Object%2CSystem.Object%29> sobrecarga establece el valor de una propiedad no indizada. Para determinar si una propiedad está indizada, llame a la <xref:System.Reflection.PropertyInfo.GetIndexParameters%2A> método. Si la matriz resultante tiene 0 (cero) elementos, la propiedad no está indizado. Para establecer el valor de una propiedad indizada, llame a la <xref:System.Reflection.PropertyInfo.SetValue%28System.Object%2CSystem.Object%2CSystem.Object%5B%5D%29> de sobrecarga.  
  
 Si la propiedad tipo de este <xref:System.Reflection.PropertyInfo> objeto es un tipo de valor y `value` es `null`, la propiedad se establecerá en el valor predeterminado para ese tipo.  
  
 Se trata de un método de conveniencia que llama a la implementación en tiempo de ejecución del resumen <xref:System.Reflection.PropertyInfo.SetValue%28System.Object%2CSystem.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> método, especifica <xref:System.Reflection.BindingFlags.Default?displayProperty=nameWithType> para el `BindingFlags` parámetro, `null` para `Binder`, `null` para `Object[]`y `null` para `CultureInfo`.  
  
 Para usar el <xref:System.Reflection.PropertyInfo.SetValue%2A> método, primero obtenga una <xref:System.Type> objeto que representa la clase. Desde el <xref:System.Type>, obtener el <xref:System.Reflection.PropertyInfo> objeto. Desde el <xref:System.Reflection.PropertyInfo> de objeto, llame a la <xref:System.Reflection.PropertyInfo.SetValue%2A> método.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a miembros no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los miembros no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
   
  
## Examples  
 En el ejemplo siguiente se declara una clase denominada `Example` con uno `static` (`Shared` en Visual Basic) y la propiedad de una instancia. El ejemplo se usa el <xref:System.Reflection.PropertyInfo.SetValue%28System.Object%2CSystem.Object%29> método para cambiar la propiedad original y muestra los valores originales y finales.  
  
 [!code-cpp[PropertyInfo.SetValue#2](~/samples/snippets/cpp/VS_Snippets_CLR/PropertyInfo.SetValue/cpp/example2.cpp#2)]
 [!code-csharp[PropertyInfo.SetValue#2](~/samples/snippets/csharp/VS_Snippets_CLR/PropertyInfo.SetValue/cs/example2.cs#2)]
 [!code-vb[PropertyInfo.SetValue#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PropertyInfo.SetValue/vb/example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No se encuentra el descriptor de acceso <see langword="set" /> de la propiedad.  
  
O bien 
 <paramref name="value" /> no se puede convertir al tipo de <see cref="P:System.Reflection.PropertyInfo.PropertyType" />.</exception>
        <exception cref="T:System.Reflection.TargetException"><block subset="none" type="note">
            <para>  
 En <see href="https://msdn.microsoft.com/library/windows/apps/br230232(v=vs.110).aspx">.NET para aplicaciones de la Tienda Windows</see> o la <see href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md">Biblioteca de clases portable</see>, capture <see cref="T:System.Exception" /> en su lugar.  
  
</para>
          </block>  
  
 El tipo de <paramref name="obj" /> no coincide con el tipo de destino o una propiedad es una propiedad de instancia, pero <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException"><block subset="none" type="note">
            <para>  
 En <see href="https://msdn.microsoft.com/library/windows/apps/br230232(v=vs.110).aspx">.NET para aplicaciones de la Tienda Windows</see> o la <see href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.MemberAccessException" />.  
  
</para>
          </block>  
  
 Hubo un intento no válido de obtener acceso a un método privado o protegido dentro de una clase.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Error al establecer el valor de la propiedad. La propiedad <see cref="P:System.Exception.InnerException" /> indica el motivo del error.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public virtual void SetValue (object obj, object value, object[] index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(object obj, object value, object[] index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.SetValue(System.Object,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetValue (obj As Object, value As Object, index As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetValue(System::Object ^ obj, System::Object ^ value, cli::array &lt;System::Object ^&gt; ^ index);" />
      <MemberSignature Language="F#" Value="abstract member SetValue : obj * obj * obj[] -&gt; unit&#xA;override this.SetValue : obj * obj * obj[] -&gt; unit" Usage="propertyInfo.SetValue (obj, value, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.SetValue(System.Object,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto cuyo valor de propiedad se va a establecer.</param>
        <param name="value">Nuevo valor de propiedad.</param>
        <param name="index">Valores de índice opcionales para propiedades indizadas. Este valor debe ser <see langword="null" /> para propiedades no indizadas.</param>
        <summary>Establece el valor de propiedad de un objeto especificado con valores de índice opcionales para las propiedades del índice.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este <xref:System.Reflection.PropertyInfo> objeto es un tipo de valor y `value` es `null`, la propiedad se establecerá en el valor predeterminado para ese tipo.  
  
 Para determinar si una propiedad está indizada, use el <xref:System.Reflection.PropertyInfo.GetIndexParameters%2A> método. Si la matriz resultante tiene 0 (cero) elementos, la propiedad no está indizado.  
  
 Se trata de un método de conveniencia que llama a la implementación en tiempo de ejecución del resumen <xref:System.Reflection.PropertyInfo.SetValue%28System.Object%2CSystem.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> método, especifica <xref:System.Reflection.BindingFlags.Default?displayProperty=nameWithType> para el `BindingFlags` parámetro, `null` para `Binder`, y `null` para `CultureInfo`.  
  
 Para usar el <xref:System.Reflection.PropertyInfo.SetValue%2A> método, primero obtenga una <xref:System.Type> objeto que representa la clase. Desde el <xref:System.Type>, obtener el <xref:System.Reflection.PropertyInfo>. Desde el <xref:System.Reflection.PropertyInfo>, utilice el <xref:System.Reflection.PropertyInfo.SetValue%2A> método.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a miembros no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los miembros no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una clase denominada `TestClass` que tiene una propiedad de lectura y escritura denominada `Caption`. Muestra el valor predeterminado de la `Caption` propiedad, llama el <xref:System.Reflection.PropertyInfo.SetValue%2A> método para cambiar el valor de propiedad y muestra el resultado.  
  
 [!code-cpp[Classic PropertyInfo.SetValue1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PropertyInfo.SetValue1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PropertyInfo.SetValue1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PropertyInfo.SetValue1 Example/CS/source.cs#1)]
 [!code-vb[Classic PropertyInfo.SetValue1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PropertyInfo.SetValue1 Example/VB/source.vb#1)]  
  
 Tenga en cuenta que, dado el `Caption` propiedad no es una matriz de parámetros, el `index` argumento es `null`.  
  
 En el ejemplo siguiente se declara una clase denominada `Example` con tres propiedades: una `static` propiedad (`Shared` en Visual Basic), una propiedad de instancia y una propiedad de instancia indizada. El ejemplo se usa el <xref:System.Reflection.PropertyInfo.SetValue%2A> método para cambiar los valores predeterminados de las propiedades y muestra los valores originales y finales.  
  
 El nombre que se usa para buscar una propiedad de instancia indizada con reflexión es diferente según el idioma y de los atributos aplicados a la propiedad.  
  
-   En Visual Basic, el nombre de propiedad siempre se utiliza para buscar la propiedad con reflexión. Puede usar el `Default` propiedad de la palabra clave para convertir un valor predeterminado de la propiedad indizada, en cuyo caso puede omitir el nombre al obtener acceso a la propiedad, como en este ejemplo. También puede usar el nombre de propiedad.  
  
-   En C#, la propiedad de instancia indizada es una propiedad predeterminada denominada indizador y el nombre nunca se usa al obtener acceso a la propiedad en el código. De forma predeterminada, el nombre de la propiedad es `Item`, y debe usar ese nombre cuando busque la propiedad con reflexión. Puede usar el <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atributo para asignar un nombre diferente de indizador. En este ejemplo, el nombre es `IndexedInstanceProperty`.  
  
-   En C++, el `default` especificador puede usarse para convertir un valor predeterminado de una propiedad indizada (indizador de clase) de la propiedad indizada. En ese caso, el nombre de la propiedad predeterminada es `Item`, y debe usar ese nombre al realizar una búsqueda para la propiedad con reflexión, como en este ejemplo. Puede usar el <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atributo para asignar un nombre diferente del indizador de clase en la reflexión, pero no se puede usar ese nombre para tener acceso a la propiedad en el código. Se tiene acceso a una propiedad indizada que no es un indizador de clase utilizando su nombre tanto en el código en la reflexión.  
  
 [!code-cpp[PropertyInfo.SetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR/PropertyInfo.SetValue/cpp/Example.cpp#1)]
 [!code-csharp[PropertyInfo.SetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR/PropertyInfo.SetValue/cs/Example.cs#1)]
 [!code-vb[PropertyInfo.SetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PropertyInfo.SetValue/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="index" /> no contiene el tipo de argumentos necesario.  
  
O bien 
No se encuentra el descriptor de acceso <see langword="set" /> de la propiedad.  
  
O bien 
 <paramref name="value" /> no se puede convertir al tipo de <see cref="P:System.Reflection.PropertyInfo.PropertyType" />.</exception>
        <exception cref="T:System.Reflection.TargetException"><block subset="none" type="note">
            <para>  
 En <see href="https://msdn.microsoft.com/library/windows/apps/br230232(v=vs.110).aspx">.NET para aplicaciones de la Tienda Windows</see> o la <see href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md">Biblioteca de clases portable</see>, capture <see cref="T:System.Exception" /> en su lugar.  
  
</para>
          </block>  
  
 El objeto no coincide con el tipo de destino o una propiedad es una propiedad de instancia pero <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">El número de parámetros de <paramref name="index" /> no coincide con el número de parámetros que toma la propiedad indexada.</exception>
        <exception cref="T:System.MethodAccessException"><block subset="none" type="note">
            <para>  
 En <see href="https://msdn.microsoft.com/library/windows/apps/br230232(v=vs.110).aspx">.NET para aplicaciones de la Tienda Windows</see> o la <see href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.MemberAccessException" />.  
  
</para>
          </block>  
  
 Hubo un intento no válido de obtener acceso a un método privado o protegido dentro de una clase.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Error al configurar el valor de la propiedad. Por ejemplo, un valor de índice especificado para una propiedad indexada está fuera del intervalo. La propiedad <see cref="P:System.Exception.InnerException" /> indica el motivo del error.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public abstract void SetValue (object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(object obj, object value, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] index, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetValue(System::Object ^ obj, System::Object ^ value, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ index, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member SetValue : obj * obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; unit" Usage="propertyInfo.SetValue (obj, value, invokeAttr, binder, index, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="index" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto cuyo valor de propiedad se va a establecer.</param>
        <param name="value">Nuevo valor de propiedad.</param>
        <param name="invokeAttr">Una combinación bit a bit de los miembros de enumeración siguientes que especifican el atributo de invocación: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />. Debe especificarse un atributo de invocación apropiado. Por ejemplo, para llamar a un miembro estático, establezca la marca <see langword="Static" />.</param>
        <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la llamada de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante reflexión. Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</param>
        <param name="index">Valores de índice opcionales para propiedades indizadas. Este valor debe ser <see langword="null" /> para propiedades no indizadas.</param>
        <param name="culture">Referencia cultural para la que se va a localizar el recurso. Si no se encuentra el recurso correspondiente a esta referencia cultural, se llamará sucesivamente a la propiedad <see cref="P:System.Globalization.CultureInfo.Parent" /> para buscar una coincidencia. Si este valor es <see langword="null" />, la información específica de la referencia cultural se obtiene de la propiedad <see cref="P:System.Globalization.CultureInfo.CurrentUICulture" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, establece el valor de propiedad para un objeto especificado que tiene el enlace, el índice y la información específica de la referencia cultural especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este <xref:System.Reflection.PropertyInfo> objeto es un tipo de valor y `value` es `null`, la propiedad se establecerá en el valor predeterminado para ese tipo.  
  
 Para determinar si una propiedad está indizada, use el <xref:System.Reflection.PropertyInfo.GetIndexParameters%2A> método. Si la matriz resultante tiene 0 (cero) elementos, la propiedad no está indizado.  
  
 Se omiten las restricciones de acceso para el código de plena confianza. Es decir, las propiedades, métodos, campos y constructores privados pueden tener acceso a e invoca a través de Reflection siempre que el código es de plena confianza.  
  
 Para usar el `SetValue` método, obtenga primero la clase `Type`. Desde el `Type`, obtener el `PropertyInfo`. Desde el `PropertyInfo`, utilice el `SetValue` método.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a miembros no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los miembros no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="index" /> no contiene el tipo de argumentos necesario.  
  
O bien 
No se encuentra el descriptor de acceso <see langword="set" /> de la propiedad.  
  
O bien 
 <paramref name="value" /> no se puede convertir al tipo de <see cref="P:System.Reflection.PropertyInfo.PropertyType" />.</exception>
        <exception cref="T:System.Reflection.TargetException">El objeto no coincide con el tipo de destino o una propiedad es una propiedad de instancia, pero <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">El número de parámetros de <paramref name="index" /> no coincide con el número de parámetros que toma la propiedad indexada.</exception>
        <exception cref="T:System.MethodAccessException">Hubo un intento no válido de obtener acceso a un método privado o protegido dentro de una clase.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Error al configurar el valor de la propiedad. Por ejemplo, un valor de índice especificado para una propiedad indexada está fuera del intervalo. La propiedad <see cref="P:System.Exception.InnerException" /> indica el motivo del error.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._PropertyInfo.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _PropertyInfo.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._PropertyInfo.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.System#Runtime#InteropServices#_PropertyInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _PropertyInfo.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._PropertyInfo.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_PropertyInfo::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reservado para un uso futuro. Debe ser IID_NULL.</param>
        <param name="rgszNames">Matriz que se pasa con los nombres que se van a asignar.</param>
        <param name="cNames">Número de nombres que se van a asignar.</param>
        <param name="lcid">Contexto de configuración regional en el que se van a interpretar los nombres.</param>
        <param name="rgDispId">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</param>
        <summary>Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::GetIDsOfNames`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._PropertyInfo.GetType">
      <MemberSignature Language="C#" Value="Type _PropertyInfo.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._PropertyInfo.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.System#Runtime#InteropServices#_PropertyInfo#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _PropertyInfo.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._PropertyInfo.GetType() = System::Runtime::InteropServices::_PropertyInfo::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Type" /> que representa el tipo de <see cref="T:System.Reflection.PropertyInfo" />.</summary>
        <returns>Objeto <see cref="T:System.Type" /> que representa el tipo <see cref="T:System.Reflection.PropertyInfo" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._PropertyInfo.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _PropertyInfo.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._PropertyInfo.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.System#Runtime#InteropServices#_PropertyInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _PropertyInfo.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._PropertyInfo.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_PropertyInfo::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Información de tipos que se va a devolver.</param>
        <param name="lcid">Identificador de la configuración regional de la información de tipo.</param>
        <param name="ppTInfo">Recibe un puntero al objeto de información de tipo solicitado.</param>
        <summary>Recupera la información de tipo de un objeto, que se puede usar después para obtener la información de tipo de una interfaz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::GetTypeInfo`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._PropertyInfo.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _PropertyInfo.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._PropertyInfo.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.System#Runtime#InteropServices#_PropertyInfo#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _PropertyInfo.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._PropertyInfo.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_PropertyInfo::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</param>
        <summary>Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::GetTypeInfoCount`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._PropertyInfo.Invoke">
      <MemberSignature Language="C#" Value="void _PropertyInfo.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._PropertyInfo.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.System#Runtime#InteropServices#_PropertyInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _PropertyInfo.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._PropertyInfo.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_PropertyInfo::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica el miembro.</param>
        <param name="riid">Reservado para un uso futuro. Debe ser IID_NULL.</param>
        <param name="lcid">Contexto de la configuración regional en que se interpretan los argumentos.</param>
        <param name="wFlags">Marcas que describen el contexto de la llamada.</param>
        <param name="pDispParams">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</param>
        <param name="pVarResult">Puntero a la ubicación donde se va a almacenar el resultado.</param>
        <param name="pExcepInfo">Puntero a una estructura que contiene información de excepciones.</param>
        <param name="puArgErr">Índice del primer argumento que tiene un error.</param>
        <summary>Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::Invoke`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
  </Members>
</Type>