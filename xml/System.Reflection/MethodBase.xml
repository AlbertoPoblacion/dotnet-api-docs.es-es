<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MethodBase.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9575d09f-9d72-4690-889e-b83c405ca456cc835ba89554a81318a5948b06c2447df89fe759.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cc835ba89554a81318a5948b06c2447df89fe759</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">254e16ae65e82f4aa59360cd8572b36b6b5b2f80</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/05/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodBase">
          <source>Provides information about methods and constructors.</source>
          <target state="translated">Proporciona información sobre los métodos y los constructores.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source><ph id="ph1">`MethodBase`</ph> is the base class of <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`MethodBase`</ph> es la clase base de <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> y <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>for full trust for inheritors.</source>
          <target state="translated">de plena confianza para los herederos.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">Esta clase no puede heredarse mediante código de confianza parcial.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>This type is thread safe.</source>
          <target state="translated">Este tipo es seguro para la ejecución de subprocesos.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>When you inherit from <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph>, you must override the following members: <ph id="ph2">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>, <ph id="ph5">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>, <ph id="ph6">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>, <ph id="ph7">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>, <ph id="ph8">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>, <ph id="ph9">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>, <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>, <ph id="ph11">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph>, <ph id="ph12">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>, and <ph id="ph13">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</source>
          <target state="translated">Al heredar de <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph>, debe reemplazar los miembros siguientes: <ph id="ph2">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>, <ph id="ph5">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>, <ph id="ph6">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>, <ph id="ph7">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>, <ph id="ph8">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>, <ph id="ph9">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>, <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>, <ph id="ph11">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> , <ph id="ph12">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>, y <ph id="ph13">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.#ctor">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Cuando se invoca en tiempo de ejecución a través de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.#ctor">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Gets the attributes associated with this method.</source>
          <target state="translated">Obtiene los atributos asociados a este método.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> values.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>All members have a set of attributes, which are defined in relation to the specific type of member.</source>
          <target state="translated">Todos los miembros tienen un conjunto de atributos, que se definen en relación con el tipo específico del miembro.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, first get the type.</source>
          <target state="translated">Para obtener el <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, primero hay que obtener el tipo.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>From the type, get the method.</source>
          <target state="translated">A partir del tipo, obtenga el método.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>From the method, get the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>.</source>
          <target state="translated">A partir del método, obtenga el <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>The following code example displays the attributes of the user-defined method Mymethod.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra los atributos del método Mymethod definido por el usuario.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>This code produces the following output:</source>
          <target state="translated">Este código genera el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Reflection.MethodBase.Attributes Sample</source>
          <target state="translated">Ejemplo de Reflection.MethodBase.Attributes</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef)</source>
          <target state="translated">Mymethodbase = Mymethod Void (Int32, System.String ByRef, System.String ByRef)</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>PrivateScope</source>
          <target state="translated">PrivateScope</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>FamANDAssem</source>
          <target state="translated">FamANDAssem</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Family</source>
          <target state="translated">Familia</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Public</source>
          <target state="translated">Public</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>HideBySig</source>
          <target state="translated">HideBySig</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>ReuseSlot</source>
          <target state="translated">ReuseSlot</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Use the <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph> property to determine whether a method is <ph id="ph2">&lt;see langword="public" /&gt;</ph>, <ph id="ph3">&lt;see langword="private" /&gt;</ph>, <ph id="ph4">&lt;see langword="final" /&gt;</ph>, <ph id="ph5">&lt;see langword="virtual" /&gt;</ph>, and so on.</source>
          <target state="translated">Use la <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph> propiedad para determinar si un método es <ph id="ph2">&lt;see langword="public" /&gt;</ph>, <ph id="ph3">&lt;see langword="private" /&gt;</ph>, <ph id="ph4">&lt;see langword="final" /&gt;</ph>, <ph id="ph5">&lt;see langword="virtual" /&gt;</ph>, y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.CallingConvention">
          <source>Gets a value indicating the calling conventions for this method.</source>
          <target state="translated">Obtiene un valor que indica las convenciones de llamada de este método.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.CallingConvention">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph> for this method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph> de este método.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Gets a value indicating whether the generic method contains unassigned generic type parameters.</source>
          <target state="translated">Obtiene un valor que indica si el método genérico contiene parámetros de tipo genérico sin asignar.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object represents a generic method that contains unassigned generic type parameters; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> actual representa un método genérico que contiene parámetros de tipo genérico sin asignar; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types.</source>
          <target state="translated">Un método genérico se puede invocar solo si no hay ninguna definición de tipo genérico o tipos construidos abiertos en los argumentos de tipo del propio método o en los tipos envolventes.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Because types can be arbitrarily complex, making this recursive determination is difficult.</source>
          <target state="translated">Dado que los tipos pueden ser arbitrariamente complejos, es difícil tomar esta determinación recursiva.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For convenience, and to reduce the chance of error, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</source>
          <target state="translated">Por comodidad y para reducir la posibilidad de error, el <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propiedad proporciona un método estándar para distinguir entre los métodos construidos cerrados, que se pueden invocar, y métodos, que no construye a abrir.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, the method cannot be invoked.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propiedad devuelve <ph id="ph2">`true`</ph>, no se puede invocar el método.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property searches recursively for type parameters.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propiedad busca de forma recursiva para parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For example, it returns <ph id="ph1">`true`</ph> for any method in an open type <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> in Visual Basic), even though the method itself is not generic.</source>
          <target state="translated">Por ejemplo, devuelve <ph id="ph1">`true`</ph> para cualquier método en un tipo abierto <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> en Visual Basic), aunque el propio método no es genérico.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Contrast this with the behavior of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property, which returns <ph id="ph2">`false`</ph> for such a method.</source>
          <target state="translated">Compare esto con el comportamiento de la <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> propiedad, que devuelve <ph id="ph2">`false`</ph> para este tipo de método.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Similarly, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property parameter returns <ph id="ph2">`true`</ph> for any constructor in an open type, even though constructors cannot have type parameters of their own.</source>
          <target state="translated">De forma similar, el <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> devuelve el parámetro property <ph id="ph2">`true`</ph> para cualquier constructor en un tipo abierto, aunque los constructores no pueden tener sus propios parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Para obtener una lista de las condiciones invariables de términos específicos de métodos genéricos, vea la <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para obtener una lista de las condiciones invariables en otros términos utilizados en la reflexión genérica, vea la <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Equals(System.Object)">
          <source>An object to compare with this instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que se va a comparar con esta instancia o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Equals(System.Object)">
          <source>Returns a value that indicates whether this instance is equal to a specified object.</source>
          <target state="translated">Devuelve un valor que indica si esta instancia es igual que un objeto especificado.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> equals the type and value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> es igual al tipo y valor de esta instancia; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Returns a <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> object representing the currently executing method.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> que representa el método actualmente en ejecución.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /&gt;</ph> is a static method that is called from within an executing method and that returns information about that method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /&gt;</ph> es un método estático que se llama desde dentro del método que se está ejecutando y devuelve información acerca de ese método.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>A <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> object representing the currently executing method.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> que representa el método actualmente en ejecución.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>If the currently executing method is defined on a generic type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that is returned by <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> is obtained from the generic type definition (that is, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph> returns <ph id="ph4">`true`</ph>).</source>
          <target state="translated">Si el método actualmente en ejecución se define en un tipo genérico, la <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> devuelto por <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> se obtiene de la definición de tipo genérico (es decir, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph> devuelve <ph id="ph4">`true`</ph>).</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Therefore, it does not reflect the type arguments that were used when the method was called.</source>
          <target state="translated">Por lo tanto, no refleja los argumentos de tipo que se utilizaron cuando se llamó al método.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>For example, if a method <ph id="ph1">`M()`</ph> is defined on a generic type <ph id="ph2">`C&lt;T&gt;`</ph> (<ph id="ph3">`C(Of T)`</ph> in Visual Basic), and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> is called from <ph id="ph5">`C&lt;string&gt;.M()`</ph>, then <ph id="ph6">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> returns <ph id="ph7">`C&lt;T&gt;.M()`</ph> (<ph id="ph8">`C(Of T).M()`</ph> in Visual Basic).</source>
          <target state="translated">Por ejemplo, si un método <ph id="ph1">`M()`</ph> se define en un tipo genérico <ph id="ph2">`C&lt;T&gt;`</ph> (<ph id="ph3">`C(Of T)`</ph> en Visual Basic), y <ph id="ph4">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> se llama desde <ph id="ph5">`C&lt;string&gt;.M()`</ph>, a continuación, <ph id="ph6">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> devuelve <ph id="ph7">`C&lt;T&gt;.M()`</ph> (<ph id="ph8">`C(Of T).M()`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>If the currently executing method is a generic method, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> returns the generic method definition.</source>
          <target state="translated">Si el método actualmente en ejecución es un método genérico, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> devuelve la definición de método genérico.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>If the generic method is defined on a generic type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is obtained from the generic type definition.</source>
          <target state="translated">Si el método genérico se define en un tipo genérico, el <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> se obtiene de la definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>The following example defines two types.</source>
          <target state="translated">El siguiente ejemplo define dos tipos.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>The first is a non-generic class, <ph id="ph1">`TestClass`</ph>, includes a constructor, a method named <ph id="ph2">`GetValue`</ph>, and a read-write property named <ph id="ph3">`GetValue`</ph>.</source>
          <target state="translated">La primera es una clase no genérica, <ph id="ph1">`TestClass`</ph>, incluye un constructor, un método denominado <ph id="ph2">`GetValue`</ph>y una propiedad de lectura y escritura denominada <ph id="ph3">`GetValue`</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>The second is a generic class named <ph id="ph1">`TestClass&lt;T&gt;`</ph> that includes a constructor, a <ph id="ph2">`GetValue`</ph> method, and a generic method, <ph id="ph3">`ConvertValue&lt;Y&gt;`</ph>.</source>
          <target state="translated">El segundo es una clase genérica denominada <ph id="ph1">`TestClass&lt;T&gt;`</ph> que incluye un constructor, un <ph id="ph2">`GetValue`</ph> método y un método genérico, <ph id="ph3">`ConvertValue&lt;Y&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Each constructor, method, and property accessor includes a call to the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> method.</source>
          <target state="translated">Cada constructor, el método y el descriptor de acceso de propiedad incluyen una llamada a la <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>This member was invoked with a late-binding mechanism.</source>
          <target state="translated">Este miembro se invocó con un mecanismo de enlace en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Cuando se invoca en tiempo de ejecución a través de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated">Devuelve una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan los argumentos de tipo de un método genérico o los parámetros de tipo de una definición de método genérico.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan los argumentos de tipo de un método genérico o los parámetros de tipo de una definición de método genérico.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Returns an empty array if the current method is not a generic method.</source>
          <target state="translated">Devuelve una matriz vacía si el método actual no es un método genérico.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</source>
          <target state="translated">Los elementos de la matriz devuelta están en el orden en que aparecen en la lista de parámetros de tipo para el método genérico.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>If the current method is a closed constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic method definition.</source>
          <target state="translated">Si el método actual es un método construido cerrado (es decir, el <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propiedad devuelve <ph id="ph2">`false`</ph>), la matriz devuelta por la <ph id="ph3">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> método contiene los tipos que se han asignado a los parámetros de tipo genérico de la definición de método genérico.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>If the current method is a generic method definition, the array contains the type parameters.</source>
          <target state="translated">Si el método actual es una definición de método genérico, la matriz contiene los parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>If the current method is an open constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</source>
          <target state="translated">Si el método actual es un método construido abierto (es decir, el <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propiedad devuelve <ph id="ph2">`true`</ph>) en el que se han asignado tipos específicos a algunos parámetros de tipo y parámetros de tipo de tipos genéricos envolventes se han asignado a otros parámetros de tipo, la matriz contiene tanto tipos como tipo de parámetros.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> propiedad para distinguirlos.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>For a demonstration of this scenario, see the code example provided for the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">Para ver una demostración de este escenario, vea el ejemplo de código proporcionado para el <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Generic constructors are not supported in the .NET Framework version 2.0.</source>
          <target state="translated">Los constructores genéricos no se admiten en la versión 2.0 de .NET Framework.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>This property throws <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> if not overridden in a derived class, so an exception is thrown if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">Esta propiedad produce <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> si no se reemplaza en una clase derivada, por lo que se produce una excepción si la instancia actual es de tipo <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Para obtener una lista de las condiciones invariables de términos específicos de métodos genéricos, vea la <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para obtener una lista de las condiciones invariables en otros términos utilizados en la reflexión genérica, vea la <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>The current object is a <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>.</source>
          <target state="translated">El objeto actual es de tipo <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Generic constructors are not supported in the .NET Framework version 2.0.</source>
          <target state="translated">Los constructores genéricos no se admiten en la versión 2.0 de .NET Framework.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>This exception is the default behavior if this method is not overridden in a derived class.</source>
          <target state="translated">Esta excepción es el comportamiento predeterminado si no se reemplaza este método en una clase derivada.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Devuelve el código hash de esta instancia.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Código hash de un entero de 32 bits con signo.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>When overridden in a derived class, gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</source>
          <target state="translated">Cuando se reemplaza en una clase derivada, obtiene un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> que proporciona el acceso a la secuencia de MSIL, las variables locales y las excepciones del método actual.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> que proporciona el acceso a la secuencia de MSIL, las variables locales y las excepciones del método actual.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>You do not have to override the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> in order to use it.</source>
          <target state="translated">No es necesario reemplazar el <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> para poder utilizarlo.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>You can call the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> method on <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects, because the method is overridden in the runtime versions of these classes.</source>
          <target state="translated">Puede llamar a la <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> método <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> y <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objetos, porque el método se invalida en las versiones en tiempo de ejecución de estas clases.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>For example, the runtime version of the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class derives from the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class, which in turn derives from the <ph id="ph3">&lt;xref:System.Reflection.MethodBase&gt;</ph> class.</source>
          <target state="translated">Por ejemplo, la versión en tiempo de ejecución de la <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> clase se deriva de la <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> (clase), que a su vez se deriva de la <ph id="ph3">&lt;xref:System.Reflection.MethodBase&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The following code example defines a test method named <ph id="ph1">`MethodBodyExample`</ph> and displays its local variable information and exception-handling clauses.</source>
          <target state="translated">En el ejemplo de código siguiente se define un método de prueba denominado <ph id="ph1">`MethodBodyExample`</ph> y se muestra su información de variables locales y cláusulas de control de excepciones.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType&gt;</ph> method is used to obtain a <ph id="ph2">&lt;xref:System.Reflection.MethodBody&gt;</ph> object for the test method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType&gt;</ph> método se utiliza para obtener un <ph id="ph2">&lt;xref:System.Reflection.MethodBody&gt;</ph> objeto del método de prueba.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBody.LocalVariables%2A&gt;</ph> property is used to obtain a list of <ph id="ph2">&lt;xref:System.Reflection.LocalVariableInfo&gt;</ph> objects and display their types and index order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.MethodBody.LocalVariables%2A&gt;</ph> propiedad se utiliza para obtener una lista de <ph id="ph2">&lt;xref:System.Reflection.LocalVariableInfo&gt;</ph> objetos y mostrar sus tipos y orden de índice.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A&gt;</ph> property is used to obtain a list of exception-handling clauses.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A&gt;</ph> propiedad se utiliza para obtener una lista de cláusulas de control de excepciones.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>Not all computer languages can generate <ph id="ph1">&lt;xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType&gt;</ph> clauses.</source>
          <target state="translated">No todos los lenguajes de programación pueden generar <ph id="ph1">&lt;xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType&gt;</ph> cláusulas.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The Visual Basic example shows a filter clause, using a Visual Basic <ph id="ph1">`When`</ph> expression, which is omitted from the examples for other languages.</source>
          <target state="translated">El ejemplo de Visual Basic muestra una cláusula de filtro, utilizando un de Visual Basic <ph id="ph1">`When`</ph> expresión, que se omite en los ejemplos de otros lenguajes.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>This method is invalid unless overridden in a derived class.</source>
          <target state="translated">Este método no es válido a menos que se reemplace en una clase derivada.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>for the access to metadata for members.</source>
          <target state="translated">Para obtener acceso a los metadatos para los miembros.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>Permission value: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Valor del permiso: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodBase">
          <source>Gets method information using the specified handle.</source>
          <target state="translated">Obtiene información de método mediante el identificador especificado.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>The method's handle.</source>
          <target state="translated">Identificador del método.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>Gets method information by using the method's internal metadata representation (handle).</source>
          <target state="translated">Obtiene información del método por medio de la representación interna de metadatos del método (identificador).</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>A <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> containing information about the method.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> que contiene información sobre el método.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>Handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Identificadores son válidos únicamente en el dominio de aplicación en el que se obtuvieron.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> no es válido.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Cuando se invoca en tiempo de ejecución a través de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A handle to the internal metadata representation of a constructor or method.</source>
          <target state="translated">Identificador de la representación interna de metadatos de un constructor o método.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A handle to the generic type that defines the constructor or method.</source>
          <target state="translated">Identificador del tipo genérico que define el constructor o método.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object for the constructor or method represented by the specified handle, for the specified generic type.</source>
          <target state="translated">Obtiene un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> que corresponde al constructor o el método representado por el identificador especificado, para el tipo genérico especificado.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object representing the method or constructor specified by <ph id="ph2">&lt;paramref name="handle" /&gt;</ph>, in the generic type specified by <ph id="ph3">&lt;paramref name="declaringType" /&gt;</ph>.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> que representa el método o el constructor especificado por <ph id="ph2">&lt;paramref name="handle" /&gt;</ph>, en el tipo genérico especificado por <ph id="ph3">&lt;paramref name="declaringType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>Handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Identificadores son válidos únicamente en el dominio de aplicación en el que se obtuvieron.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A <ph id="ph1">&lt;xref:System.RuntimeMethodHandle&gt;</ph> structure for a constructor or method of a generic type can represent different <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> objects, depending on the types specified for the type parameters of the generic type.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.RuntimeMethodHandle&gt;</ph> estructura de un constructor o método de un tipo genérico puede representar diferentes <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> objetos, dependiendo de los tipos especificados por los parámetros del tipo genérico.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>For example, if <ph id="ph1">`class G&lt;T&gt;`</ph> (<ph id="ph2">`class G(Of T)`</ph> in Visual Basic, <ph id="ph3">`generic &lt;T&gt; ref class G`</ph> in C++) has a method that returns type <ph id="ph4">`T`</ph>, the <ph id="ph5">&lt;xref:System.Reflection.MethodBase&gt;</ph> object for that method in a constructed class such as <ph id="ph6">`G&lt;int&gt;`</ph> is different from the <ph id="ph7">&lt;xref:System.Reflection.MethodBase&gt;</ph> object for that method in the generic type definition.</source>
          <target state="translated">Por ejemplo, si <ph id="ph1">`class G&lt;T&gt;`</ph> (<ph id="ph2">`class G(Of T)`</ph> en Visual Basic, <ph id="ph3">`generic &lt;T&gt; ref class G`</ph> en C++) tiene un método que devuelve el tipo <ph id="ph4">`T`</ph>, el <ph id="ph5">&lt;xref:System.Reflection.MethodBase&gt;</ph> de los objetos de ese método en una clase construida como <ph id="ph6">`G&lt;int&gt;`</ph> es diferente de la <ph id="ph7">&lt;xref:System.Reflection.MethodBase&gt;</ph> objeto de ese método en la definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> no es válido.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Cuando se invoca en tiempo de ejecución a través de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags.</source>
          <target state="translated">Cuando se reemplaza en una clase derivada, devuelve las marcas <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>The <ph id="ph1">&lt;see langword="MethodImplAttributes" /&gt;</ph> flags.</source>
          <target state="translated">Marcas <ph id="ph1">&lt;see langword="MethodImplAttributes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>The following example defines a constructor in a dynamic assembly and then uses the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> method to display the method implementation flags that are set by default.</source>
          <target state="translated">En el ejemplo siguiente se define un constructor en un ensamblado dinámico y, a continuación, usa el <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> método para mostrar los marcadores de implementación de método que se establecen de forma predeterminada.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Cuando se invoca en tiempo de ejecución a través de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>When overridden in a derived class, gets the parameters of the specified method or constructor.</source>
          <target state="translated">Cuando se reemplaza en una clase derivada, obtiene los parámetros del método o constructor especificado.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>An array of type <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph> containing information that matches the signature of the method (or constructor) reflected by this <ph id="ph2">&lt;see langword="MethodBase" /&gt;</ph> instance.</source>
          <target state="translated">Matriz de tipo <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph> con información que coincide con la firma del método (o constructor) que refleja esta instancia de <ph id="ph2">&lt;see langword="MethodBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> method to retrieve the parameters of the <ph id="ph2">`Invoke`</ph> method of a delegate.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> método para recuperar los parámetros de la <ph id="ph2">`Invoke`</ph> método de un delegado.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>The example defines a delegate named <ph id="ph1">`MyDelegate`</ph> and an event named <ph id="ph2">`ev`</ph> of type <ph id="ph3">`MyDelegate`</ph>.</source>
          <target state="translated">En el ejemplo se define un delegado denominado <ph id="ph1">`MyDelegate`</ph> y un evento denominado <ph id="ph2">`ev`</ph> de tipo <ph id="ph3">`MyDelegate`</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>The code in the <ph id="ph1">`Main`</ph> method discovers the event signature by getting the delegate type of the event, getting the <ph id="ph2">`Invoke`</ph> method of the delegate type, and then retrieving and displaying the parameters.</source>
          <target state="translated">El código en el <ph id="ph1">`Main`</ph> método detecta la firma del evento obteniendo el tipo de delegado del evento, obtener el <ph id="ph2">`Invoke`</ph> método para el tipo de delegado y, a continuación, recuperar y mostrar los parámetros.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Cuando se invoca en tiempo de ejecución a través de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodBase">
          <source>Invokes the method or constructor reflected by this <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> instance.</source>
          <target state="translated">Invoca el método o constructor que refleja esta instancia de <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The object on which to invoke the method or constructor.</source>
          <target state="translated">Objeto en el que se va a invocar al método o constructor.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a method is static, this argument is ignored.</source>
          <target state="translated">Si el método es estático, se omite este argumento.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a constructor is static, this argument must be <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an instance of the class that defines the constructor.</source>
          <target state="translated">Si un constructor es estático, este argumento debe ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> o una instancia de la clase que define el constructor.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>An argument list for the invoked method or constructor.</source>
          <target state="translated">Lista de argumentos del método o constructor invocado.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</source>
          <target state="translated">Esta es una matriz de objetos con el mismo número, orden y tipo que los parámetros del método o constructor al que se van a invocar.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If there are no parameters, <bpt id="p1">&lt;c&gt;</bpt>parameters<ept id="p1">&lt;/c&gt;</ept> should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si no hay ningún parámetro, <bpt id="p1">&lt;c&gt;</bpt>parameters<ept id="p1">&lt;/c&gt;</ept> debe ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If the method or constructor represented by this instance takes a <ph id="ph1">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function.</source>
          <target state="translated">Si el método o constructor representado por esta instancia tiene un parámetro <ph id="ph1">&lt;see langword="ref" /&gt;</ph> (<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> en Visual Basic), no es necesario ningún atributo especial para ese parámetro para invocar el método o constructor mediante esta función.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</source>
          <target state="translated">Cualquier objeto de esta matriz que no se inicialice explícitamente con un valor contendrá el valor predeterminado de este tipo de objeto.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>For reference-type elements, this value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Para los elementos de tipo de referencia, este valor es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>For value-type elements, this value is 0, 0.0, or <ph id="ph1">&lt;see langword="false" /&gt;</ph>, depending on the specific element type.</source>
          <target state="translated">Para los elementos de tipo de valor, este valor es 0, 0.0 o <ph id="ph1">&lt;see langword="false" /&gt;</ph>, en función del tipo de elemento específico.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Invokes the method or constructor represented by the current instance, using the specified parameters.</source>
          <target state="translated">Invoca el método o constructor representado por la instancia actual, utilizando los parámetros especificados.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>An object containing the return value of the invoked method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> in the case of a constructor.</source>
          <target state="translated">Objeto que contiene el valor devuelto del método invocado, o <ph id="ph1">&lt;see langword="null" /&gt;</ph> en caso de un constructor.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>This is a convenience method that calls the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph> method overload, passing <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Default&gt;</ph> for <ph id="ph3">`invokeAttr`</ph> and <ph id="ph4">`null`</ph> for <ph id="ph5">`binder`</ph> and <ph id="ph6">`culture`</ph>.</source>
          <target state="translated">Se trata de un método de conveniencia que llama el <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph> sobrecarga del método, pasando <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Default&gt;</ph> para <ph id="ph3">`invokeAttr`</ph> y <ph id="ph4">`null`</ph> para <ph id="ph5">`binder`</ph> y <ph id="ph6">`culture`</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If the invoked method throws an exception, the <ph id="ph1">&lt;xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType&gt;</ph> method returns the exception.</source>
          <target state="translated">Si el método invocado produce una excepción, el <ph id="ph1">&lt;xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType&gt;</ph> método devuelve la excepción.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>To invoke a static method using its <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object, pass <ph id="ph2">`null`</ph> for <ph id="ph3">`obj`</ph>.</source>
          <target state="translated">Para invocar un método estático utilizando su <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> de objetos, pasar <ph id="ph2">`null`</ph> para <ph id="ph3">`obj`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If this method overload is used to invoke an instance constructor, the object supplied for <ph id="ph1">`obj`</ph> is reinitialized; that is, all instance initializers are executed.</source>
          <target state="translated">Si esta sobrecarga del método se utiliza para invocar un constructor de instancia, el objeto proporcionado para <ph id="ph1">`obj`</ph> se reinicializa; es decir, se ejecutan todos los inicializadores de instancia.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">El valor devuelto es <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</source>
          <target state="translated">Si se invoca un constructor de clase, la clase es reinicializada; es decir, se ejecutan todos los inicializadores de clase.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">El valor devuelto es <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">A partir de la <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, este método se puede utilizar para tener acceso a miembros no públicos si se ha concedido el autor de llamada <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con el <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> marca y, si el conjunto de permisos de los miembros no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>consideraciones de seguridad para la reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Para utilizar esta funcionalidad, la aplicación debe utilizar <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o posterior como destino.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a parameter of the current method is a value type, and the corresponding argument in <ph id="ph1">`parameters`</ph> is <ph id="ph2">`null`</ph>, the runtime passes a zero-initialized instance of the value type.</source>
          <target state="translated">Si un parámetro del método actual es un tipo de valor y el argumento correspondiente en <ph id="ph1">`parameters`</ph> es <ph id="ph2">`null`</ph>, el tiempo de ejecución pasa una instancia del tipo de valor inicializa a cero.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The following code example demonstrates dynamic method lookup using reflection.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra la búsqueda del método dinámico utilizando la reflexión.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Note that you cannot use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.</source>
          <target state="translated">Tenga en cuenta que no se puede utilizar el <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto de la clase base para invocar el método invalidado en la clase derivada, porque el enlace más tarde, no puede resolver invalidaciones.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> instead.</source>
          <target state="translated">En <bpt id="p1">[</bpt>.NET para aplicaciones de la Tienda Windows<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> o la <bpt id="p2">[</bpt>Biblioteca de clases portable<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, capture <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> en su lugar.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and the method is not static.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph> y el método no es estático.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The method is not declared or inherited by the class of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated">La clase de <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> no declara ni hereda el método.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>A static constructor is invoked, and <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is neither <ph id="ph2">&lt;see langword="null" /&gt;</ph> nor an instance of the class that declared the constructor.</source>
          <target state="translated">Se invoca un constructor estático, y <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> no es ni <ph id="ph2">&lt;see langword="null" /&gt;</ph> ni una instancia de la clase que declaró el constructor.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The elements of the <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> array do not match the signature of the method or constructor reflected by this instance.</source>
          <target state="translated">Los elementos de la matriz <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> no coinciden con la firma del método o constructor que esta instancia refleja.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The invoked method or constructor throws an exception.</source>
          <target state="translated">El método o constructor invocado produce una excepción.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The current instance is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph> that contains unverifiable code.</source>
          <target state="translated">La instancia actual es un <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph> que contiene código no comprobable.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>See the "Verification" section in Remarks for <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>.</source>
          <target state="translated">Vea la sección "Comprobación" en Comentarios para <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> array does not have the correct number of arguments.</source>
          <target state="translated">La matriz <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> no tiene el número correcto de argumentos.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.MemberAccessException" /&gt;</ph>, instead.</source>
          <target state="translated">En <bpt id="p1">[</bpt>.NET para aplicaciones de la Tienda Windows<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> o la <bpt id="p2">[</bpt>Biblioteca de clases portable<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, capture en su lugar la excepción de clase base, <ph id="ph1">&lt;see cref="T:System.MemberAccessException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The caller does not have permission to execute the method or constructor that is represented by the current instance.</source>
          <target state="translated">El autor de la llamada no tiene permiso para ejecutar el método o constructor representado por la instancia actual.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The type that declares the method is an open generic type.</source>
          <target state="translated">El tipo que declara el método es un tipo genérico abierto.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph> for the declaring type.</source>
          <target state="translated">Es decir, la propiedad <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> devuelve <ph id="ph2">&lt;see langword="true" /&gt;</ph> para el tipo declarador.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The current instance is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</source>
          <target state="translated">La instancia actual es un <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Cuando se invoca en tiempo de ejecución a través de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The object on which to invoke the method or constructor.</source>
          <target state="translated">Objeto en el que se va a invocar al método o constructor.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a method is static, this argument is ignored.</source>
          <target state="translated">Si el método es estático, se omite este argumento.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a constructor is static, this argument must be <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an instance of the class that defines the constructor.</source>
          <target state="translated">Si un constructor es estático, este argumento debe ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> o una instancia de la clase que define el constructor.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A bitmask that is a combination of 0 or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Una máscara de bits que es una combinación de 0 o más marcas de bits de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this parameter is assigned the value <ph id="ph2">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>; thus, whatever you pass in is ignored.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> es <ph id="ph1">&lt;see langword="null" /&gt;</ph>, se asigna el valor <ph id="ph2">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph> a este parámetro; por lo tanto, se omite cualquier valor que se pase.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects via reflection.</source>
          <target state="translated">Objeto que habilita el enlace, la conversión de tipos de argumentos, las llamadas a miembros y la recuperación de objetos <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> mediante reflexión.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> es <ph id="ph1">&lt;see langword="null" /&gt;</ph>, se usará el enlazador predeterminado.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An argument list for the invoked method or constructor.</source>
          <target state="translated">Lista de argumentos del método o constructor invocado.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</source>
          <target state="translated">Esta es una matriz de objetos con el mismo número, orden y tipo que los parámetros del método o constructor al que se van a invocar.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If there are no parameters, this should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si no hay ningún parámetro, debe ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function.</source>
          <target state="translated">Si el método o constructor que representa esta instancia adopta un parámetro ByRef, éste no necesita ningún atributo especial para que pueda invocar el método o constructor utilizando esta función.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</source>
          <target state="translated">Cualquier objeto de esta matriz que no se inicialice explícitamente con un valor contendrá el valor predeterminado de este tipo de objeto.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For reference-type elements, this value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Para los elementos de tipo de referencia, este valor es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For value-type elements, this value is 0, 0.0, or <ph id="ph1">&lt;see langword="false" /&gt;</ph>, depending on the specific element type.</source>
          <target state="translated">Para los elementos de tipo de valor, este valor es 0, 0.0 o <ph id="ph1">&lt;see langword="false" /&gt;</ph>, en función del tipo de elemento específico.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An instance of <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Instancia de <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> usada para regir la conversión de tipos.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Si es <ph id="ph1">&lt;see langword="null" /&gt;</ph>, se utiliza <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> para el subproceso actual.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>(This is necessary to convert a <ph id="ph1">&lt;see langword="String" /&gt;</ph> that represents 1000 to a <ph id="ph2">&lt;see langword="Double" /&gt;</ph> value, for example, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">(Esto es necesario para convertir un objeto <ph id="ph1">&lt;see langword="String" /&gt;</ph> que representa 1000 en un valor <ph id="ph2">&lt;see langword="Double" /&gt;</ph>, por ejemplo, dado que 1000 se representa de maneras diferentes según la referencia cultural).</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</source>
          <target state="translated">Cuando se reemplaza en una clase derivada, invoca el método o constructor reflejado con los parámetros especificados.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An <ph id="ph1">&lt;see langword="Object" /&gt;</ph> containing the return value of the invoked method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> in the case of a constructor, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the method's return type is <ph id="ph4">&lt;see langword="void" /&gt;</ph>.</source>
          <target state="translated">Un tipo <ph id="ph1">&lt;see langword="Object" /&gt;</ph> que contiene el valor devuelto del método invocado, o un objeto <ph id="ph2">&lt;see langword="null" /&gt;</ph> en el caso de un constructor, o <ph id="ph3">&lt;see langword="null" /&gt;</ph> si el tipo de valor devuelto del método es <ph id="ph4">&lt;see langword="void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Before calling the method or constructor, <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> checks to see if the user has access permission and verifies that the parameters are valid.</source>
          <target state="translated">Antes de llamar al método o constructor, <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> comprueba si el usuario tiene permiso de acceso y si los parámetros son válidos.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Dynamically invokes the method reflected by this instance on <ph id="ph1">`obj`</ph>, and passes along the specified parameters.</source>
          <target state="translated">Invoca dinámicamente el método reflejado por esta instancia en <ph id="ph1">`obj`</ph>y pasa los parámetros especificados.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method is static, the <ph id="ph1">`obj`</ph> parameter is ignored.</source>
          <target state="translated">Si el método es estático, el <ph id="ph1">`obj`</ph> parámetro se ignora.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For non-static methods, <ph id="ph1">`obj`</ph> should be an instance of a class that inherits or declares the method and must be the same type as this class.</source>
          <target state="translated">Para los métodos no estáticos, <ph id="ph1">`obj`</ph> debe ser una instancia de una clase que hereda o declara el método y debe ser del mismo tipo que esta clase.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method has no parameters, the value of <ph id="ph1">`parameters`</ph> should be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si el método no tiene parámetros, el valor de <ph id="ph1">`parameters`</ph> debe ser <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Otherwise, the number, type, and order of elements in <ph id="ph1">`parameters`</ph> should be identical to the number, type, and order of parameters for the method reflected by this instance.</source>
          <target state="translated">En caso contrario, el número, el tipo y el orden de los elementos de <ph id="ph1">`parameters`</ph> debe ser idéntico al número, tipo y orden de los parámetros para el método reflejado por esta instancia.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>You may not omit optional parameters in calls to <ph id="ph1">`Invoke`</ph>.</source>
          <target state="translated">No se puede omitir los parámetros opcionales en las llamadas a <ph id="ph1">`Invoke`</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>To invoke a method omitting optional parameters, you should call <ph id="ph1">`Type.InvokeMember`</ph> instead.</source>
          <target state="translated">Para invocar un método omitiendo los parámetros opcionales, debe llamar a <ph id="ph1">`Type.InvokeMember`</ph> en su lugar.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this method overload is used to invoke an instance constructor, the object supplied for <ph id="ph1">`obj`</ph> is reinitialized; that is, all instance initializers are executed.</source>
          <target state="translated">Si esta sobrecarga del método se utiliza para invocar un constructor de instancia, el objeto proporcionado para <ph id="ph1">`obj`</ph> se reinicializa; es decir, se ejecutan todos los inicializadores de instancia.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">El valor devuelto es <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</source>
          <target state="translated">Si se invoca un constructor de clase, la clase es reinicializada; es decir, se ejecutan todos los inicializadores de clase.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">El valor devuelto es <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For pass-by-value primitive parameters, normal widening is performed (Int16 -&gt; Int32, for example).</source>
          <target state="translated">Para los parámetros primitivos de paso por valor, se realizan la ampliación normal (Int16 -&gt; Int32, por ejemplo).</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type).</source>
          <target state="translated">Para los parámetros de referencia de paso por valor, la ampliación de referencia normal se permite (clase derivada a clase base y la clase base para el tipo de interfaz).</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>However, for pass-by-reference primitive parameters, the types must match exactly.</source>
          <target state="translated">Sin embargo, para los parámetros primitivos de paso por referencia, los tipos deben coincidir exactamente.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For pass-by-reference reference parameters, the normal widening still applies.</source>
          <target state="translated">Para los parámetros de referencia de paso por referencia, la ampliación normal todavía se aplica.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, if the method reflected by this instance is declared as <ph id="ph1">`public boolean Compare(String a, String b)`</ph>, then <ph id="ph2">`parameters`</ph> should be an array of <ph id="ph3">`Objects`</ph> with length 2 such that <ph id="ph4">`parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`</ph>.</source>
          <target state="translated">Por ejemplo, si el método reflejado por esta instancia se declara como <ph id="ph1">`public boolean Compare(String a, String b)`</ph>, a continuación, <ph id="ph2">`parameters`</ph> debe ser una matriz de <ph id="ph3">`Objects`</ph> con una longitud 2 que <ph id="ph4">`parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a parameter of the current method is a value type, and the corresponding argument in <ph id="ph1">`parameters`</ph> is <ph id="ph2">`null`</ph>, the runtime passes a zero-initialized instance of the value type.</source>
          <target state="translated">Si un parámetro del método actual es un tipo de valor y el argumento correspondiente en <ph id="ph1">`parameters`</ph> es <ph id="ph2">`null`</ph>, el tiempo de ejecución pasa una instancia del tipo de valor inicializa a cero.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Reflection uses dynamic method lookup when invoking virtual methods.</source>
          <target state="translated">Reflexión utiliza la búsqueda de método dinámico al invocar métodos virtuales.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a <ph id="ph1">`MethodInfo`</ph> object that represents M on class A. If you use the <ph id="ph2">`Invoke`</ph> method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).</source>
          <target state="translated">Por ejemplo, suponga que la clase B hereda de la clase A y ambas implementan un método virtual denominado m. Ahora suponga que tiene un <ph id="ph1">`MethodInfo`</ph> objeto que representa a M en la clase A. Si usas el <ph id="ph2">`Invoke`</ph> método para invocar M en un objeto de tipo B, a continuación, la reflexión utilizará la implementación proporcionada por la clase B. Incluso si el objeto de tipo B se convierte en una, se utiliza la implementación proporcionada por la clase B (vea el ejemplo de código siguiente).</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the <ph id="ph1">`MethodInfo`</ph> was obtained, regardless of the type of the object passed as the target.</source>
          <target state="translated">Por otro lado, si el método no es virtual, a continuación, la reflexión utilizará la implementación proporcionada por el tipo desde el que el <ph id="ph1">`MethodInfo`</ph> obtuvo, independientemente del tipo del objeto pasado como el destino.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Access restrictions are ignored for fully trusted code.</source>
          <target state="translated">Se omiten las restricciones de acceso de código de plena confianza.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</source>
          <target state="translated">Es decir, las propiedades, métodos, campos y constructores privados se pueden acceso e invocar mediante reflexión siempre que el código es de plena confianza.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the invoked method throws an exception, <ph id="ph1">`TargetInvocationException.GetException`</ph> returns the exception.</source>
          <target state="translated">Si el método invocado produce una excepción, <ph id="ph1">`TargetInvocationException.GetException`</ph> devuelve la excepción.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This implementation throws a <ph id="ph1">`NotSupportedException`</ph>.</source>
          <target state="translated">Esta implementación produce un <ph id="ph1">`NotSupportedException`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">A partir de la <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, este método se puede utilizar para tener acceso a miembros no públicos si se ha concedido el autor de llamada <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con el <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> marca y, si el conjunto de permisos de los miembros no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>consideraciones de seguridad para la reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Para utilizar esta funcionalidad, la aplicación debe utilizar <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o posterior como destino.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The following example demonstrates all members of the <ph id="ph1">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class using an overload of <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">El ejemplo siguiente muestra todos los miembros de la <ph id="ph1">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> usa una sobrecarga de la clase <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The private method <ph id="ph1">`CanConvertFrom`</ph> finds compatible types for a given type.</source>
          <target state="translated">El método privado <ph id="ph1">`CanConvertFrom`</ph> busca tipos compatibles con un tipo determinado.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For another example of invoking members in a custom binding scenario, see <bpt id="p1">[</bpt>Dynamically Loading and Using Types<ept id="p1">](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md)</ept>.</source>
          <target state="translated">Para obtener otro ejemplo de invocación de miembros en un escenario de enlace personalizado, vea <bpt id="p1">[</bpt>cargar y utilizar tipos dinámicamente<ept id="p1">](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and the method is not static.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph> y el método no es estático.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The method is not declared or inherited by the class of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated">La clase de <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> no declara ni hereda el método.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A static constructor is invoked, and <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is neither <ph id="ph2">&lt;see langword="null" /&gt;</ph> nor an instance of the class that declared the constructor.</source>
          <target state="translated">Se invoca un constructor estático, y <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> no es ni <ph id="ph2">&lt;see langword="null" /&gt;</ph> ni una instancia de la clase que declaró el constructor.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of the <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> parameter does not match the signature of the method or constructor reflected by this instance.</source>
          <target state="translated">El tipo del parámetro <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> no coincide con la firma del método o constructor que esta instancia refleja.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> array does not have the correct number of arguments.</source>
          <target state="translated">La matriz <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> no tiene el número correcto de argumentos.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The invoked method or constructor throws an exception.</source>
          <target state="translated">El método o constructor invocado produce una excepción.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The caller does not have permission to execute the method or constructor that is represented by the current instance.</source>
          <target state="translated">El autor de la llamada no tiene permiso para ejecutar el método o constructor representado por la instancia actual.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The type that declares the method is an open generic type.</source>
          <target state="translated">El tipo que declara el método es un tipo genérico abierto.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph> for the declaring type.</source>
          <target state="translated">Es decir, la propiedad <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> devuelve <ph id="ph2">&lt;see langword="true" /&gt;</ph> para el tipo declarador.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Cuando se invoca en tiempo de ejecución a través de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>Gets a value indicating whether the method is abstract.</source>
          <target state="translated">Obtiene un valor que indica si el método es abstracto.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method is abstract; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el método es abstracto; de lo contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>An abstract member is declared on a base class and has no implementation supplied.</source>
          <target state="translated">Un miembro abstracto se declara en una clase base y no ha proporcionado ninguna implementación.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, first get the type.</source>
          <target state="translated">Para obtener el <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, primero hay que obtener el tipo.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>From the type, get the method.</source>
          <target state="translated">A partir del tipo, obtenga el método.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>From the method, get the <ph id="ph1">`MethodBase`</ph>.</source>
          <target state="translated">A partir del método, obtenga el <ph id="ph1">`MethodBase`</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>If the <ph id="ph1">`MethodBase`</ph> or constructor is other than public, it is protected and cannot be readily accessed.</source>
          <target state="translated">Si el <ph id="ph1">`MethodBase`</ph> o constructor no son públicos, están protegido y no se puede obtener acceso inmediato.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>To access a non-public method, set the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> mask to <ph id="ph2">`NonPublic`</ph> in <ph id="ph3">`GetMethod`</ph>.</source>
          <target state="translated">Para obtener acceso a un método no público, establezca la <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> enmascarar a <ph id="ph2">`NonPublic`</ph> en <ph id="ph3">`GetMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>The following example determines whether specified the method is abstract and displays the result.</source>
          <target state="translated">En el ejemplo siguiente se determina si el método especificado es abstracto y muestra el resultado.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>Gets a value indicating whether the potential visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph>; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph> describe la visibilidad posible de este método o constructor; es decir, el método o el constructor es visible como mucho para otros tipos del mismo ensamblado y no es visible para los tipos derivados fuera del ensamblado.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the visibility of this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph> describe exactamente la visibilidad de este método o constructor; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The actual visibility of a method is limited by the visibility of its type.</source>
          <target state="translated">La visibilidad real de un método está limitada por la visibilidad de su tipo.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph> property might be <ph id="ph2">`true`</ph> for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph> propiedad podría ser <ph id="ph2">`true`</ph> para un método, pero si se trata de un método de un tipo anidado privado, a continuación, el método no es visible fuera del tipo contenedor.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType&gt;</ph> if the only visibility modifier is <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic).</source>
          <target state="translated">Describe exactamente la visibilidad de un método o constructor <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType&gt;</ph> si el modificador de visibilidad solo es <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>This property is <ph id="ph1">`false`</ph> for methods that are <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++); use the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property to identify such methods.</source>
          <target state="translated">Esta propiedad es <ph id="ph1">`false`</ph> para los métodos que son <ph id="ph2">`protected internal`</ph> en C# (<ph id="ph3">`Protected Friend`</ph> en Visual Basic, <ph id="ph4">`protected public`</ph> en C++); use la <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> propiedad para identificar estos métodos.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">En el ejemplo de código siguiente se definen métodos con distintos niveles de visibilidad y muestra los valores de sus <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, y <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">Los lenguajes Visual Basic y C# no pueden definir métodos con <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibilidad; que se muestra el nivel de acceso sólo en el ejemplo de C++.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source>Gets a value indicating whether the method is a constructor.</source>
          <target state="translated">Obtiene un valor que indica si el método es un constructor.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is a constructor represented by a <ph id="ph2">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object (see note in Remarks about <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.ConstructorBuilder" /&gt;</ph> objects); otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si este método es un constructor representado por un objeto <ph id="ph2">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> (vea los Comentarios de los objetos <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.ConstructorBuilder" /&gt;</ph>); de lo contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsConstructor%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for a <ph id="ph3">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object in a dynamic type, unless the <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType&gt;</ph> flag was included in the <ph id="ph5">`attributes`</ph> parameter when the constructor was defined.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsConstructor%2A&gt;</ph> propiedad devuelve <ph id="ph2">`false`</ph> para un <ph id="ph3">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> objeto en un tipo dinámico, a menos que la <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType&gt;</ph> marca se incluyó en el <ph id="ph5">`attributes`</ph> parámetro cuando se definió el constructor.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source>Omitting the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph> flag does not affect the correctness of the emitted constructor.</source>
          <target state="translated">Si se omite la <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph> marca no afecta a la validez del constructor emitido.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>Gets a value indicating whether the visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph>; that is, the method or constructor is visible only within its class and derived classes.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph> describe la visibilidad de este método o constructor; es decir, el método o el constructor sólo es visible dentro de su clase y clases derivadas.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph> describe exactamente el acceso a este método o constructor; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType&gt;</ph> if the only visibility modifier is <ph id="ph2">`protected`</ph>.</source>
          <target state="translated">Describe exactamente la visibilidad de un método o constructor <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType&gt;</ph> si el modificador de visibilidad solo es <ph id="ph2">`protected`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>This property is <ph id="ph1">`false`</ph> for methods that are <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++); use the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property to identify such methods.</source>
          <target state="translated">Esta propiedad es <ph id="ph1">`false`</ph> para los métodos que son <ph id="ph2">`protected internal`</ph> en C# (<ph id="ph3">`Protected Friend`</ph> en Visual Basic, <ph id="ph4">`protected public`</ph> en C++); use la <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> propiedad para identificar estos métodos.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">En el ejemplo de código siguiente se definen métodos con distintos niveles de visibilidad y muestra los valores de sus <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, y <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">Los lenguajes Visual Basic y C# no pueden definir métodos con <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibilidad; que se muestra el nivel de acceso sólo en el ejemplo de C++.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>Gets a value indicating whether the visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph>; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph> describe la visibilidad de este método o constructor; es decir, las clases derivadas pueden llamar al método o constructor, pero sólo si están en el mismo ensamblado.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph> describe exactamente el acceso a este método o constructor; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> if the visibility modifier is <ph id="ph2">`protected private`</ph> in C++.</source>
          <target state="translated">Describe exactamente la visibilidad de un método o constructor <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> si el modificador de visibilidad es <ph id="ph2">`protected private`</ph> en C++.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>Methods with this visibility cannot be defined in Visual Basic or C#.</source>
          <target state="translated">No se pueden definir métodos con esta visibilidad en Visual Basic o C#.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">En el ejemplo de código siguiente se definen métodos con distintos niveles de visibilidad y muestra los valores de sus <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, y <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">Los lenguajes Visual Basic y C# no pueden definir métodos con <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibilidad; que se muestra el nivel de acceso sólo en el ejemplo de C++.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>Gets a value indicating whether the potential visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph>; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph> describe la visibilidad posible de este método o constructor; es decir, las clases derivadas pueden llamar al método o constructor con independencia de dónde se encuentren, así como las clases del mismo ensamblado.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph> describe exactamente el acceso a este método o constructor; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>If a type member has <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</source>
          <target state="translated">Si tiene un miembro de tipo <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> visibilidad, pueda llamarse desde cualquier miembro en una clase derivada o cualquier miembro del mismo ensamblado, pero no de cualquier otro tipo.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The actual visibility of a method is limited by the visibility of its type.</source>
          <target state="translated">La visibilidad real de un método está limitada por la visibilidad de su tipo.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property might be <ph id="ph2">`true`</ph> for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> propiedad podría ser <ph id="ph2">`true`</ph> para un método, pero si se trata de un método de un tipo anidado privado, a continuación, el método no es visible fuera del tipo contenedor.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> if the visibility modifier is <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++).</source>
          <target state="translated">Describe exactamente la visibilidad de un método o constructor <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> si el modificador de visibilidad es <ph id="ph2">`protected internal`</ph> en C# (<ph id="ph3">`Protected Friend`</ph> en Visual Basic, <ph id="ph4">`protected public`</ph> en C++).</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">En el ejemplo de código siguiente se definen métodos con distintos niveles de visibilidad y muestra los valores de sus <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, y <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">Los lenguajes Visual Basic y C# no pueden definir métodos con <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibilidad; que se muestra el nivel de acceso sólo en el ejemplo de C++.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>Gets a value indicating whether this method is <ph id="ph1">&lt;see langword="final" /&gt;</ph>.</source>
          <target state="translated">Obtiene un valor que indica si este método es <ph id="ph1">&lt;see langword="final" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is <ph id="ph2">&lt;see langword="final" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si este método es <ph id="ph2">&lt;see langword="final" /&gt;</ph>; en caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>To determine if a method is overridable, it is not sufficient to check that <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsVirtual%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Para determinar si un método es reemplazable, no es suficiente comprobar que <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsVirtual%2A&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>For a method to be overridable, <ph id="ph1">`IsVirtual`</ph> must be <ph id="ph2">`true`</ph> and <ph id="ph3">`IsFinal`</ph> must be <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Para un método se pueda reemplazar, <ph id="ph1">`IsVirtual`</ph> debe ser <ph id="ph2">`true`</ph> y <ph id="ph3">`IsFinal`</ph> debe ser <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>For example, a method might be non-virtual, but it implements an interface method.</source>
          <target state="translated">Por ejemplo, un método podría ser no virtual, pero implementa un método de interfaz.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>The common language runtime requires that all methods that implement interface members must be marked as <ph id="ph1">`virtual`</ph>; therefore, the compiler marks the method <ph id="ph2">`virtual final`</ph>.</source>
          <target state="translated">Common language runtime requiere que todos los métodos que implementan miembros de interfaz deben marcarse como <ph id="ph1">`virtual`</ph>; por lo tanto, el compilador marca el método <ph id="ph2">`virtual final`</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>So there are cases where a method is marked as <ph id="ph1">`virtual`</ph> but is still not overridable.</source>
          <target state="translated">Por lo que hay casos donde un método está marcado como <ph id="ph1">`virtual`</ph> , pero no es reemplazable.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>To establish with certainty whether a method is overridable, use code such as this:</source>
          <target state="translated">Para establecer con certeza si un método es reemplazable, utilice código como este:</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>If <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`false`</ph> or <ph id="ph3">`IsFinal`</ph> is <ph id="ph4">`true`</ph>, then the method cannot be overridden.</source>
          <target state="translated">Si <ph id="ph1">`IsVirtual`</ph> es <ph id="ph2">`false`</ph> o <ph id="ph3">`IsFinal`</ph> es <ph id="ph4">`true`</ph>, a continuación, no se puede invalidar el método.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>The following example displays <ph id="ph1">`false`</ph> for <ph id="ph2">`IsFinal`</ph>, which might lead you to think that MyMethod is overridable.</source>
          <target state="translated">En el ejemplo siguiente se muestra <ph id="ph1">`false`</ph> para <ph id="ph2">`IsFinal`</ph>, que puede llevarle a pensar que MyMethod se puede reemplazar.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>The code prints <ph id="ph1">`false`</ph> even though MyMethod is not marked <ph id="ph2">`virtual`</ph> and thus cannot be overridden.</source>
          <target state="translated">El código imprime <ph id="ph1">`false`</ph> aunque MyMethod no está marcada como <ph id="ph2">`virtual`</ph> y, por tanto, no se puede invalidar.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Gets a value indicating whether the method is generic.</source>
          <target state="translated">Obtiene un valor que indica si el método es genérico.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> represents a generic method; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> actual representa a un método genérico; en caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> object represents a generic method.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> propiedad para determinar si la actual <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> objeto representa un método genérico.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> object represents an open constructed method or a closed constructed method.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propiedad para determinar si la actual <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> objeto representa un método construido abierto o un método construido cerrado.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Generics are not supported by default; this property returns <ph id="ph1">`false`</ph> if not overridden in a derived class.</source>
          <target state="translated">De forma predeterminada; no admite elementos genéricos Esta propiedad devuelve <ph id="ph1">`false`</ph> si no se reemplaza en una clase derivada.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Generic constructors are not supported in the .NET Framework version 2.0, so this property returns <ph id="ph1">`false`</ph> if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">No se admiten constructores genéricos en .NET Framework versión 2.0, por lo que esta propiedad devuelve <ph id="ph1">`false`</ph> si la instancia actual es de tipo <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The following table summarizes the invariant conditions for terms specific to generic methods.</source>
          <target state="translated">En la tabla siguiente se resume las condiciones invariables de términos específicos de los métodos genéricos.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>For other terms used in generic reflection, such as <bpt id="p1">*</bpt>generic type parameter<ept id="p1">*</ept> and <bpt id="p2">*</bpt>generic type<ept id="p2">*</ept>, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">En otros términos utilizados en la reflexión genérica, como <bpt id="p1">*</bpt>parámetro de tipo genérico<ept id="p1">*</ept> y <bpt id="p2">*</bpt>tipo genérico<ept id="p2">*</ept>, consulte el <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Term</source>
          <target state="translated">Término</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Invariant condition</source>
          <target state="translated">Condición invariable</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>generic method definition</source>
          <target state="translated">definición de método genérico</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Defines a generic method.</source>
          <target state="translated">Define un método genérico.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>A constructed method is created by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition, and specifying an array of type arguments.</source>
          <target state="translated">Se crea un método construido mediante una llamada a la <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> método en un <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto que representa una definición de método genérico y especifica una matriz de argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method can be called only on generic method definitions.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> método puede llamarse únicamente en las definiciones de método genérico.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Any generic method definition is a generic method, but the converse is not true.</source>
          <target state="translated">Cualquier definición de método genérico es un método genérico, pero no al revés.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>generic method</source>
          <target state="translated">método genérico</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">`IsGenericMethod`</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">`IsGenericMethod`</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Can be a generic method definition, an open constructed method, or a closed constructed method.</source>
          <target state="translated">Puede ser una definición de método genérico, un método construido abierto o un método construido cerrado.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>open constructed method</source>
          <target state="translated">Open construido (método)</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>It is not possible to invoke an open constructed method.</source>
          <target state="translated">No es posible invocar un método construido abierto.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>closed constructed method</source>
          <target state="translated">método construido cerrado</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> property is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> es <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>When examined recursively, the method has no unassigned generic parameters.</source>
          <target state="translated">Cuando examina de forma recursiva, el método no tiene ningún parámetro genérico sin asignar.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The containing type has no generic type parameters, and none of the type arguments have generic type parameters.</source>
          <target state="translated">El tipo contenedor no tiene ningún parámetro de tipo genérico y ninguno de los argumentos de tipo tiene parámetros de tipo genérico.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The method can be invoked.</source>
          <target state="translated">Puede invocar el método.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>Gets a value indicating whether the method is a generic method definition.</source>
          <target state="translated">Obtiene un valor que indica si el método es una definición de método genérico.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object represents the definition of a generic method; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> representa la definición de un método genérico; si no, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> represents a generic method definition, then:</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> representa una definición de método genérico, entonces:</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>For each <ph id="ph1">&lt;xref:System.Type&gt;</ph> object in the array returned by the <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> method:</source>
          <target state="translated">Para cada <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto en la matriz devuelta por la <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> método:</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType&gt;</ph> property returns the current instance.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType&gt;</ph> propiedad devuelve la instancia actual.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType&gt;</ph> property is the same as the position of the <ph id="ph2">&lt;xref:System.Type&gt;</ph> object in the array.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType&gt;</ph> propiedad es igual que la posición de la <ph id="ph2">&lt;xref:System.Type&gt;</ph> los objetos de la matriz.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>Generics are not supported by default; this property returns <ph id="ph1">`false`</ph> if not overridden in a derived class.</source>
          <target state="translated">De forma predeterminada; no admite elementos genéricos Esta propiedad devuelve <ph id="ph1">`false`</ph> si no se reemplaza en una clase derivada.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>Generic constructors are not supported in the .NET Framework version 2.0, so this property returns <ph id="ph1">`false`</ph> if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">No se admiten constructores genéricos en .NET Framework versión 2.0, por lo que esta propiedad devuelve <ph id="ph1">`false`</ph> si la instancia actual es de tipo <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Para obtener una lista de las condiciones invariables de términos específicos de métodos genéricos, vea la <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para obtener una lista de las condiciones invariables en otros términos utilizados en la reflexión genérica, vea la <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</source>
          <target state="translated">Obtiene un valor que indica si sólo hay un miembro del mismo tipo y con idéntica firma oculto en la clase derivada.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the member is hidden by signature; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el miembro está oculto por firma; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>When a member in a derived class is declared with the C# <ph id="ph1">`new`</ph> modifier or the Visual Basic <ph id="ph2">`Shadows`</ph> modifier, it can hide a member of the same name in the base class.</source>
          <target state="translated">Cuando se declara un miembro en una clase derivada con C# <ph id="ph1">`new`</ph> modificador o Visual Basic <ph id="ph2">`Shadows`</ph> modificador, puede ocultar un miembro del mismo nombre en la clase base.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>C# hides base class members by signature.</source>
          <target state="translated">C# oculta a los miembros de clase base mediante la firma.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature.</source>
          <target state="translated">Es decir, si el miembro de clase base tiene varias sobrecargas, la única persona que está oculto es aquel que tiene la firma idéntica.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>By contrast, Visual Basic hides all the base class overloads.</source>
          <target state="translated">Por el contrario, Visual Basic oculta todas las sobrecargas de la clase base.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>Thus, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> returns <ph id="ph2">`false`</ph> on a member declared with the Visual Basic <ph id="ph3">`Shadows`</ph> modifier, and <ph id="ph4">`true`</ph> on a member declared with the C# <ph id="ph5">`new`</ph> modifier.</source>
          <target state="translated">Por lo tanto, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> devuelve <ph id="ph2">`false`</ph> en un miembro declarado con el de Visual Basic <ph id="ph3">`Shadows`</ph> modificador, y <ph id="ph4">`true`</ph> en un miembro declarado con C# <ph id="ph5">`new`</ph> modificador.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>This property does not determine whether a method has the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute.</source>
          <target state="translated">Esta propiedad no determina si un método que tiene el <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>A method that is declared with either the <ph id="ph1">`new`</ph> or the <ph id="ph2">`Shadows`</ph> modifier will have the <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, but only methods declared with <ph id="ph4">`new`</ph> (that is, only C# methods) will have the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> property set to <ph id="ph6">`true`</ph>.</source>
          <target state="translated">Un método que se declara con cualquiera el <ph id="ph1">`new`</ph> o <ph id="ph2">`Shadows`</ph> modificador tendrá el <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> atributo, pero sólo los métodos declarados con <ph id="ph4">`new`</ph> (es decir, solo métodos de C#) tendrá la <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> propiedad establecida en <ph id="ph6">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>To determine whether a method has the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, use code similar to the following: <ph id="ph2">`if ((myMethodInfo.Attributes &amp; MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)`</ph> in C# or <ph id="ph3">`If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot`</ph> in Visual Basic.</source>
          <target state="translated">Para determinar si un método que tiene el <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> atributo, use código similar al siguiente: <ph id="ph2">`if ((myMethodInfo.Attributes &amp; MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)`</ph> en C# o <ph id="ph3">`If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot`</ph> en Visual Basic.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>Note, however, that although all methods declared with <ph id="ph1">`new`</ph> or <ph id="ph2">`Shadows`</ph> have the <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, not all methods that have the <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute are declared with <ph id="ph5">`new`</ph> or <ph id="ph6">`Shadows`</ph>.</source>
          <target state="translated">Sin embargo, tenga en cuenta que aunque todos los métodos declaran con <ph id="ph1">`new`</ph> o <ph id="ph2">`Shadows`</ph> tienen la <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> atributo, no todos los métodos que tienen el <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> atributos se declaran con <ph id="ph5">`new`</ph> o <ph id="ph6">`Shadows`</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads.</source>
          <target state="translated">El siguiente ejemplo de código contiene una clase base con un método sobrecargado y una clase derivada que oculta una de las sobrecargas.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>In the Visual Basic version of the code example, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for the member in the derived class.</source>
          <target state="translated">En la versión de Visual Basic del ejemplo de código, el <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> propiedad devuelve <ph id="ph2">`false`</ph> para el miembro de la clase derivada.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>In the C# version of the code sample, the property returns <ph id="ph1">`true`</ph> for the member in the derived class.</source>
          <target state="translated">En la versión de C# del ejemplo de código, se devuelve la propiedad <ph id="ph1">`true`</ph> para el miembro de la clase derivada.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsPrivate">
          <source>Gets a value indicating whether this member is private.</source>
          <target state="translated">Obtiene un valor que indica si este miembro es privado.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPrivate">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method is restricted to other members of the class itself; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el acceso a este método está restringido a otros miembros de la propia clase; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPrivate">
          <source>If a type member has <ph id="ph1">`Private`</ph> level visibility, it can be called from any member in the same class and no others.</source>
          <target state="translated">Si tiene un miembro de tipo <ph id="ph1">`Private`</ph> visibilidad de nivel, se puede llamar desde cualquier miembro de la misma clase.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>Gets a value indicating whether this is a public method.</source>
          <target state="translated">Obtiene un valor que indica si éste es un método público.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is public; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si este método es público; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, first get the type.</source>
          <target state="translated">Para obtener el <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, primero hay que obtener el tipo.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>From the type, get the method.</source>
          <target state="translated">A partir del tipo, obtenga el método.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>From the method, get the <ph id="ph1">`MethodBase`</ph>.</source>
          <target state="translated">A partir del método, obtenga el <ph id="ph1">`MethodBase`</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>If the <ph id="ph1">`MethodBase`</ph> or constructor is other than public, it is protected and cannot be readily accessed.</source>
          <target state="translated">Si el <ph id="ph1">`MethodBase`</ph> o constructor no son públicos, están protegido y no se puede obtener acceso inmediato.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>To access a non-public method, set the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> mask to <ph id="ph2">`NonPublic`</ph> in <ph id="ph3">`GetMethod`</ph>.</source>
          <target state="translated">Para obtener acceso a un método no público, establezca la <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> enmascarar a <ph id="ph2">`NonPublic`</ph> en <ph id="ph3">`GetMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> property to display a message that indicates whether the specified method is public.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> propiedad para mostrar un mensaje que indica si el método especificado es público.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</source>
          <target state="translated">Obtiene un valor que indica si el método o el constructor actual es crítico para la seguridad o es crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual y, por tanto, puede realizar operaciones críticas.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el método o el constructor actual es crítico para la seguridad o crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; <ph id="ph2">&lt;see langword="false" /&gt;</ph> si es transparente.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> propiedades notifican el nivel de transparencia del método o constructor en su nivel de confianza actual, determinado por common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">Las combinaciones de estas propiedades se muestran en la tabla siguiente:</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">Nivel de seguridad</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Crítico</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Safe critical</source>
          <target state="translated">Crítico seguro</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Transparente</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos y miembros, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Para los ensamblados de confianza parcial, el valor de esta propiedad depende del nivel de confianza actual del ensamblado.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Si el ensamblado se carga en un dominio de aplicación de confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el runtime omite las anotaciones de seguridad del ensamblado.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">El ensamblado y todos sus tipos se tratan como transparente.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">El tiempo de ejecución presta atención a las anotaciones de seguridad de un ensamblado de confianza parcial sólo cuando ese ensamblado se carga en un dominio de aplicación de plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio).</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">Por el contrario, un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) siempre se carga con plena confianza, independientemente del nivel de confianza del dominio de aplicación, por lo que su nivel de confianza actual siempre es de plena confianza.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Puede determinar los niveles de confianza actuales de ensamblados y dominios de aplicación mediante el <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre la reflexión y transparencia, consulte <bpt id="p1">[</bpt>consideraciones de seguridad para la reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de las transparencias, consulte <bpt id="p1">[</bpt>cambios de seguridad<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">Obtiene un valor que indica si el método o el constructor actual es crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; es decir, si puede realizar operaciones críticas y está disponible desde código transparente.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method or constructor is security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el método o el constructor es crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; <ph id="ph2">&lt;see langword="false" /&gt;</ph> si es crítico para la seguridad o transparente.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> propiedades notifican el nivel de transparencia del método o constructor en su nivel de confianza actual, determinado por common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">Las combinaciones de estas propiedades se muestran en la tabla siguiente:</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">Nivel de seguridad</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Crítico</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Safe critical</source>
          <target state="translated">Crítico seguro</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Transparente</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos y miembros, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Para los ensamblados de confianza parcial, el valor de esta propiedad depende del nivel de confianza actual del ensamblado.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Si el ensamblado se carga en un dominio de aplicación de confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el runtime omite las anotaciones de seguridad del ensamblado.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">El ensamblado y todos sus tipos se tratan como transparente.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">El tiempo de ejecución presta atención a las anotaciones de seguridad de un ensamblado de confianza parcial sólo cuando ese ensamblado se carga en un dominio de aplicación de plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio).</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">Por el contrario, un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) siempre se carga con plena confianza, independientemente del nivel de confianza del dominio de aplicación, por lo que su nivel de confianza actual siempre es de plena confianza.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Puede determinar los niveles de confianza actuales de ensamblados y dominios de aplicación mediante el <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre la reflexión y transparencia, consulte <bpt id="p1">[</bpt>consideraciones de seguridad para la reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de las transparencias, consulte <bpt id="p1">[</bpt>cambios de seguridad<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</source>
          <target state="translated">Obtiene un valor que indica si el método o el constructor actual es transparente en el nivel de confianza actual y, por tanto, no puede realizar operaciones críticas.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method or constructor is security-transparent at the current trust level; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el método o el constructor es transparente para la seguridad en el nivel de confianza actual; de lo contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>If this property returns <ph id="ph1">`true`</ph>, the <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> properties return <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Si esta propiedad devuelve <ph id="ph1">`true`</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> devuelven propiedades <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> propiedades notifican el nivel de transparencia del método o constructor en su nivel de confianza actual, determinado por common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos y miembros, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Para los ensamblados de confianza parcial, el valor de esta propiedad depende del nivel de confianza actual del ensamblado.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Si el ensamblado se carga en un dominio de aplicación de confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el runtime omite las anotaciones de seguridad del ensamblado.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">El ensamblado y todos sus tipos se tratan como transparente.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">El tiempo de ejecución presta atención a las anotaciones de seguridad de un ensamblado de confianza parcial sólo cuando ese ensamblado se carga en un dominio de aplicación de plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio).</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">Por el contrario, un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) siempre se carga con plena confianza, independientemente del nivel de confianza del dominio de aplicación, por lo que su nivel de confianza actual siempre es de plena confianza.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Puede determinar los niveles de confianza actuales de ensamblados y dominios de aplicación mediante el <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre la reflexión y transparencia, consulte <bpt id="p1">[</bpt>consideraciones de seguridad para la reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de las transparencias, consulte <bpt id="p1">[</bpt>cambios de seguridad<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source>Gets a value indicating whether this method has a special name.</source>
          <target state="translated">Obtiene un valor que indica si este método tiene un nombre especial.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method has a special name; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si este método tiene un nombre especial; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph> bit se establece para marcar los miembros que se tratan de una manera especial por parte de algunos compiladores (por ejemplo, los descriptores de acceso de propiedades y métodos de sobrecarga de operadores).</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source>This example shows a use of <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSpecialName%2A&gt;</ph> to filter internal or private members out of a list.</source>
          <target state="translated">Este ejemplo muestra el uso de <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSpecialName%2A&gt;</ph> para filtrar internos o los miembros privados de una lista.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsStatic">
          <source>Gets a value indicating whether the method is <ph id="ph1">&lt;see langword="static" /&gt;</ph>.</source>
          <target state="translated">Obtiene un valor que indica si el método es <ph id="ph1">&lt;see langword="static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsStatic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is <ph id="ph2">&lt;see langword="static" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si este método es <ph id="ph2">&lt;see langword="static" /&gt;</ph>; en caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsStatic">
          <source>A static member cannot implicitly reference instance data in a class.</source>
          <target state="translated">Un miembro estático implícitamente no puede hacer referencia a datos de instancia de una clase.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>Gets a value indicating whether the method is <ph id="ph1">&lt;see langword="virtual" /&gt;</ph>.</source>
          <target state="translated">Obtiene un valor que indica si el método es <ph id="ph1">&lt;see langword="virtual" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is <ph id="ph2">&lt;see langword="virtual" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si este método es <ph id="ph2">&lt;see langword="virtual" /&gt;</ph>; en caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>A virtual member may reference instance data in a class and must be referenced through an instance of the class.</source>
          <target state="translated">Un miembro virtual puede hacer referencia a datos de instancia de una clase y se debe hacer referencia a través de una instancia de la clase.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>To determine if a method is overridable, it is not sufficient to check that <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Para determinar si un método es reemplazable, no es suficiente comprobar que <ph id="ph1">`IsVirtual`</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>For a method to be overridable, <ph id="ph1">`IsVirtual`</ph> must be <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFinal%2A&gt;</ph> must be <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Para un método se pueda reemplazar, <ph id="ph1">`IsVirtual`</ph> debe ser <ph id="ph2">`true`</ph> y <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFinal%2A&gt;</ph> debe ser <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>For example, a method might be non-virtual, but it implements an interface method.</source>
          <target state="translated">Por ejemplo, un método podría ser no virtual, pero implementa un método de interfaz.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The common language runtime requires that all methods that implement interface members must be marked as <ph id="ph1">`virtual`</ph>; therefore, the compiler marks the method <ph id="ph2">`virtual final`</ph>.</source>
          <target state="translated">Common language runtime requiere que todos los métodos que implementan miembros de interfaz deben marcarse como <ph id="ph1">`virtual`</ph>; por lo tanto, el compilador marca el método <ph id="ph2">`virtual final`</ph>.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>So there are cases where a method is marked as <ph id="ph1">`virtual`</ph> but is still not overridable.</source>
          <target state="translated">Por lo que hay casos donde un método está marcado como <ph id="ph1">`virtual`</ph> , pero no es reemplazable.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>To establish with certainty whether a method is overridable, use code such as this:</source>
          <target state="translated">Para establecer con certeza si un método es reemplazable, utilice código como este:</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>If <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`false`</ph> or <ph id="ph3">`IsFinal`</ph> is <ph id="ph4">`true`</ph>, then the method cannot be overridden.</source>
          <target state="translated">Si <ph id="ph1">`IsVirtual`</ph> es <ph id="ph2">`false`</ph> o <ph id="ph3">`IsFinal`</ph> es <ph id="ph4">`true`</ph>, a continuación, no se puede invalidar el método.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>You can determine whether the current method overrides a method in a base class by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Puede determinar si el método actual invalida un método en una clase base mediante una llamada a la <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The following example implements an <ph id="ph1">`IsOverride`</ph> method that does this.</source>
          <target state="translated">En el ejemplo siguiente se implementa un <ph id="ph1">`IsOverride`</ph> método que lo haga.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The following example displays <ph id="ph1">`false`</ph> for <ph id="ph2">`IsFinal`</ph>, which might lead you to think that <ph id="ph3">`MyMethod`</ph> is overridable.</source>
          <target state="translated">En el ejemplo siguiente se muestra <ph id="ph1">`false`</ph> para <ph id="ph2">`IsFinal`</ph>, que puede llevarle a pensar que <ph id="ph3">`MyMethod`</ph> es reemplazable.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The code prints <ph id="ph1">`false`</ph> even though <ph id="ph2">`MyMethod`</ph> is not marked <ph id="ph3">`virtual`</ph> and thus cannot be overridden.</source>
          <target state="translated">El código imprime <ph id="ph1">`false`</ph> aunque <ph id="ph2">`MyMethod`</ph> no está marcada como <ph id="ph3">`virtual`</ph> y, por tanto, no se puede invalidar.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.MethodHandle">
          <source>Gets a handle to the internal metadata representation of a method.</source>
          <target state="translated">Obtiene un identificador para la representación interna de metadatos de un método.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodHandle">
          <source>A <ph id="ph1">&lt;see cref="T:System.RuntimeMethodHandle" /&gt;</ph> object.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.RuntimeMethodHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodHandle">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Los identificadores son válidos únicamente en el dominio de aplicación en el que se obtuvieron.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.MethodImplementationFlags">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags that specify the attributes of a method implementation.</source>
          <target state="translated">Obtiene las marcas <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> que especifican los atributos de una implementación de método.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodImplementationFlags">
          <source>The method implementation flags.</source>
          <target state="translated">Marcas de implementación de método.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodImplementationFlags">
          <source>See the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> method for more information.</source>
          <target state="translated">Vea el método <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> para más información.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The first object to compare.</source>
          <target state="translated">Primer objeto que se va a comparar.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The second object to compare.</source>
          <target state="translated">Segundo objeto que se va a comparar.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> objects are equal.</source>
          <target state="translated">Indica si dos objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> son iguales.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="left" /&gt;</ph> es igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; en caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The first object to compare.</source>
          <target state="translated">Primer objeto que se va a comparar.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The second object to compare.</source>
          <target state="translated">Segundo objeto que se va a comparar.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Indica si dos objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> no son iguales.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="left" /&gt;</ph> no es igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; en caso contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para un uso futuro.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Debe ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matriz que se pasa con los nombres que se van a asignar.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Número de nombres que se van a asignar.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Contexto de configuración regional en el que se van a interpretar los nombres.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Información de tipos que se va a devolver.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Identificador de la configuración regional de la información de tipo.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Recibe un puntero al objeto de información de tipo solicitado.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Recupera la información de tipo de un objeto, que se puede usar después para obtener la información de tipo de una interfaz.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifica el miembro.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para un uso futuro.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Debe ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Contexto de la configuración regional en que se interpretan los argumentos.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Marcas que describen el contexto de la llamada.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Puntero a la ubicación donde se va a almacenar el resultado.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Puntero a una estructura que contiene información de excepciones.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Índice del primer argumento que tiene un error.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::Invoke`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>