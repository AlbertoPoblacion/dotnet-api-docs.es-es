<Type Name="MethodBase" FullName="System.Reflection.MethodBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5a27c711459e7ed675df80d23d28b658e1d7b113" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MethodBase : System.Reflection.MemberInfo, System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodBase extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodBase&#xA;Inherits MemberInfo&#xA;Implements _MethodBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBase abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_MethodBase" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBase))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="bbff2-101">Proporciona información sobre los métodos y los constructores.</span>
      <span class="sxs-lookup">
        <span data-stu-id="bbff2-101">Provides information about methods and constructors.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-102">`MethodBase` es la clase base de <xref:System.Reflection.MethodInfo> y <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-102">`MethodBase` is the base class of <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="bbff2-103">de plena confianza para los herederos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="bbff2-103">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="bbff2-104">Esta clase no puede heredarse mediante código de confianza parcial.</span>
      <span class="sxs-lookup">
        <span data-stu-id="bbff2-104">This class cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <threadsafe>
      <span data-ttu-id="bbff2-105">Este tipo es seguro para la ejecución de subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="bbff2-105">This type is thread safe.</span>
      </span>
    </threadsafe>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="bbff2-106">Al heredar de <see langword="MethodBase" />, debe reemplazar los miembros siguientes: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> , <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, y <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span>
        <span class="sxs-lookup">
          <span data-stu-id="bbff2-106">When you inherit from <see langword="MethodBase" />, you must override the following members: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, and <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span>
        </span>
      </para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-107">Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.MethodBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-107">Initializes a new instance of the <see cref="T:System.Reflection.MethodBase" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="bbff2-108">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-108">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="bbff2-109">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-109">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-110">Obtiene los atributos asociados a este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-110">Gets the attributes associated with this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-111">Uno de los valores de <see cref="T:System.Reflection.MethodAttributes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-111">One of the <see cref="T:System.Reflection.MethodAttributes" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-112">Todos los miembros tienen un conjunto de atributos, que se definen en relación con el tipo específico del miembro.</span><span class="sxs-lookup"><span data-stu-id="bbff2-112">All members have a set of attributes, which are defined in relation to the specific type of member.</span></span>  
  
 <span data-ttu-id="bbff2-113">Para obtener el <xref:System.Reflection.MethodAttributes>, primero hay que obtener el tipo.</span><span class="sxs-lookup"><span data-stu-id="bbff2-113">To get the <xref:System.Reflection.MethodAttributes>, first get the type.</span></span> <span data-ttu-id="bbff2-114">A partir del tipo, obtenga el método.</span><span class="sxs-lookup"><span data-stu-id="bbff2-114">From the type, get the method.</span></span> <span data-ttu-id="bbff2-115">A partir del método, obtenga el <xref:System.Reflection.MethodAttributes>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-115">From the method, get the <xref:System.Reflection.MethodAttributes>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bbff2-116">En el ejemplo de código siguiente se muestra los atributos del método Mymethod definido por el usuario.</span><span class="sxs-lookup"><span data-stu-id="bbff2-116">The following code example displays the attributes of the user-defined method Mymethod.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 <span data-ttu-id="bbff2-117">Este código genera el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="bbff2-117">This code produces the following output:</span></span>  
  
 <span data-ttu-id="bbff2-118">Ejemplo de Reflection.MethodBase.Attributes</span><span class="sxs-lookup"><span data-stu-id="bbff2-118">Reflection.MethodBase.Attributes Sample</span></span>  
  
 <span data-ttu-id="bbff2-119">Mymethodbase = Mymethod Void (Int32, System.String ByRef, System.String ByRef)</span><span class="sxs-lookup"><span data-stu-id="bbff2-119">Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef)</span></span>  
  
 <span data-ttu-id="bbff2-120">PrivateScope</span><span class="sxs-lookup"><span data-stu-id="bbff2-120">PrivateScope</span></span>  
  
 <span data-ttu-id="bbff2-121">FamANDAssem</span><span class="sxs-lookup"><span data-stu-id="bbff2-121">FamANDAssem</span></span>  
  
 <span data-ttu-id="bbff2-122">Familia</span><span class="sxs-lookup"><span data-stu-id="bbff2-122">Family</span></span>  
  
 <span data-ttu-id="bbff2-123">Public</span><span class="sxs-lookup"><span data-stu-id="bbff2-123">Public</span></span>  
  
 <span data-ttu-id="bbff2-124">HideBySig</span><span class="sxs-lookup"><span data-stu-id="bbff2-124">HideBySig</span></span>  
  
 <span data-ttu-id="bbff2-125">ReuseSlot</span><span class="sxs-lookup"><span data-stu-id="bbff2-125">ReuseSlot</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="bbff2-126">Use la <see cref="P:System.Reflection.MethodBase.Attributes" /> propiedad para determinar si un método es <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />, y así sucesivamente.</span>
            <span class="sxs-lookup">
              <span data-stu-id="bbff2-126">Use the <see cref="P:System.Reflection.MethodBase.Attributes" /> property to determine whether a method is <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />, and so on.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.CallingConvention</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-127">Obtiene un valor que indica las convenciones de llamada de este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-127">Gets a value indicating the calling conventions for this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-128">
            <see cref="T:System.Reflection.CallingConventions" /> de este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-128">The <see cref="T:System.Reflection.CallingConventions" /> for this method.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-129">Obtiene un valor que indica si el método genérico contiene parámetros de tipo genérico sin asignar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-129">Gets a value indicating whether the generic method contains unassigned generic type parameters.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-130">
            <see langword="true" /> si el objeto <see cref="T:System.Reflection.MethodBase" /> actual representa un método genérico que contiene parámetros de tipo genérico sin asignar; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-130">
              <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents a generic method that contains unassigned generic type parameters; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-131">Un método genérico se puede invocar solo si no hay ninguna definición de tipo genérico o tipos construidos abiertos en los argumentos de tipo del propio método o en los tipos envolventes.</span><span class="sxs-lookup"><span data-stu-id="bbff2-131">A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types.</span></span> <span data-ttu-id="bbff2-132">Dado que los tipos pueden ser arbitrariamente complejos, es difícil tomar esta determinación recursiva.</span><span class="sxs-lookup"><span data-stu-id="bbff2-132">Because types can be arbitrarily complex, making this recursive determination is difficult.</span></span> <span data-ttu-id="bbff2-133">Por comodidad y para reducir la posibilidad de error, el <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propiedad proporciona un método estándar para distinguir entre los métodos construidos cerrados, que se pueden invocar, y métodos, que no construye a abrir.</span><span class="sxs-lookup"><span data-stu-id="bbff2-133">For convenience, and to reduce the chance of error, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</span></span> <span data-ttu-id="bbff2-134">Si el <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propiedad devuelve `true`, no se puede invocar el método.</span><span class="sxs-lookup"><span data-stu-id="bbff2-134">If the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`, the method cannot be invoked.</span></span>  
  
 <span data-ttu-id="bbff2-135">El <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propiedad busca de forma recursiva para parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="bbff2-135">The <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="bbff2-136">Por ejemplo, devuelve `true` para cualquier método en un tipo abierto `A<T>` (`A(Of T)` en Visual Basic), aunque el propio método no es genérico.</span><span class="sxs-lookup"><span data-stu-id="bbff2-136">For example, it returns `true` for any method in an open type `A<T>` (`A(Of T)` in Visual Basic), even though the method itself is not generic.</span></span> <span data-ttu-id="bbff2-137">Compare esto con el comportamiento de la <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propiedad, que devuelve `false` para este tipo de método.</span><span class="sxs-lookup"><span data-stu-id="bbff2-137">Contrast this with the behavior of the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property, which returns `false` for such a method.</span></span>  
  
 <span data-ttu-id="bbff2-138">De forma similar, el <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> devuelve el parámetro property `true` para cualquier constructor en un tipo abierto, aunque los constructores no pueden tener sus propios parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="bbff2-138">Similarly, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property parameter returns `true` for any constructor in an open type, even though constructors cannot have type parameters of their own.</span></span>  
  
 <span data-ttu-id="bbff2-139">Para obtener una lista de las condiciones invariables de términos específicos de métodos genéricos, vea la <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="bbff2-139">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="bbff2-140">Para obtener una lista de las condiciones invariables en otros términos utilizados en la reflexión genérica, vea la <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="bbff2-140">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="bbff2-141">Objeto que se va a comparar con esta instancia o <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-141">An object to compare with this instance, or <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bbff2-142">Devuelve un valor que indica si esta instancia es igual que un objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-142">Returns a value that indicates whether this instance is equal to a specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bbff2-143">Es <see langword="true" /> si <paramref name="obj" /> es igual al tipo y valor de esta instancia; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-143">
              <see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetCurrentMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetCurrentMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetCurrentMethod" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentMethod () As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetCurrentMethod();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-144">Devuelve un objeto <see langword="MethodBase" /> que representa el método actualmente en ejecución.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-144">Returns a <see langword="MethodBase" /> object representing the currently executing method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bbff2-145">
            <see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> es un método estático que se llama desde dentro del método que se está ejecutando y devuelve información acerca de ese método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-145">
              <see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> is a static method that is called from within an executing method and that returns information about that method.</span>
          </span>
          <span data-ttu-id="bbff2-146">Objeto <see langword="MethodBase" /> que representa el método actualmente en ejecución.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-146">A <see langword="MethodBase" /> object representing the currently executing method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-147">Si el método actualmente en ejecución se define en un tipo genérico, la <xref:System.Reflection.MethodInfo> devuelto por <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> se obtiene de la definición de tipo genérico (es decir, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> devuelve `true`).</span><span class="sxs-lookup"><span data-stu-id="bbff2-147">If the currently executing method is defined on a generic type, the <xref:System.Reflection.MethodInfo> that is returned by <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is obtained from the generic type definition (that is, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> returns `true`).</span></span> <span data-ttu-id="bbff2-148">Por lo tanto, no refleja los argumentos de tipo que se utilizaron cuando se llamó al método.</span><span class="sxs-lookup"><span data-stu-id="bbff2-148">Therefore, it does not reflect the type arguments that were used when the method was called.</span></span> <span data-ttu-id="bbff2-149">Por ejemplo, si un método `M()` se define en un tipo genérico `C<T>` (`C(Of T)` en Visual Basic), y <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> se llama desde `C<string>.M()`, a continuación, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> devuelve `C<T>.M()` (`C(Of T).M()` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bbff2-149">For example, if a method `M()` is defined on a generic type `C<T>` (`C(Of T)` in Visual Basic), and <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is called from `C<string>.M()`, then <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns `C<T>.M()` (`C(Of T).M()` in Visual Basic).</span></span>  
  
 <span data-ttu-id="bbff2-150">Si el método actualmente en ejecución es un método genérico, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> devuelve la definición de método genérico.</span><span class="sxs-lookup"><span data-stu-id="bbff2-150">If the currently executing method is a generic method, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns the generic method definition.</span></span> <span data-ttu-id="bbff2-151">Si el método genérico se define en un tipo genérico, el <xref:System.Reflection.MethodInfo> se obtiene de la definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="bbff2-151">If the generic method is defined on a generic type, the <xref:System.Reflection.MethodInfo> is obtained from the generic type definition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bbff2-152">El siguiente ejemplo define dos tipos.</span><span class="sxs-lookup"><span data-stu-id="bbff2-152">The following example defines two types.</span></span> <span data-ttu-id="bbff2-153">La primera es una clase no genérica, `TestClass`, incluye un constructor, un método denominado `GetValue`y una propiedad de lectura y escritura denominada `GetValue`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-153">The first is a non-generic class, `TestClass`, includes a constructor, a method named `GetValue`, and a read-write property named `GetValue`.</span></span> <span data-ttu-id="bbff2-154">El segundo es una clase genérica denominada `TestClass<T>` que incluye un constructor, un `GetValue` método y un método genérico, `ConvertValue<Y>`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-154">The second is a generic class named `TestClass<T>` that includes a constructor, a `GetValue` method, and a generic method, `ConvertValue<Y>`.</span></span> <span data-ttu-id="bbff2-155">Cada constructor, el método y el descriptor de acceso de propiedad incluyen una llamada a la <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> método.</span><span class="sxs-lookup"><span data-stu-id="bbff2-155">Each constructor, method, and property accessor includes a call to the <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> method.</span></span>  
  
 [!code-csharp[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/cs/GetCurentMethod1.cs#1)]
 [!code-vb[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/vb/GetCurentMethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="bbff2-156">Este miembro se invocó con un mecanismo de enlace en tiempo de ejecución.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-156">This member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="bbff2-157">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-157">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="bbff2-158">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-158">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-159">Devuelve una matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo de un método genérico o los parámetros de tipo de una definición de método genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-159">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bbff2-160">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo de un método genérico o los parámetros de tipo de una definición de método genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-160">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span>
          </span>
          <span data-ttu-id="bbff2-161">Devuelve una matriz vacía si el método actual no es un método genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-161">Returns an empty array if the current method is not a generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-162">Los elementos de la matriz devuelta están en el orden en que aparecen en la lista de parámetros de tipo para el método genérico.</span><span class="sxs-lookup"><span data-stu-id="bbff2-162">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</span></span>  
  
-   <span data-ttu-id="bbff2-163">Si el método actual es un método construido cerrado (es decir, el <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propiedad devuelve `false`), la matriz devuelta por la <xref:System.Reflection.MethodBase.GetGenericArguments%2A> método contiene los tipos que se han asignado a los parámetros de tipo genérico de la definición de método genérico.</span><span class="sxs-lookup"><span data-stu-id="bbff2-163">If the current method is a closed constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic method definition.</span></span>  
  
-   <span data-ttu-id="bbff2-164">Si el método actual es una definición de método genérico, la matriz contiene los parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="bbff2-164">If the current method is a generic method definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="bbff2-165">Si el método actual es un método construido abierto (es decir, el <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propiedad devuelve `true`) en el que se han asignado tipos específicos a algunos parámetros de tipo y parámetros de tipo de tipos genéricos envolventes se han asignado a otros parámetros de tipo, la matriz contiene tanto tipos como tipo de parámetros.</span><span class="sxs-lookup"><span data-stu-id="bbff2-165">If the current method is an open constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</span></span> <span data-ttu-id="bbff2-166">Use la <xref:System.Type.IsGenericParameter%2A> propiedad para distinguirlos.</span><span class="sxs-lookup"><span data-stu-id="bbff2-166">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="bbff2-167">Para ver una demostración de este escenario, vea el ejemplo de código proporcionado para el <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="bbff2-167">For a demonstration of this scenario, see the code example provided for the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="bbff2-168">Los constructores genéricos no se admiten en la versión 2.0 de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="bbff2-168">Generic constructors are not supported in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bbff2-169">Esta propiedad produce <xref:System.NotSupportedException> si no se reemplaza en una clase derivada, por lo que se produce una excepción si la instancia actual es de tipo <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-169">This property throws <xref:System.NotSupportedException> if not overridden in a derived class, so an exception is thrown if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="bbff2-170">Para obtener una lista de las condiciones invariables de términos específicos de métodos genéricos, vea la <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="bbff2-170">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="bbff2-171">Para obtener una lista de las condiciones invariables en otros términos utilizados en la reflexión genérica, vea la <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="bbff2-171">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bbff2-172">El objeto actual es de tipo <see cref="T:System.Reflection.ConstructorInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-172">The current object is a <see cref="T:System.Reflection.ConstructorInfo" />.</span>
          </span>
          <span data-ttu-id="bbff2-173">Los constructores genéricos no se admiten en la versión 2.0 de .NET Framework.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-173">Generic constructors are not supported in the .NET Framework version 2.0.</span>
          </span>
          <span data-ttu-id="bbff2-174">Esta excepción es el comportamiento predeterminado si no se reemplaza este método en una clase derivada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-174">This exception is the default behavior if this method is not overridden in a derived class.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericArguments" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-175">Devuelve el código hash de esta instancia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-175">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bbff2-176">Código hash de un entero de 32 bits con signo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-176">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBody">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBody GetMethodBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBody GetMethodBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodBody" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMethodBody () As MethodBody" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBody ^ GetMethodBody();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBody</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-177">Cuando se reemplaza en una clase derivada, obtiene un objeto <see cref="T:System.Reflection.MethodBody" /> que proporciona el acceso a la secuencia de MSIL, las variables locales y las excepciones del método actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-177">When overridden in a derived class, gets a <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bbff2-178">Un objeto <see cref="T:System.Reflection.MethodBody" /> que proporciona el acceso a la secuencia de MSIL, las variables locales y las excepciones del método actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-178">A <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-179">No es necesario reemplazar el <xref:System.Reflection.MethodBase.GetMethodBody%2A> para poder utilizarlo.</span><span class="sxs-lookup"><span data-stu-id="bbff2-179">You do not have to override the <xref:System.Reflection.MethodBase.GetMethodBody%2A> in order to use it.</span></span> <span data-ttu-id="bbff2-180">Puede llamar a la <xref:System.Reflection.MethodBase.GetMethodBody%2A> método <xref:System.Reflection.MethodInfo> y <xref:System.Reflection.ConstructorInfo> objetos, porque el método se invalida en las versiones en tiempo de ejecución de estas clases.</span><span class="sxs-lookup"><span data-stu-id="bbff2-180">You can call the <xref:System.Reflection.MethodBase.GetMethodBody%2A> method on <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo> objects, because the method is overridden in the runtime versions of these classes.</span></span> <span data-ttu-id="bbff2-181">Por ejemplo, la versión en tiempo de ejecución de la <xref:System.Reflection.MethodInfo> clase se deriva de la <xref:System.Reflection.MethodInfo> (clase), que a su vez se deriva de la <xref:System.Reflection.MethodBase> clase.</span><span class="sxs-lookup"><span data-stu-id="bbff2-181">For example, the runtime version of the <xref:System.Reflection.MethodInfo> class derives from the <xref:System.Reflection.MethodInfo> class, which in turn derives from the <xref:System.Reflection.MethodBase> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bbff2-182">En el ejemplo de código siguiente se define un método de prueba denominado `MethodBodyExample` y se muestra su información de variables locales y cláusulas de control de excepciones.</span><span class="sxs-lookup"><span data-stu-id="bbff2-182">The following code example defines a test method named `MethodBodyExample` and displays its local variable information and exception-handling clauses.</span></span> <span data-ttu-id="bbff2-183">El <xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> método se utiliza para obtener un <xref:System.Reflection.MethodBody> objeto del método de prueba.</span><span class="sxs-lookup"><span data-stu-id="bbff2-183">The <xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> method is used to obtain a <xref:System.Reflection.MethodBody> object for the test method.</span></span>  
  
 <span data-ttu-id="bbff2-184">El <xref:System.Reflection.MethodBody.LocalVariables%2A> propiedad se utiliza para obtener una lista de <xref:System.Reflection.LocalVariableInfo> objetos y mostrar sus tipos y orden de índice.</span><span class="sxs-lookup"><span data-stu-id="bbff2-184">The <xref:System.Reflection.MethodBody.LocalVariables%2A> property is used to obtain a list of <xref:System.Reflection.LocalVariableInfo> objects and display their types and index order.</span></span> <span data-ttu-id="bbff2-185">El <xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> propiedad se utiliza para obtener una lista de cláusulas de control de excepciones.</span><span class="sxs-lookup"><span data-stu-id="bbff2-185">The <xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> property is used to obtain a list of exception-handling clauses.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bbff2-186">No todos los lenguajes de programación pueden generar <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> cláusulas.</span><span class="sxs-lookup"><span data-stu-id="bbff2-186">Not all computer languages can generate <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> clauses.</span></span> <span data-ttu-id="bbff2-187">El ejemplo de Visual Basic muestra una cláusula de filtro, utilizando un de Visual Basic `When` expresión, que se omite en los ejemplos de otros lenguajes.</span><span class="sxs-lookup"><span data-stu-id="bbff2-187">The Visual Basic example shows a filter clause, using a Visual Basic `When` expression, which is omitted from the examples for other languages.</span></span>  
  
 [!code-cpp[MethodBody#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBody/cpp/source.cpp#1)]
 [!code-csharp[MethodBody#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBody/CS/source.cs#1)]
 [!code-vb[MethodBody#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBody/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bbff2-188">Este método no es válido a menos que se reemplace en una clase derivada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-188">This method is invalid unless overridden in a derived class.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="bbff2-189">Para obtener acceso a los metadatos para los miembros.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-189">for the access to metadata for members.</span>
          </span>
          <span data-ttu-id="bbff2-190">Valor del permiso: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-190">Permission value: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethodFromHandle">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-191">Obtiene información de método mediante el identificador especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-191">Gets method information using the specified handle.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="bbff2-192">Identificador del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-192">The method's handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bbff2-193">Obtiene información del método por medio de la representación interna de metadatos del método (identificador).</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-193">Gets method information by using the method's internal metadata representation (handle).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bbff2-194">Un objeto <see langword="MethodBase" /> que contiene información sobre el método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-194">A <see langword="MethodBase" /> containing information about the method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-195">Identificadores son válidos únicamente en el dominio de aplicación en el que se obtuvieron.</span><span class="sxs-lookup"><span data-stu-id="bbff2-195">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bbff2-196">
            <paramref name="handle" /> no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-196">
              <paramref name="handle" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="bbff2-197">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-197">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="bbff2-198">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-198">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle, declaringType As RuntimeTypeHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="bbff2-199">Identificador de la representación interna de metadatos de un constructor o método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-199">A handle to the internal metadata representation of a constructor or method.</span>
          </span>
        </param>
        <param name="declaringType">
          <span data-ttu-id="bbff2-200">Identificador del tipo genérico que define el constructor o método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-200">A handle to the generic type that defines the constructor or method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bbff2-201">Obtiene un objeto <see cref="T:System.Reflection.MethodBase" /> que corresponde al constructor o el método representado por el identificador especificado, para el tipo genérico especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-201">Gets a <see cref="T:System.Reflection.MethodBase" /> object for the constructor or method represented by the specified handle, for the specified generic type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bbff2-202">Un objeto <see cref="T:System.Reflection.MethodBase" /> que representa el método o el constructor especificado por <paramref name="handle" />, en el tipo genérico especificado por <paramref name="declaringType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-202">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor specified by <paramref name="handle" />, in the generic type specified by <paramref name="declaringType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-203">Identificadores son válidos únicamente en el dominio de aplicación en el que se obtuvieron.</span><span class="sxs-lookup"><span data-stu-id="bbff2-203">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 <span data-ttu-id="bbff2-204">A <xref:System.RuntimeMethodHandle> estructura de un constructor o método de un tipo genérico puede representar diferentes <xref:System.Reflection.MethodBase> objetos, dependiendo de los tipos especificados por los parámetros del tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="bbff2-204">A <xref:System.RuntimeMethodHandle> structure for a constructor or method of a generic type can represent different <xref:System.Reflection.MethodBase> objects, depending on the types specified for the type parameters of the generic type.</span></span> <span data-ttu-id="bbff2-205">Por ejemplo, si `class G<T>` (`class G(Of T)` en Visual Basic, `generic <T> ref class G` en C++) tiene un método que devuelve el tipo `T`, el <xref:System.Reflection.MethodBase> de los objetos de ese método en una clase construida como `G<int>` es diferente de la <xref:System.Reflection.MethodBase> objeto de ese método en la definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="bbff2-205">For example, if `class G<T>` (`class G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) has a method that returns type `T`, the <xref:System.Reflection.MethodBase> object for that method in a constructed class such as `G<int>` is different from the <xref:System.Reflection.MethodBase> object for that method in the generic type definition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bbff2-206">
            <paramref name="handle" /> no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-206">
              <paramref name="handle" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="bbff2-207">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-207">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="bbff2-208">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-208">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetMethodImplementationFlags</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-209">Cuando se reemplaza en una clase derivada, devuelve las marcas <see cref="T:System.Reflection.MethodImplAttributes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-209">When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodImplAttributes" /> flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bbff2-210">Marcas <see langword="MethodImplAttributes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-210">The <see langword="MethodImplAttributes" /> flags.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="bbff2-211">En el ejemplo siguiente se define un constructor en un ensamblado dinámico y, a continuación, usa el <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> método para mostrar los marcadores de implementación de método que se establecen de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="bbff2-211">The following example defines a constructor in a dynamic assembly and then uses the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method to display the method implementation flags that are set by default.</span></span>  
  
 [!code-cpp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CPP/constructorbuilder_getmodule_4.cpp#3)]
 [!code-csharp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CS/constructorbuilder_getmodule_4.cs#3)]
 [!code-vb[ConstructorBuilder_GetModule_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/VB/constructorbuilder_getmodule_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="bbff2-212">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-212">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="bbff2-213">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-213">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.MethodImplAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-214">Cuando se reemplaza en una clase derivada, obtiene los parámetros del método o constructor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-214">When overridden in a derived class, gets the parameters of the specified method or constructor.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bbff2-215">Matriz de tipo <see langword="ParameterInfo" /> con información que coincide con la firma del método (o constructor) que refleja esta instancia de <see langword="MethodBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-215">An array of type <see langword="ParameterInfo" /> containing information that matches the signature of the method (or constructor) reflected by this <see langword="MethodBase" /> instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="bbff2-216">En el ejemplo siguiente se usa el <xref:System.Reflection.MethodBase.GetParameters%2A> método para recuperar los parámetros de la `Invoke` método de un delegado.</span><span class="sxs-lookup"><span data-stu-id="bbff2-216">The following example uses the <xref:System.Reflection.MethodBase.GetParameters%2A> method to retrieve the parameters of the `Invoke` method of a delegate.</span></span>  
  
 <span data-ttu-id="bbff2-217">En el ejemplo se define un delegado denominado `MyDelegate` y un evento denominado `ev` de tipo `MyDelegate`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-217">The example defines a delegate named `MyDelegate` and an event named `ev` of type `MyDelegate`.</span></span> <span data-ttu-id="bbff2-218">El código en el `Main` método detecta la firma del evento obteniendo el tipo de delegado del evento, obtener el `Invoke` método para el tipo de delegado y, a continuación, recuperar y mostrar los parámetros.</span><span class="sxs-lookup"><span data-stu-id="bbff2-218">The code in the `Main` method discovers the event signature by getting the delegate type of the event, getting the `Invoke` method of the delegate type, and then retrieving and displaying the parameters.</span></span>  
  
 [!code-cpp[eventarg#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventArg/CPP/eventarg.cpp#1)]
 [!code-csharp[eventarg#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventArg/CS/eventarg.cs#1)]
 [!code-vb[eventarg#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventArg/VB/eventarg.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="bbff2-219">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-219">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="bbff2-220">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-220">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.ParameterInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-221">Invoca el método o constructor que refleja esta instancia de <see langword="MethodInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-221">Invokes the method or constructor reflected by this <see langword="MethodInfo" /> instance.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (obj As Object, parameters As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="bbff2-222">Objeto en el que se va a invocar al método o constructor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-222">The object on which to invoke the method or constructor.</span>
          </span>
          <span data-ttu-id="bbff2-223">Si el método es estático, se omite este argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-223">If a method is static, this argument is ignored.</span>
          </span>
          <span data-ttu-id="bbff2-224">Si un constructor es estático, este argumento debe ser <see langword="null" /> o una instancia de la clase que define el constructor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-224">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="bbff2-225">Lista de argumentos del método o constructor invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-225">An argument list for the invoked method or constructor.</span>
          </span>
          <span data-ttu-id="bbff2-226">Esta es una matriz de objetos con el mismo número, orden y tipo que los parámetros del método o constructor al que se van a invocar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-226">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span>
          </span>
          <span data-ttu-id="bbff2-227">Si no hay ningún parámetro, <c>parameters</c> debe ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-227">If there are no parameters, <c>parameters</c> should be <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bbff2-228">Si el método o constructor representado por esta instancia tiene un parámetro <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic), no es necesario ningún atributo especial para ese parámetro para invocar el método o constructor mediante esta función.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-228">If the method or constructor represented by this instance takes a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function.</span>
          </span>
          <span data-ttu-id="bbff2-229">Cualquier objeto de esta matriz que no se inicialice explícitamente con un valor contendrá el valor predeterminado de este tipo de objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-229">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span>
          </span>
          <span data-ttu-id="bbff2-230">Para los elementos de tipo de referencia, este valor es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-230">For reference-type elements, this value is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bbff2-231">Para los elementos de tipo de valor, este valor es 0, 0.0 o <see langword="false" />, en función del tipo de elemento específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-231">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bbff2-232">Invoca el método o constructor representado por la instancia actual, utilizando los parámetros especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-232">Invokes the method or constructor represented by the current instance, using the specified parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bbff2-233">Objeto que contiene el valor devuelto del método invocado, o <see langword="null" /> en caso de un constructor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-233">An object containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-234">Se trata de un método de conveniencia que llama el <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> sobrecarga del método, pasando <xref:System.Reflection.BindingFlags.Default> para `invokeAttr` y `null` para `binder` y `culture`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-234">This is a convenience method that calls the <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> method overload, passing <xref:System.Reflection.BindingFlags.Default> for `invokeAttr` and `null` for `binder` and `culture`.</span></span>  
  
 <span data-ttu-id="bbff2-235">Si el método invocado produce una excepción, el <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> método devuelve la excepción.</span><span class="sxs-lookup"><span data-stu-id="bbff2-235">If the invoked method throws an exception, the <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> method returns the exception.</span></span>  
  
 <span data-ttu-id="bbff2-236">Para invocar un método estático utilizando su <xref:System.Reflection.MethodInfo> de objetos, pasar `null` para `obj`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-236">To invoke a static method using its <xref:System.Reflection.MethodInfo> object, pass `null` for `obj`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bbff2-237">Si esta sobrecarga del método se utiliza para invocar un constructor de instancia, el objeto proporcionado para `obj` se reinicializa; es decir, se ejecutan todos los inicializadores de instancia.</span><span class="sxs-lookup"><span data-stu-id="bbff2-237">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="bbff2-238">El valor devuelto es `null`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-238">The return value is `null`.</span></span> <span data-ttu-id="bbff2-239">Si se invoca un constructor de clase, la clase es reinicializada; es decir, se ejecutan todos los inicializadores de clase.</span><span class="sxs-lookup"><span data-stu-id="bbff2-239">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="bbff2-240">El valor devuelto es `null`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-240">The return value is `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bbff2-241">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a miembros no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y, si el conjunto de permisos de los miembros no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</span><span class="sxs-lookup"><span data-stu-id="bbff2-241">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="bbff2-242">(Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="bbff2-242">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="bbff2-243">Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="bbff2-243">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 <span data-ttu-id="bbff2-244">Si un parámetro del método actual es un tipo de valor y el argumento correspondiente en `parameters` es `null`, el tiempo de ejecución pasa una instancia del tipo de valor inicializa a cero.</span><span class="sxs-lookup"><span data-stu-id="bbff2-244">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bbff2-245">En el ejemplo de código siguiente se muestra la búsqueda del método dinámico utilizando la reflexión.</span><span class="sxs-lookup"><span data-stu-id="bbff2-245">The following code example demonstrates dynamic method lookup using reflection.</span></span> <span data-ttu-id="bbff2-246">Tenga en cuenta que no se puede utilizar el <xref:System.Reflection.MethodInfo> objeto de la clase base para invocar el método invalidado en la clase derivada, porque el enlace más tarde, no puede resolver invalidaciones.</span><span class="sxs-lookup"><span data-stu-id="bbff2-246">Note that you cannot use the <xref:System.Reflection.MethodInfo> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.</span></span>  
  
 [!code-cpp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="bbff2-247">En [.NET para aplicaciones de la Tienda Windows](http://go.microsoft.com/fwlink/?LinkID=247912) o la [Biblioteca de clases portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture <see cref="T:System.Exception" /> en su lugar.</span>
              <span class="sxs-lookup">
                <span data-stu-id="bbff2-247">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch <see cref="T:System.Exception" /> instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="bbff2-248">El parámetro <paramref name="obj" /> es <see langword="null" /> y el método no es estático.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-248">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span>
          </span>
          <span data-ttu-id="bbff2-249">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-249">-or-</span>
          </span>
          <span data-ttu-id="bbff2-250">La clase de <paramref name="obj" /> no declara ni hereda el método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-250">The method is not declared or inherited by the class of <paramref name="obj" />.</span>
          </span>
          <span data-ttu-id="bbff2-251">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-251">-or-</span>
          </span>
          <span data-ttu-id="bbff2-252">Se invoca un constructor estático, y <paramref name="obj" /> no es ni <see langword="null" /> ni una instancia de la clase que declaró el constructor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-252">A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bbff2-253">Los elementos de la matriz <paramref name="parameters" /> no coinciden con la firma del método o constructor que esta instancia refleja.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-253">The elements of the <paramref name="parameters" /> array do not match the signature of the method or constructor reflected by this instance.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="bbff2-254">El método o constructor invocado produce una excepción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-254">The invoked method or constructor throws an exception.</span>
          </span>
          <span data-ttu-id="bbff2-255">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-255">-or-</span>
          </span>
          <span data-ttu-id="bbff2-256">La instancia actual es un <see cref="T:System.Reflection.Emit.DynamicMethod" /> que contiene código no comprobable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-256">The current instance is a <see cref="T:System.Reflection.Emit.DynamicMethod" /> that contains unverifiable code.</span>
          </span>
          <span data-ttu-id="bbff2-257">Vea la sección "Comprobación" en Comentarios para <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-257">See the "Verification" section in Remarks for <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <span data-ttu-id="bbff2-258">La matriz <paramref name="parameters" /> no tiene el número correcto de argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-258">The <paramref name="parameters" /> array does not have the correct number of arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="bbff2-259">En [.NET para aplicaciones de la Tienda Windows](http://go.microsoft.com/fwlink/?LinkID=247912) o la [Biblioteca de clases portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture en su lugar la excepción de clase base, <see cref="T:System.MemberAccessException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="bbff2-259">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="bbff2-260">El autor de la llamada no tiene permiso para ejecutar el método o constructor representado por la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-260">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bbff2-261">El tipo que declara el método es un tipo genérico abierto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-261">The type that declares the method is an open generic type.</span>
          </span>
          <span data-ttu-id="bbff2-262">Es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" /> para el tipo declarador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-262">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bbff2-263">La instancia actual es un <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-263">The current instance is a <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="bbff2-264">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-264">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="bbff2-265">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-265">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Missing" />
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public abstract object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="bbff2-266">Objeto en el que se va a invocar al método o constructor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-266">The object on which to invoke the method or constructor.</span>
          </span>
          <span data-ttu-id="bbff2-267">Si el método es estático, se omite este argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-267">If a method is static, this argument is ignored.</span>
          </span>
          <span data-ttu-id="bbff2-268">Si un constructor es estático, este argumento debe ser <see langword="null" /> o una instancia de la clase que define el constructor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-268">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="bbff2-269">Una máscara de bits que es una combinación de 0 o más marcas de bits de <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-269">A bitmask that is a combination of 0 or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
          <span data-ttu-id="bbff2-270">Si <c>binder</c> es <see langword="null" />, se asigna el valor <see cref="F:System.Reflection.BindingFlags.Default" /> a este parámetro; por lo tanto, se omite cualquier valor que se pase.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-270">If <c>binder</c> is <see langword="null" />, this parameter is assigned the value <see cref="F:System.Reflection.BindingFlags.Default" />; thus, whatever you pass in is ignored.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="bbff2-271">Objeto que habilita el enlace, la conversión de tipos de argumentos, las llamadas a miembros y la recuperación de objetos <see langword="MemberInfo" /> mediante reflexión.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-271">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span>
          </span>
          <span data-ttu-id="bbff2-272">Si <c>binder</c> es <see langword="null" />, se usará el enlazador predeterminado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-272">If <c>binder</c> is <see langword="null" />, the default binder is used.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="bbff2-273">Lista de argumentos del método o constructor invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-273">An argument list for the invoked method or constructor.</span>
          </span>
          <span data-ttu-id="bbff2-274">Esta es una matriz de objetos con el mismo número, orden y tipo que los parámetros del método o constructor al que se van a invocar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-274">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span>
          </span>
          <span data-ttu-id="bbff2-275">Si no hay ningún parámetro, debe ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-275">If there are no parameters, this should be <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bbff2-276">Si el método o constructor que representa esta instancia adopta un parámetro ByRef, éste no necesita ningún atributo especial para que pueda invocar el método o constructor utilizando esta función.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-276">If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function.</span>
          </span>
          <span data-ttu-id="bbff2-277">Cualquier objeto de esta matriz que no se inicialice explícitamente con un valor contendrá el valor predeterminado de este tipo de objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-277">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span>
          </span>
          <span data-ttu-id="bbff2-278">Para los elementos de tipo de referencia, este valor es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-278">For reference-type elements, this value is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bbff2-279">Para los elementos de tipo de valor, este valor es 0, 0.0 o <see langword="false" />, en función del tipo de elemento específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-279">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="bbff2-280">Instancia de <see langword="CultureInfo" /> usada para regir la conversión de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-280">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span>
          </span>
          <span data-ttu-id="bbff2-281">Si es <see langword="null" />, se utiliza <see langword="CultureInfo" /> para el subproceso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-281">If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span>
          </span>
          <span data-ttu-id="bbff2-282">(Esto es necesario para convertir un objeto <see langword="String" /> que representa 1000 en un valor <see langword="Double" />, por ejemplo, dado que 1000 se representa de maneras diferentes según la referencia cultural).</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-282">(This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bbff2-283">Cuando se reemplaza en una clase derivada, invoca el método o constructor reflejado con los parámetros especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-283">When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bbff2-284">Un tipo <see langword="Object" /> que contiene el valor devuelto del método invocado, o un objeto <see langword="null" /> en el caso de un constructor, o <see langword="null" /> si el tipo de valor devuelto del método es <see langword="void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-284">An <see langword="Object" /> containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor, or <see langword="null" /> if the method's return type is <see langword="void" />.</span>
          </span>
          <span data-ttu-id="bbff2-285">Antes de llamar al método o constructor, <see langword="Invoke" /> comprueba si el usuario tiene permiso de acceso y si los parámetros son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-285">Before calling the method or constructor, <see langword="Invoke" /> checks to see if the user has access permission and verifies that the parameters are valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-286">Invoca dinámicamente el método reflejado por esta instancia en `obj`y pasa los parámetros especificados.</span><span class="sxs-lookup"><span data-stu-id="bbff2-286">Dynamically invokes the method reflected by this instance on `obj`, and passes along the specified parameters.</span></span> <span data-ttu-id="bbff2-287">Si el método es estático, el `obj` parámetro se ignora.</span><span class="sxs-lookup"><span data-stu-id="bbff2-287">If the method is static, the `obj` parameter is ignored.</span></span> <span data-ttu-id="bbff2-288">Para los métodos no estáticos, `obj` debe ser una instancia de una clase que hereda o declara el método y debe ser del mismo tipo que esta clase.</span><span class="sxs-lookup"><span data-stu-id="bbff2-288">For non-static methods, `obj` should be an instance of a class that inherits or declares the method and must be the same type as this class.</span></span> <span data-ttu-id="bbff2-289">Si el método no tiene parámetros, el valor de `parameters` debe ser `null`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-289">If the method has no parameters, the value of `parameters` should be `null`.</span></span> <span data-ttu-id="bbff2-290">En caso contrario, el número, el tipo y el orden de los elementos de `parameters` debe ser idéntico al número, tipo y orden de los parámetros para el método reflejado por esta instancia.</span><span class="sxs-lookup"><span data-stu-id="bbff2-290">Otherwise, the number, type, and order of elements in `parameters` should be identical to the number, type, and order of parameters for the method reflected by this instance.</span></span>  
  
 <span data-ttu-id="bbff2-291">No se puede omitir los parámetros opcionales en las llamadas a `Invoke`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-291">You may not omit optional parameters in calls to `Invoke`.</span></span> <span data-ttu-id="bbff2-292">Para invocar un método omitiendo los parámetros opcionales, debe llamar a `Type.InvokeMember` en su lugar.</span><span class="sxs-lookup"><span data-stu-id="bbff2-292">To invoke a method omitting optional parameters, you should call `Type.InvokeMember` instead.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bbff2-293">Si esta sobrecarga del método se utiliza para invocar un constructor de instancia, el objeto proporcionado para `obj` se reinicializa; es decir, se ejecutan todos los inicializadores de instancia.</span><span class="sxs-lookup"><span data-stu-id="bbff2-293">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="bbff2-294">El valor devuelto es `null`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-294">The return value is `null`.</span></span> <span data-ttu-id="bbff2-295">Si se invoca un constructor de clase, la clase es reinicializada; es decir, se ejecutan todos los inicializadores de clase.</span><span class="sxs-lookup"><span data-stu-id="bbff2-295">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="bbff2-296">El valor devuelto es `null`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-296">The return value is `null`.</span></span>  
  
 <span data-ttu-id="bbff2-297">Para los parámetros primitivos de paso por valor, se realizan la ampliación normal (Int16 -> Int32, por ejemplo).</span><span class="sxs-lookup"><span data-stu-id="bbff2-297">For pass-by-value primitive parameters, normal widening is performed (Int16 -> Int32, for example).</span></span> <span data-ttu-id="bbff2-298">Para los parámetros de referencia de paso por valor, la ampliación de referencia normal se permite (clase derivada a clase base y la clase base para el tipo de interfaz).</span><span class="sxs-lookup"><span data-stu-id="bbff2-298">For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type).</span></span> <span data-ttu-id="bbff2-299">Sin embargo, para los parámetros primitivos de paso por referencia, los tipos deben coincidir exactamente.</span><span class="sxs-lookup"><span data-stu-id="bbff2-299">However, for pass-by-reference primitive parameters, the types must match exactly.</span></span> <span data-ttu-id="bbff2-300">Para los parámetros de referencia de paso por referencia, la ampliación normal todavía se aplica.</span><span class="sxs-lookup"><span data-stu-id="bbff2-300">For pass-by-reference reference parameters, the normal widening still applies.</span></span>  
  
 <span data-ttu-id="bbff2-301">Por ejemplo, si el método reflejado por esta instancia se declara como `public boolean Compare(String a, String b)`, a continuación, `parameters` debe ser una matriz de `Objects` con una longitud 2 que `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-301">For example, if the method reflected by this instance is declared as `public boolean Compare(String a, String b)`, then `parameters` should be an array of `Objects` with length 2 such that `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.</span></span>  
  
 <span data-ttu-id="bbff2-302">Si un parámetro del método actual es un tipo de valor y el argumento correspondiente en `parameters` es `null`, el tiempo de ejecución pasa una instancia del tipo de valor inicializa a cero.</span><span class="sxs-lookup"><span data-stu-id="bbff2-302">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
 <span data-ttu-id="bbff2-303">Reflexión utiliza la búsqueda de método dinámico al invocar métodos virtuales.</span><span class="sxs-lookup"><span data-stu-id="bbff2-303">Reflection uses dynamic method lookup when invoking virtual methods.</span></span> <span data-ttu-id="bbff2-304">Por ejemplo, suponga que la clase B hereda de la clase A y ambas implementan un método virtual denominado m. Ahora suponga que tiene un `MethodInfo` objeto que representa a M en la clase A. Si usas el `Invoke` método para invocar M en un objeto de tipo B, a continuación, la reflexión utilizará la implementación proporcionada por la clase B. Incluso si el objeto de tipo B se convierte en una, se utiliza la implementación proporcionada por la clase B (vea el ejemplo de código siguiente).</span><span class="sxs-lookup"><span data-stu-id="bbff2-304">For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a `MethodInfo` object that represents M on class A. If you use the `Invoke` method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).</span></span>  
  
 <span data-ttu-id="bbff2-305">Por otro lado, si el método no es virtual, a continuación, la reflexión utilizará la implementación proporcionada por el tipo desde el que el `MethodInfo` obtuvo, independientemente del tipo del objeto pasado como el destino.</span><span class="sxs-lookup"><span data-stu-id="bbff2-305">On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the `MethodInfo` was obtained, regardless of the type of the object passed as the target.</span></span>  
  
 <span data-ttu-id="bbff2-306">Se omiten las restricciones de acceso de código de plena confianza.</span><span class="sxs-lookup"><span data-stu-id="bbff2-306">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="bbff2-307">Es decir, las propiedades, métodos, campos y constructores privados se pueden acceso e invocar mediante reflexión siempre que el código es de plena confianza.</span><span class="sxs-lookup"><span data-stu-id="bbff2-307">That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="bbff2-308">Si el método invocado produce una excepción, `TargetInvocationException.GetException` devuelve la excepción.</span><span class="sxs-lookup"><span data-stu-id="bbff2-308">If the invoked method throws an exception, `TargetInvocationException.GetException` returns the exception.</span></span> <span data-ttu-id="bbff2-309">Esta implementación produce un `NotSupportedException`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-309">This implementation throws a `NotSupportedException`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bbff2-310">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a miembros no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y, si el conjunto de permisos de los miembros no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</span><span class="sxs-lookup"><span data-stu-id="bbff2-310">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="bbff2-311">(Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="bbff2-311">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="bbff2-312">Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="bbff2-312">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bbff2-313">El ejemplo siguiente muestra todos los miembros de la <xref:System.Reflection.Binder?displayProperty=nameWithType> usa una sobrecarga de la clase <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-313">The following example demonstrates all members of the <xref:System.Reflection.Binder?displayProperty=nameWithType> class using an overload of <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bbff2-314">El método privado `CanConvertFrom` busca tipos compatibles con un tipo determinado.</span><span class="sxs-lookup"><span data-stu-id="bbff2-314">The private method `CanConvertFrom` finds compatible types for a given type.</span></span> <span data-ttu-id="bbff2-315">Para obtener otro ejemplo de invocación de miembros en un escenario de enlace personalizado, vea [cargar y utilizar tipos dinámicamente](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).</span><span class="sxs-lookup"><span data-stu-id="bbff2-315">For another example of invoking members in a custom binding scenario, see [Dynamically Loading and Using Types](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).</span></span>  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="bbff2-316">El parámetro <paramref name="obj" /> es <see langword="null" /> y el método no es estático.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-316">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span>
          </span>
          <span data-ttu-id="bbff2-317">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-317">-or-</span>
          </span>
          <span data-ttu-id="bbff2-318">La clase de <paramref name="obj" /> no declara ni hereda el método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-318">The method is not declared or inherited by the class of <paramref name="obj" />.</span>
          </span>
          <span data-ttu-id="bbff2-319">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-319">-or-</span>
          </span>
          <span data-ttu-id="bbff2-320">Se invoca un constructor estático, y <paramref name="obj" /> no es ni <see langword="null" /> ni una instancia de la clase que declaró el constructor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-320">A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bbff2-321">El tipo del parámetro <paramref name="parameters" /> no coincide con la firma del método o constructor que esta instancia refleja.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-321">The type of the <paramref name="parameters" /> parameter does not match the signature of the method or constructor reflected by this instance.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <span data-ttu-id="bbff2-322">La matriz <paramref name="parameters" /> no tiene el número correcto de argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-322">The <paramref name="parameters" /> array does not have the correct number of arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="bbff2-323">El método o constructor invocado produce una excepción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-323">The invoked method or constructor throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="bbff2-324">El autor de la llamada no tiene permiso para ejecutar el método o constructor representado por la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-324">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bbff2-325">El tipo que declara el método es un tipo genérico abierto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-325">The type that declares the method is an open generic type.</span>
          </span>
          <span data-ttu-id="bbff2-326">Es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" /> para el tipo declarador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-326">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="bbff2-327">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-327">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="bbff2-328">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-328">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-329">Obtiene un valor que indica si el método es abstracto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-329">Gets a value indicating whether the method is abstract.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-330">Es <see langword="true" /> si el método es abstracto; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-330">
              <see langword="true" /> if the method is abstract; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-331">Un miembro abstracto se declara en una clase base y no ha proporcionado ninguna implementación.</span><span class="sxs-lookup"><span data-stu-id="bbff2-331">An abstract member is declared on a base class and has no implementation supplied.</span></span>  
  
 <span data-ttu-id="bbff2-332">Para obtener el <xref:System.Reflection.MethodBase>, primero hay que obtener el tipo.</span><span class="sxs-lookup"><span data-stu-id="bbff2-332">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="bbff2-333">A partir del tipo, obtenga el método.</span><span class="sxs-lookup"><span data-stu-id="bbff2-333">From the type, get the method.</span></span> <span data-ttu-id="bbff2-334">A partir del método, obtenga el `MethodBase`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-334">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="bbff2-335">Si el `MethodBase` o constructor no son públicos, están protegido y no se puede obtener acceso inmediato.</span><span class="sxs-lookup"><span data-stu-id="bbff2-335">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="bbff2-336">Para obtener acceso a un método no público, establezca la <xref:System.Reflection.BindingFlags> enmascarar a `NonPublic` en `GetMethod`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-336">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bbff2-337">En el ejemplo siguiente se determina si el método especificado es abstracto y muestra el resultado.</span><span class="sxs-lookup"><span data-stu-id="bbff2-337">The following example determines whether specified the method is abstract and displays the result.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-338">Obtiene un valor que indica si <see cref="F:System.Reflection.MethodAttributes.Assembly" /> describe la visibilidad posible de este método o constructor; es decir, el método o el constructor es visible como mucho para otros tipos del mismo ensamblado y no es visible para los tipos derivados fuera del ensamblado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-338">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-339">
            <see langword="true" /> si <see cref="F:System.Reflection.MethodAttributes.Assembly" /> describe exactamente la visibilidad de este método o constructor; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-339">
              <see langword="true" /> if the visibility of this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-340">La visibilidad real de un método está limitada por la visibilidad de su tipo.</span><span class="sxs-lookup"><span data-stu-id="bbff2-340">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="bbff2-341">El <xref:System.Reflection.MethodBase.IsAssembly%2A> propiedad podría ser `true` para un método, pero si se trata de un método de un tipo anidado privado, a continuación, el método no es visible fuera del tipo contenedor.</span><span class="sxs-lookup"><span data-stu-id="bbff2-341">The <xref:System.Reflection.MethodBase.IsAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="bbff2-342">Describe exactamente la visibilidad de un método o constructor <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> si el modificador de visibilidad solo es `internal` (`Friend` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bbff2-342">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> if the only visibility modifier is `internal` (`Friend` in Visual Basic).</span></span> <span data-ttu-id="bbff2-343">Esta propiedad es `false` para los métodos que son `protected internal` en C# (`Protected Friend` en Visual Basic, `protected public` en C++); use la <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> propiedad para identificar estos métodos.</span><span class="sxs-lookup"><span data-stu-id="bbff2-343">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bbff2-344">En el ejemplo de código siguiente se definen métodos con distintos niveles de visibilidad y muestra los valores de sus <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, y <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> propiedades.</span><span class="sxs-lookup"><span data-stu-id="bbff2-344">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bbff2-345">Los lenguajes Visual Basic y C# no pueden definir métodos con <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibilidad; que se muestra el nivel de acceso sólo en el ejemplo de C++.</span><span class="sxs-lookup"><span data-stu-id="bbff2-345">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructor">
      <MemberSignature Language="C#" Value="public bool IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructor" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructor { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-346">Obtiene un valor que indica si el método es un constructor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-346">Gets a value indicating whether the method is a constructor.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-347">
            <see langword="true" /> si este método es un constructor representado por un objeto <see cref="T:System.Reflection.ConstructorInfo" /> (vea los Comentarios de los objetos <see cref="T:System.Reflection.Emit.ConstructorBuilder" />); de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-347">
              <see langword="true" /> if this method is a constructor represented by a <see cref="T:System.Reflection.ConstructorInfo" /> object (see note in Remarks about <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> objects); otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="bbff2-348">El <xref:System.Reflection.MethodBase.IsConstructor%2A> propiedad devuelve `false` para un <xref:System.Reflection.Emit.ConstructorBuilder> objeto en un tipo dinámico, a menos que la <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> marca se incluyó en el `attributes` parámetro cuando se definió el constructor.</span><span class="sxs-lookup"><span data-stu-id="bbff2-348">The <xref:System.Reflection.MethodBase.IsConstructor%2A> property returns `false` for a <xref:System.Reflection.Emit.ConstructorBuilder> object in a dynamic type, unless the <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> flag was included in the `attributes` parameter when the constructor was defined.</span></span> <span data-ttu-id="bbff2-349">Si se omite la <xref:System.Reflection.MethodAttributes.RTSpecialName> marca no afecta a la validez del constructor emitido.</span><span class="sxs-lookup"><span data-stu-id="bbff2-349">Omitting the <xref:System.Reflection.MethodAttributes.RTSpecialName> flag does not affect the correctness of the emitted constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-350">Obtiene un valor que indica si <see cref="F:System.Reflection.MethodAttributes.Family" /> describe la visibilidad de este método o constructor; es decir, el método o el constructor sólo es visible dentro de su clase y clases derivadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-350">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Family" />; that is, the method or constructor is visible only within its class and derived classes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-351">
            <see langword="true" /> si <see cref="F:System.Reflection.MethodAttributes.Family" /> describe exactamente el acceso a este método o constructor; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-351">
              <see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Family" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-352">Describe exactamente la visibilidad de un método o constructor <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> si el modificador de visibilidad solo es `protected`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-352">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> if the only visibility modifier is `protected`.</span></span> <span data-ttu-id="bbff2-353">Esta propiedad es `false` para los métodos que son `protected internal` en C# (`Protected Friend` en Visual Basic, `protected public` en C++); use la <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> propiedad para identificar estos métodos.</span><span class="sxs-lookup"><span data-stu-id="bbff2-353">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bbff2-354">En el ejemplo de código siguiente se definen métodos con distintos niveles de visibilidad y muestra los valores de sus <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, y <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> propiedades.</span><span class="sxs-lookup"><span data-stu-id="bbff2-354">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bbff2-355">Los lenguajes Visual Basic y C# no pueden definir métodos con <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibilidad; que se muestra el nivel de acceso sólo en el ejemplo de C++.</span><span class="sxs-lookup"><span data-stu-id="bbff2-355">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyAndAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyAndAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-356">Obtiene un valor que indica si <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /> describe la visibilidad de este método o constructor; es decir, las clases derivadas pueden llamar al método o constructor, pero sólo si están en el mismo ensamblado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-356">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-357">
            <see langword="true" /> si <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /> describe exactamente el acceso a este método o constructor; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-357">
              <see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-358">Describe exactamente la visibilidad de un método o constructor <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> si el modificador de visibilidad es `protected private` en C++.</span><span class="sxs-lookup"><span data-stu-id="bbff2-358">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> if the visibility modifier is `protected private` in C++.</span></span> <span data-ttu-id="bbff2-359">No se pueden definir métodos con esta visibilidad en Visual Basic o C#.</span><span class="sxs-lookup"><span data-stu-id="bbff2-359">Methods with this visibility cannot be defined in Visual Basic or C#.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bbff2-360">En el ejemplo de código siguiente se definen métodos con distintos niveles de visibilidad y muestra los valores de sus <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, y <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> propiedades.</span><span class="sxs-lookup"><span data-stu-id="bbff2-360">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bbff2-361">Los lenguajes Visual Basic y C# no pueden definir métodos con <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibilidad; que se muestra el nivel de acceso sólo en el ejemplo de C++.</span><span class="sxs-lookup"><span data-stu-id="bbff2-361">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyOrAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyOrAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-362">Obtiene un valor que indica si <see cref="F:System.Reflection.MethodAttributes.FamORAssem" /> describe la visibilidad posible de este método o constructor; es decir, las clases derivadas pueden llamar al método o constructor con independencia de dónde se encuentren, así como las clases del mismo ensamblado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-362">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-363">
            <see langword="true" /> si <see cref="F:System.Reflection.MethodAttributes.FamORAssem" /> describe exactamente el acceso a este método o constructor; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-363">
              <see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-364">Si tiene un miembro de tipo <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> visibilidad, pueda llamarse desde cualquier miembro en una clase derivada o cualquier miembro del mismo ensamblado, pero no de cualquier otro tipo.</span><span class="sxs-lookup"><span data-stu-id="bbff2-364">If a type member has <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</span></span>  
  
 <span data-ttu-id="bbff2-365">La visibilidad real de un método está limitada por la visibilidad de su tipo.</span><span class="sxs-lookup"><span data-stu-id="bbff2-365">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="bbff2-366">El <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> propiedad podría ser `true` para un método, pero si se trata de un método de un tipo anidado privado, a continuación, el método no es visible fuera del tipo contenedor.</span><span class="sxs-lookup"><span data-stu-id="bbff2-366">The <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="bbff2-367">Describe exactamente la visibilidad de un método o constructor <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> si el modificador de visibilidad es `protected internal` en C# (`Protected Friend` en Visual Basic, `protected public` en C++).</span><span class="sxs-lookup"><span data-stu-id="bbff2-367">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> if the visibility modifier is `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bbff2-368">En el ejemplo de código siguiente se definen métodos con distintos niveles de visibilidad y muestra los valores de sus <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, y <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> propiedades.</span><span class="sxs-lookup"><span data-stu-id="bbff2-368">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bbff2-369">Los lenguajes Visual Basic y C# no pueden definir métodos con <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibilidad; que se muestra el nivel de acceso sólo en el ejemplo de C++.</span><span class="sxs-lookup"><span data-stu-id="bbff2-369">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFinal">
      <MemberSignature Language="C#" Value="public bool IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFinal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFinal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFinal { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-370">Obtiene un valor que indica si este método es <see langword="final" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-370">Gets a value indicating whether this method is <see langword="final" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-371">
            <see langword="true" /> si este método es <see langword="final" />; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-371">
              <see langword="true" /> if this method is <see langword="final" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-372">Para determinar si un método es reemplazable, no es suficiente comprobar que <xref:System.Reflection.MethodBase.IsVirtual%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-372">To determine if a method is overridable, it is not sufficient to check that <xref:System.Reflection.MethodBase.IsVirtual%2A> is `true`.</span></span> <span data-ttu-id="bbff2-373">Para un método se pueda reemplazar, `IsVirtual` debe ser `true` y `IsFinal` debe ser `false`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-373">For a method to be overridable, `IsVirtual` must be `true` and `IsFinal` must be `false`.</span></span> <span data-ttu-id="bbff2-374">Por ejemplo, un método podría ser no virtual, pero implementa un método de interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-374">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="bbff2-375">Common language runtime requiere que todos los métodos que implementan miembros de interfaz deben marcarse como `virtual`; por lo tanto, el compilador marca el método `virtual final`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-375">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="bbff2-376">Por lo que hay casos donde un método está marcado como `virtual` , pero no es reemplazable.</span><span class="sxs-lookup"><span data-stu-id="bbff2-376">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="bbff2-377">Para establecer con certeza si un método es reemplazable, utilice código como este:</span><span class="sxs-lookup"><span data-stu-id="bbff2-377">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
 `if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)`  
  
 <span data-ttu-id="bbff2-378">Si `IsVirtual` es `false` o `IsFinal` es `true`, a continuación, no se puede invalidar el método.</span><span class="sxs-lookup"><span data-stu-id="bbff2-378">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bbff2-379">En el ejemplo siguiente se muestra `false` para `IsFinal`, que puede llevarle a pensar que MyMethod se puede reemplazar.</span><span class="sxs-lookup"><span data-stu-id="bbff2-379">The following example displays `false` for `IsFinal`, which might lead you to think that MyMethod is overridable.</span></span> <span data-ttu-id="bbff2-380">El código imprime `false` aunque MyMethod no está marcada como `virtual` y, por tanto, no se puede invalidar.</span><span class="sxs-lookup"><span data-stu-id="bbff2-380">The code prints `false` even though MyMethod is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-381">Obtiene un valor que indica si el método es genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-381">Gets a value indicating whether the method is generic.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-382">
            <see langword="true" /> si el objeto <see cref="T:System.Reflection.MethodBase" /> actual representa a un método genérico; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-382">
              <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> represents a generic method; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-383">Use la <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propiedad para determinar si la actual <xref:System.Reflection.MethodBase> objeto representa un método genérico.</span><span class="sxs-lookup"><span data-stu-id="bbff2-383">Use the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents a generic method.</span></span> <span data-ttu-id="bbff2-384">Use la <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propiedad para determinar si la actual <xref:System.Reflection.MethodBase> objeto representa un método construido abierto o un método construido cerrado.</span><span class="sxs-lookup"><span data-stu-id="bbff2-384">Use the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents an open constructed method or a closed constructed method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bbff2-385">De forma predeterminada; no admite elementos genéricos Esta propiedad devuelve `false` si no se reemplaza en una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="bbff2-385">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="bbff2-386">No se admiten constructores genéricos en .NET Framework versión 2.0, por lo que esta propiedad devuelve `false` si la instancia actual es de tipo <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-386">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
<span data-ttu-id="bbff2-387">En la tabla siguiente se resume las condiciones invariables de términos específicos de los métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="bbff2-387">The following table summarizes the invariant conditions for terms specific to generic methods.</span></span> <span data-ttu-id="bbff2-388">En otros términos utilizados en la reflexión genérica, como *parámetro de tipo genérico* y *tipo genérico*, consulte el <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="bbff2-388">For other terms used in generic reflection, such as *generic type parameter* and *generic type*, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>   

|<span data-ttu-id="bbff2-389">Término</span><span class="sxs-lookup"><span data-stu-id="bbff2-389">Term</span></span>|<span data-ttu-id="bbff2-390">Condición invariable</span><span class="sxs-lookup"><span data-stu-id="bbff2-390">Invariant condition</span></span>| 
|---|---| 
|<span data-ttu-id="bbff2-391">definición de método genérico</span><span class="sxs-lookup"><span data-stu-id="bbff2-391">generic method definition</span></span>| <span data-ttu-id="bbff2-392">La propiedad <xref:System.Reflection.MethodBase.IsGenericMethodDefinition> es `true`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-392">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition> property is `true`.</span></span> <br /><span data-ttu-id="bbff2-393">Define un método genérico.</span><span class="sxs-lookup"><span data-stu-id="bbff2-393">Defines a generic method.</span></span> <span data-ttu-id="bbff2-394">Se crea un método construido mediante una llamada a la <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> método en un <xref:System.Reflection.MethodInfo> objeto que representa una definición de método genérico y especifica una matriz de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="bbff2-394">A constructed method is created by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method on a <xref:System.Reflection.MethodInfo> object that represents a generic method definition, and specifying an array of type arguments.</span></span> <br /><span data-ttu-id="bbff2-395">El <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> método puede llamarse únicamente en las definiciones de método genérico.</span><span class="sxs-lookup"><span data-stu-id="bbff2-395">The <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method can be called only on generic method definitions.</span></span> <br/><span data-ttu-id="bbff2-396">Cualquier definición de método genérico es un método genérico, pero no al revés.</span><span class="sxs-lookup"><span data-stu-id="bbff2-396">Any generic method definition is a generic method, but the converse is not true.</span></span>|    
|<span data-ttu-id="bbff2-397">método genérico</span><span class="sxs-lookup"><span data-stu-id="bbff2-397">generic method</span></span>|<span data-ttu-id="bbff2-398">La propiedad `IsGenericMethod` es `true`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-398">The `IsGenericMethod` property is `true`.</span></span> <br/> <span data-ttu-id="bbff2-399">Puede ser una definición de método genérico, un método construido abierto o un método construido cerrado.</span><span class="sxs-lookup"><span data-stu-id="bbff2-399">Can be a generic method definition, an open constructed method, or a closed constructed method.</span></span>| 
|<span data-ttu-id="bbff2-400">Open construido (método)</span><span class="sxs-lookup"><span data-stu-id="bbff2-400">open constructed method</span></span>|<span data-ttu-id="bbff2-401">La propiedad <xref:System.Reflection.MethodBase.ContainsGenericParameters> es `true`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-401">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `true`.</span></span> <br/><span data-ttu-id="bbff2-402">No es posible invocar un método construido abierto.</span><span class="sxs-lookup"><span data-stu-id="bbff2-402">It is not possible to invoke an open constructed method.</span></span>|  
|<span data-ttu-id="bbff2-403">método construido cerrado</span><span class="sxs-lookup"><span data-stu-id="bbff2-403">closed constructed method</span></span>|<span data-ttu-id="bbff2-404">La propiedad <xref:System.Reflection.MethodBase.ContainsGenericParameters> es `false`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-404">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `false`.</span></span> <br/><span data-ttu-id="bbff2-405">Cuando examina de forma recursiva, el método no tiene ningún parámetro genérico sin asignar.</span><span class="sxs-lookup"><span data-stu-id="bbff2-405">When examined recursively, the method has no unassigned generic parameters.</span></span> <span data-ttu-id="bbff2-406">El tipo contenedor no tiene ningún parámetro de tipo genérico y ninguno de los argumentos de tipo tiene parámetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="bbff2-406">The containing type has no generic type parameters, and none of the type arguments have generic type parameters.</span></span> <br/><span data-ttu-id="bbff2-407">Puede invocar el método.</span><span class="sxs-lookup"><span data-stu-id="bbff2-407">The method can be invoked.</span></span>|   

 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-408">Obtiene un valor que indica si el método es una definición de método genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-408">Gets a value indicating whether the method is a generic method definition.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-409">
            <see langword="true" /> si el objeto <see cref="T:System.Reflection.MethodBase" /> representa la definición de un método genérico; si no, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-409">
              <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-410">Si la actual <xref:System.Reflection.MethodBase> representa una definición de método genérico, entonces:</span><span class="sxs-lookup"><span data-stu-id="bbff2-410">If the current <xref:System.Reflection.MethodBase> represents a generic method definition, then:</span></span>  
  
-   <span data-ttu-id="bbff2-411">La propiedad <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-411">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property is `true`.</span></span>  
  
-   <span data-ttu-id="bbff2-412">Para cada <xref:System.Type> objeto en la matriz devuelta por la <xref:System.Reflection.MethodBase.GetGenericArguments%2A> método:</span><span class="sxs-lookup"><span data-stu-id="bbff2-412">For each <xref:System.Type> object in the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method:</span></span>  
  
    -   <span data-ttu-id="bbff2-413">La propiedad <xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> es `true`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-413">The <xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> property is `true`.</span></span>  
  
    -   <span data-ttu-id="bbff2-414">El <xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> propiedad devuelve la instancia actual.</span><span class="sxs-lookup"><span data-stu-id="bbff2-414">The <xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> property returns the current instance.</span></span>  
  
    -   <span data-ttu-id="bbff2-415">El <xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> propiedad es igual que la posición de la <xref:System.Type> los objetos de la matriz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-415">The <xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> property is the same as the position of the <xref:System.Type> object in the array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bbff2-416">De forma predeterminada; no admite elementos genéricos Esta propiedad devuelve `false` si no se reemplaza en una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="bbff2-416">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="bbff2-417">No se admiten constructores genéricos en .NET Framework versión 2.0, por lo que esta propiedad devuelve `false` si la instancia actual es de tipo <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-417">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="bbff2-418">Para obtener una lista de las condiciones invariables de términos específicos de métodos genéricos, vea la <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="bbff2-418">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="bbff2-419">Para obtener una lista de las condiciones invariables en otros términos utilizados en la reflexión genérica, vea la <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="bbff2-419">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsHideBySig">
      <MemberSignature Language="C#" Value="public bool IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsHideBySig" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHideBySig As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHideBySig { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-420">Obtiene un valor que indica si sólo hay un miembro del mismo tipo y con idéntica firma oculto en la clase derivada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-420">Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-421">
            <see langword="true" /> si el miembro está oculto por firma; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-421">
              <see langword="true" /> if the member is hidden by signature; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-422">Cuando se declara un miembro en una clase derivada con C# `new` modificador o Visual Basic `Shadows` modificador, puede ocultar un miembro del mismo nombre en la clase base.</span><span class="sxs-lookup"><span data-stu-id="bbff2-422">When a member in a derived class is declared with the C# `new` modifier or the Visual Basic `Shadows` modifier, it can hide a member of the same name in the base class.</span></span> <span data-ttu-id="bbff2-423">C# oculta a los miembros de clase base mediante la firma.</span><span class="sxs-lookup"><span data-stu-id="bbff2-423">C# hides base class members by signature.</span></span> <span data-ttu-id="bbff2-424">Es decir, si el miembro de clase base tiene varias sobrecargas, la única persona que está oculto es aquel que tiene la firma idéntica.</span><span class="sxs-lookup"><span data-stu-id="bbff2-424">That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature.</span></span> <span data-ttu-id="bbff2-425">Por el contrario, Visual Basic oculta todas las sobrecargas de la clase base.</span><span class="sxs-lookup"><span data-stu-id="bbff2-425">By contrast, Visual Basic hides all the base class overloads.</span></span> <span data-ttu-id="bbff2-426">Por lo tanto, <xref:System.Reflection.MethodBase.IsHideBySig%2A> devuelve `false` en un miembro declarado con el de Visual Basic `Shadows` modificador, y `true` en un miembro declarado con C# `new` modificador.</span><span class="sxs-lookup"><span data-stu-id="bbff2-426">Thus, <xref:System.Reflection.MethodBase.IsHideBySig%2A> returns `false` on a member declared with the Visual Basic `Shadows` modifier, and `true` on a member declared with the C# `new` modifier.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="bbff2-427">Esta propiedad no determina si un método que tiene el <xref:System.Reflection.MethodAttributes.NewSlot> atributo.</span><span class="sxs-lookup"><span data-stu-id="bbff2-427">This property does not determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute.</span></span> <span data-ttu-id="bbff2-428">Un método que se declara con cualquiera el `new` o `Shadows` modificador tendrá el <xref:System.Reflection.MethodAttributes.NewSlot> atributo, pero sólo los métodos declarados con `new` (es decir, solo métodos de C#) tendrá la <xref:System.Reflection.MethodBase.IsHideBySig%2A> propiedad establecida en `true`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-428">A method that is declared with either the `new` or the `Shadows` modifier will have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, but only methods declared with `new` (that is, only C# methods) will have the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property set to `true`.</span></span>  <span data-ttu-id="bbff2-429">Para determinar si un método que tiene el <xref:System.Reflection.MethodAttributes.NewSlot> atributo, use código similar al siguiente: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` en C# o `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="bbff2-429">To determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, use code similar to the following: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` in C# or `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` in Visual Basic.</span></span> <span data-ttu-id="bbff2-430">Sin embargo, tenga en cuenta que aunque todos los métodos declaran con `new` o `Shadows` tienen la <xref:System.Reflection.MethodAttributes.NewSlot> atributo, no todos los métodos que tienen el <xref:System.Reflection.MethodAttributes.NewSlot> atributos se declaran con `new` o `Shadows`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-430">Note, however, that although all methods declared with `new` or `Shadows` have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, not all methods that have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute are declared with `new` or `Shadows`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bbff2-431">El siguiente ejemplo de código contiene una clase base con un método sobrecargado y una clase derivada que oculta una de las sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="bbff2-431">The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads.</span></span> <span data-ttu-id="bbff2-432">En la versión de Visual Basic del ejemplo de código, el <xref:System.Reflection.MethodBase.IsHideBySig%2A> propiedad devuelve `false` para el miembro de la clase derivada.</span><span class="sxs-lookup"><span data-stu-id="bbff2-432">In the Visual Basic version of the code example, the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property returns `false` for the member in the derived class.</span></span> <span data-ttu-id="bbff2-433">En la versión de C# del ejemplo de código, se devuelve la propiedad `true` para el miembro de la clase derivada.</span><span class="sxs-lookup"><span data-stu-id="bbff2-433">In the C# version of the code sample, the property returns `true` for the member in the derived class.</span></span>  
  
 [!code-cpp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/cpp/hide.cpp#1)]
 [!code-csharp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/CS/hide.cs#1)]
 [!code-vb[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/VB/hide.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-434">Obtiene un valor que indica si este miembro es privado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-434">Gets a value indicating whether this member is private.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-435">
            <see langword="true" /> si el acceso a este método está restringido a otros miembros de la propia clase; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-435">
              <see langword="true" /> if access to this method is restricted to other members of the class itself; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-436">Si tiene un miembro de tipo `Private` visibilidad de nivel, se puede llamar desde cualquier miembro de la misma clase.</span><span class="sxs-lookup"><span data-stu-id="bbff2-436">If a type member has `Private` level visibility, it can be called from any member in the same class and no others.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-437">Obtiene un valor que indica si éste es un método público.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-437">Gets a value indicating whether this is a public method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-438">
            <see langword="true" /> si este método es público; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-438">
              <see langword="true" /> if this method is public; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-439">Para obtener el <xref:System.Reflection.MethodBase>, primero hay que obtener el tipo.</span><span class="sxs-lookup"><span data-stu-id="bbff2-439">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="bbff2-440">A partir del tipo, obtenga el método.</span><span class="sxs-lookup"><span data-stu-id="bbff2-440">From the type, get the method.</span></span> <span data-ttu-id="bbff2-441">A partir del método, obtenga el `MethodBase`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-441">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="bbff2-442">Si el `MethodBase` o constructor no son públicos, están protegido y no se puede obtener acceso inmediato.</span><span class="sxs-lookup"><span data-stu-id="bbff2-442">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="bbff2-443">Para obtener acceso a un método no público, establezca la <xref:System.Reflection.BindingFlags> enmascarar a `NonPublic` en `GetMethod`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-443">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bbff2-444">En el ejemplo siguiente se usa el <xref:System.Reflection.MethodBase.IsPublic%2A> propiedad para mostrar un mensaje que indica si el método especificado es público.</span><span class="sxs-lookup"><span data-stu-id="bbff2-444">The following example uses the <xref:System.Reflection.MethodBase.IsPublic%2A> property to display a message that indicates whether the specified method is public.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-445">Obtiene un valor que indica si el método o el constructor actual es crítico para la seguridad o es crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual y, por tanto, puede realizar operaciones críticas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-445">Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-446">
            <see langword="true" /> si el método o el constructor actual es crítico para la seguridad o crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; <see langword="false" /> si es transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-446">
              <see langword="true" /> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-447">El <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, y <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> propiedades notifican el nivel de transparencia del método o constructor en su nivel de confianza actual, determinado por common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="bbff2-447">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="bbff2-448">Las combinaciones de estas propiedades se muestran en la tabla siguiente:</span><span class="sxs-lookup"><span data-stu-id="bbff2-448">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="bbff2-449">Nivel de seguridad</span><span class="sxs-lookup"><span data-stu-id="bbff2-449">Security level</span></span>|<span data-ttu-id="bbff2-450">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="bbff2-450">IsSecurityCritical</span></span>|<span data-ttu-id="bbff2-451">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="bbff2-451">IsSecuritySafeCritical</span></span>|<span data-ttu-id="bbff2-452">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="bbff2-452">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="bbff2-453">Crítico</span><span class="sxs-lookup"><span data-stu-id="bbff2-453">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="bbff2-454">Crítico seguro</span><span class="sxs-lookup"><span data-stu-id="bbff2-454">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="bbff2-455">Transparente</span><span class="sxs-lookup"><span data-stu-id="bbff2-455">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="bbff2-456">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos y miembros, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</span><span class="sxs-lookup"><span data-stu-id="bbff2-456">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="bbff2-457">Para los ensamblados de confianza parcial, el valor de esta propiedad depende del nivel de confianza actual del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="bbff2-457">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="bbff2-458">Si el ensamblado se carga en un dominio de aplicación de confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el runtime omite las anotaciones de seguridad del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="bbff2-458">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="bbff2-459">El ensamblado y todos sus tipos se tratan como transparente.</span><span class="sxs-lookup"><span data-stu-id="bbff2-459">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="bbff2-460">El tiempo de ejecución presta atención a las anotaciones de seguridad de un ensamblado de confianza parcial sólo cuando ese ensamblado se carga en un dominio de aplicación de plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio).</span><span class="sxs-lookup"><span data-stu-id="bbff2-460">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="bbff2-461">Por el contrario, un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) siempre se carga con plena confianza, independientemente del nivel de confianza del dominio de aplicación, por lo que su nivel de confianza actual siempre es de plena confianza.</span><span class="sxs-lookup"><span data-stu-id="bbff2-461">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="bbff2-462">Puede determinar los niveles de confianza actuales de ensamblados y dominios de aplicación mediante el <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> y <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propiedades.</span><span class="sxs-lookup"><span data-stu-id="bbff2-462">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="bbff2-463">Para obtener más información sobre la reflexión y transparencia, consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="bbff2-463">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="bbff2-464">Para obtener información acerca de las transparencias, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="bbff2-464">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-465">Obtiene un valor que indica si el método o el constructor actual es crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; es decir, si puede realizar operaciones críticas y está disponible desde código transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-465">Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-466">
            <see langword="true" /> si el método o el constructor es crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; <see langword="false" /> si es crítico para la seguridad o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-466">
              <see langword="true" /> if the method or constructor is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-467">El <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, y <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> propiedades notifican el nivel de transparencia del método o constructor en su nivel de confianza actual, determinado por common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="bbff2-467">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="bbff2-468">Las combinaciones de estas propiedades se muestran en la tabla siguiente:</span><span class="sxs-lookup"><span data-stu-id="bbff2-468">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="bbff2-469">Nivel de seguridad</span><span class="sxs-lookup"><span data-stu-id="bbff2-469">Security level</span></span>|<span data-ttu-id="bbff2-470">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="bbff2-470">IsSecurityCritical</span></span>|<span data-ttu-id="bbff2-471">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="bbff2-471">IsSecuritySafeCritical</span></span>|<span data-ttu-id="bbff2-472">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="bbff2-472">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="bbff2-473">Crítico</span><span class="sxs-lookup"><span data-stu-id="bbff2-473">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="bbff2-474">Crítico seguro</span><span class="sxs-lookup"><span data-stu-id="bbff2-474">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="bbff2-475">Transparente</span><span class="sxs-lookup"><span data-stu-id="bbff2-475">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="bbff2-476">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos y miembros, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</span><span class="sxs-lookup"><span data-stu-id="bbff2-476">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="bbff2-477">Para los ensamblados de confianza parcial, el valor de esta propiedad depende del nivel de confianza actual del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="bbff2-477">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="bbff2-478">Si el ensamblado se carga en un dominio de aplicación de confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el runtime omite las anotaciones de seguridad del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="bbff2-478">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="bbff2-479">El ensamblado y todos sus tipos se tratan como transparente.</span><span class="sxs-lookup"><span data-stu-id="bbff2-479">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="bbff2-480">El tiempo de ejecución presta atención a las anotaciones de seguridad de un ensamblado de confianza parcial sólo cuando ese ensamblado se carga en un dominio de aplicación de plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio).</span><span class="sxs-lookup"><span data-stu-id="bbff2-480">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="bbff2-481">Por el contrario, un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) siempre se carga con plena confianza, independientemente del nivel de confianza del dominio de aplicación, por lo que su nivel de confianza actual siempre es de plena confianza.</span><span class="sxs-lookup"><span data-stu-id="bbff2-481">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="bbff2-482">Puede determinar los niveles de confianza actuales de ensamblados y dominios de aplicación mediante el <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> y <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propiedades.</span><span class="sxs-lookup"><span data-stu-id="bbff2-482">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="bbff2-483">Para obtener más información sobre la reflexión y transparencia, consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="bbff2-483">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="bbff2-484">Para obtener información acerca de las transparencias, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="bbff2-484">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-485">Obtiene un valor que indica si el método o el constructor actual es transparente en el nivel de confianza actual y, por tanto, no puede realizar operaciones críticas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-485">Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-486">Es <see langword="true" /> si el método o el constructor es transparente para la seguridad en el nivel de confianza actual; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-486">
              <see langword="true" /> if the method or constructor is security-transparent at the current trust level; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-487">Si esta propiedad devuelve `true`, <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> y <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> devuelven propiedades `false`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-487">If this property returns `true`, the <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> and <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="bbff2-488">El <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, y <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> propiedades notifican el nivel de transparencia del método o constructor en su nivel de confianza actual, determinado por common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="bbff2-488">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="bbff2-489">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos y miembros, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</span><span class="sxs-lookup"><span data-stu-id="bbff2-489">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="bbff2-490">Para los ensamblados de confianza parcial, el valor de esta propiedad depende del nivel de confianza actual del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="bbff2-490">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="bbff2-491">Si el ensamblado se carga en un dominio de aplicación de confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el runtime omite las anotaciones de seguridad del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="bbff2-491">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="bbff2-492">El ensamblado y todos sus tipos se tratan como transparente.</span><span class="sxs-lookup"><span data-stu-id="bbff2-492">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="bbff2-493">El tiempo de ejecución presta atención a las anotaciones de seguridad de un ensamblado de confianza parcial sólo cuando ese ensamblado se carga en un dominio de aplicación de plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio).</span><span class="sxs-lookup"><span data-stu-id="bbff2-493">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="bbff2-494">Por el contrario, un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) siempre se carga con plena confianza, independientemente del nivel de confianza del dominio de aplicación, por lo que su nivel de confianza actual siempre es de plena confianza.</span><span class="sxs-lookup"><span data-stu-id="bbff2-494">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="bbff2-495">Puede determinar los niveles de confianza actuales de ensamblados y dominios de aplicación mediante el <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> y <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propiedades.</span><span class="sxs-lookup"><span data-stu-id="bbff2-495">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="bbff2-496">Para obtener más información sobre la reflexión y transparencia, consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="bbff2-496">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="bbff2-497">Para obtener información acerca de las transparencias, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="bbff2-497">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-498">Obtiene un valor que indica si este método tiene un nombre especial.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-498">Gets a value indicating whether this method has a special name.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-499">
            <see langword="true" /> si este método tiene un nombre especial; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-499">
              <see langword="true" /> if this method has a special name; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-500">El <xref:System.Reflection.MethodAttributes.SpecialName> bit se establece para marcar los miembros que se tratan de una manera especial por parte de algunos compiladores (por ejemplo, los descriptores de acceso de propiedades y métodos de sobrecarga de operadores).</span><span class="sxs-lookup"><span data-stu-id="bbff2-500">The <xref:System.Reflection.MethodAttributes.SpecialName> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bbff2-501">Este ejemplo muestra el uso de <xref:System.Reflection.MethodBase.IsSpecialName%2A> para filtrar internos o los miembros privados de una lista.</span><span class="sxs-lookup"><span data-stu-id="bbff2-501">This example shows a use of <xref:System.Reflection.MethodBase.IsSpecialName%2A> to filter internal or private members out of a list.</span></span>  
  
 [!code-cpp[Classic Type.IsSpecialName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsSpecialName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsSpecialName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-502">Obtiene un valor que indica si el método es <see langword="static" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-502">Gets a value indicating whether the method is <see langword="static" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-503">
            <see langword="true" /> si este método es <see langword="static" />; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-503">
              <see langword="true" /> if this method is <see langword="static" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-504">Un miembro estático implícitamente no puede hacer referencia a datos de instancia de una clase.</span><span class="sxs-lookup"><span data-stu-id="bbff2-504">A static member cannot implicitly reference instance data in a class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsVirtual">
      <MemberSignature Language="C#" Value="public bool IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsVirtual" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVirtual As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVirtual { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-505">Obtiene un valor que indica si el método es <see langword="virtual" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-505">Gets a value indicating whether the method is <see langword="virtual" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-506">
            <see langword="true" /> si este método es <see langword="virtual" />; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-506">
              <see langword="true" /> if this method is <see langword="virtual" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-507">Un miembro virtual puede hacer referencia a datos de instancia de una clase y se debe hacer referencia a través de una instancia de la clase.</span><span class="sxs-lookup"><span data-stu-id="bbff2-507">A virtual member may reference instance data in a class and must be referenced through an instance of the class.</span></span>  
  
 <span data-ttu-id="bbff2-508">Para determinar si un método es reemplazable, no es suficiente comprobar que `IsVirtual` es `true`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-508">To determine if a method is overridable, it is not sufficient to check that `IsVirtual` is `true`.</span></span> <span data-ttu-id="bbff2-509">Para un método se pueda reemplazar, `IsVirtual` debe ser `true` y <xref:System.Reflection.MethodBase.IsFinal%2A> debe ser `false`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-509">For a method to be overridable, `IsVirtual` must be `true` and <xref:System.Reflection.MethodBase.IsFinal%2A> must be `false`.</span></span> <span data-ttu-id="bbff2-510">Por ejemplo, un método podría ser no virtual, pero implementa un método de interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-510">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="bbff2-511">Common language runtime requiere que todos los métodos que implementan miembros de interfaz deben marcarse como `virtual`; por lo tanto, el compilador marca el método `virtual final`.</span><span class="sxs-lookup"><span data-stu-id="bbff2-511">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="bbff2-512">Por lo que hay casos donde un método está marcado como `virtual` , pero no es reemplazable.</span><span class="sxs-lookup"><span data-stu-id="bbff2-512">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="bbff2-513">Para establecer con certeza si un método es reemplazable, utilice código como este:</span><span class="sxs-lookup"><span data-stu-id="bbff2-513">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
```csharp  
if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)  
```  
  
```vb  
If MethodInfo.IsVirtual AndAlso Not MethodInfo.IsFinal Then  
```  
  
 <span data-ttu-id="bbff2-514">Si `IsVirtual` es `false` o `IsFinal` es `true`, a continuación, no se puede invalidar el método.</span><span class="sxs-lookup"><span data-stu-id="bbff2-514">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
 <span data-ttu-id="bbff2-515">Puede determinar si el método actual invalida un método en una clase base mediante una llamada a la <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="bbff2-515">You can determine whether the current method overrides a method in a base class by calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="bbff2-516">En el ejemplo siguiente se implementa un `IsOverride` método que lo haga.</span><span class="sxs-lookup"><span data-stu-id="bbff2-516">The following example implements an `IsOverride` method that does this.</span></span>  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="bbff2-517">En el ejemplo siguiente se muestra `false` para `IsFinal`, que puede llevarle a pensar que `MyMethod` es reemplazable.</span><span class="sxs-lookup"><span data-stu-id="bbff2-517">The following example displays `false` for `IsFinal`, which might lead you to think that `MyMethod` is overridable.</span></span> <span data-ttu-id="bbff2-518">El código imprime `false` aunque `MyMethod` no está marcada como `virtual` y, por tanto, no se puede invalidar.</span><span class="sxs-lookup"><span data-stu-id="bbff2-518">The code prints `false` even though `MyMethod` is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.MethodHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-519">Obtiene un identificador para la representación interna de metadatos de un método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-519">Gets a handle to the internal metadata representation of a method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-520">Un objeto <see cref="T:System.RuntimeMethodHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-520">A <see cref="T:System.RuntimeMethodHandle" /> object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-521">Los identificadores son válidos únicamente en el dominio de aplicación en el que se obtuvieron.</span><span class="sxs-lookup"><span data-stu-id="bbff2-521">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-522">Obtiene las marcas <see cref="T:System.Reflection.MethodImplAttributes" /> que especifican los atributos de una implementación de método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-522">Gets the <see cref="T:System.Reflection.MethodImplAttributes" /> flags that specify the attributes of a method implementation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-523">Marcas de implementación de método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-523">The method implementation flags.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-524">Vea el método <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> para más información.</span><span class="sxs-lookup"><span data-stu-id="bbff2-524">See the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method for more information.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="bbff2-525">Primer objeto que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-525">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="bbff2-526">Segundo objeto que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-526">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bbff2-527">Indica si dos objetos <see cref="T:System.Reflection.MethodBase" /> son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-527">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bbff2-528">
            <see langword="true" /> si <paramref name="left" /> es igual a <paramref name="right" />; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-528">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="bbff2-529">Primer objeto que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-529">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="bbff2-530">Segundo objeto que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-530">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bbff2-531">Indica si dos objetos <see cref="T:System.Reflection.MethodBase" /> no son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-531">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bbff2-532">Es <see langword="true" /> si <paramref name="left" /> no es igual a <paramref name="right" />; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-532">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBase.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBase.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBase::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="bbff2-533">Reservado para un uso futuro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-533">Reserved for future use.</span>
          </span>
          <span data-ttu-id="bbff2-534">Debe ser IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-534">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="bbff2-535">Matriz que se pasa con los nombres que se van a asignar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-535">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="bbff2-536">Número de nombres que se van a asignar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-536">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="bbff2-537">Contexto de configuración regional en el que se van a interpretar los nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-537">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="bbff2-538">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-538">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bbff2-539">Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-539">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-540">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="bbff2-540">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="bbff2-541">Para obtener más información sobre `IDispatch::GetIDsOfNames`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="bbff2-541">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="bbff2-542">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-542">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetType">
      <MemberSignature Language="C#" Value="Type _MethodBase.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodBase.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodBase.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodBase.GetType() = System::Runtime::InteropServices::_MethodBase::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-543">Para una descripción de este miembro, vea <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-543">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bbff2-544">Para una descripción de este miembro, vea <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-544">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-545">Este miembro es una implementación explícita de un miembro de interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-545">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="bbff2-546">Solo se puede utilizar cuando la instancia de <xref:System.Reflection.MethodBase> se convierte en una interfaz <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-546">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBase.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="bbff2-547">Información de tipos que se va a devolver.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-547">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="bbff2-548">Identificador de la configuración regional de la información de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-548">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="bbff2-549">Recibe un puntero al objeto de información de tipo solicitado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-549">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bbff2-550">Recupera la información de tipo de un objeto, que se puede usar después para obtener la información de tipo de una interfaz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-550">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-551">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="bbff2-551">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="bbff2-552">Para obtener más información sobre `IDispatch::GetTypeInfo`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="bbff2-552">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="bbff2-553">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-553">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBase.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="bbff2-554">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-554">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bbff2-555">Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-555">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-556">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="bbff2-556">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="bbff2-557">Para obtener más información sobre `IDispatch::GetTypeInfoCount`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="bbff2-557">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="bbff2-558">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-558">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBase.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBase.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBase::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="bbff2-559">Identifica el miembro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-559">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="bbff2-560">Reservado para un uso futuro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-560">Reserved for future use.</span>
          </span>
          <span data-ttu-id="bbff2-561">Debe ser IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-561">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="bbff2-562">Contexto de la configuración regional en que se interpretan los argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-562">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="bbff2-563">Marcas que describen el contexto de la llamada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-563">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="bbff2-564">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-564">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="bbff2-565">Puntero a la ubicación donde se va a almacenar el resultado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-565">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="bbff2-566">Puntero a una estructura que contiene información de excepciones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-566">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="bbff2-567">Índice del primer argumento que tiene un error.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-567">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bbff2-568">Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-568">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-569">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="bbff2-569">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="bbff2-570">Para obtener más información sobre `IDispatch::Invoke`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="bbff2-570">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="bbff2-571">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-571">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAbstract">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAbstract As Boolean Implements _MethodBase.IsAbstract" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-572">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-572">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-573">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-573">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-574">Este miembro es una implementación explícita de un miembro de interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-574">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="bbff2-575">Solo se puede utilizar cuando la instancia de <xref:System.Reflection.MethodBase> se convierte en una interfaz <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-575">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAssembly As Boolean Implements _MethodBase.IsAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-576">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-576">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-577">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-577">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-578">Este miembro es una implementación explícita de un miembro de interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-578">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="bbff2-579">Solo se puede utilizar cuando la instancia de <xref:System.Reflection.MethodBase> se convierte en una interfaz <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-579">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsConstructor">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsConstructor As Boolean Implements _MethodBase.IsConstructor" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsConstructor { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-580">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-580">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-581">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-581">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-582">Este miembro es una implementación explícita de un miembro de interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-582">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="bbff2-583">Solo se puede utilizar cuando la instancia de <xref:System.Reflection.MethodBase> se convierte en una interfaz <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-583">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamily">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamily As Boolean Implements _MethodBase.IsFamily" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-584">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-584">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-585">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-585">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-586">Este miembro es una implementación explícita de un miembro de interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-586">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="bbff2-587">Solo se puede utilizar cuando la instancia de <xref:System.Reflection.MethodBase> se convierte en una interfaz <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-587">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyAndAssembly As Boolean Implements _MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-588">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-588">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-589">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-589">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-590">Este miembro es una implementación explícita de un miembro de interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-590">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="bbff2-591">Solo se puede utilizar cuando la instancia de <xref:System.Reflection.MethodBase> se convierte en una interfaz <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-591">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyOrAssembly As Boolean Implements _MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-592">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-592">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-593">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-593">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-594">Este miembro es una implementación explícita de un miembro de interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-594">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="bbff2-595">Solo se puede utilizar cuando la instancia de <xref:System.Reflection.MethodBase> se convierte en una interfaz <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-595">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFinal">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFinal As Boolean Implements _MethodBase.IsFinal" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFinal { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-596">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-596">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-597">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-597">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-598">Este miembro es una implementación explícita de un miembro de interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-598">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="bbff2-599">Solo se puede utilizar cuando la instancia de <xref:System.Reflection.MethodBase> se convierte en una interfaz <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-599">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsHideBySig">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsHideBySig As Boolean Implements _MethodBase.IsHideBySig" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsHideBySig { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-600">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-600">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-601">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-601">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-602">Este miembro es una implementación explícita de un miembro de interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-602">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="bbff2-603">Solo se puede utilizar cuando la instancia de <xref:System.Reflection.MethodBase> se convierte en una interfaz <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-603">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPrivate">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPrivate As Boolean Implements _MethodBase.IsPrivate" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-604">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-604">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-605">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-605">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-606">Este miembro es una implementación explícita de un miembro de interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-606">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="bbff2-607">Solo se puede utilizar cuando la instancia de <xref:System.Reflection.MethodBase> se convierte en una interfaz <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-607">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPublic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPublic As Boolean Implements _MethodBase.IsPublic" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-608">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-608">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-609">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-609">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-610">Este miembro es una implementación explícita de un miembro de interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-610">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="bbff2-611">Solo se puede utilizar cuando la instancia de <xref:System.Reflection.MethodBase> se convierte en una interfaz <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-611">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsSpecialName">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSpecialName As Boolean Implements _MethodBase.IsSpecialName" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-612">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-612">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-613">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-613">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-614">Este miembro es una implementación explícita de un miembro de interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-614">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="bbff2-615">Solo se puede utilizar cuando la instancia de <xref:System.Reflection.MethodBase> se convierte en una interfaz <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-615">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsStatic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsStatic As Boolean Implements _MethodBase.IsStatic" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsStatic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-616">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-616">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-617">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-617">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-618">Este miembro es una implementación explícita de un miembro de interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-618">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="bbff2-619">Solo se puede utilizar cuando la instancia de <xref:System.Reflection.MethodBase> se convierte en una interfaz <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-619">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsVirtual">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsVirtual As Boolean Implements _MethodBase.IsVirtual" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsVirtual { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bbff2-620">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-620">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bbff2-621">Para una descripción de este miembro, vea <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bbff2-621">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bbff2-622">Este miembro es una implementación explícita de un miembro de interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbff2-622">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="bbff2-623">Solo se puede utilizar cuando la instancia de <xref:System.Reflection.MethodBase> se convierte en una interfaz <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="bbff2-623">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>