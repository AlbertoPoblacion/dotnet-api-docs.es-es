<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MemberInfo.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac58db62a3ed31bdc693e0000017df74ab65286b3e5.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8db62a3ed31bdc693e0000017df74ab65286b3e5</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.MemberInfo">
          <source>Obtains information about the attributes of a member and provides access to member metadata.</source>
          <target state="translated">Obtiene información de los atributos de un miembro y proporciona acceso a los metadatos del miembro.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MemberInfo">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> class is the abstract base class for classes used to obtain information about all members of a class (constructors, events, fields, methods, and properties).</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> clase es la clase base abstracta para las clases utilizadas para obtener información acerca de todos los miembros de una clase (constructores, eventos, campos, métodos y propiedades).</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MemberInfo">
          <source>This class introduces the basic functionality that all members provide.</source>
          <target state="translated">Esta clase contiene la funcionalidad básica que proporcionan todos los miembros.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MemberInfo">
          <source>This example shows how to use various reflection classes to analyze the metadata contained in an assembly.</source>
          <target state="translated">Este ejemplo muestra cómo usar varias clases de reflexión para analizar los metadatos contenidos en un ensamblado.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MemberInfo">
          <source>for full trust for inheritors.</source>
          <target state="translated">de plena confianza para los herederos.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MemberInfo">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">Esta clase no puede heredarse mediante código de confianza parcial.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MemberInfo">
          <source>This type is thread safe.</source>
          <target state="translated">Este tipo es seguro para la ejecución de subprocesos.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MemberInfo">
          <source>When you inherit from <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> you must override the following members: <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> and <ph id="ph3">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</source>
          <target state="translated">Al heredar de <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> debe reemplazar los miembros siguientes: <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> y <ph id="ph3">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.#ctor">
          <source>Only a derived class can create this <ph id="ph1">`MemberInfo`</ph> class.</source>
          <target state="translated">Solo puede crear una clase derivada esto <ph id="ph1">`MemberInfo`</ph> clase.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="P:System.Reflection.MemberInfo.CustomAttributes">
          <source>Gets a collection that contains this member's custom attributes.</source>
          <target state="translated">Obtiene una colección que contiene los atributos personalizados de este miembro.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.CustomAttributes">
          <source>A collection that contains this member's custom attributes.</source>
          <target state="translated">Colección que contiene los atributos personalizados de este miembro.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="P:System.Reflection.MemberInfo.DeclaringType">
          <source>Gets the class that declares this member.</source>
          <target state="translated">Obtiene la clase que declara este miembro.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.DeclaringType">
          <source>The <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object for the class that declares this member.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see langword="Type" /&gt;</ph> de la clase que declara este miembro.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.DeclaringType">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> property retrieves a reference to the <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for the type that declares this member.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> propiedad recupera una referencia a la <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto para el tipo que declara este miembro.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.DeclaringType">
          <source>A member of a type is either declared by the type or inherited from a base type, so the <ph id="ph1">`Type`</ph> object returned by the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> property might not be the same as the <ph id="ph3">`Type`</ph> object used to obtain the current <ph id="ph4">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object.</source>
          <target state="translated">Un miembro de un tipo está declarado por el tipo o se hereda de un tipo base, por lo que la <ph id="ph1">`Type`</ph> objeto devuelto por la <ph id="ph2">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> propiedad no puede ser el mismo que el <ph id="ph3">`Type`</ph> objeto que se usa para obtener la actual <ph id="ph4">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.DeclaringType">
          <source>If the <ph id="ph1">`Type`</ph> object from which this <ph id="ph2">`MemberInfo`</ph> object was obtained did not declare this member, the <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> property will represent one of its base types.</source>
          <target state="translated">Si el <ph id="ph1">`Type`</ph> objeto a partir del cual <ph id="ph2">`MemberInfo`</ph> se obtuvo el objeto no declara este miembro, la <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> propiedad representará uno de sus tipos base.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.DeclaringType">
          <source>If the <ph id="ph1">`MemberInfo`</ph> object is a global member (that is, if it was obtained from the <ph id="ph2">&lt;xref:System.Reflection.Module.GetMethods%2A?displayProperty=nameWithType&gt;</ph> method, which returns global methods on a module), the returned <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> will be <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Si el <ph id="ph1">`MemberInfo`</ph> objeto es un miembro global (es decir, si se obtuvo de la <ph id="ph2">&lt;xref:System.Reflection.Module.GetMethods%2A?displayProperty=nameWithType&gt;</ph> método, que devuelve los métodos globales en un módulo), el valor devuelto <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> será <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.DeclaringType">
          <source>The following example defines an interface, <ph id="ph1">`IValue`</ph>, with a single member, <ph id="ph2">`GetValue`</ph>.</source>
          <target state="translated">En el ejemplo siguiente se define una interfaz, <ph id="ph1">`IValue`</ph>, con un solo miembro, <ph id="ph2">`GetValue`</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.DeclaringType">
          <source>It also defines four classes: <ph id="ph1">`A`</ph>, a base class that implements the <ph id="ph2">`IValue`</ph> interface; <ph id="ph3">`B`</ph>, which inherits from <ph id="ph4">`A`</ph> and hides its implementation of <ph id="ph5">`GetValue`</ph> from the base class implementation; <ph id="ph6">`C`</ph>, which simply inherits from <ph id="ph7">`A`</ph>; and <ph id="ph8">`D`</ph>, which inherits from <ph id="ph9">`A`</ph> and overrides its <ph id="ph10">`GetValue`</ph> method.</source>
          <target state="translated">También define cuatro clases: <ph id="ph1">`A`</ph>, una clase base que implementa el <ph id="ph2">`IValue`</ph> interfaz; <ph id="ph3">`B`</ph>, que hereda de <ph id="ph4">`A`</ph> y oculta su implementación de <ph id="ph5">`GetValue`</ph> de la implementación de la clase base; <ph id="ph6">`C`</ph>, que se deriva simplemente de <ph id="ph7">`A`</ph>; y <ph id="ph8">`D`</ph>, que hereda de <ph id="ph9">`A`</ph> e invalida su <ph id="ph10">`GetValue`</ph> método.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.DeclaringType">
          <source>The example then retrieves a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object for each member of the type (including members inherited from <ph id="ph2">&lt;xref:System.Object&gt;</ph>) and displays the value of its <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> property.</source>
          <target state="translated">El ejemplo, a continuación, se recupera un <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objeto para cada miembro del tipo (incluidos los miembros heredaron de <ph id="ph2">&lt;xref:System.Object&gt;</ph>) y muestra el valor de su <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.DeclaringType">
          <source>Note that the declaring type of <ph id="ph1">`A.GetValue`</ph> is <ph id="ph2">`A`</ph>, that <ph id="ph3">`B`</ph> includes two <ph id="ph4">`GetValue`</ph> methods, one declared by <ph id="ph5">`A`</ph> and one by <ph id="ph6">`B`</ph>, and that the declaring type of <ph id="ph7">`D.GetValue`</ph> is <ph id="ph8">`D`</ph>.</source>
          <target state="translated">Tenga en cuenta que el tipo declarativo del <ph id="ph1">`A.GetValue`</ph> es <ph id="ph2">`A`</ph>, que <ph id="ph3">`B`</ph> incluye dos <ph id="ph4">`GetValue`</ph> métodos, uno declarado por <ph id="ph5">`A`</ph> y una por <ph id="ph6">`B`</ph>, y que el tipo declarativo del <ph id="ph7">`D.GetValue`</ph> es <ph id="ph8">`D`</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.DeclaringType">
          <source><ph id="ph1">`DeclaringType`</ph> returns only the member names and the names of their declaring types.</source>
          <target state="translated"><ph id="ph1">`DeclaringType`</ph> Devuelve solo los nombres de miembro y los nombres de sus tipos declarativo.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.DeclaringType">
          <source>To return the member names with their prototypes, call <ph id="ph1">`MemberInfo.ToString`</ph>.</source>
          <target state="translated">Para devolver el miembro de los nombres con los prototipos, llame a <ph id="ph1">`MemberInfo.ToString`</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.Equals(System.Object)">
          <source>An object to compare with this instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que se va a comparar con esta instancia o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.Equals(System.Object)">
          <source>Returns a value that indicates whether this instance is equal to a specified object.</source>
          <target state="translated">Devuelve un valor que indica si esta instancia equivale a un objeto especificado.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> equals the type and value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> es igual al tipo y valor de esta instancia; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="T:System.Reflection.MemberInfo">
          <source>When overridden in a derived class, returns custom attributes applied to this member.</source>
          <target state="translated">Cuando se reemplaza en una clase derivada, devuelve los atributos personalizados aplicados a este miembro.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to search this member's inheritance chain to find the attributes; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para buscar en la cadena de herencia de este miembro para encontrar los atributos; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)">
          <source>This parameter is ignored for properties and events.</source>
          <target state="translated">Este parámetro se omite para las propiedades y los eventos.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)">
          <source>When overridden in a derived class, returns an array of all custom attributes applied to this member.</source>
          <target state="translated">Cuando se reemplaza en una clase derivada, devuelve una matriz de todos los atributos personalizados aplicados a este miembro.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)">
          <source>An array that contains all the custom attributes applied to this member, or an array with zero elements if no attributes are defined.</source>
          <target state="translated">Matriz que contiene todos los atributos personalizados aplicados a este miembro, o matriz con cero elementos si no se ha definido ningún atributo.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)">
          <source>This method ignores the <ph id="ph1">`inherit`</ph> parameter for properties and events.</source>
          <target state="translated">Este método omite la <ph id="ph1">`inherit`</ph> parámetro para las propiedades y eventos.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)">
          <source>To search the inheritance chain for attributes on properties and events, use the appropriate overloads of the <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para buscar la cadena de herencia de atributos en las propiedades y eventos, use las sobrecargas adecuadas de la <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)">
          <source>In the .NET Framework version 2.0, this method returns security attributes on methods, constructors, and types if they are stored in the new metadata format.</source>
          <target state="translated">En la versión 2.0 de .NET Framework, este método devuelve los atributos de seguridad en métodos, constructores y tipos si se almacenan en el nuevo formato de metadatos.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)">
          <source>Assemblies compiled with version 2.0 use this format.</source>
          <target state="translated">Los ensamblados compilados con la versión 2.0 utilizan este formato.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)">
          <source>Dynamic assemblies and assemblies compiled with earlier versions of the .NET Framework use the old XML format.</source>
          <target state="translated">Ensamblados dinámicos y los ensamblados compilados con versiones anteriores de .NET Framework usan el formato XML antiguo.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Emitting Declarative Security Attributes<ept id="p1">](http://msdn.microsoft.com/library/9eeddee8-ca89-4440-b84b-fd613f590cd5)</ept>.</source>
          <target state="translated">Vea <bpt id="p1">[</bpt>emitir atributos de seguridad declarativa<ept id="p1">](http://msdn.microsoft.com/library/9eeddee8-ca89-4440-b84b-fd613f590cd5)</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)">
          <source>The following example defines a custom attribute and associates the attribute with <ph id="ph1">`MyClass.MyMethod`</ph>, retrieves the attribute at run time, and displays the result.</source>
          <target state="translated">En el ejemplo siguiente se define un atributo personalizado y asocia el atributo con <ph id="ph1">`MyClass.MyMethod`</ph>, recupera el atributo en tiempo de ejecución y se muestra el resultado.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)">
          <source>This member belongs to a type that is loaded into the reflection-only context.</source>
          <target state="translated">Este miembro pertenece a un tipo que se carga en el contexto de sólo reflexión.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)">
          <source>See <bpt id="p1">[</bpt>How to: Load Assemblies into the Reflection-Only Context<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)</ept>.</source>
          <target state="translated">Consulte <bpt id="p1">[</bpt>Cómo: Cargar ensamblados en el contexto de solo reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)</ept>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)">
          <source>A custom attribute type could not be loaded.</source>
          <target state="translated">No ha podido cargarse un tipo de atributo personalizado.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type of attribute to search for.</source>
          <target state="translated">Tipo de atributo que se va a buscar.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Only attributes that are assignable to this type are returned.</source>
          <target state="translated">Sólo se devuelven los atributos que se pueden asignar a este tipo.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to search this member's inheritance chain to find the attributes; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para buscar en la cadena de herencia de este miembro para encontrar los atributos; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This parameter is ignored for properties and events.</source>
          <target state="translated">Este parámetro se omite para las propiedades y los eventos.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>When overridden in a derived class, returns an array of custom attributes applied to this member and identified by <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Cuando se reemplaza en una clase derivada, devuelve una matriz de atributos personalizados aplicados a este miembro e identificados por <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of custom attributes applied to this member, or an array with zero elements if no attributes assignable to <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> have been applied.</source>
          <target state="translated">Matriz de atributos personalizados aplicados a este miembro, o matriz con cero elementos si no se ha aplicado ningún atributo que se pueda asignar a <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This method ignores the <ph id="ph1">`inherit`</ph> parameter for properties and events.</source>
          <target state="translated">Este método omite la <ph id="ph1">`inherit`</ph> parámetro para las propiedades y eventos.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>To search the inheritance chain for attributes on properties and events, use the appropriate overloads of the <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para buscar la cadena de herencia de atributos en las propiedades y eventos, use las sobrecargas adecuadas de la <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>In the .NET Framework version 2.0, this method returns security attributes on methods, constructors, and types if the attributes are stored in the new metadata format.</source>
          <target state="translated">En la versión 2.0 de .NET Framework, este método devuelve los atributos de seguridad en métodos, constructores y tipos si los atributos se almacenan en el nuevo formato de metadatos.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Assemblies compiled with version 2.0 use this format.</source>
          <target state="translated">Los ensamblados compilados con la versión 2.0 utilizan este formato.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Dynamic assemblies and assemblies compiled with earlier versions of the .NET Framework use the old XML format.</source>
          <target state="translated">Ensamblados dinámicos y los ensamblados compilados con versiones anteriores de .NET Framework usan el formato XML antiguo.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Emitting Declarative Security Attributes<ept id="p1">](http://msdn.microsoft.com/library/9eeddee8-ca89-4440-b84b-fd613f590cd5)</ept>.</source>
          <target state="translated">Vea <bpt id="p1">[</bpt>emitir atributos de seguridad declarativa<ept id="p1">](http://msdn.microsoft.com/library/9eeddee8-ca89-4440-b84b-fd613f590cd5)</ept>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The following example defines a class named <ph id="ph1">`BaseClass`</ph> that has two non-inherited members: a thread static field named <ph id="ph2">`total`</ph> and a non-CLS-compliant method named <ph id="ph3">`MethodA`</ph>.</source>
          <target state="translated">En el ejemplo siguiente se define una clase denominada <ph id="ph1">`BaseClass`</ph> que tiene dos miembros no heredados: un campo estático de subproceso denominado <ph id="ph2">`total`</ph> y un método no es conforme a CLS denominado <ph id="ph3">`MethodA`</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>A class named <ph id="ph1">`DerivedClass`</ph> inherits from <ph id="ph2">`BaseClass`</ph> and overrides its <ph id="ph3">`MethodA`</ph> method.</source>
          <target state="translated">Una clase denominada <ph id="ph1">`DerivedClass`</ph> hereda de <ph id="ph2">`BaseClass`</ph> e invalida su <ph id="ph3">`MethodA`</ph> método.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Note that no attributes are applied to the members of <ph id="ph1">`DerivedClass`</ph>.</source>
          <target state="translated">Tenga en cuenta que no hay atributos se aplican a los miembros de <ph id="ph1">`DerivedClass`</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The example iterates the members of <ph id="ph1">`DerivedClass`</ph> to determine whether the <ph id="ph2">&lt;xref:System.CLSCompliantAttribute&gt;</ph> or <ph id="ph3">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute as been applied to them.</source>
          <target state="translated">El ejemplo recorre en iteración los miembros de <ph id="ph1">`DerivedClass`</ph> para determinar si la <ph id="ph2">&lt;xref:System.CLSCompliantAttribute&gt;</ph> o <ph id="ph3">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atributo tal y como se ha aplicado a ellos.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Because <ph id="ph1">`inherit`</ph> is <ph id="ph2">`true`</ph>, the method searches the inheritance hierarchy of <ph id="ph3">`DerivedClass`</ph> for the specified attribute.</source>
          <target state="translated">Dado que <ph id="ph1">`inherit`</ph> es <ph id="ph2">`true`</ph>, el método busca en la jerarquía de herencia de <ph id="ph3">`DerivedClass`</ph> para el atributo especificado.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>As the output from the example shows, the <ph id="ph1">`total`</ph> field is decorated with the <ph id="ph2">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute, and the <ph id="ph3">`MethodA`</ph> method is decorated with the <ph id="ph4">&lt;xref:System.CLSCompliantAttribute&gt;</ph> attribute.</source>
          <target state="translated">Como la salida se muestra en el ejemplo, el <ph id="ph1">`total`</ph> campo se decora con el <ph id="ph2">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atributo y el <ph id="ph3">`MethodA`</ph> método se decora con el <ph id="ph4">&lt;xref:System.CLSCompliantAttribute&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>A custom attribute type cannot be loaded.</source>
          <target state="translated">Un tipo de atributo personalizado no puede cargarse.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>If <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This member belongs to a type that is loaded into the reflection-only context.</source>
          <target state="translated">Este miembro pertenece a un tipo que se carga en el contexto de sólo reflexión.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>How to: Load Assemblies into the Reflection-Only Context<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)</ept>.</source>
          <target state="translated">Consulte <bpt id="p1">[</bpt>Cómo: Cargar ensamblados en el contexto de solo reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)</ept>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributesData">
          <source>Returns a list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects representing data about the attributes that have been applied to the target member.</source>
          <target state="translated">Devuelve una lista de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> que representan datos sobre los atributos que se han aplicado al miembro de destino.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetCustomAttributesData">
          <source>A generic list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects representing data about the attributes that have been applied to the target member.</source>
          <target state="translated">Lista genérica de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> que representan datos sobre los atributos que se han aplicado al miembro de destino.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributesData">
          <source>Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</source>
          <target state="translated">Utilice este método para examinar los atributos personalizados del código en el contexto de solo reflexión, en casos donde se definen los atributos personalizados propios en el código que se carga en el contexto de solo reflexión.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributesData">
          <source>Methods like <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> cannot be used in such cases, because they create instances of the attributes.</source>
          <target state="translated">Métodos como <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> no se puede usar en casos como éste, porque crean instancias de los atributos.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributesData">
          <source>Code in the reflection-only context cannot be executed.</source>
          <target state="translated">No se puede ejecutar código en el contexto de solo reflexión.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributesData">
          <source>For more information and for example code, see the <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> class.</source>
          <target state="translated">Para obtener más información y por ejemplo código, vea la <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.GetCustomAttributesData">
          <source>This method gets custom attribute data for types, nested types, and type members, because the <ph id="ph1">&lt;xref:System.Type&gt;</ph> class and the classes in the <ph id="ph2">&lt;xref:System.Reflection&gt;</ph> namespace that represent type members all derive from <ph id="ph3">&lt;xref:System.Reflection.MemberInfo&gt;</ph>.</source>
          <target state="translated">Este método obtiene datos de atributos personalizados para tipos, tipos anidados y miembros de tipo, porque el <ph id="ph1">&lt;xref:System.Type&gt;</ph> y las clases en el <ph id="ph2">&lt;xref:System.Reflection&gt;</ph> espacio de nombres que representan miembros de tipo todos se derivan <ph id="ph3">&lt;xref:System.Reflection.MemberInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Devuelve el código hash de esta instancia.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Código hash de un entero de 32 bits con signo.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)">
          <source>The type of custom attribute to search for.</source>
          <target state="translated">Tipo de atributo personalizado que se va a buscar.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)">
          <source>The search includes derived types.</source>
          <target state="translated">La búsqueda incluye los tipos derivados.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to search this member's inheritance chain to find the attributes; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para buscar en la cadena de herencia de este miembro para encontrar los atributos; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)">
          <source>This parameter is ignored for properties and events.</source>
          <target state="translated">Este parámetro se omite para las propiedades y los eventos.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)">
          <source>When overridden in a derived class, indicates whether one or more attributes of the specified type or of its derived types is applied to this member.</source>
          <target state="translated">Cuando se reemplaza en una clase derivada, indica si se aplican a este miembro uno o más atributos del tipo especificado o de sus tipos derivados.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if one or more instances of <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> or any of its derived types is applied to this member; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se aplican una o más instancias de <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> o alguno de sus tipos derivados a este miembro; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)">
          <source>This method ignores the <ph id="ph1">`inherit`</ph> parameter for properties and events.</source>
          <target state="translated">Este método omite la <ph id="ph1">`inherit`</ph> parámetro para las propiedades y eventos.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)">
          <source>To search the inheritance chain for attributes on properties and events, use the appropriate overloads of the <ph id="ph1">&lt;xref:System.Attribute.IsDefined%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para buscar la cadena de herencia de atributos en las propiedades y eventos, use las sobrecargas adecuadas de la <ph id="ph1">&lt;xref:System.Attribute.IsDefined%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)">
          <source>In the .NET Framework version 2.0, this method returns <ph id="ph1">`true`</ph> if a type, method, or constructor has security attributes stored in the new metadata format.</source>
          <target state="translated">En la versión 2.0 de .NET Framework, este método devuelve <ph id="ph1">`true`</ph> si un tipo, método o constructor tiene atributos de seguridad almacenados en el nuevo formato de metadatos.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)">
          <source>Assemblies compiled with version 2.0 use this format.</source>
          <target state="translated">Los ensamblados compilados con la versión 2.0 utilizan este formato.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)">
          <source>Dynamic assemblies and assemblies compiled with earlier versions of the .NET Framework use the old XML format.</source>
          <target state="translated">Ensamblados dinámicos y los ensamblados compilados con versiones anteriores de .NET Framework usan el formato XML antiguo.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Emitting Declarative Security Attributes<ept id="p1">](http://msdn.microsoft.com/library/9eeddee8-ca89-4440-b84b-fd613f590cd5)</ept>.</source>
          <target state="translated">Vea <bpt id="p1">[</bpt>emitir atributos de seguridad declarativa<ept id="p1">](http://msdn.microsoft.com/library/9eeddee8-ca89-4440-b84b-fd613f590cd5)</ept>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)">
          <source>The following example determines whether the specified attribute is applied to the specified member.</source>
          <target state="translated">En el ejemplo siguiente se determina si el atributo especificado se aplica al miembro especificado.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="P:System.Reflection.MemberInfo.MemberType">
          <source>When overridden in a derived class, gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating the type of the member — method, constructor, event, and so on.</source>
          <target state="translated">Cuando se invalida en una clase derivada, obtiene un valor de <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> que indica el tipo de miembro (método, constructor, evento, etc.).</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.MemberType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating the type of member.</source>
          <target state="translated">Valor de <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> que indica el tipo de miembro.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.MemberType">
          <source>This property is overridden in derived classes, and the override returns the appropriate member type.</source>
          <target state="translated">Esta propiedad se reemplaza en las clases derivadas, y la invalidación devuelve el tipo de miembro adecuado.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.MemberType">
          <source>Therefore, when you examine a set of <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects — for example, the array returned by <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph> — the <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> property can be used to determine the member type of any given member.</source>
          <target state="translated">Por lo tanto, cuando se examina un conjunto de <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objetos, por ejemplo, la matriz devuelta por <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph> : el <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> propiedad puede utilizarse para determinar el tipo de miembro de cualquier miembro determinado.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.MemberType">
          <source>To get the <ph id="ph1">`MemberType`</ph> property, get the class <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Para obtener la <ph id="ph1">`MemberType`</ph> propiedad, obtener la clase <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.MemberType">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> array.</source>
          <target state="translated">Desde el <ph id="ph1">`Type`</ph>, obtener el <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> matriz.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.MemberType">
          <source>From the <ph id="ph1">`MethodInfo`</ph> array, get the <ph id="ph2">`MemberTypes`</ph>.</source>
          <target state="translated">Desde el <ph id="ph1">`MethodInfo`</ph> de matriz, obtenga el <ph id="ph2">`MemberTypes`</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.MemberType">
          <source>The following example displays the member name and type of a specified class.</source>
          <target state="translated">En el ejemplo siguiente se muestra el nombre de miembro y el tipo de una clase especificada.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="P:System.Reflection.MemberInfo.MetadataToken">
          <source>Gets a value that identifies a metadata element.</source>
          <target state="translated">Obtiene un valor que identifica un elemento de metadatos.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.MetadataToken">
          <source>A value which, in combination with <ph id="ph1">&lt;see cref="P:System.Reflection.MemberInfo.Module" /&gt;</ph>, uniquely identifies a metadata element.</source>
          <target state="translated">Un valor que, en combinación con <ph id="ph1">&lt;see cref="P:System.Reflection.MemberInfo.Module" /&gt;</ph>, identifica de forma única a un elemento de metadatos.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.MetadataToken">
          <source>The tokens obtained using this property can be passed to the unmanaged reflection API.</source>
          <target state="translated">Los tokens obtenidos mediante esta propiedad se pueden pasar a la API de reflexión no administrada.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.MetadataToken">
          <source>For more information, please see <bpt id="p1">[</bpt>Unmanaged Reflection API<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</source>
          <target state="translated">Para obtener más información, vea <bpt id="p1">[</bpt>API de reflexión no administrada<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.MetadataToken">
          <source>Using the unmanaged reflection API requires familiarity with the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics" and "Partition III: CIL Instruction Set".</source>
          <target state="translated">Mediante la API de reflexión no administrada requiere estar familiarizado con la documentación de Common Language Infrastructure (CLI), especialmente en "Partition II: definición y semántica de los metadatos" y "Partition III: CIL Instruction Set".</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.MetadataToken">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="P:System.Reflection.MemberInfo.MetadataToken">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> represents an array method, such as <ph id="ph2">&lt;see langword="Address" /&gt;</ph>, on an array type whose element type is a dynamic type that has not been completed.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> actual representa un método de matriz, como <ph id="ph2">&lt;see langword="Address" /&gt;</ph>, en un tipo de matriz cuyo tipo de elemento es un tipo dinámico que no se ha finalizado.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="P:System.Reflection.MemberInfo.MetadataToken">
          <source>To get a metadata token in this case, pass the <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> object to the <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)" /&gt;</ph> method; or use the <ph id="ph3">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])" /&gt;</ph> method to get the token directly, instead of using the <ph id="ph4">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])" /&gt;</ph> method to get a <ph id="ph5">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> first.</source>
          <target state="translated">Para obtener un token de metadatos en este caso, pase el objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> al método <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)" /&gt;</ph> o utilice el método <ph id="ph3">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])" /&gt;</ph> para obtener el símbolo (token) directamente, en lugar de usar el método <ph id="ph4">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])" /&gt;</ph> para obtener primero <ph id="ph5">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="P:System.Reflection.MemberInfo.Module">
          <source>Gets the module in which the type that declares the member represented by the current <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> is defined.</source>
          <target state="translated">Obtiene el módulo en el que el tipo que declara el miembro representado por el objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> actual está definido.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.Module">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> in which the type that declares the member represented by the current <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> is defined.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> en el que el tipo que declara el miembro representado por el objeto <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> actual está definido.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.Module">
          <source>This property is provided as a convenience.</source>
          <target state="translated">Esta propiedad se proporciona por comodidad.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.Module">
          <source>It is equivalent to using the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> property to get the type in which the method is declared, and then calling the <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> property of the resulting <ph id="ph3">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated">Es equivalente a utilizar el <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> propiedad para obtener el tipo en el que se declara el método y, a continuación, llamar a la <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> propiedad del resultante <ph id="ph3">&lt;xref:System.Type&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.Module">
          <source>The following code example declares a class that inherits <ph id="ph1">&lt;xref:System.Object&gt;</ph> and overrides <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se declara una clase que hereda <ph id="ph1">&lt;xref:System.Object&gt;</ph> e invalida <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.Module">
          <source>The example obtains <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects for the class's <ph id="ph2">`ToString`</ph> method and for the inherited <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, and displays the names of the modules in which the two methods are declared.</source>
          <target state="translated">En el ejemplo se obtiene <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objetos para la clase <ph id="ph2">`ToString`</ph> método y de los heredados <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> método y muestra los nombres de los módulos en el que se declaran los dos métodos.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="P:System.Reflection.MemberInfo.Module">
          <source>This method is not implemented.</source>
          <target state="translated">Este método no está implementado.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="P:System.Reflection.MemberInfo.Name">
          <source>Gets the name of the current member.</source>
          <target state="translated">Obtiene el nombre del miembro actual.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.Name">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the name of this member.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que contiene el nombre de este miembro.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.Name">
          <source>Only the simple name of the member is returned, not the fully qualified name.</source>
          <target state="translated">Se devuelve solo el nombre simple del miembro, no el nombre completo.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.Name">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.Name%2A&gt;</ph> property, get the class <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Para obtener la <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.Name%2A&gt;</ph> propiedad, obtener la clase <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.Name">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> array.</source>
          <target state="translated">Desde el <ph id="ph1">`Type`</ph>, obtener el <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> matriz.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.Name">
          <source>From a <ph id="ph1">`MemberInfo`</ph> element of the array, obtain the <ph id="ph2">`Name`</ph> property.</source>
          <target state="translated">Desde un <ph id="ph1">`MemberInfo`</ph> elemento de la matriz, obtener el <ph id="ph2">`Name`</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.Name">
          <source>This example lists the <ph id="ph1">`Name`</ph> and <ph id="ph2">`DeclaringType`</ph> property of each member of the specified class.</source>
          <target state="translated">Este ejemplo se enumeran los <ph id="ph1">`Name`</ph> y <ph id="ph2">`DeclaringType`</ph> propiedad de cada miembro de la clase especificada.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.op_Equality(System.Reflection.MemberInfo,System.Reflection.MemberInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> to compare to <bpt id="p1">&lt;c&gt;</bpt>right<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que se va a comparar con <bpt id="p1">&lt;c&gt;</bpt>right<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.op_Equality(System.Reflection.MemberInfo,System.Reflection.MemberInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> to compare to <bpt id="p1">&lt;c&gt;</bpt>left<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que se va a comparar con <bpt id="p1">&lt;c&gt;</bpt>left<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.op_Equality(System.Reflection.MemberInfo,System.Reflection.MemberInfo)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects are equal.</source>
          <target state="translated">Indica si dos objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> son iguales.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.op_Equality(System.Reflection.MemberInfo,System.Reflection.MemberInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="left" /&gt;</ph> es igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; de lo contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.op_Inequality(System.Reflection.MemberInfo,System.Reflection.MemberInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> to compare to <bpt id="p1">&lt;c&gt;</bpt>right<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que se va a comparar con <bpt id="p1">&lt;c&gt;</bpt>right<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.op_Inequality(System.Reflection.MemberInfo,System.Reflection.MemberInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> to compare to <bpt id="p1">&lt;c&gt;</bpt>left<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que se va a comparar con <bpt id="p1">&lt;c&gt;</bpt>left<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.op_Inequality(System.Reflection.MemberInfo,System.Reflection.MemberInfo)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Indica si dos objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> no son iguales.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.op_Inequality(System.Reflection.MemberInfo,System.Reflection.MemberInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="left" /&gt;</ph> no es igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; de lo contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="P:System.Reflection.MemberInfo.ReflectedType">
          <source>Gets the class object that was used to obtain this instance of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph>.</source>
          <target state="translated">Obtiene el objeto de la clase utilizado para obtener esta instancia de <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.ReflectedType">
          <source>The <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object through which this <ph id="ph2">&lt;see langword="MemberInfo" /&gt;</ph> object was obtained.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see langword="Type" /&gt;</ph> a través del cual se obtuvo este objeto <ph id="ph2">&lt;see langword="MemberInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.ReflectedType">
          <source>The <ph id="ph1">`ReflectedType`</ph> property retrieves the <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that was used to obtain this instance of <ph id="ph3">`MemberInfo`</ph>.</source>
          <target state="translated">El <ph id="ph1">`ReflectedType`</ph> propiedad recupera la <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto que se usó para obtener esta instancia de <ph id="ph3">`MemberInfo`</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.ReflectedType">
          <source>This may differ from the value of the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> property if this <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object represents a member that is inherited from a base class.</source>
          <target state="translated">Ésta puede ser diferente del valor de la <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> propiedad si este <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objeto representa un miembro que se hereda de una clase base.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.ReflectedType">
          <source>If the <ph id="ph1">`MemberInfo`</ph> object is a global member (that is, if it was obtained from the <ph id="ph2">&lt;xref:System.Reflection.Module.GetMethods%2A?displayProperty=nameWithType&gt;</ph> method, which returns global methods on a module), the returned <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> will be <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Si el <ph id="ph1">`MemberInfo`</ph> objeto es un miembro global (es decir, si se obtuvo de la <ph id="ph2">&lt;xref:System.Reflection.Module.GetMethods%2A?displayProperty=nameWithType&gt;</ph> método, que devuelve los métodos globales en un módulo), el valor devuelto <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> será <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MemberInfo.ReflectedType">
          <source>The following code example shows how the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.ReflectedType%2A&gt;</ph> changes when the member <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> is viewed from a <ph id="ph3">&lt;xref:System.Reflection.MemberInfo&gt;</ph> obtained from type <ph id="ph4">&lt;xref:System.Object&gt;</ph> and from a <ph id="ph5">&lt;xref:System.Reflection.MemberInfo&gt;</ph> obtained from the <ph id="ph6">&lt;xref:System.Reflection.MemberInfo&gt;</ph> class itself, which inherits <ph id="ph7">&lt;xref:System.Object&gt;</ph> but does not override <ph id="ph8">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">El siguiente ejemplo de código muestra cómo el <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.ReflectedType%2A&gt;</ph> cambia cuando el miembro <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> se ve desde un <ph id="ph3">&lt;xref:System.Reflection.MemberInfo&gt;</ph> obtenidos de tipo <ph id="ph4">&lt;xref:System.Object&gt;</ph> desde y hacia un <ph id="ph5">&lt;xref:System.Reflection.MemberInfo&gt;</ph> obtenido de la <ph id="ph6">&lt;xref:System.Reflection.MemberInfo&gt;</ph> clase propia, que hereda <ph id="ph7">&lt;xref:System.Object&gt;</ph> , pero no invalida <ph id="ph8">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para un uso futuro.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Debe ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matriz que se pasa con los nombres que se van a asignar.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Número de nombres que se van a asignar.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Contexto de configuración regional en el que se van a interpretar los nombres.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Matriz asignada por quien realiza la llamada que recibe los id. que corresponden a los nombres.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">Al método se le llama de manera enlazada en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetType">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> class.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa la clase <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> class.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa la clase <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Información de tipos que se va a devolver.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Identificador de la configuración regional de la información de tipo.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Recibe un puntero al objeto de información de tipo solicitado.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Recupera la información de tipo de un objeto, que se puede utilizar después para obtener la información de tipo de una interfaz.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">Al método se le llama de manera enlazada en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetTypeInfoCount(System.UInt32@)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">Al método se le llama de manera enlazada en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifica el miembro.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para un uso futuro.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Debe ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Contexto de la configuración regional en que se interpretan los argumentos.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Marcas que describen el contexto de la llamada.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Puntero a la ubicación donde se va a almacenar el resultado.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Puntero a una estructura que contiene información de excepciones.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Índice del primer argumento que tiene un error.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::Invoke`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">Al método se le llama de manera enlazada en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>