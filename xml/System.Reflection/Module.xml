<Type Name="Module" FullName="System.Reflection.Module">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="99434ae0ca2ae257e847cbb424c20883be128c2c" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Module : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Module, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Module extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Module, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Module" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Module&#xA;Implements _Module, ICustomAttributeProvider, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Module abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Module, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Module</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Module))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="1d7fc-101">Realiza la reflexión en un módulo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1d7fc-101">Performs reflection on a module.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-102">Un módulo es un archivo portable ejecutable, como tipo.dll o application.exe, que consta de uno o más clases e interfaces.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-102">A module is a portable executable file, such as type.dll or application.exe, consisting of one or more classes and interfaces.</span></span> <span data-ttu-id="1d7fc-103">Puede que haya varios espacios de nombres contenidos en un módulo único y un espacio de nombres puede abarcar a varios módulos.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-103">There may be multiple namespaces contained in a single module, and a namespace may span multiple modules.</span></span>  
  
 <span data-ttu-id="1d7fc-104">Un ensamblado está compuesto de uno o varios módulos implementados como una unidad.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-104">One or more modules deployed as a unit compose an assembly.</span></span> <span data-ttu-id="1d7fc-105">Para obtener información acerca de cómo crear un ensamblado con más de un módulo, consulte [Multifile Assemblies](~/docs/framework/app-domains/multifile-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="1d7fc-105">For information about creating an assembly with more than one module, see [Multifile Assemblies](~/docs/framework/app-domains/multifile-assemblies.md).</span></span>  
  
 <span data-ttu-id="1d7fc-106">Tenga en cuenta que un módulo de .NET Framework no es igual a un módulo en Visual Basic, que se usa por los programadores para organizar funciones y subrutinas en una aplicación.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-106">Note that a .NET Framework module is not the same as a module in Visual Basic, which is used by a programmers to organize functions and subroutines in an application.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d7fc-107">Ejemplos de código siguientes muestran cómo utilizar la reflexión para obtener información acerca de los módulos:</span><span class="sxs-lookup"><span data-stu-id="1d7fc-107">The following code examples show how to use reflection to get information about modules:</span></span>  
  
 [!code-csharp[System.Reflection.Module#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module/CS/source.cs#1)]
 [!code-vb[System.Reflection.Module#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="1d7fc-108">de plena confianza para los herederos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1d7fc-108">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="1d7fc-109">Esta clase no puede heredarse mediante código de confianza parcial.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1d7fc-109">This class cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Module ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Module();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-110">Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.Module" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-110">Initializes a new instance of the <see cref="T:System.Reflection.Module" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-111">Este constructor es invocado por clases derivadas durante la construcción de <xref:System.Reflection.Module> objetos.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-111">This constructor is invoked by derived classes during the construction of <xref:System.Reflection.Module> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-112">Obtiene el <see cref="T:System.Reflection.Assembly" /> adecuado para esta instancia de <see cref="T:System.Reflection.Module" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-112">Gets the appropriate <see cref="T:System.Reflection.Assembly" /> for this instance of <see cref="T:System.Reflection.Module" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="1d7fc-113">Un objeto <see langword="Assembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-113">An <see langword="Assembly" /> object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1d7fc-114">En el ejemplo siguiente se muestra el nombre completo del ensamblado especificado en el módulo especificado.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-114">The following example displays the full name of the specified assembly in the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.Assembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-115">Obtiene una colección que contiene los atributos personalizados de este módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-115">Gets a collection that contains this module's custom attributes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="1d7fc-116">Colección que contiene los atributos personalizados de este módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-116">A collection that contains this module's custom attributes.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="1d7fc-117">Objeto que se va a comparar con esta instancia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-117">The object to compare with this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-118">Determina si este módulo y el objeto especificado son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-118">Determines whether this module and the specified object are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-119">Es <see langword="true" /> si <paramref name="o" /> es igual a esta instancia; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-119">
              <see langword="true" /> if <paramref name="o" /> is equal to this instance; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterTypeName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeName" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeName As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeName;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-120">Objeto <see langword="TypeFilter" /> que filtra la lista de tipos definida en este módulo a partir del nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-120">A <see langword="TypeFilter" /> object that filters the list of types defined in this module based upon the name.</span>
          </span>
          <span data-ttu-id="1d7fc-121">Este campo distingue entre mayúsculas y minúsculas y es de sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-121">This field is case-sensitive and read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-122">El filtro admite un carácter final "\*" comodín.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-122">The filter supports a trailing "\*" wildcard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d7fc-123">El ejemplo siguiente muestra los nombres de módulo que coinciden con los criterios de búsqueda especificados.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-123">The following example displays the module names that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FilterTypeNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeNameIgnoreCase As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeNameIgnoreCase;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-124">Objeto <see langword="TypeFilter" /> que filtra la lista de tipos definida en este módulo a partir del nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-124">A <see langword="TypeFilter" /> object that filters the list of types defined in this module based upon the name.</span>
          </span>
          <span data-ttu-id="1d7fc-125">Este campo no distingue entre mayúsculas y minúsculas y es de sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-125">This field is case-insensitive and read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-126">El filtro admite un carácter final "\*" comodín.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-126">The filter supports a trailing "\*" wildcard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d7fc-127">El ejemplo siguiente muestra los nombres de módulo que coinciden con los criterios de búsqueda especificado, omitir el caso.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-127">The following example displays the module names that match the specified search criteria, ignoring the case.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FindTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] FindTypes (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindTypes(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindTypes (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindTypes(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">
          <span data-ttu-id="1d7fc-128">Delegado utilizado para filtrar las clases.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-128">The delegate used to filter the classes.</span>
          </span>
        </param>
        <param name="filterCriteria">
          <span data-ttu-id="1d7fc-129">Objeto utilizado para filtrar las clases.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-129">An Object used to filter the classes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-130">Devuelve una matriz de las clases aceptadas según el filtro y los criterios de filtro dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-130">Returns an array of classes accepted by the given filter and filter criteria.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-131">Matriz de tipo <see langword="Type" /> que contiene las clases ya aceptadas por el filtro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-131">An array of type <see langword="Type" /> containing classes that were accepted by the filter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-132"><xref:System.Reflection.ReflectionTypeLoadException> es una excepción de carga de clase especial.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-132"><xref:System.Reflection.ReflectionTypeLoadException> is a special class load exception.</span></span> <span data-ttu-id="1d7fc-133">El `ReflectionTypeLoadException.Types` propiedad contiene la matriz de clases que se definieron en el módulo y cargadas.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-133">The `ReflectionTypeLoadException.Types` property contains the array of classes that were defined in the module and were loaded.</span></span> <span data-ttu-id="1d7fc-134">Esta matriz puede contener valores null.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-134">This array may contain some null values.</span></span> <span data-ttu-id="1d7fc-135">El `ReflectionTypeLoadException.LoaderExceptions` propiedad es una matriz de excepciones que representan las excepciones producidas por el cargador de clases.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-135">The `ReflectionTypeLoadException.LoaderExceptions` property is an array of exceptions that represent the exceptions that were thrown by the class loader.</span></span> <span data-ttu-id="1d7fc-136">Los agujeros en la matriz de clase se alineen con las excepciones.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-136">The holes in the class array line up with the exceptions.</span></span>  
  
 <span data-ttu-id="1d7fc-137">El delegado proporcionado por `filter` se llama para cada clase en el módulo, pasando a lo largo de la `Type` que representa la clase de objeto, así como la determinada `filterCriteria`.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-137">The delegate given by `filter` is called for each class in the module, passing along the `Type` object representing the class as well as the given `filterCriteria`.</span></span> <span data-ttu-id="1d7fc-138">Si `filter` devuelve una determinada clase, que la clase se incluirá en la matriz devuelta.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-138">If `filter` returns a particular class, that class will be included in the returned array.</span></span> <span data-ttu-id="1d7fc-139">Si `filter` devuelve `null`, se devuelven todas las clases y `filterCriteria` se omite.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-139">If `filter` returns `null`, all classes are returned and `filterCriteria` is ignored.</span></span>  
  
 <span data-ttu-id="1d7fc-140">`FindTypes` no se puede usar para buscar tipos parametrizados como flechas.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-140">`FindTypes` cannot be used to look up parameterized types such as arrays.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d7fc-141">En el ejemplo siguiente se muestra el `FindTypes` método.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-141">The following example demonstrates the `FindTypes` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">
          <span data-ttu-id="1d7fc-142">No se han podido cargar una o varias clases en un módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-142">One or more classes in a module could not be loaded.</span>
          </span>
        </exception>
        <altmember cref="F:System.Reflection.Module.FilterTypeName" />
        <altmember cref="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public virtual string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.FullyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-143">Obtiene una cadena que representa el nombre completo y la ruta de acceso de este módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-143">Gets a string representing the fully qualified name and path to this module.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="1d7fc-144">Nombre completo del módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-144">The fully qualified module name.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-145">Para obtener el nombre sin la ruta de acceso, use <xref:System.Reflection.Module.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-145">To get the name without the path, use <xref:System.Reflection.Module.Name%2A>.</span></span>  
  
 <span data-ttu-id="1d7fc-146">Si el ensamblado de este módulo se cargó desde una matriz de bytes, a continuación, el `FullyQualifiedName` para el módulo serán: \<desconocido >.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-146">If the assembly for this module was loaded from a byte array then the `FullyQualifiedName` for the module will be: \<Unknown>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-147">El caso del nombre del módulo es dependiente de la plataforma.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-147">The case of module name is platform-dependent.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d7fc-148">En el ejemplo siguiente se muestra el nombre completo del módulo especificado.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-148">The following example displays the fully qualified name of the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="1d7fc-149">El llamador no tiene los permisos requeridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-149">The caller does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="1d7fc-150">Para obtener acceso a la información de la ruta de acceso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-150">for access to information in the path.</span>
          </span>
          <span data-ttu-id="1d7fc-151">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-151">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-152">Devuelve atributos personalizados</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-152">Returns custom attributes.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <span data-ttu-id="1d7fc-153">Se omite este argumento para los objetos de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-153">This argument is ignored for objects of this type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-154">Devuelve todos los atributos personalizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-154">Returns all custom attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-155">Matriz de tipo <see langword="Object" /> que contiene todos los atributos personalizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-155">An array of type <see langword="Object" /> containing all custom attributes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1d7fc-156">El ejemplo siguiente muestra los nombres de módulo que coinciden con los criterios de búsqueda especificados.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-156">The following example displays the module names that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="1d7fc-157">Tipo de atributo que se va a obtener.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-157">The type of attribute to get.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="1d7fc-158">Se omite este argumento para los objetos de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-158">This argument is ignored for objects of this type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-159">Obtiene los atributos personalizados del tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-159">Gets custom attributes of the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-160">Matriz de tipo <see langword="Object" /> que contiene todos los atributos personalizados del tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-160">An array of type <see langword="Object" /> containing all custom attributes of the specified type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1d7fc-161">En el ejemplo siguiente muestra los nombres de módulo del tipo especificado que coinciden con los criterios de búsqueda especificados.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-161">The following example displays the module names of the specified type that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1d7fc-162">
            <paramref name="attributeType" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-162">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d7fc-163">
            <paramref name="attributeType" /> no es un objeto <see cref="T:System.Type" /> proporcionado en tiempo de ejecución.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-163">
              <paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime.</span>
          </span>
          <span data-ttu-id="1d7fc-164">Por ejemplo, <paramref name="attributeType" /> es un objeto <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-164">For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-165">Devuelve una lista de los objetos <see cref="T:System.Reflection.CustomAttributeData" /> del módulo actual, que puede utilizarse en el contexto de solo reflexión.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-165">Returns a list of <see cref="T:System.Reflection.CustomAttributeData" /> objects for the current module, which can be used in the reflection-only context.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-166">Lista genérica de objetos <see cref="T:System.Reflection.CustomAttributeData" /> que representan datos acerca de los atributos que se han aplicado al módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-166">A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current module.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-167">Utilice este método para examinar los atributos personalizados del código en el contexto de solo reflexión, en casos donde se definen los atributos personalizados propios en el código que se carga en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-167">Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</span></span> <span data-ttu-id="1d7fc-168">Métodos como <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> y <xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType> no se puede usar en casos como éste, porque crean instancias de los atributos.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-168">Methods such as <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> and <xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType> cannot be used in such cases, because they create instances of the attributes.</span></span> <span data-ttu-id="1d7fc-169">No se puede ejecutar código en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-169">Code in the reflection-only context cannot be executed.</span></span> <span data-ttu-id="1d7fc-170">Para obtener más información y código de ejemplo, vea la <xref:System.Reflection.CustomAttributeData> clase.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-170">For more information and example code, see the <xref:System.Reflection.CustomAttributeData> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-171">Devuelve un campo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-171">Returns a specified field.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="1d7fc-172">Nombre de campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-172">The field name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-173">Devuelve un campo con el nombre especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-173">Returns a field having the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-174">Objeto <see langword="FieldInfo" /> con el nombre especificado, o <see langword="null" /> si no existe el campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-174">A <see langword="FieldInfo" /> object having the specified name, or <see langword="null" /> if the field does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1d7fc-175">El valor del parámetro <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-175">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="1d7fc-176">Nombre de campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-176">The field name.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="1d7fc-177">Uno de los marcadores de bits <see langword="BindingFlags" /> utilizados para controlar la búsqueda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-177">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-178">Devuelve un campo con el nombre especificado y los atributos de enlace.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-178">Returns a field having the specified name and binding attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-179">Objeto <see langword="FieldInfo" /> con el nombre y los atributos de enlace especificados, o <see langword="null" /> si no existe el campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-179">A <see langword="FieldInfo" /> object having the specified name and binding attributes, or <see langword="null" /> if the field does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1d7fc-180">El valor del parámetro <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-180">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-181">Devuelve los campos globales definidos en el módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-181">Returns the global fields defined on the module.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-182">Devuelve los campos globales definidos en el módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-182">Returns the global fields defined on the module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-183">Matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representan los campos globales definidos en el módulo; si no hay ningún campo global, se devolverá una matriz vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-183">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the global fields defined on the module; if there are no global fields, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-184">El <xref:System.Reflection.Module.GetFields%2A> método no devuelve campos en un orden determinado, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-184">The <xref:System.Reflection.Module.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="1d7fc-185">El código no debe depender del orden en que se devuelven los campos, porque ese orden puede variar.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-185">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">
          <span data-ttu-id="1d7fc-186">Combinación bit a bit de valores <see cref="T:System.Reflection.BindingFlags" /> que limita la búsqueda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-186">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limit the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-187">Devuelve los campos globales definidos en el módulo que coinciden con los marcadores de enlace especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-187">Returns the global fields defined on the module that match the specified binding flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-188">Matriz del tipo <see cref="T:System.Reflection.FieldInfo" /> que representa los campos globales definidos en el módulo que coinciden con los marcadores de enlace especificados; si ningún campo global coincide con los marcadores de enlace, se devolverá una matriz vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-188">An array of type <see cref="T:System.Reflection.FieldInfo" /> representing the global fields defined on the module that match the specified binding flags; if no global fields match the binding flags, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-189">El <xref:System.Reflection.Module.GetFields%2A> método no devuelve campos en un orden determinado, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-189">The <xref:System.Reflection.Module.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="1d7fc-190">El código no debe depender del orden en que se devuelven los campos, porque ese orden puede variar.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-190">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-191">Devuelve el código hash de esta instancia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-191">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-192">Código hash de un entero de 32 bits con signo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-192">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-193">Devuelve un método con los criterios especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-193">Returns a method having the specified criteria.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="1d7fc-194">Nombre del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-194">The method name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-195">Devuelve un método con el nombre especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-195">Returns a method having the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-196">Objeto <see langword="MethodInfo" /> con el nombre especificado, o <see langword="null" /> si no existe el método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-196">A <see langword="MethodInfo" /> object having the specified name, or <see langword="null" /> if the method does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1d7fc-197">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-197">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="1d7fc-198">Nombre del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-198">The method name.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="1d7fc-199">Tipos de parámetros que se van a buscar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-199">The parameter types to search for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-200">Devuelve un método con el nombre especificado y los tipos de parámetro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-200">Returns a method having the specified name and parameter types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-201">Objeto <see langword="MethodInfo" /> de acuerdo con los criterios especificados o <see langword="null" /> si no existe el método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-201">A <see langword="MethodInfo" /> object in accordance with the specified criteria, or <see langword="null" /> if the method does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1d7fc-202">
            <paramref name="name" /> es <see langword="null" />, <paramref name="types" /> es <see langword="null" /> o <paramref name="types" /> (i) es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-202">
              <paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or <paramref name="types" /> (i) is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="1d7fc-203">Nombre del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-203">The method name.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="1d7fc-204">Uno de los marcadores de bits <see langword="BindingFlags" /> utilizados para controlar la búsqueda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-204">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="1d7fc-205">Objeto que implementa <see langword="Binder" /> y que contiene propiedades relacionadas con este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-205">An object that implements <see langword="Binder" />, containing properties related to this method.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="1d7fc-206">Convención de llamada para el método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-206">The calling convention for the method.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="1d7fc-207">Tipos de parámetros que se van a buscar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-207">The parameter types to search for.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="1d7fc-208">Matriz de modificadores de parámetros que permite que el enlace funcione con firmas de parámetros en las que se han modificado los tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-208">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-209">Devuelve un método con el nombre especificado, la información de enlace, la convención de llamadas y los tipos de parámetros y modificadores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-209">Returns a method having the specified name, binding information, calling convention, and parameter types and modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-210">Objeto <see langword="MethodInfo" /> de acuerdo con los criterios especificados o <see langword="null" /> si no existe el método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-210">A <see langword="MethodInfo" /> object in accordance with the specified criteria, or <see langword="null" /> if the method does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1d7fc-211">
            <paramref name="name" /> es <see langword="null" />, <paramref name="types" /> es <see langword="null" /> o <paramref name="types" /> (i) es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-211">
              <paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or <paramref name="types" /> (i) is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="1d7fc-212">Nombre del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-212">The method name.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="1d7fc-213">Uno de los marcadores de bits <see langword="BindingFlags" /> utilizados para controlar la búsqueda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-213">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="1d7fc-214">Objeto que implementa <see langword="Binder" /> y que contiene propiedades relacionadas con este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-214">An object that implements <see langword="Binder" />, containing properties related to this method.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="1d7fc-215">Convención de llamada para el método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-215">The calling convention for the method.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="1d7fc-216">Tipos de parámetros que se van a buscar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-216">The parameter types to search for.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="1d7fc-217">Matriz de modificadores de parámetros que permite que el enlace funcione con firmas de parámetros en las que se han modificado los tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-217">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-218">Devuelve la implementación del método conforme a los criterios especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-218">Returns the method implementation in accordance with the specified criteria.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-219">Objeto <see langword="MethodInfo" /> que contiene la información de implementación especificada, o <see langword="null" /> si no existe el método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-219">A <see langword="MethodInfo" /> object containing implementation information as specified, or <see langword="null" /> if the method does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="1d7fc-220">
            <paramref name="types" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-220">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-221">Devuelve los métodos globales definidos en el módulo</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-221">Returns the global methods defined on the module</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-222">Devuelve los métodos globales definidos en el módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-222">Returns the global methods defined on the module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-223">Matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> que representan todos los métodos globales definidos en el módulo; si no hay ningún método global, se devolverá una matriz vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-223">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the global methods defined on the module; if there are no global methods, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">
          <span data-ttu-id="1d7fc-224">Combinación bit a bit de valores <see cref="T:System.Reflection.BindingFlags" /> que limita la búsqueda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-224">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limit the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-225">Devuelve los métodos globales definidos en el módulo que coinciden con los marcadores de enlace especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-225">Returns the global methods defined on the module that match the specified binding flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-226">Matriz del tipo <see cref="T:System.Reflection.MethodInfo" /> que representa los métodos globales definidos en el módulo que coinciden con los marcadores de enlace especificados; si ningún método global coincide con los marcadores de enlace, se devolverá una matriz vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-226">An array of type <see cref="T:System.Reflection.MethodInfo" /> representing the global methods defined on the module that match the specified binding flags; if no global methods match the binding flags, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="1d7fc-227">Información y datos necesarios para serializar o deserializar un objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-227">The information and data needed to serialize or deserialize an object.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="1d7fc-228">Contexto de la serialización.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-228">The context for the serialization.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-229">Proporciona una implementación de <see cref="T:System.Runtime.Serialization.ISerializable" /> para objetos serializados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-229">Provides an <see cref="T:System.Runtime.Serialization.ISerializable" /> implementation for serialized objects.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1d7fc-230">
            <paramref name="info" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-230">
              <paramref name="info" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="1d7fc-231">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-231">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="1d7fc-232">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-232">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public virtual void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetPEKind([out] valuetype System.Reflection.PortableExecutableKinds&amp; peKind, [out] valuetype System.Reflection.ImageFileMachine&amp; machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetPEKind (ByRef peKind As PortableExecutableKinds, ByRef machine As ImageFileMachine)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetPEKind([Runtime::InteropServices::Out] System::Reflection::PortableExecutableKinds % peKind, [Runtime::InteropServices::Out] System::Reflection::ImageFileMachine % machine);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds&amp;" RefType="out" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="peKind">
          <span data-ttu-id="1d7fc-233">El resultado de este método contiene una combinación de los valores <see cref="T:System.Reflection.PortableExecutableKinds" /> que indican la naturaleza del código en el módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-233">When this method returns, a combination of the <see cref="T:System.Reflection.PortableExecutableKinds" /> values indicating the nature of the code in the module.</span>
          </span>
        </param>
        <param name="machine">
          <span data-ttu-id="1d7fc-234">El resultado de este método contiene uno de los valores de <see cref="T:System.Reflection.ImageFileMachine" /> que indican la plataforma destino del módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-234">When this method returns, one of the <see cref="T:System.Reflection.ImageFileMachine" /> values indicating the platform targeted by the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-235">Obtiene un par de valores que indican la naturaleza del código en un módulo y la plataforma de destino del módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-235">Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetSignerCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSignerCertificate () As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::X509Certificates::X509Certificate ^ GetSignerCertificate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-236">Devuelve un objeto <see langword="X509Certificate" /> que corresponde al certificado incluido en la firma Authenticode del ensamblado al que pertenece este módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-236">Returns an <see langword="X509Certificate" /> object corresponding to the certificate included in the Authenticode signature of the assembly which this module belongs to.</span>
          </span>
          <span data-ttu-id="1d7fc-237">Si el ensamblado no se ha firmado mediante Authenticode, se devuelve <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-237">If the assembly has not been Authenticode signed, <see langword="null" /> is returned.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-238">Objeto <see langword="X509Certificate" />, o <see langword="null" /> si el ensamblado al que este módulo pertenece no se ha firmado mediante Authenticode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-238">An <see langword="X509Certificate" /> object, or <see langword="null" /> if the assembly to which this module belongs has not been Authenticode signed.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-239">Devuelve el tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-239">Returns the specified type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className">
          <span data-ttu-id="1d7fc-240">Nombre del tipo que se va a localizar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-240">The name of the type to locate.</span>
          </span>
          <span data-ttu-id="1d7fc-241">El nombre debe ser completo y debe estar en consonancia con el espacio de nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-241">The name must be fully qualified with the namespace.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-242">Devuelve el tipo especificado, realizando una búsqueda en la que se distingue entre mayúsculas y minúsculas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-242">Returns the specified type, performing a case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-243">Objeto <see langword="Type" /> que representa el tipo determinado, si el tipo está en este módulo; en caso contrario, es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-243">A <see langword="Type" /> object representing the given type, if the type is in this module; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-244">Si el tipo se ha reenviado a otro ensamblado, todavía es devuelto por este método.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-244">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="1d7fc-245">Para obtener información sobre el reenvío de tipos, vea [reenvío de tipos en Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="1d7fc-245">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="1d7fc-246">Un tipo se puede recuperar desde un módulo específico mediante <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-246">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1d7fc-247">Al llamar a <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> en el módulo que contiene el manifiesto no buscará en todo el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-247">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="1d7fc-248">Para recuperar un tipo de un ensamblado, independientemente del módulo donde esté, debe llamar a <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-248">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d7fc-249">En el ejemplo siguiente se muestra el nombre de un tipo en el módulo especificado.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-249">The following example displays the name of a type in the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1d7fc-250">
            <paramref name="className" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-250">
              <paramref name="className" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="1d7fc-251">Se invoca a los inicializadores de clase y se produce una excepción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-251">The class initializers are invoked and an exception is thrown.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d7fc-252">
            <paramref name="className" /> es una cadena de longitud cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-252">
              <paramref name="className" /> is a zero-length string.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="1d7fc-253">
            <paramref name="className" /> requiere un ensamblado dependiente que no se pudo encontrar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-253">
              <paramref name="className" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="1d7fc-254">
            <paramref name="className" /> requiere un ensamblado dependiente que se encontró, pero no se pudo cargar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-254">
              <paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="1d7fc-255">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-255">-or-</span>
          </span>
          <span data-ttu-id="1d7fc-256">El ensamblado actual se cargó en el contexto de solo reflexión y <paramref name="className" /> requiere un ensamblado dependiente que no se haya cargado previamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-256">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="1d7fc-257">
            <paramref name="className" /> requiere un ensamblado dependiente, pero el archivo no es un ensamblado válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-257">
              <paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="1d7fc-258">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-258">-or-</span>
          </span>
          <span data-ttu-id="1d7fc-259">
            <paramref name="className" /> requiere un ensamblado dependiente que se haya compilado para una versión del motor en tiempo de ejecución posterior a la versión que se ha cargado en la actualidad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-259">
              <paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">
          <span data-ttu-id="1d7fc-260">Nombre del tipo que se va a localizar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-260">The name of the type to locate.</span>
          </span>
          <span data-ttu-id="1d7fc-261">El nombre debe ser completo y debe estar en consonancia con el espacio de nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-261">The name must be fully qualified with the namespace.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="1d7fc-262">
            <see langword="true" /> en el caso de búsqueda sin distinción entre mayúsculas y minúsculas; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-262">
              <see langword="true" /> for case-insensitive search; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-263">Devuelve el tipo especificado, buscando el módulo con la distinción entre mayúsculas y minúsculas especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-263">Returns the specified type, searching the module with the specified case sensitivity.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-264">Objeto <see langword="Type" /> que representa el tipo determinado, si el tipo está en este módulo; en caso contrario, es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-264">A <see langword="Type" /> object representing the given type, if the type is in this module; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-265">Si el tipo se ha reenviado a otro ensamblado, todavía es devuelto por este método.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-265">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="1d7fc-266">Para obtener información sobre el reenvío de tipos, vea [reenvío de tipos en Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="1d7fc-266">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="1d7fc-267">Un tipo se puede recuperar desde un módulo específico mediante <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-267">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1d7fc-268">Al llamar a <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> en el módulo que contiene el manifiesto no buscará en todo el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-268">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="1d7fc-269">Para recuperar un tipo de un ensamblado, independientemente del módulo donde esté, debe llamar a <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-269">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d7fc-270">En el ejemplo siguiente se muestra el nombre de un tipo en el módulo especificado, especificando `false` para el `ignoreCase` parámetro para ese caso no se pasará por alto.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-270">The following example displays the name of a type in the specified module, specifying `false` for the `ignoreCase` parameter so that case will not be ignored.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1d7fc-271">
            <paramref name="className" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-271">
              <paramref name="className" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="1d7fc-272">Se invoca a los inicializadores de clase y se produce una excepción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-272">The class initializers are invoked and an exception is thrown.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d7fc-273">
            <paramref name="className" /> es una cadena de longitud cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-273">
              <paramref name="className" /> is a zero-length string.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="1d7fc-274">
            <paramref name="className" /> requiere un ensamblado dependiente que no se pudo encontrar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-274">
              <paramref name="className" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="1d7fc-275">
            <paramref name="className" /> requiere un ensamblado dependiente que se encontró, pero no se pudo cargar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-275">
              <paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="1d7fc-276">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-276">-or-</span>
          </span>
          <span data-ttu-id="1d7fc-277">El ensamblado actual se cargó en el contexto de solo reflexión y <paramref name="className" /> requiere un ensamblado dependiente que no se haya cargado previamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-277">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="1d7fc-278">
            <paramref name="className" /> requiere un ensamblado dependiente, pero el archivo no es un ensamblado válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-278">
              <paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="1d7fc-279">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-279">-or-</span>
          </span>
          <span data-ttu-id="1d7fc-280">
            <paramref name="className" /> requiere un ensamblado dependiente que se haya compilado para una versión del motor en tiempo de ejecución posterior a la versión que se ha cargado en la actualidad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-280">
              <paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">
          <span data-ttu-id="1d7fc-281">Nombre del tipo que se va a localizar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-281">The name of the type to locate.</span>
          </span>
          <span data-ttu-id="1d7fc-282">El nombre debe ser completo y debe estar en consonancia con el espacio de nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-282">The name must be fully qualified with the namespace.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="1d7fc-283">Es <see langword="true" /> para producir una excepción si no se puede encontrar el tipo; es <see langword="false" /> para devolver <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-283">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="1d7fc-284">
            <see langword="true" /> en el caso de búsqueda sin distinción entre mayúsculas y minúsculas; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-284">
              <see langword="true" /> for case-insensitive search; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-285">Devuelve el tipo especificado, indicando si se realiza una búsqueda que distinga entre mayúsculas y minúsculas del módulo y si se produce una excepción si no se puede encontrar el tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-285">Returns the specified type, specifying whether to make a case-sensitive search of the module and whether to throw an exception if the type cannot be found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-286">Objeto <see cref="T:System.Type" /> que representa el tipo especificado, si el tipo se declara en este módulo; en caso contrario, es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-286">A <see cref="T:System.Type" /> object representing the specified type, if the type is declared in this module; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-287">El `throwOnError` parámetro afecta a sólo lo que sucede cuando no se encuentra el tipo.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-287">The `throwOnError` parameter affects only what happens when the type is not found.</span></span> <span data-ttu-id="1d7fc-288">No afecta a las otras excepciones que pueden producirse.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-288">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="1d7fc-289">En particular, si se encuentra el tipo pero no se puede cargar, <xref:System.TypeLoadException> puede producir aunque `throwOnError` es `false`.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-289">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-290">Si el tipo se ha reenviado a otro ensamblado, todavía es devuelto por este método.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-290">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="1d7fc-291">Para obtener información sobre el reenvío de tipos, vea [reenvío de tipos en Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="1d7fc-291">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="1d7fc-292">Un tipo se puede recuperar desde un módulo específico mediante <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-292">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1d7fc-293">Al llamar a <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> en el módulo que contiene el manifiesto no buscará en todo el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-293">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="1d7fc-294">Para recuperar un tipo de un ensamblado, independientemente del módulo donde esté, debe llamar a <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-294">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d7fc-295">En el ejemplo siguiente se muestra el nombre de un tipo en el módulo especificado.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-295">The following example displays the name of a type in the specified module.</span></span> <span data-ttu-id="1d7fc-296">El `throwOnError` y `ignoreCase` parámetros se especifican como `false`.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-296">The `throwOnError` and `ignoreCase` parameters are specified as `false`.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1d7fc-297">
            <paramref name="className" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-297">
              <paramref name="className" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="1d7fc-298">Se invoca a los inicializadores de clase y se produce una excepción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-298">The class initializers are invoked and an exception is thrown.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d7fc-299">
            <paramref name="className" /> es una cadena de longitud cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-299">
              <paramref name="className" /> is a zero-length string.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="1d7fc-300">
            <paramref name="throwOnError" /> es <see langword="true" /> y no se puede encontrar el tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-300">
              <paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="1d7fc-301">
            <paramref name="className" /> requiere un ensamblado dependiente que no se pudo encontrar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-301">
              <paramref name="className" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="1d7fc-302">
            <paramref name="className" /> requiere un ensamblado dependiente que se encontró, pero no se pudo cargar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-302">
              <paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="1d7fc-303">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-303">-or-</span>
          </span>
          <span data-ttu-id="1d7fc-304">El ensamblado actual se cargó en el contexto de solo reflexión y <paramref name="className" /> requiere un ensamblado dependiente que no se haya cargado previamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-304">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="1d7fc-305">
            <paramref name="className" /> requiere un ensamblado dependiente, pero el archivo no es un ensamblado válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-305">
              <paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="1d7fc-306">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-306">-or-</span>
          </span>
          <span data-ttu-id="1d7fc-307">
            <paramref name="className" /> requiere un ensamblado dependiente que se haya compilado para una versión del motor en tiempo de ejecución posterior a la versión que se ha cargado en la actualidad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-307">
              <paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-308">Devuelve todos los tipos definidos en este módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-308">Returns all the types defined within this module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-309">Matriz de tipo <see langword="Type" /> que contiene los tipos definidos en el módulo reflejado por esta instancia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-309">An array of type <see langword="Type" /> containing types defined within the module that is reflected by this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-310">`ReflectionTypeLoadException` es una excepción de carga especial.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-310">`ReflectionTypeLoadException` is a special load exception.</span></span> <span data-ttu-id="1d7fc-311">El `ReflectionTypeLoadException.Types` propiedad contiene la matriz de tipos que se definieron en el módulo y cargadas.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-311">The `ReflectionTypeLoadException.Types` property contains the array of types that were defined in the module and were loaded.</span></span> <span data-ttu-id="1d7fc-312">Esta matriz puede contener valores null.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-312">This array may contain some null values.</span></span> <span data-ttu-id="1d7fc-313">El `ReflectionTypeLoadException.LoaderExceptions` propiedad es una matriz de excepciones que representan las excepciones producidas por el cargador.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-313">The `ReflectionTypeLoadException.LoaderExceptions` property is an array of exceptions that represent the exceptions that were thrown by the loader.</span></span> <span data-ttu-id="1d7fc-314">Los agujeros en la matriz de clase se alineen con las excepciones.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-314">The holes in the class array line up with the exceptions.</span></span>  
  
 <span data-ttu-id="1d7fc-315">Por ejemplo, si los inicializadores de clase de una de las clases produce una excepción mientras se está cargando, un `TargetInvocationException` se almacena en el elemento correspondiente de la `LoaderExceptions` matriz.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-315">For example, if the class initializers of one of the classes throws an exception while it is being loaded, a `TargetInvocationException` is stored in the corresponding element of the `LoaderExceptions` array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-316">Si un tipo se ha reenviado a otro ensamblado, no se incluye en la matriz devuelta.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-316">If a type has been forwarded to another assembly, it is not included in the returned array.</span></span> <span data-ttu-id="1d7fc-317">Para obtener información sobre el reenvío de tipos, vea [reenvío de tipos en Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="1d7fc-317">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">
          <span data-ttu-id="1d7fc-318">No se han podido cargar una o varias clases en un módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-318">One or more classes in a module could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="1d7fc-319">El llamador no dispone del permiso requerido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-319">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="1d7fc-320">Permiso de reflexión del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-320">Reflection permission for the current module.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="1d7fc-321">Tipo de atributo personalizado que se va a probar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-321">The type of custom attribute to test for.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="1d7fc-322">Se omite este argumento para los objetos de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-322">This argument is ignored for objects of this type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-323">Devuelve un valor que indica si el tipo de atributo especificado se ha aplicado a este módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-323">Returns a value that indicates whether the specified attribute type has been applied to this module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-324">Es <see langword="true" /> si se han aplicado una o varias instancias de <paramref name="attributeType" /> a este módulo; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-324">
              <see langword="true" /> if one or more instances of <paramref name="attributeType" /> have been applied to this module; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1d7fc-325">En el ejemplo siguiente se muestra un uso de la `IsDefined` método.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-325">The following example demonstrates a use of the `IsDefined` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1d7fc-326">
            <paramref name="attributeType" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-326">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d7fc-327">
            <paramref name="attributeType" /> no es un objeto <see cref="T:System.Type" /> proporcionado en tiempo de ejecución.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-327">
              <paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime.</span>
          </span>
          <span data-ttu-id="1d7fc-328">Por ejemplo, <paramref name="attributeType" /> es un objeto <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-328">For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public virtual bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsResource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsResource () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsResource();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-329">Obtiene un valor que indica si el objeto es un recurso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-329">Gets a value indicating whether the object is a resource.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-330">Es <see langword="true" /> si el objeto es un recurso; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-330">
              <see langword="true" /> if the object is a resource; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1d7fc-331">En el ejemplo siguiente se muestra un uso de la `IsResource` método.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-331">The following example demonstrates a use of the `IsResource` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsResource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public virtual int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MDStreamVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MDStreamVersion As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MDStreamVersion { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-332">Obtiene la versión del flujo de metadatos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-332">Gets the metadata stream version.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="1d7fc-333">Entero de 32 bits que representa la versión del flujo de metadatos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-333">A 32-bit integer representing the metadata stream version.</span>
          </span>
          <span data-ttu-id="1d7fc-334">Los dos bytes de orden superior representan el número de versión principal, mientras que los dos bytes de orden inferior representan el número de versión secundaria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-334">The high-order two bytes represent the major version number, and the low-order two bytes represent the minor version number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-335">Para obtener más información sobre el encabezado de metadatos, vea "Partición II: definición y semántica de los metadatos" en la documentación de Common Language Infrastructure (CLI).</span><span class="sxs-lookup"><span data-stu-id="1d7fc-335">For more information on the metadata header, see "Partition II: Metadata Definition and Semantics" in the Common Language Infrastructure (CLI) documentation.</span></span> <span data-ttu-id="1d7fc-336">La documentación está disponible en línea; vea [ECMA C# y Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) en MSDN y [estándar ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) en el sitio Web de ECMA.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-336">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public virtual int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-337">Obtiene un token que identifica el módulo en los metadatos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-337">Gets a token that identifies the module in metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="1d7fc-338">Token entero que identifica el módulo actual en los metadatos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-338">An integer token that identifies the current module in metadata.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-339">Los tokens obtenidos mediante esta propiedad se pueden pasar a la API de reflexión no administrada.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-339">The tokens obtained using this property can be passed to the unmanaged Reflection API.</span></span> <span data-ttu-id="1d7fc-340">Para obtener más información, consulte [API de reflexión no administrada](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span><span class="sxs-lookup"><span data-stu-id="1d7fc-340">For more information, see [Unmanaged Reflection API](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-341">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</span><span class="sxs-lookup"><span data-stu-id="1d7fc-341">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="1d7fc-342">La documentación está disponible en línea; vea [ECMA C# y Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) en MSDN y [estándar ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) en el sitio Web de ECMA.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-342">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleHandle">
      <MemberSignature Language="C#" Value="public ModuleHandle ModuleHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ModuleHandle ModuleHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModuleHandle As ModuleHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ModuleHandle ModuleHandle { ModuleHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ModuleHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-343">Obtiene un identificador para el módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-343">Gets a handle for the module.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="1d7fc-344">Estructura <see cref="T:System.ModuleHandle" /> del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-344">A <see cref="T:System.ModuleHandle" /> structure for the current module.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public virtual Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleVersionId" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ModuleVersionId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid ModuleVersionId { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-345">Obtiene un identificador único universal (UUID) que se puede utilizar para distinguir entre dos versiones de un módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-345">Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="1d7fc-346">
            <see cref="T:System.Guid" /> que se puede utilizar para distinguir entre dos versiones de un módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-346">A <see cref="T:System.Guid" /> that can be used to distinguish between two versions of a module.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-347">En los metadatos no administrado, el GUID devuelto por la <xref:System.Reflection.Module.ModuleVersionId%2A> propiedad se conoce como el `mvid`y se almacena en el montón GUID.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-347">In unmanaged metadata, the GUID returned by the <xref:System.Reflection.Module.ModuleVersionId%2A> property is referred to as the `mvid`, and is stored in the GUID heap.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-348">Para obtener más información acerca de los metadatos se puede encontrar en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</span><span class="sxs-lookup"><span data-stu-id="1d7fc-348">More information about metadata can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="1d7fc-349">La documentación está disponible en línea; vea [ECMA C# y Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) en MSDN y [estándar ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) en el sitio Web de ECMA.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-349">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-350">Obtiene una cadena, <see langword="String" />, que representa al nombre del módulo sin la ruta de acceso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-350">Gets a <see langword="String" /> representing the name of the module with the path removed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="1d7fc-351">Nombre del módulo sin la ruta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-351">The module name with no path.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-352">`Name` es una cadena depende de la plataforma.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-352">`Name` is a platform-dependent string.</span></span>  
  
 <span data-ttu-id="1d7fc-353">Si el ensamblado de este módulo se cargó desde una matriz de bytes, a continuación, el `FullyQualifiedName` para el módulo serán: \<desconocido >.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-353">If the assembly for this module was loaded from a byte array then the `FullyQualifiedName` for the module will be: \<Unknown>.</span></span>  
  
 <span data-ttu-id="1d7fc-354">Para obtener el nombre y la ruta de acceso, use <xref:System.Reflection.Module.FullyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-354">To get the name and the path, use <xref:System.Reflection.Module.FullyQualifiedName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d7fc-355">Este ejemplo muestra el efecto de la `ScopeName`, `FullyQualifiedName`, y `Name` propiedades.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-355">This example shows the effect of the `ScopeName`, `FullyQualifiedName`, and `Name` properties.</span></span>  
  
 [!code-cpp[Classic Module.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.Name Example/CS/source.cs#1)]
 [!code-vb[Classic Module.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="1d7fc-356">Primer objeto que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-356">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="1d7fc-357">Segundo objeto que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-357">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-358">Indica si dos objetos <see cref="T:System.Reflection.Module" /> son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-358">Indicates whether two <see cref="T:System.Reflection.Module" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-359">
            <see langword="true" /> si <paramref name="left" /> es igual a <paramref name="right" />; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-359">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="1d7fc-360">Primer objeto que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-360">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="1d7fc-361">Segundo objeto que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-361">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-362">Indica si dos objetos <see cref="T:System.Reflection.Module" /> no son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-362">Indicates whether two <see cref="T:System.Reflection.Module" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-363">Es <see langword="true" /> si <paramref name="left" /> no es igual a <paramref name="right" />; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-363">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-364">Devuelve el campo identificado por un token de metadatos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-364">Returns the field identified by a metadata token.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo ResolveField (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveField (metadataToken As Integer) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ ResolveField(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="1d7fc-365">Token de metadatos que identifica un campo del módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-365">A metadata token that identifies a field in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-366">Devuelve el campo identificado por el token de metadatos especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-366">Returns the field identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-367">Objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo identificado por el token de metadatos especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-367">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-368">Para resolver un símbolo (token) de metadatos que identifica un campo cuyo elemento primario `TypeSpec` tiene una firma que contiene el tipo de elemento `ELEMENT_TYPE_VAR` o `ELEMENT_TYPE_MVAR`, use el <xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> sobrecarga del método, que permite proporcionar el contexto necesario.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-368">To resolve a metadata token that identifies a field whose parent `TypeSpec` has a signature containing element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="1d7fc-369">Es decir, cuando se resuelve un token de metadatos para un campo que depende de los parámetros de tipo genérico del tipo genérico y/o del método genérico en el que está incrustado el token, debe usar la sobrecarga que le permite proporcionar los parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-369">That is, when you are resolving a metadata token for a field that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-370">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</span><span class="sxs-lookup"><span data-stu-id="1d7fc-370">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="1d7fc-371">La documentación está disponible en línea; vea [ECMA C# y Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) en MSDN y [estándar ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) en el sitio Web de ECMA.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-371">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="1d7fc-372">Para el código que muestra cómo resolver tokens mediante el contexto genérico (es decir, los parámetros de tipo genérico del tipo genérico y/o del método genérico en el que está incrustado el token) consulte el <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> método.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-372">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d7fc-373">
            <paramref name="metadataToken" /> no es un token válido para un campo en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-373">
              <paramref name="metadataToken" /> is not a token for a field in the scope of the current module.</span>
          </span>
          <span data-ttu-id="1d7fc-374">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-374">-or-</span>
          </span>
          <span data-ttu-id="1d7fc-375">
            <paramref name="metadataToken" /> identifica un campo cuyo <see langword="TypeSpec" /> primario tiene una firma que contiene el tipo de elemento <see langword="var" /> (un parámetro de tipo de un tipo genérico) o <see langword="mvar" /> (un parámetro de tipo de un método genérico).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-375">
              <paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d7fc-376">
            <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-376">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveField (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ ResolveField(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="1d7fc-377">Token de metadatos que identifica un campo del módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-377">A metadata token that identifies a field in the module.</span>
          </span>
        </param>
        <param name="genericTypeArguments">
          <span data-ttu-id="1d7fc-378">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del tipo en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho tipo no es genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-378">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          </span>
        </param>
        <param name="genericMethodArguments">
          <span data-ttu-id="1d7fc-379">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del método en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho método no es genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-379">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-380">Devuelve el campo identificado por el token de metadatos especificado, en el contexto definido por los parámetros de tipo genérico especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-380">Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-381">Objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo identificado por el token de metadatos especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-381">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-382">Use la <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> método en el tipo donde `metadataToken` está en el ámbito para obtener una matriz de argumentos de tipo genérico para `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-382">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="1d7fc-383">Use la <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> método en el método donde `metadataToken` está en el ámbito para obtener una matriz de argumentos de tipo genérico para `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-383">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="1d7fc-384">Siempre es seguro proporcionar estos argumentos, incluso cuando no se necesitan.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-384">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-385">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</span><span class="sxs-lookup"><span data-stu-id="1d7fc-385">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="1d7fc-386">La documentación está disponible en línea; vea [ECMA C# y Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) en MSDN y [estándar ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) en el sitio Web de ECMA.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-386">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="1d7fc-387">Para el código que muestra cómo resolver tokens mediante el contexto genérico (es decir, los parámetros de tipo genérico del tipo genérico y/o del método genérico en el que está incrustado el token) consulte el <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> método.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-387">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d7fc-388">
            <paramref name="metadataToken" /> no es un token válido para un campo en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-388">
              <paramref name="metadataToken" /> is not a token for a field in the scope of the current module.</span>
          </span>
          <span data-ttu-id="1d7fc-389">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-389">-or-</span>
          </span>
          <span data-ttu-id="1d7fc-390">
            <paramref name="metadataToken" /> identifica un campo cuyo <see langword="TypeSpec" /> primario tiene una firma que contiene el tipo de elemento <see langword="var" /> (un parámetro de tipo de un tipo genérico) o <see langword="mvar" /> (un parámetro de tipo de un método genérico) y no se proporcionaron los argumentos de tipo genérico necesarios para uno o ambos parámetros <paramref name="genericTypeArguments" /> y <paramref name="genericMethodArguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-390">
              <paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d7fc-391">
            <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-391">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-392">Devuelve el tipo o integrante identificado por un token de metadatos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-392">Returns the type or member identified by a metadata token.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo ResolveMember (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMember (metadataToken As Integer) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MemberInfo ^ ResolveMember(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="1d7fc-393">Token de metadatos que identifica un tipo o integrante del módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-393">A metadata token that identifies a type or member in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-394">Devuelve el tipo o integrante identificado por el token de metadatos especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-394">Returns the type or member identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-395">Objeto <see cref="T:System.Reflection.MemberInfo" /> que representa el tipo o integrante identificado por el token de metadatos especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-395">A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-396">Para resolver un símbolo (token) de metadatos para un `MethodSpec` o `TypeSpec` cuya firma contiene el tipo de elemento `ELEMENT_TYPE_VAR` o `ELEMENT_TYPE_MVAR`, use el <xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> sobrecarga del método, que permite proporcionar el contexto necesario.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-396">To resolve a metadata token for a `MethodSpec` or `TypeSpec` whose signature contains element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="1d7fc-397">Es decir, cuando se resuelve un token de metadatos para un miembro que depende de los parámetros de tipo genérico del tipo genérico y/o del método genérico en el que está incrustado el token, debe usar la sobrecarga que le permite proporcionar los parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-397">That is, when you are resolving a metadata token for a member that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-398">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</span><span class="sxs-lookup"><span data-stu-id="1d7fc-398">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="1d7fc-399">La documentación está disponible en línea; vea [ECMA C# y Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) en MSDN y [estándar ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) en el sitio Web de ECMA.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-399">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="1d7fc-400">Para el código que muestra cómo resolver tokens mediante el contexto genérico (es decir, los parámetros de tipo genérico del tipo genérico y/o del método genérico en el que está incrustado el token) consulte el <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> método.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-400">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d7fc-401">
            <paramref name="metadataToken" /> no es un token para un tipo o integrante en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-401">
              <paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.</span>
          </span>
          <span data-ttu-id="1d7fc-402">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-402">-or-</span>
          </span>
          <span data-ttu-id="1d7fc-403">
            <paramref name="metadataToken" /> es un <see langword="MethodSpec" /> o <see langword="TypeSpec" /> cuya firma contiene el tipo de elemento <see langword="var" /> (un parámetro de tipo de un tipo genérico) o <see langword="mvar" /> (un parámetro de tipo de un método genérico).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-403">
              <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          </span>
          <span data-ttu-id="1d7fc-404">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-404">-or-</span>
          </span>
          <span data-ttu-id="1d7fc-405">
            <paramref name="metadataToken" /> identifica una propiedad o evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-405">
              <paramref name="metadataToken" /> identifies a property or event.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d7fc-406">
            <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-406">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMember (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MemberInfo ^ ResolveMember(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="1d7fc-407">Token de metadatos que identifica un tipo o integrante del módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-407">A metadata token that identifies a type or member in the module.</span>
          </span>
        </param>
        <param name="genericTypeArguments">
          <span data-ttu-id="1d7fc-408">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del tipo en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho tipo no es genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-408">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          </span>
        </param>
        <param name="genericMethodArguments">
          <span data-ttu-id="1d7fc-409">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del método en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho método no es genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-409">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-410">Devuelve el tipo o miembro identificado por el token de metadatos especificado, en el contexto definido por los parámetros de tipo genérico especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-410">Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-411">Objeto <see cref="T:System.Reflection.MemberInfo" /> que representa el tipo o integrante identificado por el token de metadatos especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-411">A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-412">Use la <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> método en el tipo donde `metadataToken` está en el ámbito para obtener una matriz de argumentos de tipo genérico para `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-412">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="1d7fc-413">Use la <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> método en el método donde `metadataToken` está en el ámbito para obtener una matriz de argumentos de tipo genérico para `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-413">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="1d7fc-414">Siempre es seguro proporcionar estos argumentos, incluso cuando no se necesitan.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-414">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-415">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</span><span class="sxs-lookup"><span data-stu-id="1d7fc-415">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="1d7fc-416">La documentación está disponible en línea; vea [ECMA C# y Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) en MSDN y [estándar ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) en el sitio Web de ECMA.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-416">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="1d7fc-417">Para el código que muestra cómo resolver tokens mediante el contexto genérico (es decir, los parámetros de tipo genérico del tipo genérico y/o del método genérico en el que está incrustado el token) consulte el <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> método.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-417">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d7fc-418">
            <paramref name="metadataToken" /> no es un token para un tipo o integrante en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-418">
              <paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.</span>
          </span>
          <span data-ttu-id="1d7fc-419">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-419">-or-</span>
          </span>
          <span data-ttu-id="1d7fc-420">
            <paramref name="metadataToken" /> es un <see langword="MethodSpec" /> o <see langword="TypeSpec" /> cuya firma contiene el tipo de elemento <see langword="var" /> (un parámetro de tipo de un tipo genérico) o <see langword="mvar" /> (un parámetro de tipo de un método genérico) y no se proporcionaron los argumentos de tipo genérico necesarios para uno o ambos parámetros <paramref name="genericTypeArguments" /> y <paramref name="genericMethodArguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-420">
              <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          </span>
          <span data-ttu-id="1d7fc-421">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-421">-or-</span>
          </span>
          <span data-ttu-id="1d7fc-422">
            <paramref name="metadataToken" /> identifica una propiedad o evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-422">
              <paramref name="metadataToken" /> identifies a property or event.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d7fc-423">
            <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-423">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-424">Devuelve el método identificado por un token de metadatos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-424">Returns the method identified by a metadata token.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase ResolveMethod (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMethod (metadataToken As Integer) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodBase ^ ResolveMethod(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="1d7fc-425">Token de metadatos que identifica un método o constructor en el módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-425">A metadata token that identifies a method or constructor in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-426">Devuelve el método o constructor identificado por el token de metadatos especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-426">Returns the method or constructor identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-427">Objeto <see cref="T:System.Reflection.MethodBase" /> que representa el método o constructor identificado por el token de metadatos especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-427">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-428">Para resolver un símbolo (token) de metadatos para un `MethodSpec` cuya firma contiene el tipo de elemento `ELEMENT_TYPE_VAR` o `ELEMENT_TYPE_MVAR`, use el <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> sobrecarga del método, que permite proporcionar el contexto necesario.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-428">To resolve a metadata token for a `MethodSpec` whose signature contains element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="1d7fc-429">Es decir, cuando se resuelve un token de metadatos para un método que depende de los parámetros de tipo genérico del tipo genérico o el método genérico en el que está incrustado el token, debe usar la sobrecarga que le permite proporcionar los parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-429">That is, when you are resolving a metadata token for a method that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-430">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</span><span class="sxs-lookup"><span data-stu-id="1d7fc-430">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="1d7fc-431">La documentación está disponible en línea; vea [ECMA C# y Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) en MSDN y [estándar ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) en el sitio Web de ECMA.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-431">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d7fc-432">En el ejemplo siguiente se muestra cómo usar las dos sobrecargas de la <xref:System.Reflection.Module.ResolveMethod%2A> sitios de método para resolver los tokens de metadatos de la llamada en contextos genéricos y no genéricos.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-432">The following example shows how to use the two overloads of the <xref:System.Reflection.Module.ResolveMethod%2A> method to resolve metadata tokens from call sites in generic and non-generic contexts.</span></span>  
  
 <span data-ttu-id="1d7fc-433">El ejemplo de código define dos tipos genéricos, `G1<Tg1>` y `G2<Tg2>` (`G1(Of Tg1)` y `G2(Of Tg2)` en Visual Basic), cada uno de los cuales tiene un método genérico.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-433">The code example defines two generic types, `G1<Tg1>` and `G2<Tg2>` (`G1(Of Tg1)` and `G2(Of Tg2)` in Visual Basic), each of which has a generic method.</span></span> <span data-ttu-id="1d7fc-434">`G1<Tg1>` También tiene un método no genérico que usa el parámetro de tipo `Tg1` para su parámetro.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-434">`G1<Tg1>` also has a non-generic method that uses the type parameter `Tg1` for its parameter.</span></span> <span data-ttu-id="1d7fc-435">El método genérico `GM2<Tgm2>` en tipo `G2<Tg2>` contiene varias llamadas a métodos:</span><span class="sxs-lookup"><span data-stu-id="1d7fc-435">The generic method `GM2<Tgm2>` in type `G2<Tg2>` contains several method calls:</span></span>  
  
-   <span data-ttu-id="1d7fc-436">Caso 1: El método genérico `GM1<Tgm1>` se llama con los parámetros de tipo de `G2<Tg2>` y `GM2<Tgm2>` como los argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-436">Case 1: The generic method `GM1<Tgm1>` is called, using the type parameters of `G2<Tg2>` and `GM2<Tgm2>` as the type arguments.</span></span> <span data-ttu-id="1d7fc-437">En otras palabras, los tipos de parámetros del método llamado dependerá de los tipos que se usan para construir un tipo genérico de la definición de tipo para `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-437">In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="1d7fc-438">Caso 2: El método no genérico `M1` se llama.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-438">Case 2: The non-generic method `M1` is called.</span></span> <span data-ttu-id="1d7fc-439">El parámetro de este método utiliza el parámetro de tipo del tipo de definición, `G1<Tg1>`, que será sustituido por el parámetro de tipo del tipo envolvente, en este caso `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-439">The parameter of this method uses the type parameter of the defining type, `G1<Tg1>`, which is replaced in this case by the type parameter of the enclosing type, `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="1d7fc-440">Caso 3: El método genérico `GM1<Tgm1>` se llama, especificar <xref:System.Int32> y <xref:System.Object> para los argumentos de tipo del tipo genérico y el método genérico, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-440">Case 3: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="1d7fc-441">Esta llamada al método no depende de los parámetros de tipo del tipo o método envolvente.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-441">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
-   <span data-ttu-id="1d7fc-442">Caso 4: El método no genérico `M1` de la `Example` clase se denomina.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-442">Case 4: The non-generic method `M1` of the `Example` class is called.</span></span> <span data-ttu-id="1d7fc-443">Esta llamada al método no depende de los parámetros de tipo del tipo o método envolvente.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-443">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
 <span data-ttu-id="1d7fc-444">Además, el ejemplo define no genérica `Example` clase.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-444">In addition, the example defines the non-generic `Example` class.</span></span> <span data-ttu-id="1d7fc-445">Esta clase tiene un método `M` que realiza una llamada a un método genérico:</span><span class="sxs-lookup"><span data-stu-id="1d7fc-445">This class has a method `M` that makes a call to a generic method:</span></span>  
  
-   <span data-ttu-id="1d7fc-446">Caso 5: El método genérico `GM1` se llama, especificar <xref:System.Int32> y <xref:System.Object> para los argumentos de tipo del tipo genérico y el método genérico, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-446">Case 5: The generic method `GM1` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="1d7fc-447">El contexto de este método no tiene ningún envolvente tipo genérico o método genérico.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-447">The context for this method has no enclosing generic type or generic method.</span></span>  
  
 <span data-ttu-id="1d7fc-448">Para cada caso, el ejemplo crea primero un <xref:System.Reflection.MethodInfo> que representa el método llamado y, a continuación, resuelve el token mediante la <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> sobrecarga del método, con el <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> y <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> métodos para obtener los valores para el `genericTypeArguments` y `genericMethodArguments` parámetros.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-448">For each case, the example first constructs a <xref:System.Reflection.MethodInfo> that represents the called method, and then resolves the token using the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, using the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> methods to get the values for the `genericTypeArguments` and `genericMethodArguments` parameters.</span></span> <span data-ttu-id="1d7fc-449">Esta técnica funciona en todos los casos, porque los métodos devuelven <xref:System.Type.EmptyTypes?displayProperty=nameWithType> para contextos no genérica.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-449">This technique works in all cases, because the methods return <xref:System.Type.EmptyTypes?displayProperty=nameWithType> for non-generic contexts.</span></span> <span data-ttu-id="1d7fc-450">En el ejemplo se compara el resuelto <xref:System.Reflection.MethodInfo> con creado <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-450">The example compares the resolved <xref:System.Reflection.MethodInfo> with the constructed <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="1d7fc-451">En el ejemplo, a continuación, intenta utilizar el <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> sobrecarga del método para resolver el token.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-451">The example then attempts to use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> method overload to resolve the token.</span></span> <span data-ttu-id="1d7fc-452">Esto funciona en los casos 3, 4 y 5, porque las llamadas al método no dependen del contexto genérico.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-452">This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</span></span> <span data-ttu-id="1d7fc-453">En los casos 1 y 2, se produce una excepción porque no hay suficiente información para resolver el token.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-453">In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</span></span>  
  
 <span data-ttu-id="1d7fc-454">Los valores de símbolo (token) de metadatos están codificados de forma rígida como una enumeración.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-454">The metadata token values are hard-coded as an enumeration.</span></span> <span data-ttu-id="1d7fc-455">Si cambia este ejemplo de código, los valores de token están probables que cambie.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-455">If you change this code example, the token values are likely to change.</span></span> <span data-ttu-id="1d7fc-456">Para determinar los nuevos valores de token, compile el código y use Ildasm.exe con la **/TOKENS** opción para examinar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-456">To determine the new token values, compile the code and use Ildasm.exe with the **/TOKENS** option to examine the assembly.</span></span> <span data-ttu-id="1d7fc-457">Los tokens se pueden encontrar en los puntos de llamada.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-457">The tokens can be found at the points of call.</span></span> <span data-ttu-id="1d7fc-458">Inserte los nuevos valores en la enumeración, y vuelva a compilar el ejemplo.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-458">Insert the new values into the enumeration, and recompile the example.</span></span>  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d7fc-459">
            <paramref name="metadataToken" /> no es un token para un método o constructor en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-459">
              <paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.</span>
          </span>
          <span data-ttu-id="1d7fc-460">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-460">-or-</span>
          </span>
          <span data-ttu-id="1d7fc-461">
            <paramref name="metadataToken" /> es un <see langword="MethodSpec" /> cuya firma contiene el tipo de elemento <see langword="var" /> (un parámetro de tipo de un tipo genérico) o <see langword="mvar" /> (un parámetro de tipo de un método genérico).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-461">
              <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d7fc-462">
            <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-462">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMethod (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBase ^ ResolveMethod(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="1d7fc-463">Token de metadatos que identifica un método o constructor en el módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-463">A metadata token that identifies a method or constructor in the module.</span>
          </span>
        </param>
        <param name="genericTypeArguments">
          <span data-ttu-id="1d7fc-464">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del tipo en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho tipo no es genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-464">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          </span>
        </param>
        <param name="genericMethodArguments">
          <span data-ttu-id="1d7fc-465">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del método en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho método no es genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-465">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-466">Devuelve el método o constructor identificado por el token de metadatos especificado, en el contexto definido por los parámetros de tipo genérico especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-466">Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-467">Objeto <see cref="T:System.Reflection.MethodBase" /> que representa el método identificado por el token de metadatos especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-467">A <see cref="T:System.Reflection.MethodBase" /> object representing the method that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-468">Use la <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> método en el tipo donde `metadataToken` está en el ámbito para obtener una matriz de argumentos de tipo genérico para `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-468">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="1d7fc-469">Use la <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> método en el método donde `metadataToken` está en el ámbito para obtener una matriz de argumentos de tipo genérico para `genericMethodArguments`.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-469">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericMethodArguments`.</span></span> <span data-ttu-id="1d7fc-470">Siempre es seguro proporcionar estos argumentos, incluso cuando no se necesitan.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-470">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-471">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</span><span class="sxs-lookup"><span data-stu-id="1d7fc-471">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="1d7fc-472">La documentación está disponible en línea; vea [ECMA C# y Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) en MSDN y [estándar ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) en el sitio Web de ECMA.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-472">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d7fc-473">En el ejemplo siguiente se muestra cómo usar las dos sobrecargas de la <xref:System.Reflection.Module.ResolveMethod%2A> sitios de método para resolver los tokens de metadatos de la llamada en contextos genéricos y no genéricos.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-473">The following example shows how to use the two overloads of the <xref:System.Reflection.Module.ResolveMethod%2A> method to resolve metadata tokens from call sites in generic and non-generic contexts.</span></span>  
  
 <span data-ttu-id="1d7fc-474">El ejemplo de código define dos tipos genéricos, `G1<Tg1>` y `G2<Tg2>`, cada uno de los cuales tiene un método genérico.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-474">The code example defines two generic types, `G1<Tg1>` and `G2<Tg2>`, each of which has a generic method.</span></span> <span data-ttu-id="1d7fc-475">`G1<Tg1>` También tiene un método no genérico que usa el parámetro de tipo `Tg1` para su parámetro.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-475">`G1<Tg1>` also has a non-generic method that uses the type parameter `Tg1` for its parameter.</span></span> <span data-ttu-id="1d7fc-476">El método genérico `GM2<Tgm2>` en tipo `G2<Tg2>` contiene varias llamadas a métodos:</span><span class="sxs-lookup"><span data-stu-id="1d7fc-476">The generic method `GM2<Tgm2>` in type `G2<Tg2>` contains several method calls:</span></span>  
  
-   <span data-ttu-id="1d7fc-477">Caso 1: El método genérico `GM1<Tgm1>` se llama con los parámetros de tipo de `G2<Tg2>` y `GM2<Tgm2>` como los argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-477">Case 1: The generic method `GM1<Tgm1>` is called, using the type parameters of `G2<Tg2>` and `GM2<Tgm2>` as the type arguments.</span></span> <span data-ttu-id="1d7fc-478">En otras palabras, los tipos de parámetros del método llamado dependerá de los tipos que se usan para construir un tipo genérico de la definición de tipo para `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-478">In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="1d7fc-479">Caso 2: El método no genérico `M1` se llama.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-479">Case 2: The non-generic method `M1` is called.</span></span> <span data-ttu-id="1d7fc-480">El parámetro de este método utiliza el parámetro de tipo del tipo de definición, `G1<Tg1>`, que será sustituido por el parámetro de tipo del tipo envolvente, en este caso `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-480">The parameter of this method uses the type parameter of the defining type, `G1<Tg1>`, which is replaced in this case by the type parameter of the enclosing type, `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="1d7fc-481">Caso 3: El método genérico `GM1<Tgm1>` se llama, especificar <xref:System.Int32> y <xref:System.Object> para los argumentos de tipo del tipo genérico y el método genérico, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-481">Case 3: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="1d7fc-482">Esta llamada al método no depende de los parámetros de tipo del tipo o método envolvente.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-482">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
-   <span data-ttu-id="1d7fc-483">Caso 4: El método no genérico `M1` de la `Example` clase se denomina.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-483">Case 4: The non-generic method `M1` of the `Example` class is called.</span></span> <span data-ttu-id="1d7fc-484">Esta llamada al método no depende de los parámetros de tipo del tipo o método envolvente.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-484">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
 <span data-ttu-id="1d7fc-485">Además, el ejemplo define no genérica `Example` clase.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-485">In addition, the example defines the non-generic `Example` class.</span></span> <span data-ttu-id="1d7fc-486">Esta clase tiene un método `M` que realiza una llamada a un método genérico.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-486">This class has a method `M` that makes a call to a generic method.</span></span>  
  
-   <span data-ttu-id="1d7fc-487">Caso 5: El método genérico `GM1<Tgm1>` se llama, especificar <xref:System.Int32> y <xref:System.Object> para los argumentos de tipo del tipo genérico y el método genérico, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-487">Case 5: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="1d7fc-488">El contexto de este método no tiene ningún envolvente tipo genérico o método genérico.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-488">The context for this method has no enclosing generic type or generic method.</span></span>  
  
 <span data-ttu-id="1d7fc-489">Para cada caso, el ejemplo crea primero un <xref:System.Reflection.MethodInfo> que representa el método llamado y, a continuación, resuelve el token mediante la <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> sobrecarga del método, con el <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> y <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> métodos para obtener los valores para el `genericTypeArguments` y `genericMethodArguments` parámetros.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-489">For each case, the example first constructs a <xref:System.Reflection.MethodInfo> that represents the called method, and then resolves the token using the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, using the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> methods to get the values for the `genericTypeArguments` and `genericMethodArguments` parameters.</span></span> <span data-ttu-id="1d7fc-490">Esta técnica funciona en todos los casos, porque los métodos devuelven <xref:System.Type.EmptyTypes?displayProperty=nameWithType> para contextos no genérica.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-490">This technique works in all cases, because the methods return <xref:System.Type.EmptyTypes?displayProperty=nameWithType> for non-generic contexts.</span></span> <span data-ttu-id="1d7fc-491">En el ejemplo se compara el resuelto <xref:System.Reflection.MethodInfo> con creado <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-491">The example compares the resolved <xref:System.Reflection.MethodInfo> with the constructed <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="1d7fc-492">En el ejemplo, a continuación, intenta utilizar el <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> sobrecarga del método para resolver el token.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-492">The example then attempts to use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> method overload to resolve the token.</span></span> <span data-ttu-id="1d7fc-493">Esto funciona en los casos 3, 4 y 5, porque las llamadas al método no dependen del contexto genérico.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-493">This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</span></span> <span data-ttu-id="1d7fc-494">En los casos 1 y 2, se produce una excepción porque no hay suficiente información para resolver el token.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-494">In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</span></span>  
  
 <span data-ttu-id="1d7fc-495">Los valores de símbolo (token) de metadatos están codificados de forma rígida como una enumeración.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-495">The metadata token values are hard-coded as an enumeration.</span></span> <span data-ttu-id="1d7fc-496">Si cambia este ejemplo de código, los valores de token están probables que cambie.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-496">If you change this code example, the token values are likely to change.</span></span> <span data-ttu-id="1d7fc-497">Para determinar los nuevos valores de token, compile el código y use Ildasm.exe con la **/TOKENS** opción para examinar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-497">To determine the new token values, compile the code and use Ildasm.exe with the **/TOKENS** option to examine the assembly.</span></span> <span data-ttu-id="1d7fc-498">Los tokens se pueden encontrar en los puntos de llamada.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-498">The tokens can be found at the points of call.</span></span> <span data-ttu-id="1d7fc-499">Inserte los nuevos valores en la enumeración, y vuelva a compilar el ejemplo.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-499">Insert the new values into the enumeration, and recompile the example.</span></span>  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d7fc-500">
            <paramref name="metadataToken" /> no es un token para un método o constructor en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-500">
              <paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.</span>
          </span>
          <span data-ttu-id="1d7fc-501">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-501">-or-</span>
          </span>
          <span data-ttu-id="1d7fc-502">
            <paramref name="metadataToken" /> es un <see langword="MethodSpec" /> cuya firma contiene el tipo de elemento <see langword="var" /> (un parámetro de tipo de un tipo genérico) o <see langword="mvar" /> (un parámetro de tipo de un método genérico) y no se proporcionaron los argumentos de tipo genérico necesarios para uno o ambos parámetros <paramref name="genericTypeArguments" /> y <paramref name="genericMethodArguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-502">
              <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d7fc-503">
            <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-503">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public virtual byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveSignature(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveSignature (metadataToken As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ResolveSignature(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="1d7fc-504">Token de metadatos que identifica una firma en el módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-504">A metadata token that identifies a signature in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-505">Devuelve el objeto binario de firma identificado por un token de metadatos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-505">Returns the signature blob identified by a metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-506">Una matriz de bytes que representan el objeto binario de firma.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-506">An array of bytes representing the signature blob.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-507">Encontrará información sobre los tokens de metadatos y firmas en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</span><span class="sxs-lookup"><span data-stu-id="1d7fc-507">Information about metadata tokens and signatures can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="1d7fc-508">La documentación está disponible en línea; vea [ECMA C# y Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) en MSDN y [estándar ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) en el sitio Web de ECMA.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-508">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d7fc-509">
            <paramref name="metadataToken" /> no es un token <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, de firma o <see langword="FieldDef" /> válido en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-509">
              <paramref name="metadataToken" /> is not a valid <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, signature, or <see langword="FieldDef" /> token in the scope of the current module.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d7fc-510">
            <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-510">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public virtual string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveString (metadataToken As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveString(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="1d7fc-511">Token de metadatos que identifica una cadena en el montón de cadena del módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-511">A metadata token that identifies a string in the string heap of the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-512">Devuelve la cadena identificada por el token de metadatos especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-512">Returns the string identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-513">
            <see cref="T:System.String" /> que contiene un valor de cadena del montón de cadena de metadatos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-513">A <see cref="T:System.String" /> containing a string value from the metadata string heap.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-514">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</span><span class="sxs-lookup"><span data-stu-id="1d7fc-514">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="1d7fc-515">La documentación está disponible en línea; vea [ECMA C# y Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) en MSDN y [estándar ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) en el sitio Web de ECMA.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-515">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d7fc-516">
            <paramref name="metadataToken" /> no es un token de una cadena en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-516">
              <paramref name="metadataToken" /> is not a token for a string in the scope of the current module.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d7fc-517">
            <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-517">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-518">Devuelve el tipo identificado por un token de metadatos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-518">Returns the type identified by a metadata token.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public Type ResolveType (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type ResolveType(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveType (metadataToken As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ ResolveType(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="1d7fc-519">Token de metadatos que identifica un tipo en el módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-519">A metadata token that identifies a type in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-520">Devuelve el tipo identificado por el token de metadatos especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-520">Returns the type identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-521">Objeto <see cref="T:System.Type" /> que representa el tipo identificado por el token de metadatos especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-521">A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-522">Para resolver un símbolo (token) de metadatos para un `TypeSpec` cuya firma contenga `ELEMENT_TYPE_VAR` o `ELEMENT_TYPE_MVAR`, use el <xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> sobrecarga del método, que permite proporcionar el contexto necesario.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-522">To resolve a metadata token for a `TypeSpec` whose signature contains `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="1d7fc-523">Es decir, cuando se resuelve un token de metadatos para un tipo que depende de los parámetros de tipo genérico del tipo genérico y/o del método genérico en el que está incrustado el token, debe usar la sobrecarga que le permite proporcionar los parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-523">That is, when you are resolving a metadata token for a type that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-524">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</span><span class="sxs-lookup"><span data-stu-id="1d7fc-524">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="1d7fc-525">La documentación está disponible en línea; vea [ECMA C# y Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) en MSDN y [estándar ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) en el sitio Web de ECMA.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-525">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d7fc-526">
            <paramref name="metadataToken" /> no es un token válido para un tipo en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-526">
              <paramref name="metadataToken" /> is not a token for a type in the scope of the current module.</span>
          </span>
          <span data-ttu-id="1d7fc-527">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-527">-or-</span>
          </span>
          <span data-ttu-id="1d7fc-528">
            <paramref name="metadataToken" /> es un <see langword="TypeSpec" /> cuya firma contiene el tipo de elemento <see langword="var" /> (un parámetro de tipo de un tipo genérico) o <see langword="mvar" /> (un parámetro de tipo de un método genérico).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-528">
              <paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d7fc-529">
            <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-529">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public virtual Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveType (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ ResolveType(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="1d7fc-530">Token de metadatos que identifica un tipo en el módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-530">A metadata token that identifies a type in the module.</span>
          </span>
        </param>
        <param name="genericTypeArguments">
          <span data-ttu-id="1d7fc-531">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del tipo en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho tipo no es genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-531">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          </span>
        </param>
        <param name="genericMethodArguments">
          <span data-ttu-id="1d7fc-532">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del método en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho método no es genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-532">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-533">Devuelve el campo identificado por el token de metadatos especificado, en el contexto definido por los parámetros de tipo genérico especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-533">Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-534">Objeto <see cref="T:System.Type" /> que representa el tipo identificado por el token de metadatos especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-534">A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-535">Use la <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> método en el tipo donde `metadataToken` está en el ámbito para obtener una matriz de argumentos de tipo genérico para `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-535">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="1d7fc-536">Use la <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> método en el método donde `metadataToken` está en el ámbito para obtener una matriz de argumentos de tipo genérico para `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-536">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="1d7fc-537">Siempre es seguro proporcionar estos argumentos, incluso cuando no se necesitan.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-537">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d7fc-538">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</span><span class="sxs-lookup"><span data-stu-id="1d7fc-538">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="1d7fc-539">La documentación está disponible en línea; vea [ECMA C# y Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) en MSDN y [estándar ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) en el sitio Web de ECMA.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-539">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="1d7fc-540">Para el código que muestra cómo resolver tokens mediante el contexto genérico (es decir, los parámetros de tipo genérico del tipo genérico y/o del método genérico en el que está incrustado el token) consulte el <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> método.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-540">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d7fc-541">
            <paramref name="metadataToken" /> no es un token válido para un tipo en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-541">
              <paramref name="metadataToken" /> is not a token for a type in the scope of the current module.</span>
          </span>
          <span data-ttu-id="1d7fc-542">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-542">-or-</span>
          </span>
          <span data-ttu-id="1d7fc-543">
            <paramref name="metadataToken" /> es un <see langword="TypeSpec" /> cuya firma contiene el tipo de elemento <see langword="var" /> (un parámetro de tipo de un tipo genérico) o <see langword="mvar" /> (un parámetro de tipo de un método genérico) y no se proporcionaron los argumentos de tipo genérico necesarios para uno o ambos parámetros <paramref name="genericTypeArguments" /> y <paramref name="genericMethodArguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-543">
              <paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d7fc-544">
            <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-544">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public virtual string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ScopeName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ScopeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ScopeName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-545">Obtiene una cadena que representa al nombre del módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-545">Gets a string representing the name of the module.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="1d7fc-546">Nombre del módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-546">The module name.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-547">El `ScopeName` propiedad no se usa en common language runtime, pero se puede usar para almacenar cualquier cadena que se desee en la propiedad cuando se emita un módulo mediante las API de metadatos.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-547">The `ScopeName` property is not used by the common language runtime, but you can use it to store any string you want in the property when you emit a module using the metadata APIs.</span></span> <span data-ttu-id="1d7fc-548">Propia reflexión no permite establecer el `ScopeName` propiedad.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-548">Reflection itself does not allow you to set the `ScopeName` property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d7fc-549">Este ejemplo muestra el efecto de la `ScopeName`, `FullyQualifiedName`, y `Name` propiedades.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-549">This example shows the effect of the `ScopeName`, `FullyQualifiedName`, and `Name` properties.</span></span>  
  
 [!code-cpp[Classic Module.ScopeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.ScopeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CS/source.cs#1)]
 [!code-vb[Classic Module.ScopeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Module.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Module.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Module::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="1d7fc-550">Reservado para un uso futuro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-550">Reserved for future use.</span>
          </span>
          <span data-ttu-id="1d7fc-551">Debe ser IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-551">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="1d7fc-552">Matriz que se pasa con los nombres que se van a asignar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-552">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="1d7fc-553">Número de nombres que se van a asignar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-553">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="1d7fc-554">Contexto de configuración regional en el que se van a interpretar los nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-554">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="1d7fc-555">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-555">Caller-allocated array that receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-556">Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-556">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-557">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-557">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="1d7fc-558">Para obtener más información sobre `IDispatch::GetIDsOfNames`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-558">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="1d7fc-559">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-559">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Module.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="1d7fc-560">Información de tipos que se va a devolver.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-560">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="1d7fc-561">Identificador de la configuración regional de la información de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-561">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="1d7fc-562">Recibe un puntero al objeto de información de tipo solicitado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-562">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-563">Recupera la información de tipo de un objeto, que se puede utilizar después para obtener la información de tipo de una interfaz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-563">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-564">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-564">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="1d7fc-565">Para obtener más información sobre `IDispatch::GetTypeInfo`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-565">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="1d7fc-566">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-566">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Module.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="1d7fc-567">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-567">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-568">Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-568">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-569">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-569">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="1d7fc-570">Para obtener más información sobre `IDispatch::GetTypeInfoCount`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-570">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="1d7fc-571">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-571">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.Invoke">
      <MemberSignature Language="C#" Value="void _Module.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Module.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Module::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="1d7fc-572">Identifica el miembro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-572">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="1d7fc-573">Reservado para un uso futuro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-573">Reserved for future use.</span>
          </span>
          <span data-ttu-id="1d7fc-574">Debe ser IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-574">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="1d7fc-575">Contexto de la configuración regional en que se interpretan los argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-575">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="1d7fc-576">Marcas que describen el contexto de la llamada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-576">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="1d7fc-577">Puntero a una estructura que contiene una matriz de argumentos, una matriz de DispID de los argumentos con nombre y recuentos del número de elementos en las matrices.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-577">Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="1d7fc-578">Puntero a la ubicación donde se va a almacenar el resultado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-578">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="1d7fc-579">Puntero a una estructura que contiene información de excepciones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-579">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="1d7fc-580">Índice del primer argumento que tiene un error.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-580">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1d7fc-581">Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-581">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d7fc-582">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-582">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="1d7fc-583">Para obtener más información sobre `IDispatch::Invoke`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-583">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="1d7fc-584">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-584">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1d7fc-585">Devuelve el nombre del módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-585">Returns the name of the module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1d7fc-586">
            <see langword="String" /> que representa al nombre de este módulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1d7fc-586">A <see langword="String" /> representing the name of this module.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1d7fc-587">En el ejemplo siguiente se muestra un uso de la `ToString` método.</span><span class="sxs-lookup"><span data-stu-id="1d7fc-587">The following example demonstrates a use of the `ToString` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.ToString Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>