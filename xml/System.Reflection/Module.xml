<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Module.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac599434ae0ca2ae257e847cbb424c20883be128c2c.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">99434ae0ca2ae257e847cbb424c20883be128c2c</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Performs reflection on a module.</source>
          <target state="translated">Realiza la reflexión en un módulo.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>A module is a portable executable file, such as type.dll or application.exe, consisting of one or more classes and interfaces.</source>
          <target state="translated">Un módulo es un archivo portable ejecutable, como tipo.dll o application.exe, que consta de uno o más clases e interfaces.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>There may be multiple namespaces contained in a single module, and a namespace may span multiple modules.</source>
          <target state="translated">Puede que haya varios espacios de nombres contenidos en un módulo único y un espacio de nombres puede abarcar a varios módulos.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>One or more modules deployed as a unit compose an assembly.</source>
          <target state="translated">Un ensamblado está compuesto de uno o varios módulos implementados como una unidad.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>For information about creating an assembly with more than one module, see <bpt id="p1">[</bpt>Multifile Assemblies<ept id="p1">](~/docs/framework/app-domains/multifile-assemblies.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de cómo crear un ensamblado con más de un módulo, consulte <bpt id="p1">[</bpt>Multifile Assemblies<ept id="p1">](~/docs/framework/app-domains/multifile-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>Note that a .NET Framework module is not the same as a module in Visual Basic, which is used by a programmers to organize functions and subroutines in an application.</source>
          <target state="translated">Tenga en cuenta que un módulo de .NET Framework no es igual a un módulo en Visual Basic, que se usa por los programadores para organizar funciones y subrutinas en una aplicación.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>The following code examples show how to use reflection to get information about modules:</source>
          <target state="translated">Ejemplos de código siguientes muestran cómo utilizar la reflexión para obtener información acerca de los módulos:</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>for full trust for inheritors.</source>
          <target state="translated">de plena confianza para los herederos.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">Esta clase no puede heredarse mediante código de confianza parcial.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.#ctor">
          <source>This constructor is invoked by derived classes during the construction of <ph id="ph1">&lt;xref:System.Reflection.Module&gt;</ph> objects.</source>
          <target state="translated">Este constructor es invocado por clases derivadas durante la construcción de <ph id="ph1">&lt;xref:System.Reflection.Module&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.Assembly">
          <source>Gets the appropriate <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> for this instance of <ph id="ph2">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>.</source>
          <target state="translated">Obtiene el <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> adecuado para esta instancia de <ph id="ph2">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Assembly">
          <source>An <ph id="ph1">&lt;see langword="Assembly" /&gt;</ph> object.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see langword="Assembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Assembly">
          <source>The following example displays the full name of the specified assembly in the specified module.</source>
          <target state="translated">En el ejemplo siguiente se muestra el nombre completo del ensamblado especificado en el módulo especificado.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.CustomAttributes">
          <source>Gets a collection that contains this module's custom attributes.</source>
          <target state="translated">Obtiene una colección que contiene los atributos personalizados de este módulo.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.CustomAttributes">
          <source>A collection that contains this module's custom attributes.</source>
          <target state="translated">Colección que contiene los atributos personalizados de este módulo.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.Equals(System.Object)">
          <source>The object to compare with this instance.</source>
          <target state="translated">Objeto que se va a comparar con esta instancia.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.Equals(System.Object)">
          <source>Determines whether this module and the specified object are equal.</source>
          <target state="translated">Determina si este módulo y el objeto especificado son iguales.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is equal to this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="o" /&gt;</ph> es igual a esta instancia; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="F:System.Reflection.Module.FilterTypeName">
          <source>A <ph id="ph1">&lt;see langword="TypeFilter" /&gt;</ph> object that filters the list of types defined in this module based upon the name.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see langword="TypeFilter" /&gt;</ph> que filtra la lista de tipos definida en este módulo a partir del nombre.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="F:System.Reflection.Module.FilterTypeName">
          <source>This field is case-sensitive and read-only.</source>
          <target state="translated">Este campo distingue entre mayúsculas y minúsculas y es de sólo lectura.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Module.FilterTypeName">
          <source>The filter supports a trailing "*" wildcard.</source>
          <target state="translated">El filtro admite un carácter final "*" comodín.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Module.FilterTypeName">
          <source>The following example displays the module names that match the specified search criteria.</source>
          <target state="translated">El ejemplo siguiente muestra los nombres de módulo que coinciden con los criterios de búsqueda especificados.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
          <source>A <ph id="ph1">&lt;see langword="TypeFilter" /&gt;</ph> object that filters the list of types defined in this module based upon the name.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see langword="TypeFilter" /&gt;</ph> que filtra la lista de tipos definida en este módulo a partir del nombre.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
          <source>This field is case-insensitive and read-only.</source>
          <target state="translated">Este campo no distingue entre mayúsculas y minúsculas y es de sólo lectura.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
          <source>The filter supports a trailing "*" wildcard.</source>
          <target state="translated">El filtro admite un carácter final "*" comodín.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
          <source>The following example displays the module names that match the specified search criteria, ignoring the case.</source>
          <target state="translated">El ejemplo siguiente muestra los nombres de módulo que coinciden con los criterios de búsqueda especificado, omitir el caso.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The delegate used to filter the classes.</source>
          <target state="translated">Delegado utilizado para filtrar las clases.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>An Object used to filter the classes.</source>
          <target state="translated">Objeto utilizado para filtrar las clases.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>Returns an array of classes accepted by the given filter and filter criteria.</source>
          <target state="translated">Devuelve una matriz de las clases aceptadas según el filtro y los criterios de filtro dados.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing classes that were accepted by the filter.</source>
          <target state="translated">Matriz de tipo <ph id="ph1">&lt;see langword="Type" /&gt;</ph> que contiene las clases ya aceptadas por el filtro.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Reflection.ReflectionTypeLoadException&gt;</ph> is a special class load exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.ReflectionTypeLoadException&gt;</ph> es una excepción de carga de clase especial.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> property contains the array of classes that were defined in the module and were loaded.</source>
          <target state="translated">El <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> propiedad contiene la matriz de clases que se definieron en el módulo y cargadas.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>This array may contain some null values.</source>
          <target state="translated">Esta matriz puede contener valores null.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> property is an array of exceptions that represent the exceptions that were thrown by the class loader.</source>
          <target state="translated">El <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> propiedad es una matriz de excepciones que representan las excepciones producidas por el cargador de clases.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The holes in the class array line up with the exceptions.</source>
          <target state="translated">Los agujeros en la matriz de clase se alineen con las excepciones.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The delegate given by <ph id="ph1">`filter`</ph> is called for each class in the module, passing along the <ph id="ph2">`Type`</ph> object representing the class as well as the given <ph id="ph3">`filterCriteria`</ph>.</source>
          <target state="translated">El delegado proporcionado por <ph id="ph1">`filter`</ph> se llama para cada clase en el módulo, pasando a lo largo de la <ph id="ph2">`Type`</ph> que representa la clase de objeto, así como la determinada <ph id="ph3">`filterCriteria`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>If <ph id="ph1">`filter`</ph> returns a particular class, that class will be included in the returned array.</source>
          <target state="translated">Si <ph id="ph1">`filter`</ph> devuelve una determinada clase, que la clase se incluirá en la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>If <ph id="ph1">`filter`</ph> returns <ph id="ph2">`null`</ph>, all classes are returned and <ph id="ph3">`filterCriteria`</ph> is ignored.</source>
          <target state="translated">Si <ph id="ph1">`filter`</ph> devuelve <ph id="ph2">`null`</ph>, se devuelven todas las clases y <ph id="ph3">`filterCriteria`</ph> se omite.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">`FindTypes`</ph> cannot be used to look up parameterized types such as arrays.</source>
          <target state="translated"><ph id="ph1">`FindTypes`</ph> no se puede usar para buscar tipos parametrizados como flechas.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The following example demonstrates the <ph id="ph1">`FindTypes`</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra el <ph id="ph1">`FindTypes`</ph> método.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>One or more classes in a module could not be loaded.</source>
          <target state="translated">No se han podido cargar una o varias clases en un módulo.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>Gets a string representing the fully qualified name and path to this module.</source>
          <target state="translated">Obtiene una cadena que representa el nombre completo y la ruta de acceso de este módulo.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>The fully qualified module name.</source>
          <target state="translated">Nombre completo del módulo.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>To get the name without the path, use <ph id="ph1">&lt;xref:System.Reflection.Module.Name%2A&gt;</ph>.</source>
          <target state="translated">Para obtener el nombre sin la ruta de acceso, use <ph id="ph1">&lt;xref:System.Reflection.Module.Name%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>If the assembly for this module was loaded from a byte array then the <ph id="ph1">`FullyQualifiedName`</ph> for the module will be: <ph id="ph2">\&lt;</ph>Unknown&gt;.</source>
          <target state="translated">Si el ensamblado de este módulo se cargó desde una matriz de bytes, a continuación, el <ph id="ph1">`FullyQualifiedName`</ph> para el módulo serán: <ph id="ph2">\&lt;</ph>desconocido &gt;.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>The case of module name is platform-dependent.</source>
          <target state="translated">El caso del nombre del módulo es dependiente de la plataforma.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>The following example displays the fully qualified name of the specified module.</source>
          <target state="translated">En el ejemplo siguiente se muestra el nombre completo del módulo especificado.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>The caller does not have the required permissions.</source>
          <target state="translated">El llamador no tiene los permisos requeridos.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>for access to information in the path.</source>
          <target state="translated">Para obtener acceso a la información de la ruta de acceso.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns custom attributes.</source>
          <target state="translated">Devuelve atributos personalizados</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Se omite este argumento para los objetos de este tipo.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)">
          <source>Returns all custom attributes.</source>
          <target state="translated">Devuelve todos los atributos personalizados.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)">
          <source>An array of type <ph id="ph1">&lt;see langword="Object" /&gt;</ph> containing all custom attributes.</source>
          <target state="translated">Matriz de tipo <ph id="ph1">&lt;see langword="Object" /&gt;</ph> que contiene todos los atributos personalizados.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)">
          <source>The following example displays the module names that match the specified search criteria.</source>
          <target state="translated">El ejemplo siguiente muestra los nombres de módulo que coinciden con los criterios de búsqueda especificados.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type of attribute to get.</source>
          <target state="translated">Tipo de atributo que se va a obtener.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Se omite este argumento para los objetos de este tipo.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Gets custom attributes of the specified type.</source>
          <target state="translated">Obtiene los atributos personalizados del tipo especificado.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of type <ph id="ph1">&lt;see langword="Object" /&gt;</ph> containing all custom attributes of the specified type.</source>
          <target state="translated">Matriz de tipo <ph id="ph1">&lt;see langword="Object" /&gt;</ph> que contiene todos los atributos personalizados del tipo especificado.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The following example displays the module names of the specified type that match the specified search criteria.</source>
          <target state="translated">En el ejemplo siguiente muestra los nombres de módulo del tipo especificado que coinciden con los criterios de búsqueda especificados.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object supplied by the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> no es un objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> proporcionado en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>For example, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Por ejemplo, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> es un objeto <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>Returns a list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects for the current module, which can be used in the reflection-only context.</source>
          <target state="translated">Devuelve una lista de los objetos <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> del módulo actual, que puede utilizarse en el contexto de solo reflexión.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>A generic list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects representing data about the attributes that have been applied to the current module.</source>
          <target state="translated">Lista genérica de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> que representan datos acerca de los atributos que se han aplicado al módulo actual.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</source>
          <target state="translated">Utilice este método para examinar los atributos personalizados del código en el contexto de solo reflexión, en casos donde se definen los atributos personalizados propios en el código que se carga en el contexto de solo reflexión.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>Methods such as <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> cannot be used in such cases, because they create instances of the attributes.</source>
          <target state="translated">Métodos como <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> no se puede usar en casos como éste, porque crean instancias de los atributos.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>Code in the reflection-only context cannot be executed.</source>
          <target state="translated">No se puede ejecutar código en el contexto de solo reflexión.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>For more information and example code, see the <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> class.</source>
          <target state="translated">Para obtener más información y código de ejemplo, vea la <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns a specified field.</source>
          <target state="translated">Devuelve un campo especificado.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String)">
          <source>The field name.</source>
          <target state="translated">Nombre de campo.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String)">
          <source>Returns a field having the specified name.</source>
          <target state="translated">Devuelve un campo con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String)">
          <source>A <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> object having the specified name, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the field does not exist.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> con el nombre especificado, o <ph id="ph2">&lt;see langword="null" /&gt;</ph> si no existe el campo.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The field name.</source>
          <target state="translated">Nombre de campo.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>One of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Uno de los marcadores de bits <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> utilizados para controlar la búsqueda.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns a field having the specified name and binding attributes.</source>
          <target state="translated">Devuelve un campo con el nombre especificado y los atributos de enlace.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> object having the specified name and binding attributes, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the field does not exist.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> con el nombre y los atributos de enlace especificados, o <ph id="ph2">&lt;see langword="null" /&gt;</ph> si no existe el campo.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the global fields defined on the module.</source>
          <target state="translated">Devuelve los campos globales definidos en el módulo.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields">
          <source>Returns the global fields defined on the module.</source>
          <target state="translated">Devuelve los campos globales definidos en el módulo.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing the global fields defined on the module; if there are no global fields, an empty array is returned.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> que representan los campos globales definidos en el módulo; si no hay ningún campo global, se devolverá una matriz vacía.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetFields">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Module.GetFields%2A&gt;</ph> método no devuelve campos en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetFields">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los campos, porque ese orden puede variar.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limit the search.</source>
          <target state="translated">Combinación bit a bit de valores <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que limita la búsqueda.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>Returns the global fields defined on the module that match the specified binding flags.</source>
          <target state="translated">Devuelve los campos globales definidos en el módulo que coinciden con los marcadores de enlace especificados.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> representing the global fields defined on the module that match the specified binding flags; if no global fields match the binding flags, an empty array is returned.</source>
          <target state="translated">Matriz del tipo <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> que representa los campos globales definidos en el módulo que coinciden con los marcadores de enlace especificados; si ningún campo global coincide con los marcadores de enlace, se devolverá una matriz vacía.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Module.GetFields%2A&gt;</ph> método no devuelve campos en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los campos, porque ese orden puede variar.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Devuelve el código hash de esta instancia.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Código hash de un entero de 32 bits con signo.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns a method having the specified criteria.</source>
          <target state="translated">Devuelve un método con los criterios especificados.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String)">
          <source>The method name.</source>
          <target state="translated">Nombre del método.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String)">
          <source>Returns a method having the specified name.</source>
          <target state="translated">Devuelve un método con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String)">
          <source>A <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> object having the specified name, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method does not exist.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> con el nombre especificado, o <ph id="ph2">&lt;see langword="null" /&gt;</ph> si no existe el método.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source>The method name.</source>
          <target state="translated">Nombre del método.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source>The parameter types to search for.</source>
          <target state="translated">Tipos de parámetros que se van a buscar.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source>Returns a method having the specified name and parameter types.</source>
          <target state="translated">Devuelve un método con el nombre especificado y los tipos de parámetro.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source>A <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> object in accordance with the specified criteria, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method does not exist.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> de acuerdo con los criterios especificados o <ph id="ph2">&lt;see langword="null" /&gt;</ph> si no existe el método.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>, or <ph id="ph5">&lt;paramref name="types" /&gt;</ph> (i) is <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> es <ph id="ph4">&lt;see langword="null" /&gt;</ph> o <ph id="ph5">&lt;paramref name="types" /&gt;</ph> (i) es <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The method name.</source>
          <target state="translated">Nombre del método.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Uno de los marcadores de bits <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> utilizados para controlar la búsqueda.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that implements <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, containing properties related to this method.</source>
          <target state="translated">Objeto que implementa <ph id="ph1">&lt;see langword="Binder" /&gt;</ph> y que contiene propiedades relacionadas con este método.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling convention for the method.</source>
          <target state="translated">Convención de llamada para el método.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The parameter types to search for.</source>
          <target state="translated">Tipos de parámetros que se van a buscar.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</source>
          <target state="translated">Matriz de modificadores de parámetros que permite que el enlace funcione con firmas de parámetros en las que se han modificado los tipos.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Returns a method having the specified name, binding information, calling convention, and parameter types and modifiers.</source>
          <target state="translated">Devuelve un método con el nombre especificado, la información de enlace, la convención de llamadas y los tipos de parámetros y modificadores.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> object in accordance with the specified criteria, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method does not exist.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> de acuerdo con los criterios especificados o <ph id="ph2">&lt;see langword="null" /&gt;</ph> si no existe el método.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>, or <ph id="ph5">&lt;paramref name="types" /&gt;</ph> (i) is <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> es <ph id="ph4">&lt;see langword="null" /&gt;</ph> o <ph id="ph5">&lt;paramref name="types" /&gt;</ph> (i) es <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The method name.</source>
          <target state="translated">Nombre del método.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Uno de los marcadores de bits <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> utilizados para controlar la búsqueda.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that implements <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, containing properties related to this method.</source>
          <target state="translated">Objeto que implementa <ph id="ph1">&lt;see langword="Binder" /&gt;</ph> y que contiene propiedades relacionadas con este método.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling convention for the method.</source>
          <target state="translated">Convención de llamada para el método.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The parameter types to search for.</source>
          <target state="translated">Tipos de parámetros que se van a buscar.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</source>
          <target state="translated">Matriz de modificadores de parámetros que permite que el enlace funcione con firmas de parámetros en las que se han modificado los tipos.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Returns the method implementation in accordance with the specified criteria.</source>
          <target state="translated">Devuelve la implementación del método conforme a los criterios especificados.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> object containing implementation information as specified, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method does not exist.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> que contiene la información de implementación especificada, o <ph id="ph2">&lt;see langword="null" /&gt;</ph> si no existe el método.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the global methods defined on the module</source>
          <target state="translated">Devuelve los métodos globales definidos en el módulo</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods">
          <source>Returns the global methods defined on the module.</source>
          <target state="translated">Devuelve los métodos globales definidos en el módulo.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing all the global methods defined on the module; if there are no global methods, an empty array is returned.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> que representan todos los métodos globales definidos en el módulo; si no hay ningún método global, se devolverá una matriz vacía.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limit the search.</source>
          <target state="translated">Combinación bit a bit de valores <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que limita la búsqueda.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns the global methods defined on the module that match the specified binding flags.</source>
          <target state="translated">Devuelve los métodos globales definidos en el módulo que coinciden con los marcadores de enlace especificados.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> representing the global methods defined on the module that match the specified binding flags; if no global methods match the binding flags, an empty array is returned.</source>
          <target state="translated">Matriz del tipo <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> que representa los métodos globales definidos en el módulo que coinciden con los marcadores de enlace especificados; si ningún método global coincide con los marcadores de enlace, se devolverá una matriz vacía.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The information and data needed to serialize or deserialize an object.</source>
          <target state="translated">Información y datos necesarios para serializar o deserializar un objeto.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The context for the serialization.</source>
          <target state="translated">Contexto de la serialización.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Provides an <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> implementation for serialized objects.</source>
          <target state="translated">Proporciona una implementación de <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> para objetos serializados.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>When this method returns, a combination of the <ph id="ph1">&lt;see cref="T:System.Reflection.PortableExecutableKinds" /&gt;</ph> values indicating the nature of the code in the module.</source>
          <target state="translated">El resultado de este método contiene una combinación de los valores <ph id="ph1">&lt;see cref="T:System.Reflection.PortableExecutableKinds" /&gt;</ph> que indican la naturaleza del código en el módulo.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>When this method returns, one of the <ph id="ph1">&lt;see cref="T:System.Reflection.ImageFileMachine" /&gt;</ph> values indicating the platform targeted by the module.</source>
          <target state="translated">El resultado de este método contiene uno de los valores de <ph id="ph1">&lt;see cref="T:System.Reflection.ImageFileMachine" /&gt;</ph> que indican la plataforma destino del módulo.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.</source>
          <target state="translated">Obtiene un par de valores que indican la naturaleza del código en un módulo y la plataforma de destino del módulo.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetSignerCertificate">
          <source>Returns an <ph id="ph1">&lt;see langword="X509Certificate" /&gt;</ph> object corresponding to the certificate included in the Authenticode signature of the assembly which this module belongs to.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see langword="X509Certificate" /&gt;</ph> que corresponde al certificado incluido en la firma Authenticode del ensamblado al que pertenece este módulo.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetSignerCertificate">
          <source>If the assembly has not been Authenticode signed, <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">Si el ensamblado no se ha firmado mediante Authenticode, se devuelve <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetSignerCertificate">
          <source>An <ph id="ph1">&lt;see langword="X509Certificate" /&gt;</ph> object, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the assembly to which this module belongs has not been Authenticode signed.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see langword="X509Certificate" /&gt;</ph>, o <ph id="ph2">&lt;see langword="null" /&gt;</ph> si el ensamblado al que este módulo pertenece no se ha firmado mediante Authenticode.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the specified type.</source>
          <target state="translated">Devuelve el tipo especificado.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The name of the type to locate.</source>
          <target state="translated">Nombre del tipo que se va a localizar.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The name must be fully qualified with the namespace.</source>
          <target state="translated">El nombre debe ser completo y debe estar en consonancia con el espacio de nombres.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>Returns the specified type, performing a case-sensitive search.</source>
          <target state="translated">Devuelve el tipo especificado, realizando una búsqueda en la que se distingue entre mayúsculas y minúsculas.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>A <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object representing the given type, if the type is in this module; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see langword="Type" /&gt;</ph> que representa el tipo determinado, si el tipo está en este módulo; en caso contrario, es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Si el tipo se ha reenviado a otro ensamblado, todavía es devuelto por este método.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Para obtener información sobre el reenvío de tipos, vea <bpt id="p1">[</bpt>reenvío de tipos en Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>A type can be retrieved from a specific module using <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Un tipo se puede recuperar desde un módulo específico mediante <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>Calling <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> on the module that contains the manifest will not search the entire assembly.</source>
          <target state="translated">Al llamar a <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> en el módulo que contiene el manifiesto no buscará en todo el ensamblado.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>To retrieve a type from an assembly, regardless of which module it is in, you must call <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para recuperar un tipo de un ensamblado, independientemente del módulo donde esté, debe llamar a <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The following example displays the name of a type in the specified module.</source>
          <target state="translated">En el ejemplo siguiente se muestra el nombre de un tipo en el módulo especificado.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The class initializers are invoked and an exception is thrown.</source>
          <target state="translated">Se invoca a los inicializadores de clase y se produce una excepción.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> es una cadena de longitud cero.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requiere un ensamblado dependiente que no se pudo encontrar.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requiere un ensamblado dependiente que se encontró, pero no se pudo cargar.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">El ensamblado actual se cargó en el contexto de solo reflexión y <ph id="ph1">&lt;paramref name="className" /&gt;</ph> requiere un ensamblado dependiente que no se haya cargado previamente.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requiere un ensamblado dependiente, pero el archivo no es un ensamblado válido.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requiere un ensamblado dependiente que se haya compilado para una versión del motor en tiempo de ejecución posterior a la versión que se ha cargado en la actualidad.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The name of the type to locate.</source>
          <target state="translated">Nombre del tipo que se va a localizar.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The name must be fully qualified with the namespace.</source>
          <target state="translated">El nombre debe ser completo y debe estar en consonancia con el espacio de nombres.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> for case-insensitive search; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> en el caso de búsqueda sin distinción entre mayúsculas y minúsculas; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>Returns the specified type, searching the module with the specified case sensitivity.</source>
          <target state="translated">Devuelve el tipo especificado, buscando el módulo con la distinción entre mayúsculas y minúsculas especificada.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>A <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object representing the given type, if the type is in this module; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see langword="Type" /&gt;</ph> que representa el tipo determinado, si el tipo está en este módulo; en caso contrario, es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Si el tipo se ha reenviado a otro ensamblado, todavía es devuelto por este método.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Para obtener información sobre el reenvío de tipos, vea <bpt id="p1">[</bpt>reenvío de tipos en Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>A type can be retrieved from a specific module using <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Un tipo se puede recuperar desde un módulo específico mediante <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>Calling <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> on the module that contains the manifest will not search the entire assembly.</source>
          <target state="translated">Al llamar a <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> en el módulo que contiene el manifiesto no buscará en todo el ensamblado.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>To retrieve a type from an assembly, regardless of which module it is in, you must call <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para recuperar un tipo de un ensamblado, independientemente del módulo donde esté, debe llamar a <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The following example displays the name of a type in the specified module, specifying <ph id="ph1">`false`</ph> for the <ph id="ph2">`ignoreCase`</ph> parameter so that case will not be ignored.</source>
          <target state="translated">En el ejemplo siguiente se muestra el nombre de un tipo en el módulo especificado, especificando <ph id="ph1">`false`</ph> para el <ph id="ph2">`ignoreCase`</ph> parámetro para ese caso no se pasará por alto.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The class initializers are invoked and an exception is thrown.</source>
          <target state="translated">Se invoca a los inicializadores de clase y se produce una excepción.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> es una cadena de longitud cero.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requiere un ensamblado dependiente que no se pudo encontrar.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requiere un ensamblado dependiente que se encontró, pero no se pudo cargar.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">El ensamblado actual se cargó en el contexto de solo reflexión y <ph id="ph1">&lt;paramref name="className" /&gt;</ph> requiere un ensamblado dependiente que no se haya cargado previamente.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requiere un ensamblado dependiente, pero el archivo no es un ensamblado válido.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requiere un ensamblado dependiente que se haya compilado para una versión del motor en tiempo de ejecución posterior a la versión que se ha cargado en la actualidad.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name of the type to locate.</source>
          <target state="translated">Nombre del tipo que se va a localizar.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name must be fully qualified with the namespace.</source>
          <target state="translated">El nombre debe ser completo y debe estar en consonancia con el espacio de nombres.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> para producir una excepción si no se puede encontrar el tipo; es <ph id="ph2">&lt;see langword="false" /&gt;</ph> para devolver <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> for case-insensitive search; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> en el caso de búsqueda sin distinción entre mayúsculas y minúsculas; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Returns the specified type, specifying whether to make a case-sensitive search of the module and whether to throw an exception if the type cannot be found.</source>
          <target state="translated">Devuelve el tipo especificado, indicando si se realiza una búsqueda que distinga entre mayúsculas y minúsculas del módulo y si se produce una excepción si no se puede encontrar el tipo.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the specified type, if the type is declared in this module; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el tipo especificado, si el tipo se declara en este módulo; en caso contrario, es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter affects only what happens when the type is not found.</source>
          <target state="translated">El <ph id="ph1">`throwOnError`</ph> parámetro afecta a sólo lo que sucede cuando no se encuentra el tipo.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>It does not affect any other exceptions that might be thrown.</source>
          <target state="translated">No afecta a las otras excepciones que pueden producirse.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In particular, if the type is found but cannot be loaded, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> can be thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">En particular, si se encuentra el tipo pero no se puede cargar, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> puede producir aunque <ph id="ph2">`throwOnError`</ph> es <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Si el tipo se ha reenviado a otro ensamblado, todavía es devuelto por este método.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Para obtener información sobre el reenvío de tipos, vea <bpt id="p1">[</bpt>reenvío de tipos en Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A type can be retrieved from a specific module using <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Un tipo se puede recuperar desde un módulo específico mediante <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Calling <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> on the module that contains the manifest will not search the entire assembly.</source>
          <target state="translated">Al llamar a <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> en el módulo que contiene el manifiesto no buscará en todo el ensamblado.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To retrieve a type from an assembly, regardless of which module it is in, you must call <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para recuperar un tipo de un ensamblado, independientemente del módulo donde esté, debe llamar a <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The following example displays the name of a type in the specified module.</source>
          <target state="translated">En el ejemplo siguiente se muestra el nombre de un tipo en el módulo especificado.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> and <ph id="ph2">`ignoreCase`</ph> parameters are specified as <ph id="ph3">`false`</ph>.</source>
          <target state="translated">El <ph id="ph1">`throwOnError`</ph> y <ph id="ph2">`ignoreCase`</ph> parámetros se especifican como <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The class initializers are invoked and an exception is thrown.</source>
          <target state="translated">Se invoca a los inicializadores de clase y se produce una excepción.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> es una cadena de longitud cero.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, and the type cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y no se puede encontrar el tipo.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requiere un ensamblado dependiente que no se pudo encontrar.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requiere un ensamblado dependiente que se encontró, pero no se pudo cargar.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">El ensamblado actual se cargó en el contexto de solo reflexión y <ph id="ph1">&lt;paramref name="className" /&gt;</ph> requiere un ensamblado dependiente que no se haya cargado previamente.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requiere un ensamblado dependiente, pero el archivo no es un ensamblado válido.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requiere un ensamblado dependiente que se haya compilado para una versión del motor en tiempo de ejecución posterior a la versión que se ha cargado en la actualidad.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetTypes">
          <source>Returns all the types defined within this module.</source>
          <target state="translated">Devuelve todos los tipos definidos en este módulo.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetTypes">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing types defined within the module that is reflected by this instance.</source>
          <target state="translated">Matriz de tipo <ph id="ph1">&lt;see langword="Type" /&gt;</ph> que contiene los tipos definidos en el módulo reflejado por esta instancia.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source><ph id="ph1">`ReflectionTypeLoadException`</ph> is a special load exception.</source>
          <target state="translated"><ph id="ph1">`ReflectionTypeLoadException`</ph> es una excepción de carga especial.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> property contains the array of types that were defined in the module and were loaded.</source>
          <target state="translated">El <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> propiedad contiene la matriz de tipos que se definieron en el módulo y cargadas.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>This array may contain some null values.</source>
          <target state="translated">Esta matriz puede contener valores null.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> property is an array of exceptions that represent the exceptions that were thrown by the loader.</source>
          <target state="translated">El <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> propiedad es una matriz de excepciones que representan las excepciones producidas por el cargador.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>The holes in the class array line up with the exceptions.</source>
          <target state="translated">Los agujeros en la matriz de clase se alineen con las excepciones.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>For example, if the class initializers of one of the classes throws an exception while it is being loaded, a <ph id="ph1">`TargetInvocationException`</ph> is stored in the corresponding element of the <ph id="ph2">`LoaderExceptions`</ph> array.</source>
          <target state="translated">Por ejemplo, si los inicializadores de clase de una de las clases produce una excepción mientras se está cargando, un <ph id="ph1">`TargetInvocationException`</ph> se almacena en el elemento correspondiente de la <ph id="ph2">`LoaderExceptions`</ph> matriz.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>If a type has been forwarded to another assembly, it is not included in the returned array.</source>
          <target state="translated">Si un tipo se ha reenviado a otro ensamblado, no se incluye en la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Para obtener información sobre el reenvío de tipos, vea <bpt id="p1">[</bpt>reenvío de tipos en Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetTypes">
          <source>One or more classes in a module could not be loaded.</source>
          <target state="translated">No se han podido cargar una o varias clases en un módulo.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetTypes">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>Reflection permission for the current module.</source>
          <target state="translated">Permiso de reflexión del módulo actual.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>The type of custom attribute to test for.</source>
          <target state="translated">Tipo de atributo personalizado que se va a probar.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Se omite este argumento para los objetos de este tipo.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>Returns a value that indicates whether the specified attribute type has been applied to this module.</source>
          <target state="translated">Devuelve un valor que indica si el tipo de atributo especificado se ha aplicado a este módulo.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if one or more instances of <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> have been applied to this module; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se han aplicado una o varias instancias de <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> a este módulo; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsDefined`</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra un uso de la <ph id="ph1">`IsDefined`</ph> método.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object supplied by the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> no es un objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> proporcionado en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>For example, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Por ejemplo, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> es un objeto <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsResource">
          <source>Gets a value indicating whether the object is a resource.</source>
          <target state="translated">Obtiene un valor que indica si el objeto es un recurso.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsResource">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the object is a resource; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto es un recurso; de lo contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.IsResource">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsResource`</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra un uso de la <ph id="ph1">`IsResource`</ph> método.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>Gets the metadata stream version.</source>
          <target state="translated">Obtiene la versión del flujo de metadatos.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>A 32-bit integer representing the metadata stream version.</source>
          <target state="translated">Entero de 32 bits que representa la versión del flujo de metadatos.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>The high-order two bytes represent the major version number, and the low-order two bytes represent the minor version number.</source>
          <target state="translated">Los dos bytes de orden superior representan el número de versión principal, mientras que los dos bytes de orden inferior representan el número de versión secundaria.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>For more information on the metadata header, see "Partition II: Metadata Definition and Semantics" in the Common Language Infrastructure (CLI) documentation.</source>
          <target state="translated">Para obtener más información sobre el encabezado de metadatos, vea "Partición II: definición y semántica de los metadatos" en la documentación de Common Language Infrastructure (CLI).</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# y Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> en MSDN y <bpt id="p2">[</bpt>estándar ECMA-335: Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> en el sitio Web de ECMA.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.MetadataToken">
          <source>Gets a token that identifies the module in metadata.</source>
          <target state="translated">Obtiene un token que identifica el módulo en los metadatos.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>An integer token that identifies the current module in metadata.</source>
          <target state="translated">Token entero que identifica el módulo actual en los metadatos.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>The tokens obtained using this property can be passed to the unmanaged Reflection API.</source>
          <target state="translated">Los tokens obtenidos mediante esta propiedad se pueden pasar a la API de reflexión no administrada.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>For more information, see <bpt id="p1">[</bpt>Unmanaged Reflection API<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>API de reflexión no administrada<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# y Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> en MSDN y <bpt id="p2">[</bpt>estándar ECMA-335: Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> en el sitio Web de ECMA.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.ModuleHandle">
          <source>Gets a handle for the module.</source>
          <target state="translated">Obtiene un identificador para el módulo.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleHandle">
          <source>A <ph id="ph1">&lt;see cref="T:System.ModuleHandle" /&gt;</ph> structure for the current module.</source>
          <target state="translated">Estructura <ph id="ph1">&lt;see cref="T:System.ModuleHandle" /&gt;</ph> del módulo actual.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</source>
          <target state="translated">Obtiene un identificador único universal (UUID) que se puede utilizar para distinguir entre dos versiones de un módulo.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>A <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> that can be used to distinguish between two versions of a module.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> que se puede utilizar para distinguir entre dos versiones de un módulo.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>In unmanaged metadata, the GUID returned by the <ph id="ph1">&lt;xref:System.Reflection.Module.ModuleVersionId%2A&gt;</ph> property is referred to as the <ph id="ph2">`mvid`</ph>, and is stored in the GUID heap.</source>
          <target state="translated">En los metadatos no administrado, el GUID devuelto por la <ph id="ph1">&lt;xref:System.Reflection.Module.ModuleVersionId%2A&gt;</ph> propiedad se conoce como el <ph id="ph2">`mvid`</ph>y se almacena en el montón GUID.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>More information about metadata can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Para obtener más información acerca de los metadatos se puede encontrar en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# y Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> en MSDN y <bpt id="p2">[</bpt>estándar ECMA-335: Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> en el sitio Web de ECMA.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.Name">
          <source>Gets a <ph id="ph1">&lt;see langword="String" /&gt;</ph> representing the name of the module with the path removed.</source>
          <target state="translated">Obtiene una cadena, <ph id="ph1">&lt;see langword="String" /&gt;</ph>, que representa al nombre del módulo sin la ruta de acceso.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source>The module name with no path.</source>
          <target state="translated">Nombre del módulo sin la ruta.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source><ph id="ph1">`Name`</ph> is a platform-dependent string.</source>
          <target state="translated"><ph id="ph1">`Name`</ph> es una cadena depende de la plataforma.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source>If the assembly for this module was loaded from a byte array then the <ph id="ph1">`FullyQualifiedName`</ph> for the module will be: <ph id="ph2">\&lt;</ph>Unknown&gt;.</source>
          <target state="translated">Si el ensamblado de este módulo se cargó desde una matriz de bytes, a continuación, el <ph id="ph1">`FullyQualifiedName`</ph> para el módulo serán: <ph id="ph2">\&lt;</ph>desconocido &gt;.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source>To get the name and the path, use <ph id="ph1">&lt;xref:System.Reflection.Module.FullyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">Para obtener el nombre y la ruta de acceso, use <ph id="ph1">&lt;xref:System.Reflection.Module.FullyQualifiedName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source>This example shows the effect of the <ph id="ph1">`ScopeName`</ph>, <ph id="ph2">`FullyQualifiedName`</ph>, and <ph id="ph3">`Name`</ph> properties.</source>
          <target state="translated">Este ejemplo muestra el efecto de la <ph id="ph1">`ScopeName`</ph>, <ph id="ph2">`FullyQualifiedName`</ph>, y <ph id="ph3">`Name`</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)">
          <source>The first object to compare.</source>
          <target state="translated">Primer objeto que se va a comparar.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)">
          <source>The second object to compare.</source>
          <target state="translated">Segundo objeto que se va a comparar.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> objects are equal.</source>
          <target state="translated">Indica si dos objetos <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> son iguales.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="left" /&gt;</ph> es igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; en caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)">
          <source>The first object to compare.</source>
          <target state="translated">Primer objeto que se va a comparar.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)">
          <source>The second object to compare.</source>
          <target state="translated">Segundo objeto que se va a comparar.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Indica si dos objetos <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> no son iguales.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="left" /&gt;</ph> no es igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; en caso contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the field identified by a metadata token.</source>
          <target state="translated">Devuelve el campo identificado por un token de metadatos.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>A metadata token that identifies a field in the module.</source>
          <target state="translated">Token de metadatos que identifica un campo del módulo.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>Returns the field identified by the specified metadata token.</source>
          <target state="translated">Devuelve el campo identificado por el token de metadatos especificado.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field that is identified by the specified metadata token.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> que representa el campo identificado por el token de metadatos especificado.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>To resolve a metadata token that identifies a field whose parent <ph id="ph1">`TypeSpec`</ph> has a signature containing element type <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> or <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use the <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, which allows you to supply the necessary context.</source>
          <target state="translated">Para resolver un símbolo (token) de metadatos que identifica un campo cuyo elemento primario <ph id="ph1">`TypeSpec`</ph> tiene una firma que contiene el tipo de elemento <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> o <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use el <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> sobrecarga del método, que permite proporcionar el contexto necesario.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>That is, when you are resolving a metadata token for a field that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</source>
          <target state="translated">Es decir, cuando se resuelve un token de metadatos para un campo que depende de los parámetros de tipo genérico del tipo genérico y/o del método genérico en el que está incrustado el token, debe usar la sobrecarga que le permite proporcionar los parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# y Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> en MSDN y <bpt id="p2">[</bpt>estándar ECMA-335: Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> en el sitio Web de ECMA.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Para el código que muestra cómo resolver tokens mediante el contexto genérico (es decir, los parámetros de tipo genérico del tipo genérico y/o del método genérico en el que está incrustado el token) consulte el <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a field in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token válido para un campo en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a field whose parent <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> has a signature containing element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifica un campo cuyo <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> primario tiene una firma que contiene el tipo de elemento <ph id="ph3">&lt;see langword="var" /&gt;</ph> (un parámetro de tipo de un tipo genérico) o <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (un parámetro de tipo de un método genérico).</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token válido en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a field in the module.</source>
          <target state="translated">Token de metadatos que identifica un campo del módulo.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan los argumentos de tipo genérico del tipo en cuyo ámbito se encuentra el token; o es <ph id="ph2">&lt;see langword="null" /&gt;</ph> si dicho tipo no es genérico.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan los argumentos de tipo genérico del método en cuyo ámbito se encuentra el token; o es <ph id="ph2">&lt;see langword="null" /&gt;</ph> si dicho método no es genérico.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Devuelve el campo identificado por el token de metadatos especificado, en el contexto definido por los parámetros de tipo genérico especificados.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field that is identified by the specified metadata token.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> que representa el campo identificado por el token de metadatos especificado.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método en el tipo donde <ph id="ph2">`metadataToken`</ph> está en el ámbito para obtener una matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método en el método donde <ph id="ph2">`metadataToken`</ph> está en el ámbito para obtener una matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Siempre es seguro proporcionar estos argumentos, incluso cuando no se necesitan.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# y Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> en MSDN y <bpt id="p2">[</bpt>estándar ECMA-335: Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> en el sitio Web de ECMA.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Para el código que muestra cómo resolver tokens mediante el contexto genérico (es decir, los parámetros de tipo genérico del tipo genérico y/o del método genérico en el que está incrustado el token) consulte el <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a field in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token válido para un campo en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a field whose parent <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> has a signature containing element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifica un campo cuyo <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> primario tiene una firma que contiene el tipo de elemento <ph id="ph3">&lt;see langword="var" /&gt;</ph> (un parámetro de tipo de un tipo genérico) o <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (un parámetro de tipo de un método genérico) y no se proporcionaron los argumentos de tipo genérico necesarios para uno o ambos parámetros <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> y <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token válido en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the type or member identified by a metadata token.</source>
          <target state="translated">Devuelve el tipo o integrante identificado por un token de metadatos.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>A metadata token that identifies a type or member in the module.</source>
          <target state="translated">Token de metadatos que identifica un tipo o integrante del módulo.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>Returns the type or member identified by the specified metadata token.</source>
          <target state="translated">Devuelve el tipo o integrante identificado por el token de metadatos especificado.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> object representing the type or member that is identified by the specified metadata token.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que representa el tipo o integrante identificado por el token de metadatos especificado.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>To resolve a metadata token for a <ph id="ph1">`MethodSpec`</ph> or <ph id="ph2">`TypeSpec`</ph> whose signature contains element type <ph id="ph3">`ELEMENT_TYPE_VAR`</ph> or <ph id="ph4">`ELEMENT_TYPE_MVAR`</ph>, use the <ph id="ph5">&lt;xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, which allows you to supply the necessary context.</source>
          <target state="translated">Para resolver un símbolo (token) de metadatos para un <ph id="ph1">`MethodSpec`</ph> o <ph id="ph2">`TypeSpec`</ph> cuya firma contiene el tipo de elemento <ph id="ph3">`ELEMENT_TYPE_VAR`</ph> o <ph id="ph4">`ELEMENT_TYPE_MVAR`</ph>, use el <ph id="ph5">&lt;xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> sobrecarga del método, que permite proporcionar el contexto necesario.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>That is, when you are resolving a metadata token for a member that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</source>
          <target state="translated">Es decir, cuando se resuelve un token de metadatos para un miembro que depende de los parámetros de tipo genérico del tipo genérico y/o del método genérico en el que está incrustado el token, debe usar la sobrecarga que le permite proporcionar los parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# y Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> en MSDN y <bpt id="p2">[</bpt>estándar ECMA-335: Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> en el sitio Web de ECMA.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Para el código que muestra cómo resolver tokens mediante el contexto genérico (es decir, los parámetros de tipo genérico del tipo genérico y/o del método genérico en el que está incrustado el token) consulte el <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type or member in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token para un tipo o integrante en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> or <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph4">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> es un <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> o <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> cuya firma contiene el tipo de elemento <ph id="ph4">&lt;see langword="var" /&gt;</ph> (un parámetro de tipo de un tipo genérico) o <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (un parámetro de tipo de un método genérico).</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a property or event.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifica una propiedad o evento.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token válido en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a type or member in the module.</source>
          <target state="translated">Token de metadatos que identifica un tipo o integrante del módulo.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan los argumentos de tipo genérico del tipo en cuyo ámbito se encuentra el token; o es <ph id="ph2">&lt;see langword="null" /&gt;</ph> si dicho tipo no es genérico.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan los argumentos de tipo genérico del método en cuyo ámbito se encuentra el token; o es <ph id="ph2">&lt;see langword="null" /&gt;</ph> si dicho método no es genérico.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Devuelve el tipo o miembro identificado por el token de metadatos especificado, en el contexto definido por los parámetros de tipo genérico especificados.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> object representing the type or member that is identified by the specified metadata token.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que representa el tipo o integrante identificado por el token de metadatos especificado.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método en el tipo donde <ph id="ph2">`metadataToken`</ph> está en el ámbito para obtener una matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método en el método donde <ph id="ph2">`metadataToken`</ph> está en el ámbito para obtener una matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Siempre es seguro proporcionar estos argumentos, incluso cuando no se necesitan.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# y Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> en MSDN y <bpt id="p2">[</bpt>estándar ECMA-335: Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> en el sitio Web de ECMA.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Para el código que muestra cómo resolver tokens mediante el contexto genérico (es decir, los parámetros de tipo genérico del tipo genérico y/o del método genérico en el que está incrustado el token) consulte el <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type or member in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token para un tipo o integrante en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> or <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph4">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph6">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph7">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> es un <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> o <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> cuya firma contiene el tipo de elemento <ph id="ph4">&lt;see langword="var" /&gt;</ph> (un parámetro de tipo de un tipo genérico) o <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (un parámetro de tipo de un método genérico) y no se proporcionaron los argumentos de tipo genérico necesarios para uno o ambos parámetros <ph id="ph6">&lt;paramref name="genericTypeArguments" /&gt;</ph> y <ph id="ph7">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a property or event.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifica una propiedad o evento.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token válido en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the method identified by a metadata token.</source>
          <target state="translated">Devuelve el método identificado por un token de metadatos.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>A metadata token that identifies a method or constructor in the module.</source>
          <target state="translated">Token de metadatos que identifica un método o constructor en el módulo.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Returns the method or constructor identified by the specified metadata token.</source>
          <target state="translated">Devuelve el método o constructor identificado por el token de metadatos especificado.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object representing the method or constructor that is identified by the specified metadata token.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> que representa el método o constructor identificado por el token de metadatos especificado.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>To resolve a metadata token for a <ph id="ph1">`MethodSpec`</ph> whose signature contains element type <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> or <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use the <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, which allows you to supply the necessary context.</source>
          <target state="translated">Para resolver un símbolo (token) de metadatos para un <ph id="ph1">`MethodSpec`</ph> cuya firma contiene el tipo de elemento <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> o <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use el <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> sobrecarga del método, que permite proporcionar el contexto necesario.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>That is, when you are resolving a metadata token for a method that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</source>
          <target state="translated">Es decir, cuando se resuelve un token de metadatos para un método que depende de los parámetros de tipo genérico del tipo genérico o el método genérico en el que está incrustado el token, debe usar la sobrecarga que le permite proporcionar los parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# y Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> en MSDN y <bpt id="p2">[</bpt>estándar ECMA-335: Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> en el sitio Web de ECMA.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The following example shows how to use the two overloads of the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%2A&gt;</ph> method to resolve metadata tokens from call sites in generic and non-generic contexts.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo usar las dos sobrecargas de la <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%2A&gt;</ph> sitios de método para resolver los tokens de metadatos de la llamada en contextos genéricos y no genéricos.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The code example defines two generic types, <ph id="ph1">`G1&lt;Tg1&gt;`</ph> and <ph id="ph2">`G2&lt;Tg2&gt;`</ph> (<ph id="ph3">`G1(Of Tg1)`</ph> and <ph id="ph4">`G2(Of Tg2)`</ph> in Visual Basic), each of which has a generic method.</source>
          <target state="translated">El ejemplo de código define dos tipos genéricos, <ph id="ph1">`G1&lt;Tg1&gt;`</ph> y <ph id="ph2">`G2&lt;Tg2&gt;`</ph> (<ph id="ph3">`G1(Of Tg1)`</ph> y <ph id="ph4">`G2(Of Tg2)`</ph> en Visual Basic), cada uno de los cuales tiene un método genérico.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source><ph id="ph1">`G1&lt;Tg1&gt;`</ph> also has a non-generic method that uses the type parameter <ph id="ph2">`Tg1`</ph> for its parameter.</source>
          <target state="translated"><ph id="ph1">`G1&lt;Tg1&gt;`</ph> También tiene un método no genérico que usa el parámetro de tipo <ph id="ph2">`Tg1`</ph> para su parámetro.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The generic method <ph id="ph1">`GM2&lt;Tgm2&gt;`</ph> in type <ph id="ph2">`G2&lt;Tg2&gt;`</ph> contains several method calls:</source>
          <target state="translated">El método genérico <ph id="ph1">`GM2&lt;Tgm2&gt;`</ph> en tipo <ph id="ph2">`G2&lt;Tg2&gt;`</ph> contiene varias llamadas a métodos:</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 1: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, using the type parameters of <ph id="ph2">`G2&lt;Tg2&gt;`</ph> and <ph id="ph3">`GM2&lt;Tgm2&gt;`</ph> as the type arguments.</source>
          <target state="translated">Caso 1: El método genérico <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> se llama con los parámetros de tipo de <ph id="ph2">`G2&lt;Tg2&gt;`</ph> y <ph id="ph3">`GM2&lt;Tgm2&gt;`</ph> como los argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for <ph id="ph1">`G2&lt;Tg2&gt;`</ph>.</source>
          <target state="translated">En otras palabras, los tipos de parámetros del método llamado dependerá de los tipos que se usan para construir un tipo genérico de la definición de tipo para <ph id="ph1">`G2&lt;Tg2&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 2: The non-generic method <ph id="ph1">`M1`</ph> is called.</source>
          <target state="translated">Caso 2: El método no genérico <ph id="ph1">`M1`</ph> se llama.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The parameter of this method uses the type parameter of the defining type, <ph id="ph1">`G1&lt;Tg1&gt;`</ph>, which is replaced in this case by the type parameter of the enclosing type, <ph id="ph2">`G2&lt;Tg2&gt;`</ph>.</source>
          <target state="translated">El parámetro de este método utiliza el parámetro de tipo del tipo de definición, <ph id="ph1">`G1&lt;Tg1&gt;`</ph>, que será sustituido por el parámetro de tipo del tipo envolvente, en este caso <ph id="ph2">`G2&lt;Tg2&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 3: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, specifying <ph id="ph2">&lt;xref:System.Int32&gt;</ph> and <ph id="ph3">&lt;xref:System.Object&gt;</ph> for the type arguments of the generic type and the generic method, respectively.</source>
          <target state="translated">Caso 3: El método genérico <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> se llama, especificar <ph id="ph2">&lt;xref:System.Int32&gt;</ph> y <ph id="ph3">&lt;xref:System.Object&gt;</ph> para los argumentos de tipo del tipo genérico y el método genérico, respectivamente.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This method call does not depend on the type parameters of the enclosing type or method.</source>
          <target state="translated">Esta llamada al método no depende de los parámetros de tipo del tipo o método envolvente.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 4: The non-generic method <ph id="ph1">`M1`</ph> of the <ph id="ph2">`Example`</ph> class is called.</source>
          <target state="translated">Caso 4: El método no genérico <ph id="ph1">`M1`</ph> de la <ph id="ph2">`Example`</ph> clase se denomina.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This method call does not depend on the type parameters of the enclosing type or method.</source>
          <target state="translated">Esta llamada al método no depende de los parámetros de tipo del tipo o método envolvente.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>In addition, the example defines the non-generic <ph id="ph1">`Example`</ph> class.</source>
          <target state="translated">Además, el ejemplo define no genérica <ph id="ph1">`Example`</ph> clase.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This class has a method <ph id="ph1">`M`</ph> that makes a call to a generic method:</source>
          <target state="translated">Esta clase tiene un método <ph id="ph1">`M`</ph> que realiza una llamada a un método genérico:</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 5: The generic method <ph id="ph1">`GM1`</ph> is called, specifying <ph id="ph2">&lt;xref:System.Int32&gt;</ph> and <ph id="ph3">&lt;xref:System.Object&gt;</ph> for the type arguments of the generic type and the generic method, respectively.</source>
          <target state="translated">Caso 5: El método genérico <ph id="ph1">`GM1`</ph> se llama, especificar <ph id="ph2">&lt;xref:System.Int32&gt;</ph> y <ph id="ph3">&lt;xref:System.Object&gt;</ph> para los argumentos de tipo del tipo genérico y el método genérico, respectivamente.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The context for this method has no enclosing generic type or generic method.</source>
          <target state="translated">El contexto de este método no tiene ningún envolvente tipo genérico o método genérico.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>For each case, the example first constructs a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents the called method, and then resolves the token using the <ph id="ph2">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, using the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> methods to get the values for the <ph id="ph5">`genericTypeArguments`</ph> and <ph id="ph6">`genericMethodArguments`</ph> parameters.</source>
          <target state="translated">Para cada caso, el ejemplo crea primero un <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> que representa el método llamado y, a continuación, resuelve el token mediante la <ph id="ph2">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> sobrecarga del método, con el <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> métodos para obtener los valores para el <ph id="ph5">`genericTypeArguments`</ph> y <ph id="ph6">`genericMethodArguments`</ph> parámetros.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This technique works in all cases, because the methods return <ph id="ph1">&lt;xref:System.Type.EmptyTypes?displayProperty=nameWithType&gt;</ph> for non-generic contexts.</source>
          <target state="translated">Esta técnica funciona en todos los casos, porque los métodos devuelven <ph id="ph1">&lt;xref:System.Type.EmptyTypes?displayProperty=nameWithType&gt;</ph> para contextos no genérica.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The example compares the resolved <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the constructed <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">En el ejemplo se compara el resuelto <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> con creado <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The example then attempts to use the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%29&gt;</ph> method overload to resolve the token.</source>
          <target state="translated">En el ejemplo, a continuación, intenta utilizar el <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%29&gt;</ph> sobrecarga del método para resolver el token.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</source>
          <target state="translated">Esto funciona en los casos 3, 4 y 5, porque las llamadas al método no dependen del contexto genérico.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</source>
          <target state="translated">En los casos 1 y 2, se produce una excepción porque no hay suficiente información para resolver el token.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The metadata token values are hard-coded as an enumeration.</source>
          <target state="translated">Los valores de símbolo (token) de metadatos están codificados de forma rígida como una enumeración.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>If you change this code example, the token values are likely to change.</source>
          <target state="translated">Si cambia este ejemplo de código, los valores de token están probables que cambie.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>To determine the new token values, compile the code and use Ildasm.exe with the <bpt id="p1">**</bpt>/TOKENS<ept id="p1">**</ept> option to examine the assembly.</source>
          <target state="translated">Para determinar los nuevos valores de token, compile el código y use Ildasm.exe con la <bpt id="p1">**</bpt>/TOKENS<ept id="p1">**</ept> opción para examinar el ensamblado.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The tokens can be found at the points of call.</source>
          <target state="translated">Los tokens se pueden encontrar en los puntos de llamada.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Insert the new values into the enumeration, and recompile the example.</source>
          <target state="translated">Inserte los nuevos valores en la enumeración, y vuelva a compilar el ejemplo.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a method or constructor in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token para un método o constructor en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> es un <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> cuya firma contiene el tipo de elemento <ph id="ph3">&lt;see langword="var" /&gt;</ph> (un parámetro de tipo de un tipo genérico) o <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (un parámetro de tipo de un método genérico).</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token válido en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a method or constructor in the module.</source>
          <target state="translated">Token de metadatos que identifica un método o constructor en el módulo.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan los argumentos de tipo genérico del tipo en cuyo ámbito se encuentra el token; o es <ph id="ph2">&lt;see langword="null" /&gt;</ph> si dicho tipo no es genérico.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan los argumentos de tipo genérico del método en cuyo ámbito se encuentra el token; o es <ph id="ph2">&lt;see langword="null" /&gt;</ph> si dicho método no es genérico.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Devuelve el método o constructor identificado por el token de metadatos especificado, en el contexto definido por los parámetros de tipo genérico especificados.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object representing the method that is identified by the specified metadata token.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> que representa el método identificado por el token de metadatos especificado.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método en el tipo donde <ph id="ph2">`metadataToken`</ph> está en el ámbito para obtener una matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericMethodArguments`</ph>.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método en el método donde <ph id="ph2">`metadataToken`</ph> está en el ámbito para obtener una matriz de argumentos de tipo genérico para <ph id="ph3">`genericMethodArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Siempre es seguro proporcionar estos argumentos, incluso cuando no se necesitan.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# y Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> en MSDN y <bpt id="p2">[</bpt>estándar ECMA-335: Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> en el sitio Web de ECMA.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The following example shows how to use the two overloads of the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%2A&gt;</ph> method to resolve metadata tokens from call sites in generic and non-generic contexts.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo usar las dos sobrecargas de la <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%2A&gt;</ph> sitios de método para resolver los tokens de metadatos de la llamada en contextos genéricos y no genéricos.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The code example defines two generic types, <ph id="ph1">`G1&lt;Tg1&gt;`</ph> and <ph id="ph2">`G2&lt;Tg2&gt;`</ph>, each of which has a generic method.</source>
          <target state="translated">El ejemplo de código define dos tipos genéricos, <ph id="ph1">`G1&lt;Tg1&gt;`</ph> y <ph id="ph2">`G2&lt;Tg2&gt;`</ph>, cada uno de los cuales tiene un método genérico.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">`G1&lt;Tg1&gt;`</ph> also has a non-generic method that uses the type parameter <ph id="ph2">`Tg1`</ph> for its parameter.</source>
          <target state="translated"><ph id="ph1">`G1&lt;Tg1&gt;`</ph> También tiene un método no genérico que usa el parámetro de tipo <ph id="ph2">`Tg1`</ph> para su parámetro.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The generic method <ph id="ph1">`GM2&lt;Tgm2&gt;`</ph> in type <ph id="ph2">`G2&lt;Tg2&gt;`</ph> contains several method calls:</source>
          <target state="translated">El método genérico <ph id="ph1">`GM2&lt;Tgm2&gt;`</ph> en tipo <ph id="ph2">`G2&lt;Tg2&gt;`</ph> contiene varias llamadas a métodos:</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 1: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, using the type parameters of <ph id="ph2">`G2&lt;Tg2&gt;`</ph> and <ph id="ph3">`GM2&lt;Tgm2&gt;`</ph> as the type arguments.</source>
          <target state="translated">Caso 1: El método genérico <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> se llama con los parámetros de tipo de <ph id="ph2">`G2&lt;Tg2&gt;`</ph> y <ph id="ph3">`GM2&lt;Tgm2&gt;`</ph> como los argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for <ph id="ph1">`G2&lt;Tg2&gt;`</ph>.</source>
          <target state="translated">En otras palabras, los tipos de parámetros del método llamado dependerá de los tipos que se usan para construir un tipo genérico de la definición de tipo para <ph id="ph1">`G2&lt;Tg2&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 2: The non-generic method <ph id="ph1">`M1`</ph> is called.</source>
          <target state="translated">Caso 2: El método no genérico <ph id="ph1">`M1`</ph> se llama.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The parameter of this method uses the type parameter of the defining type, <ph id="ph1">`G1&lt;Tg1&gt;`</ph>, which is replaced in this case by the type parameter of the enclosing type, <ph id="ph2">`G2&lt;Tg2&gt;`</ph>.</source>
          <target state="translated">El parámetro de este método utiliza el parámetro de tipo del tipo de definición, <ph id="ph1">`G1&lt;Tg1&gt;`</ph>, que será sustituido por el parámetro de tipo del tipo envolvente, en este caso <ph id="ph2">`G2&lt;Tg2&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 3: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, specifying <ph id="ph2">&lt;xref:System.Int32&gt;</ph> and <ph id="ph3">&lt;xref:System.Object&gt;</ph> for the type arguments of the generic type and the generic method, respectively.</source>
          <target state="translated">Caso 3: El método genérico <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> se llama, especificar <ph id="ph2">&lt;xref:System.Int32&gt;</ph> y <ph id="ph3">&lt;xref:System.Object&gt;</ph> para los argumentos de tipo del tipo genérico y el método genérico, respectivamente.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This method call does not depend on the type parameters of the enclosing type or method.</source>
          <target state="translated">Esta llamada al método no depende de los parámetros de tipo del tipo o método envolvente.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 4: The non-generic method <ph id="ph1">`M1`</ph> of the <ph id="ph2">`Example`</ph> class is called.</source>
          <target state="translated">Caso 4: El método no genérico <ph id="ph1">`M1`</ph> de la <ph id="ph2">`Example`</ph> clase se denomina.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This method call does not depend on the type parameters of the enclosing type or method.</source>
          <target state="translated">Esta llamada al método no depende de los parámetros de tipo del tipo o método envolvente.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>In addition, the example defines the non-generic <ph id="ph1">`Example`</ph> class.</source>
          <target state="translated">Además, el ejemplo define no genérica <ph id="ph1">`Example`</ph> clase.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This class has a method <ph id="ph1">`M`</ph> that makes a call to a generic method.</source>
          <target state="translated">Esta clase tiene un método <ph id="ph1">`M`</ph> que realiza una llamada a un método genérico.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 5: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, specifying <ph id="ph2">&lt;xref:System.Int32&gt;</ph> and <ph id="ph3">&lt;xref:System.Object&gt;</ph> for the type arguments of the generic type and the generic method, respectively.</source>
          <target state="translated">Caso 5: El método genérico <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> se llama, especificar <ph id="ph2">&lt;xref:System.Int32&gt;</ph> y <ph id="ph3">&lt;xref:System.Object&gt;</ph> para los argumentos de tipo del tipo genérico y el método genérico, respectivamente.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The context for this method has no enclosing generic type or generic method.</source>
          <target state="translated">El contexto de este método no tiene ningún envolvente tipo genérico o método genérico.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>For each case, the example first constructs a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents the called method, and then resolves the token using the <ph id="ph2">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, using the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> methods to get the values for the <ph id="ph5">`genericTypeArguments`</ph> and <ph id="ph6">`genericMethodArguments`</ph> parameters.</source>
          <target state="translated">Para cada caso, el ejemplo crea primero un <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> que representa el método llamado y, a continuación, resuelve el token mediante la <ph id="ph2">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> sobrecarga del método, con el <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> métodos para obtener los valores para el <ph id="ph5">`genericTypeArguments`</ph> y <ph id="ph6">`genericMethodArguments`</ph> parámetros.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This technique works in all cases, because the methods return <ph id="ph1">&lt;xref:System.Type.EmptyTypes?displayProperty=nameWithType&gt;</ph> for non-generic contexts.</source>
          <target state="translated">Esta técnica funciona en todos los casos, porque los métodos devuelven <ph id="ph1">&lt;xref:System.Type.EmptyTypes?displayProperty=nameWithType&gt;</ph> para contextos no genérica.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The example compares the resolved <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the constructed <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">En el ejemplo se compara el resuelto <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> con creado <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The example then attempts to use the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%29&gt;</ph> method overload to resolve the token.</source>
          <target state="translated">En el ejemplo, a continuación, intenta utilizar el <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%29&gt;</ph> sobrecarga del método para resolver el token.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</source>
          <target state="translated">Esto funciona en los casos 3, 4 y 5, porque las llamadas al método no dependen del contexto genérico.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</source>
          <target state="translated">En los casos 1 y 2, se produce una excepción porque no hay suficiente información para resolver el token.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The metadata token values are hard-coded as an enumeration.</source>
          <target state="translated">Los valores de símbolo (token) de metadatos están codificados de forma rígida como una enumeración.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>If you change this code example, the token values are likely to change.</source>
          <target state="translated">Si cambia este ejemplo de código, los valores de token están probables que cambie.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>To determine the new token values, compile the code and use Ildasm.exe with the <bpt id="p1">**</bpt>/TOKENS<ept id="p1">**</ept> option to examine the assembly.</source>
          <target state="translated">Para determinar los nuevos valores de token, compile el código y use Ildasm.exe con la <bpt id="p1">**</bpt>/TOKENS<ept id="p1">**</ept> opción para examinar el ensamblado.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The tokens can be found at the points of call.</source>
          <target state="translated">Los tokens se pueden encontrar en los puntos de llamada.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Insert the new values into the enumeration, and recompile the example.</source>
          <target state="translated">Inserte los nuevos valores en la enumeración, y vuelva a compilar el ejemplo.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a method or constructor in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token para un método o constructor en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> es un <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> cuya firma contiene el tipo de elemento <ph id="ph3">&lt;see langword="var" /&gt;</ph> (un parámetro de tipo de un tipo genérico) o <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (un parámetro de tipo de un método genérico) y no se proporcionaron los argumentos de tipo genérico necesarios para uno o ambos parámetros <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> y <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token válido en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>A metadata token that identifies a signature in the module.</source>
          <target state="translated">Token de metadatos que identifica una firma en el módulo.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>Returns the signature blob identified by a metadata token.</source>
          <target state="translated">Devuelve el objeto binario de firma identificado por un token de metadatos.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>An array of bytes representing the signature blob.</source>
          <target state="translated">Una matriz de bytes que representan el objeto binario de firma.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>Information about metadata tokens and signatures can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Encontrará información sobre los tokens de metadatos y firmas en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# y Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> en MSDN y <bpt id="p2">[</bpt>estándar ECMA-335: Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> en el sitio Web de ECMA.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid <ph id="ph2">&lt;see langword="MemberRef" /&gt;</ph>, <ph id="ph3">&lt;see langword="MethodDef" /&gt;</ph>, <ph id="ph4">&lt;see langword="TypeSpec" /&gt;</ph>, signature, or <ph id="ph5">&lt;see langword="FieldDef" /&gt;</ph> token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token <ph id="ph2">&lt;see langword="MemberRef" /&gt;</ph>, <ph id="ph3">&lt;see langword="MethodDef" /&gt;</ph>, <ph id="ph4">&lt;see langword="TypeSpec" /&gt;</ph>, de firma o <ph id="ph5">&lt;see langword="FieldDef" /&gt;</ph> válido en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token válido en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>A metadata token that identifies a string in the string heap of the module.</source>
          <target state="translated">Token de metadatos que identifica una cadena en el montón de cadena del módulo.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>Returns the string identified by the specified metadata token.</source>
          <target state="translated">Devuelve la cadena identificada por el token de metadatos especificado.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing a string value from the metadata string heap.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que contiene un valor de cadena del montón de cadena de metadatos.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# y Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> en MSDN y <bpt id="p2">[</bpt>estándar ECMA-335: Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> en el sitio Web de ECMA.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a string in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token de una cadena en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token válido en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the type identified by a metadata token.</source>
          <target state="translated">Devuelve el tipo identificado por un token de metadatos.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>A metadata token that identifies a type in the module.</source>
          <target state="translated">Token de metadatos que identifica un tipo en el módulo.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>Returns the type identified by the specified metadata token.</source>
          <target state="translated">Devuelve el tipo identificado por el token de metadatos especificado.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the type that is identified by the specified metadata token.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el tipo identificado por el token de metadatos especificado.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>To resolve a metadata token for a <ph id="ph1">`TypeSpec`</ph> whose signature contains <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> or <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use the <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, which allows you to supply the necessary context.</source>
          <target state="translated">Para resolver un símbolo (token) de metadatos para un <ph id="ph1">`TypeSpec`</ph> cuya firma contenga <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> o <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use el <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> sobrecarga del método, que permite proporcionar el contexto necesario.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>That is, when you are resolving a metadata token for a type that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</source>
          <target state="translated">Es decir, cuando se resuelve un token de metadatos para un tipo que depende de los parámetros de tipo genérico del tipo genérico y/o del método genérico en el que está incrustado el token, debe usar la sobrecarga que le permite proporcionar los parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# y Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> en MSDN y <bpt id="p2">[</bpt>estándar ECMA-335: Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> en el sitio Web de ECMA.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token válido para un tipo en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> es un <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> cuya firma contiene el tipo de elemento <ph id="ph3">&lt;see langword="var" /&gt;</ph> (un parámetro de tipo de un tipo genérico) o <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (un parámetro de tipo de un método genérico).</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token válido en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a type in the module.</source>
          <target state="translated">Token de metadatos que identifica un tipo en el módulo.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan los argumentos de tipo genérico del tipo en cuyo ámbito se encuentra el token; o es <ph id="ph2">&lt;see langword="null" /&gt;</ph> si dicho tipo no es genérico.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan los argumentos de tipo genérico del método en cuyo ámbito se encuentra el token; o es <ph id="ph2">&lt;see langword="null" /&gt;</ph> si dicho método no es genérico.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Devuelve el campo identificado por el token de metadatos especificado, en el contexto definido por los parámetros de tipo genérico especificados.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the type that is identified by the specified metadata token.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el tipo identificado por el token de metadatos especificado.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método en el tipo donde <ph id="ph2">`metadataToken`</ph> está en el ámbito para obtener una matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método en el método donde <ph id="ph2">`metadataToken`</ph> está en el ámbito para obtener una matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Siempre es seguro proporcionar estos argumentos, incluso cuando no se necesitan.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Encontrará información sobre los tokens de metadatos en la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# y Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> en MSDN y <bpt id="p2">[</bpt>estándar ECMA-335: Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> en el sitio Web de ECMA.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Para el código que muestra cómo resolver tokens mediante el contexto genérico (es decir, los parámetros de tipo genérico del tipo genérico y/o del método genérico en el que está incrustado el token) consulte el <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token válido para un tipo en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> es un <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> cuya firma contiene el tipo de elemento <ph id="ph3">&lt;see langword="var" /&gt;</ph> (un parámetro de tipo de un tipo genérico) o <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (un parámetro de tipo de un método genérico) y no se proporcionaron los argumentos de tipo genérico necesarios para uno o ambos parámetros <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> y <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> no es un token válido en el ámbito del módulo actual.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.ScopeName">
          <source>Gets a string representing the name of the module.</source>
          <target state="translated">Obtiene una cadena que representa al nombre del módulo.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ScopeName">
          <source>The module name.</source>
          <target state="translated">Nombre del módulo.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ScopeName">
          <source>The <ph id="ph1">`ScopeName`</ph> property is not used by the common language runtime, but you can use it to store any string you want in the property when you emit a module using the metadata APIs.</source>
          <target state="translated">El <ph id="ph1">`ScopeName`</ph> propiedad no se usa en common language runtime, pero se puede usar para almacenar cualquier cadena que se desee en la propiedad cuando se emita un módulo mediante las API de metadatos.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ScopeName">
          <source>Reflection itself does not allow you to set the <ph id="ph1">`ScopeName`</ph> property.</source>
          <target state="translated">Propia reflexión no permite establecer el <ph id="ph1">`ScopeName`</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ScopeName">
          <source>This example shows the effect of the <ph id="ph1">`ScopeName`</ph>, <ph id="ph2">`FullyQualifiedName`</ph>, and <ph id="ph3">`Name`</ph> properties.</source>
          <target state="translated">Este ejemplo muestra el efecto de la <ph id="ph1">`ScopeName`</ph>, <ph id="ph2">`FullyQualifiedName`</ph>, y <ph id="ph3">`Name`</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para un uso futuro.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Debe ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matriz que se pasa con los nombres que se van a asignar.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Número de nombres que se van a asignar.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Contexto de configuración regional en el que se van a interpretar los nombres.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array that receives the IDs corresponding to the names.</source>
          <target state="translated">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Información de tipos que se va a devolver.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Identificador de la configuración regional de la información de tipo.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Recibe un puntero al objeto de información de tipo solicitado.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Recupera la información de tipo de un objeto, que se puede utilizar después para obtener la información de tipo de una interfaz.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifica el miembro.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para un uso futuro.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Debe ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Contexto de la configuración regional en que se interpretan los argumentos.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Marcas que describen el contexto de la llamada.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Puntero a una estructura que contiene una matriz de argumentos, una matriz de DispID de los argumentos con nombre y recuentos del número de elementos en las matrices.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Puntero a la ubicación donde se va a almacenar el resultado.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Puntero a una estructura que contiene información de excepciones.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Índice del primer argumento que tiene un error.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::Invoke`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ToString">
          <source>Returns the name of the module.</source>
          <target state="translated">Devuelve el nombre del módulo.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ToString">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> representing the name of this module.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="String" /&gt;</ph> que representa al nombre de este módulo.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ToString">
          <source>The following example demonstrates a use of the <ph id="ph1">`ToString`</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra un uso de la <ph id="ph1">`ToString`</ph> método.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>