<Type Name="SerialPort" FullName="System.IO.Ports.SerialPort">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="edb46f25768209ef7558903ea96c655667e2e21a" />
    <Meta Name="ms.sourcegitcommit" Value="3507e865a3613c00760f25ad1045aaa11bae4dd8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/23/2018" />
    <Meta Name="ms.locfileid" Value="31781048" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SerialPort : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SerialPort extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.IO.Ports.SerialPort" />
  <TypeSignature Language="VB.NET" Value="Public Class SerialPort&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class SerialPort : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.Ports</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un recurso de puerto serie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta clase para controlar un recurso de archivo de puerto serie. Esta clase proporciona E/S sincrónica y orientada a eventos, acceso a los Estados de conexión e interrupción y acceso a propiedades del controlador serie. Además, la funcionalidad de esta clase puede ajustarse en un interno <xref:System.IO.Stream> objeto, accesible a través de la <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad y se pasa a las clases que contengan o utilicen secuencias.  
  
 El <xref:System.IO.Ports.SerialPort> clase admite las codificaciones siguientes: <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF32Encoding>y cualquier codificación definida en mscorlib.dll donde la página de códigos es menor que 50000 o la página de códigos es 54936.  Puede utilizar codificaciones alternativas, pero debe utilizar el <xref:System.IO.Ports.SerialPort.ReadByte%2A> o <xref:System.IO.Ports.SerialPort.Write%2A> método y realizar la codificación por sí mismo.  
  
 Usa el <xref:System.IO.Ports.SerialPort.GetPortNames%2A> método para recuperar los puertos válidos para el equipo actual.  
  
 Si un <xref:System.IO.Ports.SerialPort> objeto se bloquea durante una operación de lectura, no se anula el subproceso. En su lugar, cierre la base de transmitir por secuencias o desechar la <xref:System.IO.Ports.SerialPort> objeto.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir que dos usuarios puedan charlar desde dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios le pedirá la configuración del puerto y un nombre de usuario antes de chat. Ambos equipos deben estar ejecutando el programa para lograr una funcionalidad completa de este ejemplo.  
  
 [!code-cpp[System.IO.Ports.SerialPort#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#10)]
 [!code-csharp[System.IO.Ports.SerialPort#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#10)]
 [!code-vb[System.IO.Ports.SerialPort#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#10)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Ports.SerialPort" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor utiliza los valores de propiedad predeterminados cuando se especifica ninguno. Por ejemplo, el <xref:System.IO.Ports.SerialPort.DataBits%2A> propiedad el valor predeterminado es 8, el <xref:System.IO.Ports.SerialPort.Parity%2A> propiedad tiene como valor predeterminado el `None` valor de enumeración, la <xref:System.IO.Ports.SerialPort.StopBits%2A> propiedad el valor predeterminado es 1 y un nombre de puerto predeterminado de COM1.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir que dos usuarios puedan charlar desde dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios le pedirá la configuración del puerto y un nombre de usuario antes de chat. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (System.ComponentModel.IContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.ComponentModel.IContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (container As IContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::ComponentModel::IContainer ^ container);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
      </Parameters>
      <Docs>
        <param name="container">Interfaz a un contenedor.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Ports.SerialPort" /> utilizando el objeto <see cref="T:System.ComponentModel.IContainer" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor utiliza los valores de propiedad predeterminados cuando se especifica ninguno. Por ejemplo, el <xref:System.IO.Ports.SerialPort.DataBits%2A> propiedad el valor predeterminado es 8, el <xref:System.IO.Ports.SerialPort.Parity%2A> propiedad tiene como valor predeterminado el `None` valor de enumeración, la <xref:System.IO.Ports.SerialPort.StopBits%2A> propiedad el valor predeterminado es 1 y un nombre de puerto predeterminado de COM1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto especificado no se encuentra o no se puede abrir.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="portName">Puerto que se va a utilizar (por ejemplo, COM1).</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.IO.Ports.SerialPort" /> utilizando el nombre de puerto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para crear una nueva instancia de la <xref:System.IO.Ports.SerialPort> clase cuando desee especificar el nombre del puerto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto especificado no se encuentra o no se puede abrir.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String, baudRate As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="portName">Puerto que se va a utilizar (por ejemplo, COM1).</param>
        <param name="baudRate">Velocidad en baudios.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.IO.Ports.SerialPort" /> utilizando el nombre de puerto y la velocidad en baudios especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para crear una nueva instancia de la <xref:System.IO.Ports.SerialPort> clase cuando desee especificar el nombre del puerto y la velocidad en baudios.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto especificado no se encuentra o no se puede abrir.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
      </Parameters>
      <Docs>
        <param name="portName">Puerto que se va a utilizar (por ejemplo, COM1).</param>
        <param name="baudRate">Velocidad en baudios.</param>
        <param name="parity">Uno de los valores de <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.IO.Ports.SerialPort" /> utilizando el nombre del puerto, la velocidad en baudios y el bit de paridad especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para crear una nueva instancia de la <xref:System.IO.Ports.SerialPort> clase cuando desee especificar el nombre del puerto, la velocidad en baudios y el bit de paridad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto especificado no se encuentra o no se puede abrir.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity, int32 dataBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity, int dataBits);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
        <Parameter Name="dataBits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="portName">Puerto que se va a utilizar (por ejemplo, COM1).</param>
        <param name="baudRate">Velocidad en baudios.</param>
        <param name="parity">Uno de los valores de <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <param name="dataBits">Valor de bits de datos.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.IO.Ports.SerialPort" /> utilizando el nombre del puerto, la velocidad en baudios, el bit de paridad y los bits de datos especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para crear una nueva instancia de la <xref:System.IO.Ports.SerialPort> clase cuando desee especificar el nombre del puerto, la velocidad en baudios, el bit de paridad y los bits de datos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto especificado no se encuentra o no se puede abrir.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits, System.IO.Ports.StopBits stopBits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity, int32 dataBits, valuetype System.IO.Ports.StopBits stopBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity,System.Int32,System.IO.Ports.StopBits)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity, int dataBits, System::IO::Ports::StopBits stopBits);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
        <Parameter Name="dataBits" Type="System.Int32" />
        <Parameter Name="stopBits" Type="System.IO.Ports.StopBits" />
      </Parameters>
      <Docs>
        <param name="portName">Puerto que se va a utilizar (por ejemplo, COM1).</param>
        <param name="baudRate">Velocidad en baudios.</param>
        <param name="parity">Uno de los valores de <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <param name="dataBits">Valor de bits de datos.</param>
        <param name="stopBits">Uno de los valores de <see cref="P:System.IO.Ports.SerialPort.StopBits" />.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.IO.Ports.SerialPort" /> utilizando el nombre del puerto, la velocidad en baudios, el bit de paridad, los bits de datos y el bit de parada especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para crear una nueva instancia de la <xref:System.IO.Ports.SerialPort> clase cuando desee especificar el nombre del puerto, la velocidad en baudios, el bit de paridad, los bits de datos y el bit de parada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto especificado no se encuentra o no se puede abrir.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.IO.Stream" /> subyacente para un objeto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>Un objeto <see cref="T:System.IO.Stream" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta propiedad para operaciones de E/S asincrónicas explícitas o para pasar el <xref:System.IO.Ports.SerialPort> el objeto a un <xref:System.IO.Stream> clase contenedora como <xref:System.IO.StreamWriter>.  
  
 Abra los puertos serie <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad devuelve un objeto que se deriva de la clase abstracta <xref:System.IO.Stream> clase e implementa leer y escribir métodos con los prototipos se hereda de la <xref:System.IO.Stream> clase: <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.BeginWrite%2A>, <xref:System.IO.Stream.Read%2A>, <xref:System.IO.Stream.ReadByte%2A>, <xref:System.IO.Stream.Write%2A>, y <xref:System.IO.Stream.WriteByte%2A>. Estos métodos pueden ser útiles cuando se pasa un recurso serie ajustado a un <xref:System.IO.Stream> clase contenedora.  
  
 Dada la inaccesibilidad del identificador de archivo ajustada, el <xref:System.IO.Stream.Length%2A> y <xref:System.IO.Stream.Position%2A> no se admiten propiedades y la <xref:System.IO.Stream.Seek%2A> y <xref:System.IO.Stream.SetLength%2A> no se admiten métodos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
        <exception cref="T:System.NotSupportedException">La secuencia está en una aplicación .NET Compact Framework y se llamó a uno de los métodos siguientes:  
  
 <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /><see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /><see cref="M:System.IO.Stream.EndRead(System.IAsyncResult)" /><see cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />  
  
 .NET Compact Framework no admite el modelo asincrónico con secuencias base.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaudRate">
      <MemberSignature Language="C#" Value="public int BaudRate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BaudRate" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BaudRate" />
      <MemberSignature Language="VB.NET" Value="Public Property BaudRate As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BaudRate { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(9600)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la velocidad en baudios del puerto serie.</summary>
        <value>Velocidad en baudios.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La velocidad en baudios debe ser compatibles con el controlador de serie del usuario. El valor predeterminado es 9600 bits por segundo (bps).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.IO.Ports.SerialPort.BaudRate%2A> propiedad `9600`.  
  
 [!code-cpp[System.IO.Ports.SerialPort#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#20)]
 [!code-csharp[System.IO.Ports.SerialPort#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#20)]
 [!code-vb[System.IO.Ports.SerialPort#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#20)]  
  
 En el ejemplo siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir que dos usuarios puedan charlar desde dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios le pedirá la configuración del puerto y un nombre de usuario antes de chat. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La velocidad en baudios especificada es menor o igual que cero o es mayor que la velocidad en baudios máxima permitida para el dispositivo.</exception>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
      </Docs>
    </Member>
    <Member MemberName="BreakState">
      <MemberSignature Language="C#" Value="public bool BreakState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BreakState" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BreakState" />
      <MemberSignature Language="VB.NET" Value="Public Property BreakState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BreakState { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el estado de la señal de interrupción.</summary>
        <value>
          Es <see langword="true" /> si el puerto está en un estado de interrupción; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El estado de la señal de interrupción se produce cuando se suspende una transmisión y la línea se coloca en un estado de interrupción (todos los pocos, ningún bit de parada) hasta que haya liberado. Para especificar un estado de interrupción, establezca esta propiedad en `true`. Si el puerto ya está en estado de interrupción, al establecer esta propiedad a `true` no produce una excepción. No es posible escribir en el <xref:System.IO.Ports.SerialPort> objeto mientras <xref:System.IO.Ports.SerialPort.BreakState%2A> es `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesToRead">
      <MemberSignature Language="C#" Value="public int BytesToRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesToRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BytesToRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesToRead As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesToRead { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de bytes de datos en el búfer de recepción.</summary>
        <value>El número de bytes de datos en el búfer de recepción.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El búfer de recepción incluye del controlador serie búfer de recepción, así como el almacenamiento en búfer interno en el <xref:System.IO.Ports.SerialPort> propio objeto.  
  
 Dado que la <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad representa tanto la <xref:System.IO.Ports.SerialPort> búfer y el búfer creado por Windows, puede devolver un valor mayor que el <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> propiedad, que representa sólo el búfer creado por Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El puerto no está abierto.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesToWrite">
      <MemberSignature Language="C#" Value="public int BytesToWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesToWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BytesToWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesToWrite As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesToWrite { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de bytes de datos en el búfer de envío.</summary>
        <value>El número de bytes de datos en el búfer de envío.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El búfer de envío incluye del controlador serie búfer de envío, así como el almacenamiento en búfer interno en el <xref:System.IO.Ports.SerialPort> propio objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CDHolding">
      <MemberSignature Language="C#" Value="public bool CDHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CDHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.CDHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CDHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CDHolding { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el estado de la línea de detección de portadora para el puerto.</summary>
        <value>
          Es <see langword="true" /> si se detecta la portadora; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad puede utilizarse para supervisar el estado de la línea de detección de portadora para un puerto. Ninguna portadora normalmente indica que el receptor ha colgado y se ha quitado el transportista.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra la conexión del puerto, establece el valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> en <see langword="false" /> y elimina el objeto <see cref="T:System.IO.Stream" /> interno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método cierra la <xref:System.IO.Ports.SerialPort> objeto y borra tanto la recepción y transmisión de búferes. Este método llama a la <xref:System.ComponentModel.Component.Dispose?displayProperty=nameWithType> método, que se invoca el protegido <xref:System.IO.Ports.SerialPort.Dispose%28System.Boolean%29?displayProperty=nameWithType> método con el `disposing` parámetro establecido en `true`.  
  
 El procedimiento recomendado para cualquier aplicación es esperar durante algún tiempo después de llamar a la <xref:System.IO.Ports.SerialPort.Close%2A> método antes de intentar llamar a la <xref:System.IO.Ports.SerialPort.Open%2A> método, como el puerto no se puede cerrar al instante.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir que dos usuarios puedan charlar desde dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios le pedirá la configuración del puerto y un nombre de usuario antes de chat. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
      </Docs>
    </Member>
    <Member MemberName="CtsHolding">
      <MemberSignature Language="C#" Value="public bool CtsHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CtsHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.CtsHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CtsHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CtsHolding { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el estado de la línea Listo para enviar.</summary>
        <value>
          Es <see langword="true" /> si se detecta la línea Listo para enviar; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La línea Listo para enviar (CTS) se utiliza en la solicitud de envío/listo para enviar el protocolo de hardware (RTS/CTS). Un puerto consulta la línea CTS antes de enviar datos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataBits">
      <MemberSignature Language="C#" Value="public int DataBits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DataBits" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DataBits" />
      <MemberSignature Language="VB.NET" Value="Public Property DataBits As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DataBits { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la longitud estándar de los bits de datos por byte.</summary>
        <value>La longitud de los bits de datos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El intervalo de valores para esta propiedad es de 5 a 8. El valor predeterminado es 8.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir que dos usuarios puedan charlar desde dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios le pedirá la configuración del puerto y un nombre de usuario antes de chat. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de los bits de datos es menor que 5 o mayor que 8.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataReceived">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialDataReceivedEventHandler DataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialDataReceivedEventHandler DataReceived" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.DataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataReceived As SerialDataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialDataReceivedEventHandler ^ DataReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialDataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica que se recibieron datos a través de un puerto representado por el objeto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventos de datos pueden deberse a cualquiera de los elementos de la <xref:System.IO.Ports.SerialData> enumeración. Debido a que el sistema operativo determina si se genera este evento o no, no todos los errores de paridad se pueden notificar.  
  
 El <xref:System.IO.Ports.SerialPort.DataReceived> evento también se genera si se recibe un carácter Eof, sin tener en cuenta el número de bytes en el búfer de entrada interno y el valor de la <xref:System.IO.Ports.SerialPort.ReceivedBytesThreshold%2A> propiedad.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, y <xref:System.IO.Ports.SerialPort.ErrorReceived> se pueden llamar a eventos desordenados y puede haber un ligero retraso entre el momento en que la secuencia subyacente notifica el error y cuando se ejecuta el controlador de eventos. Sólo un controlador de eventos se puede ejecutar a la vez.  
  
 El <xref:System.IO.Ports.SerialPort.DataReceived> no se garantiza que el evento se desencadena para cada byte recibido. Use la <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad para determinar la cantidad de datos se deja para poder leerse en el búfer.  
  
 El <xref:System.IO.Ports.SerialPort.DataReceived> evento se desencadena en un subproceso secundario cuando se reciben datos desde el <xref:System.IO.Ports.SerialPort> objeto. Dado que este evento se desencadena en un subproceso secundario, y no es el subproceso principal, se intenta modificar algunos elementos en el subproceso principal, como elementos de interfaz de usuario, podría producirse una excepción. Si es necesario modificar los elementos de los principales <xref:System.Windows.Forms.Form> o <xref:System.Windows.Forms.Control>, las solicitudes de cambio de post con <xref:System.Windows.Forms.Control.Invoke%2A>, que realizará el trabajo en el subproceso adecuado.  
  
 Para obtener más información sobre el control de eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Este ejemplo se agrega un <xref:System.IO.Ports.SerialDataReceivedEventHandler> a <xref:System.IO.Ports.SerialPort.DataReceived> para leer todos los datos recibidos en el puerto COM1. Tenga en cuenta que, para probar este código es necesario tener hardware conectado al puerto COM1 que enviará los datos.  
  
 [!code-cpp[System.IO.Ports.SerialPort#06](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#06)]
 [!code-csharp[System.IO.Ports.SerialPort#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#06)]
 [!code-vb[System.IO.Ports.SerialPort#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#06)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardInBuffer">
      <MemberSignature Language="C#" Value="public void DiscardInBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardInBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.DiscardInBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardInBuffer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardInBuffer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Descarta los datos del búfer de recepción del controlador serie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es equivalente al siguiente código de Visual Basic: `MSComm1.InBufferCount = 0`. Borra el búfer de recepción, pero no afecta el búfer de transmisión.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DiscardNull">
      <MemberSignature Language="C#" Value="public bool DiscardNull { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DiscardNull" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DiscardNull" />
      <MemberSignature Language="VB.NET" Value="Public Property DiscardNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DiscardNull { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si no se tienen en cuenta los bytes nulos en las transmisiones entre el puerto y el búfer de recepción.</summary>
        <value>
          Es <see langword="true" /> si los bytes nulos no se tienen en cuenta; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, este valor debe establecerse en `false`, especialmente para las transmisiones binarias.  Si se establece esta propiedad en `true` puede producir resultados inesperados por bytes codificados con UTF32 y UTF16.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DiscardOutBuffer">
      <MemberSignature Language="C#" Value="public void DiscardOutBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardOutBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.DiscardOutBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardOutBuffer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardOutBuffer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Descarta los datos del búfer de transmisión del controlador serie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es equivalente al siguiente código de Visual Basic: `MSComm1.OutBufferCount = 0`. Borra el búfer de transmisión, pero no afecta el búfer de recepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usa <see cref="T:System.IO.Ports.SerialPort" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama a este método público <xref:System.ComponentModel.Component.Dispose%2A> método y <xref:System.Object.Finalize%2A> método. <xref:System.ComponentModel.Component.Dispose%2A> se invoca el protegido <xref:System.IO.Ports.SerialPort.Dispose%2A> método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca <xref:System.IO.Ports.SerialPort.Dispose%2A> con `disposing` establecido en `false`.  
  
 Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.IO.Ports.SerialPort> hace referencia. Este método invoca al método <xref:System.ComponentModel.Component.Dispose%2A> de cada uno de los objetos a los que se hace referencia.  
  
 Este método vacía y cierra el objeto de secuencia el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> puede recibir varias llamadas de otros objetos. Al invalidar <see cref="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see cref="M:System.ComponentModel.Component.Dispose" />. Para obtener más información sobre cómo implementar <see cref="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />, consulte [implementa un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obtener más información acerca de <see cref="M:System.ComponentModel.Component.Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DsrHolding">
      <MemberSignature Language="C#" Value="public bool DsrHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DsrHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DsrHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DsrHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DsrHolding { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el estado de la señal Conjunto de datos preparado (DSR).</summary>
        <value>
          Es <see langword="true" /> si se ha enviado al puerto una señal Conjunto de datos preparado; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se utiliza en el protocolo de enlace de conjunto de datos preparado/Terminal de datos preparado (DSR/DTR). La señal conjunto de datos preparado (DSR) normalmente se envía mediante un módem de acceso a un puerto para indicar que está listo para la transmisión de datos o recibir datos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DtrEnable">
      <MemberSignature Language="C#" Value="public bool DtrEnable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DtrEnable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DtrEnable" />
      <MemberSignature Language="VB.NET" Value="Public Property DtrEnable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DtrEnable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que habilita la señal Terminal de datos preparado (DTR) durante la comunicación en serie.</summary>
        <value>
          Es <see langword="true" /> para habilitar Terminal de datos preparado (DTR); de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente está habilitado Terminal de datos preparado (DTR) durante el protocolo de software XON/XOFF y solicitud de envío/listo para enviar el protocolo de hardware (RTS/CTS) y las comunicaciones de módem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding Encoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la codificación de bytes para la conversión de texto previa y posterior a la transmisión.</summary>
        <value>Un objeto <see cref="T:System.Text.Encoding" />. El valor predeterminado es <see cref="T:System.Text.ASCIIEncoding" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La propiedad <see cref="P:System.IO.Ports.SerialPort.Encoding" /> se estableció en <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.Encoding" /> se estableció en una codificación que no es <see cref="T:System.Text.ASCIIEncoding" />, <see cref="T:System.Text.UTF8Encoding" />, <see cref="T:System.Text.UTF32Encoding" />, <see cref="T:System.Text.UnicodeEncoding" />, una de las codificaciones de byte único de Windows o una de las codificaciones de byte doble de Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="ErrorReceived">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialErrorReceivedEventHandler ErrorReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialErrorReceivedEventHandler ErrorReceived" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.ErrorReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorReceived As SerialErrorReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialErrorReceivedEventHandler ^ ErrorReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialErrorReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica que hubo un error en el puerto representado por el objeto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventos de error pueden deberse a cualquiera de los elementos de la <xref:System.IO.Ports.SerialError> enumeración. Debido a que el sistema operativo determina si se genera este evento o no, no todos los errores de paridad se pueden notificar.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, y <xref:System.IO.Ports.SerialPort.ErrorReceived> se pueden llamar a eventos desordenados y puede haber un ligero retraso entre el momento en que la secuencia subyacente notifica el error y el momento cuando se ejecuta el controlador de eventos. Sólo un controlador de eventos se puede ejecutar a la vez.  
  
 Si se produce un error de paridad en el byte final de una secuencia, se agregará un byte adicional para el búfer de entrada con un valor de 126.  
  
 El <xref:System.IO.Ports.SerialPort.ErrorReceived> evento se desencadena en un subproceso secundario cuando se recibe un error de la <xref:System.IO.Ports.SerialPort> objeto. Dado que este evento se desencadena en un subproceso secundario, y no es el subproceso principal, se intenta modificar algunos elementos en el subproceso principal, como elementos de interfaz de usuario, podría producirse una excepción. Si es necesario modificar los elementos de los principales <xref:System.Windows.Forms.Form> o <xref:System.Windows.Forms.Control>, las solicitudes de cambio de post con <xref:System.Windows.Forms.Control.Invoke%2A>, que realizará el trabajo en el subproceso adecuado.  
  
 Para obtener más información sobre el control de eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPortNames">
      <MemberSignature Language="C#" Value="public static string[] GetPortNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetPortNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.GetPortNames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPortNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetPortNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene una matriz con los nombres de los puertos serie del equipo actual.</summary>
        <returns>Una matriz con los nombres de los puertos serie del equipo actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Devuelve el orden de los nombres de puerto de <xref:System.IO.Ports.SerialPort.GetPortNames%2A> no se ha especificado.  
  
 Use la <xref:System.IO.Ports.SerialPort.GetPortNames%2A> método para consultar el equipo actual para obtener una lista de nombres de puerto serie válido. Por ejemplo, puede usar este método para determinar si COM1 y COM2 son los puertos serie válidos para el equipo actual.  
  
 Los nombres de puerto se obtienen del registro del sistema (por ejemplo, HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\SERIALCOMM). Si el registro contiene datos obsoletos o incorrectos en caso contrario, la <xref:System.IO.Ports.SerialPort.GetPortNames%2A> método devolverá datos incorrectos.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.IO.Ports.SerialPort.GetPortNames%2A> método para mostrar los nombres de puerto serie en la consola.  
  
 [!code-cpp[IO.Ports.GetPortNames#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Ports.GetPortNames/cpp/example.cpp#1)]
 [!code-csharp[IO.Ports.GetPortNames#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Ports.GetPortNames/CS/example.cs#1)]
 [!code-vb[IO.Ports.GetPortNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Ports.GetPortNames/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">No se pudieron consultar los nombres de puerto serie.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handshake">
      <MemberSignature Language="C#" Value="public System.IO.Ports.Handshake Handshake { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.Handshake Handshake" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Handshake" />
      <MemberSignature Language="VB.NET" Value="Public Property Handshake As Handshake" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::Handshake Handshake { System::IO::Ports::Handshake get(); void set(System::IO::Ports::Handshake value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.Handshake</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el protocolo de enlace para la transmisión de datos a través del puerto serie desde <see cref="T:System.IO.Ports.Handshake" />.</summary>
        <value>Uno de los valores de <see cref="T:System.IO.Ports.Handshake" />. El valor predeterminado es <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se utiliza el protocolo de enlace, el dispositivo conectado a la <xref:System.IO.Ports.SerialPort> objeto se indica a detener el envío de datos cuando no hay como mínimo (<xref:System.IO.Ports.SerialPort.ReadBufferSize%2A>-1024) bytes en el búfer. El dispositivo se indica a empezar a enviar datos de nuevo cuando hay 1024 o menos bytes en el búfer. Si el dispositivo está enviando datos en bloques de más de 1024 bytes, esto puede ocasionar el búfer se desborde.  
  
 Si el <xref:System.IO.Ports.SerialPort.Handshake%2A> propiedad está establecida en <xref:System.IO.Ports.Handshake.RequestToSendXOnXOff> y <xref:System.IO.Ports.SerialPort.CtsHolding%2A> se establece en `false`, no se enviará el carácter XOff. Si <xref:System.IO.Ports.SerialPort.CtsHolding%2A> , a continuación, se establece en `true`, más datos se deben enviar antes de que se enviará el carácter XOff.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir que dos usuarios puedan charlar desde dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios le pedirá la configuración del puerto y un nombre de usuario antes de chat. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor pasado no es un valor válido de la enumeración <see cref="T:System.IO.Ports.Handshake" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public const int InfiniteTimeout = -1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 InfiniteTimeout = (-1)" />
      <MemberSignature Language="DocId" Value="F:System.IO.Ports.SerialPort.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const InfiniteTimeout As Integer  = -1" />
      <MemberSignature Language="C++ CLI" Value="public: int InfiniteTimeout = -1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>-1</MemberValue>
      <Docs>
        <summary>Indica que no se debe agotar el tiempo de espera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor se utiliza con la <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> y <xref:System.IO.Ports.SerialPort.WriteTimeout%2A> propiedades.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOpen">
      <MemberSignature Language="C#" Value="public bool IsOpen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOpen" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.IsOpen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOpen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOpen { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica el estado abierto o cerrado del objeto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>
          Es <see langword="true" /> si el puerto serie está abierto; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Ports.SerialPort.IsOpen%2A> propiedad realiza un seguimiento si el puerto está abierto para su uso por el llamador, no si el puerto está abierto por cualquier aplicación en el equipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> pasado es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El valor <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> pasado es una cadena vacía ("").</exception>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public string NewLine { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ NewLine { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("\n")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor utilizado para interpretar el final de una llamada a los métodos <see cref="M:System.IO.Ports.SerialPort.ReadLine" /> y <see cref="M:System.IO.Ports.SerialPort.WriteLine(System.String)" />.</summary>
        <value>Un valor que representa el final de una línea. El valor predeterminado es un avance de línea, <see cref="P:System.Environment.NewLine" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad determina qué valor (bytes) define el final de una línea para el <xref:System.IO.Ports.SerialPort.ReadLine%2A> y <xref:System.IO.Ports.SerialPort.WriteLine%2A> métodos. De forma predeterminada es el valor final de la línea <xref:System.Environment.NewLine%2A>. Debería cambiar a un valor diferente si el dispositivo serie concreto que se está trabajando con usa un valor diferente para el mismo propósito.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de propiedad está vacío.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de la propiedad es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public void Open ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Open() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Open" />
      <MemberSignature Language="VB.NET" Value="Public Sub Open ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Open();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Abre una nueva conexión de puerto serie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo una conexión abierta puede existir por <xref:System.IO.Ports.SerialPort> objeto.  
  
 El procedimiento recomendado para cualquier aplicación es esperar durante algún tiempo después de llamar a la <xref:System.IO.Ports.SerialPort.Close%2A> método antes de intentar llamar a la <xref:System.IO.Ports.SerialPort.Open%2A> método, como el puerto no se puede cerrar al instante.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir que dos usuarios puedan charlar desde dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios le pedirá la configuración del puerto y un nombre de usuario antes de chat. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Se deniega el acceso al puerto.  
  
 \- o -  
  
 El proceso actual u otro proceso en el sistema ya tiene el puerto COM especificado abierto por una instancia <see cref="T:System.IO.Ports.SerialPort" /> o en código no administrado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una o varias de las propiedades de esta instancia no son válidas. Por ejemplo, las propiedades <see cref="P:System.IO.Ports.SerialPort.Parity" />, <see cref="P:System.IO.Ports.SerialPort.DataBits" /> o <see cref="P:System.IO.Ports.SerialPort.Handshake" /> no tienen valores válidos; el valor de <see cref="P:System.IO.Ports.SerialPort.BaudRate" /> es menor o igual que cero; el valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.ReadTimeout" /> o <see cref="P:System.IO.Ports.SerialPort.WriteTimeout" /> es menor que cero y no es <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre del puerto no empieza por "COM".  
  
 \- o -  
  
 No se admite el tipo de archivo del puerto.</exception>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.InvalidOperationException">El puerto especificado en la instancia actual de <see cref="T:System.IO.Ports.SerialPort" /> ya está abierto.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Parity">
      <MemberSignature Language="C#" Value="public System.IO.Ports.Parity Parity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.Parity Parity" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Parity" />
      <MemberSignature Language="VB.NET" Value="Public Property Parity As Parity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::Parity Parity { System::IO::Ports::Parity get(); void set(System::IO::Ports::Parity value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.Parity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el protocolo de comprobación de la paridad.</summary>
        <value>Uno de los valores de enumeración que representa el protocolo de comprobación de la paridad. El valor predeterminado es <see cref="F:System.IO.Ports.Parity.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La paridad es un procedimiento de comprobación de errores en el que el número de 1 siempre debe ser el mismo: par o impar, para cada grupo de bits transmitidos sin errores. En las comunicaciones de módem a módem, paridad suele ser uno de los parámetros que se deben acordar las partes de enviando y recibiendo colocar entidades antes de realizar la transmisión.  
  
 Si se produce un error de paridad en el byte final de una secuencia, se agregará un byte adicional para el búfer de entrada con un valor de 126.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir que dos usuarios puedan charlar desde dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios le pedirá la configuración del puerto y un nombre de usuario antes de chat. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <see cref="P:System.IO.Ports.SerialPort.Parity" /> pasado no es un valor válido en la enumeración <see cref="T:System.IO.Ports.Parity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ParityReplace">
      <MemberSignature Language="C#" Value="public byte ParityReplace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8 ParityReplace" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ParityReplace" />
      <MemberSignature Language="VB.NET" Value="Public Property ParityReplace As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Byte ParityReplace { System::Byte get(); void set(System::Byte value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(63)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el byte que reemplaza los bytes no válidos en una secuencia de datos cuando se produce un error de paridad.</summary>
        <value>Un byte que reemplaza los bytes no válidos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor se establece en el carácter null, se deshabilita el reemplazo de paridad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
      </Docs>
    </Member>
    <Member MemberName="PinChanged">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialPinChangedEventHandler PinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialPinChangedEventHandler PinChanged" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.PinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PinChanged As SerialPinChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialPinChangedEventHandler ^ PinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialPinChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica que hubo un evento de señal que no es de datos en el puerto representado por el objeto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cambia pin serie eventos pueden deberse a cualquiera de los elementos de la <xref:System.IO.Ports.SerialPinChange> enumeración. Debido a que el sistema operativo determina si se genera este evento o no, no todos los errores de paridad se pueden notificar. Como parte del evento, se establece el nuevo valor del tope.  
  
 El <xref:System.IO.Ports.SerialPort.PinChanged> evento se desencadena cuando una <xref:System.IO.Ports.SerialPort> objeto entra en el <xref:System.IO.Ports.SerialPort.BreakState%2A>, pero no cuando se cierra el puerto de la <xref:System.IO.Ports.SerialPort.BreakState%2A>. Este comportamiento no se aplica a otros valores en la <xref:System.IO.Ports.SerialPinChange> enumeración.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, y <xref:System.IO.Ports.SerialPort.ErrorReceived> se pueden llamar a eventos desordenados y puede haber un ligero retraso entre el momento en que la secuencia subyacente notifica el error y cuando se ejecuta el controlador de eventos. Sólo un controlador de eventos se puede ejecutar a la vez.  
  
 El <xref:System.IO.Ports.SerialPort.PinChanged> evento se desencadena en un subproceso secundario. Dado que este evento se desencadena en un subproceso secundario, y no es el subproceso principal, se intenta modificar algunos elementos en el subproceso principal, como elementos de interfaz de usuario, podría producirse una excepción. Si es necesario modificar los elementos de los principales <xref:System.Windows.Forms.Form> o <xref:System.Windows.Forms.Control>, las solicitudes de cambio de post con <xref:System.Windows.Forms.Control.Invoke%2A>, que realizará el trabajo en el subproceso adecuado.  
  
 Para obtener más información sobre el control de eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PortName">
      <MemberSignature Language="C#" Value="public string PortName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PortName" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.PortName" />
      <MemberSignature Language="VB.NET" Value="Public Property PortName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PortName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("COM1")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el puerto de comunicaciones, incluidos por lo menos todos los puertos COM disponibles.</summary>
        <value>El puerto de comunicaciones. El valor predeterminado es COM1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede obtener una lista de nombres de puerto válido mediante el <xref:System.IO.Ports.SerialPort.GetPortNames%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir que dos usuarios puedan charlar desde dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios le pedirá la configuración del puerto y un nombre de usuario antes de chat. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.IO.Ports.SerialPort.PortName" /> se estableció en un valor con una longitud de cero.  
  
 O bien  
  
 La propiedad <see cref="P:System.IO.Ports.SerialPort.PortName" /> se ha establecido en un valor que empieza por "\\\\".  
  
 O bien  
  
 El nombre del puerto no era válido.</exception>
        <exception cref="T:System.ArgumentNullException">La propiedad <see cref="P:System.IO.Ports.SerialPort.PortName" /> se estableció en <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El puerto especificado está abierto.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lee datos del búfer de entrada de <see cref="T:System.IO.Ports.SerialPort" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de bytes en la que se va a escribir la entrada.</param>
        <param name="offset">Desplazamiento de <c>buffer</c> en el que se van a escribir los bytes.</param>
        <param name="count">Número máximo de bytes que se pueden leer. Se leen menos bytes si <c>count</c> es mayor que el número de bytes del búfer de entrada.</param>
        <summary>Lee varios bytes del búfer de entrada de <see cref="T:System.IO.Ports.SerialPort" /> y los escribe en una matriz de bytes en la posición de desplazamiento especificada.</summary>
        <returns>Número de bytes leídos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si es necesario cambiar entre leer texto y leer datos binarios de la secuencia, seleccione un protocolo que defina cuidadosamente el límite entre el texto y los datos binarios, como leer bytes y descodificar los datos manualmente.  
  
 Dado que la <xref:System.IO.Ports.SerialPort> clase almacena en búfer los datos y la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad no es así, los dos pueden estar en conflicto acerca de cuántos bytes están disponibles para leer.  El <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad puede indicar que hay bytes para leer, pero estos bytes no estén accesibles para la secuencia contenida en la <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad porque se ha almacenado en búfer para la <xref:System.IO.Ports.SerialPort> clase.  
  
 El <xref:System.IO.Ports.SerialPort.Read%2A> método no bloquear otras operaciones cuando el número de bytes leídos es igual a `count` pero hay bytes todavía no leídos en el puerto serie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El búfer pasado es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Los parámetros <paramref name="offset" /> o <paramref name="count" /> están fuera de una región válida del <paramref name="buffer" /> que se pasa. <paramref name="offset" /> o <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          La suma de <paramref name="offset" /> y <paramref name="count" /> es mayor que la longitud de <paramref name="buffer" />.</exception>
        <exception cref="T:System.TimeoutException">No había ningún byte disponible para la lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public int Read (char[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read(char[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (buffer As Char(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read(cli::array &lt;char&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de caracteres en la que se va a escribir la entrada.</param>
        <param name="offset">Desplazamiento de <c>buffer</c> en el que se van a escribir los caracteres.</param>
        <param name="count">Número máximo de caracteres que se van a leer. Se leen menos caracteres si <c>count</c> es mayor que el número de caracteres del búfer de entrada.</param>
        <summary>Lee un número de caracteres del búfer de entrada de <see cref="T:System.IO.Ports.SerialPort" /> y los escribe en una matriz de caracteres en la posición de desplazamiento especificada.</summary>
        <returns>Número de caracteres que se han leído.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para leer caracteres de puerto serie.  
  
 Si es necesario cambiar entre leer texto y leer datos binarios de la secuencia, seleccione un protocolo que defina cuidadosamente el límite entre el texto y los datos binarios, como leer bytes y descodificar los datos manualmente.  
  
 Dado que la <xref:System.IO.Ports.SerialPort> clase almacena en búfer los datos y la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad no es así, los dos pueden estar en conflicto sobre cuántos caracteres hay disponibles para leer.  El <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad puede indicar que hay caracteres que leer, pero estos caracteres no estén accesibles para la secuencia contenida en la <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad porque se ha almacenado en búfer para la <xref:System.IO.Ports.SerialPort> clase.  
  
 El <xref:System.IO.Ports.SerialPort.Read%2A> método no bloquear otras operaciones cuando el número de bytes leídos es igual a `count` pero hay bytes todavía no leídos en el puerto serie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          La suma de <paramref name="offset" /> y <paramref name="count" /> es mayor que la longitud del búfer.  
  
 \- o -  
  
 <paramref name="count" /> es 1 y hay un carácter suplente en el búfer.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="buffer" /> pasado es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Los parámetros <paramref name="offset" /> o <paramref name="count" /> están fuera de una región válida del <paramref name="buffer" /> que se pasa. <paramref name="offset" /> o <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.TimeoutException">No había ningún carácter disponible para la lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBufferSize">
      <MemberSignature Language="C#" Value="public int ReadBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReadBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(4096)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño del búfer de entrada de <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>Tamaño del búfer en bytes. El valor predeterminado es 4096; el valor máximo es el de un entero positivo, o 2147483647.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> propiedad omite los valores menores que 4096.  
  
 Porque el <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> propiedad representa sólo el búfer creado por Windows, puede devolver un valor más bajo que el <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad, que representa tanto la <xref:System.IO.Ports.SerialPort> búfer y el búfer creado por Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> es menor o igual que cero.</exception>
        <exception cref="T:System.InvalidOperationException">Se ha establecido el valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> mientras estaba abierta la secuencia.</exception>
        <exception cref="T:System.IO.IOException">Se ha establecido el valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> en un valor entero impar.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee sincrónicamente un byte del búfer de entrada de <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <returns>El byte, convertido en un <see cref="T:System.Int32" />, o -1 si se ha leído el final de la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee un byte.  
  
 Tenga cuidado cuando utilice <xref:System.IO.Ports.SerialPort.ReadByte%2A> y <xref:System.IO.Ports.SerialPort.ReadChar%2A> juntos. Cambiar entre leer bytes y leer caracteres puede producir datos adicionales que deben leerse y otros comportamientos no deseados. Si es necesario cambiar entre leer texto y leer datos binarios de la secuencia, seleccione un protocolo que defina cuidadosamente el límite entre el texto y los datos binarios, como leer bytes y descodificar los datos manualmente.  
  
> [!NOTE]
>  Dado que la <xref:System.IO.Ports.SerialPort> clase almacena en búfer los datos y la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad no es así, los dos pueden estar en conflicto acerca de cuántos bytes están disponibles para leer.  El <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad puede indicar que hay bytes para leer, pero estos bytes no estén accesibles para la secuencia contenida en la <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad porque se ha almacenado en búfer para la <xref:System.IO.Ports.SerialPort> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">La operación no se ha terminado antes de que transcurriera el tiempo de espera.  
  
 \- o -  
  
 No se leyó ningún byte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadChar">
      <MemberSignature Language="C#" Value="public int ReadChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadChar" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadChar () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadChar();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee sincrónicamente un carácter del búfer de entrada de <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <returns>El carácter leído.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee un carácter completo basándose en la codificación.  
  
 Tenga cuidado cuando utilice <xref:System.IO.Ports.SerialPort.ReadByte%2A> y <xref:System.IO.Ports.SerialPort.ReadChar%2A> juntos. Cambiar entre leer bytes y leer caracteres puede producir datos adicionales que deben leerse y otros comportamientos no deseados. Si es necesario cambiar entre leer texto y leer datos binarios de la secuencia, seleccione un protocolo que defina cuidadosamente el límite entre el texto y los datos binarios, como leer bytes y descodificar los datos manualmente.  
  
> [!NOTE]
>  Dado que la <xref:System.IO.Ports.SerialPort> clase almacena en búfer los datos y la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad no es así, los dos pueden estar en conflicto acerca de cuántos bytes están disponibles para leer.  El <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad puede indicar que hay bytes para leer, pero estos bytes no estén accesibles para la secuencia contenida en la <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad porque se ha almacenado en búfer para la <xref:System.IO.Ports.SerialPort> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">La operación no se ha terminado antes de que transcurriera el tiempo de espera.  
  
 \- o -  
  
 No estaba disponible ningún carácter en el período del tiempo de espera asignado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadExisting">
      <MemberSignature Language="C#" Value="public string ReadExisting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadExisting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadExisting" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadExisting () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadExisting();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee todos los bytes inmediatamente disponibles, basándose en la codificación, en la secuencia y el búfer de entrada del objeto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <returns>El contenido de la secuencia y del búfer de entrada del objeto <see cref="T:System.IO.Ports.SerialPort" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve el contenido de la secuencia y el búfer interno de la <xref:System.IO.Ports.SerialPort> objeto como una cadena. Este método no usa un tiempo de espera. Tenga en cuenta que este método puede dejar finales bytes iniciales en el búfer interno, lo que hace el <xref:System.IO.Ports.SerialPort.BytesToRead%2A> valor mayor que cero.  
  
 Si es necesario cambiar entre leer texto y leer datos binarios de la secuencia, seleccione un protocolo que defina cuidadosamente el límite entre el texto y los datos binarios, como leer bytes y descodificar los datos manualmente.  
  
> [!NOTE]
>  El <xref:System.IO.Ports.SerialPort> clase almacena en búfer datos, pero el objeto de secuencia incluidos en el <xref:System.IO.Ports.SerialPort.BaseStream%2A?displayProperty=nameWithType> propiedad no es así. Por lo tanto, la <xref:System.IO.Ports.SerialPort> objeto y el objeto de secuencia pueden diferir en el número de bytes que están disponibles para leer. Cuando se almacenan en búfer los bytes a la <xref:System.IO.Ports.SerialPort> objeto, el <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad incluye estos bytes en su valor; sin embargo, estos bytes pueden no ser accesibles para la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee hasta el valor de <see cref="P:System.IO.Ports.SerialPort.NewLine" /> en el búfer de entrada.</summary>
        <returns>El contenido del búfer de entrada hasta la primera vez que aparezca un valor de <see cref="P:System.IO.Ports.SerialPort.NewLine" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que, aunque este método no devuelve el <xref:System.IO.Ports.SerialPort.NewLine%2A> valor, el <xref:System.IO.Ports.SerialPort.NewLine%2A> se quita el valor del búfer de entrada.  
  
 De forma predeterminada, la <xref:System.IO.Ports.SerialPort.ReadLine%2A> método se bloqueará hasta que se reciba una línea. Si no desea este comportamiento, establezca la <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> propiedad en cualquier valor distinto de cero para forzar la <xref:System.IO.Ports.SerialPort.ReadLine%2A> método para producir una <xref:System.TimeoutException> si una línea no está disponible en el puerto.  
  
 Si es necesario cambiar entre leer texto y leer datos binarios de la secuencia, seleccione un protocolo que defina cuidadosamente el límite entre el texto y los datos binarios, como leer bytes y descodificar los datos manualmente.  
  
> [!NOTE]
>  Dado que la <xref:System.IO.Ports.SerialPort> clase almacena en búfer los datos y la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad no es así, los dos pueden estar en conflicto acerca de cuántos bytes están disponibles para leer.  El <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad puede indicar que hay bytes para leer, pero estos bytes no estén accesibles para la secuencia contenida en la <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad porque se ha almacenado en búfer para la <xref:System.IO.Ports.SerialPort> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir que dos usuarios puedan charlar desde dos equipos independientes conectados mediante un cable de módem nulo. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.TimeoutException">La operación no se ha terminado antes de que transcurriera el tiempo de espera.  
  
 \- o -  
  
 No se leyó ningún byte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número de milisegundos que transcurren antes de que se agote el tiempo de espera si una operación de lectura no finaliza.</summary>
        <value>El número de milisegundos que transcurren antes de que se agote el tiempo de espera si una operación de lectura no finaliza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de tiempo de espera de lectura se estableció originalmente en 500 milisegundos en la API de comunicaciones de Win32. Esta propiedad permite establecer este valor. El tiempo de espera se puede establecer en cualquier valor mayor que cero o establecido en <xref:System.IO.Ports.SerialPort.InfiniteTimeout>, en cuyo caso se produce ningún tiempo de espera. <xref:System.IO.Ports.SerialPort.InfiniteTimeout> es el valor predeterminado.  
  
> [!NOTE]
>  Los usuarios de la no administrada `COMMTIMEOUTS` estructura cabría esperar establecer el valor de tiempo de espera en cero para suprimir los tiempos de espera. Para suprimir los tiempos de espera con la <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> propiedad, sin embargo, se debe especificar <xref:System.IO.Ports.SerialPort.InfiniteTimeout>.  
  
 Esta propiedad no afecta a la <xref:System.IO.Stream.BeginRead%2A> método de la secuencia devuelta por la <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir que dos usuarios puedan charlar desde dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios le pedirá la configuración del puerto y un nombre de usuario antes de chat. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor del tiempo de espera de lectura es menor que cero y distinto de <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTo">
      <MemberSignature Language="C#" Value="public string ReadTo (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadTo(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadTo (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadTo(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Valor que indica dónde se detiene la operación de lectura.</param>
        <summary>Lee una cadena hasta el <paramref name="value" /> especificado en el búfer de entrada.</summary>
        <returns>El contenido del búfer de entrada hasta el valor de <paramref name="value" /> especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee una cadena hasta el especificado `value`. Mientras que la cadena devuelta no incluye el `value`, el `value` se quita del búfer de entrada.  
  
 Si es necesario cambiar entre leer texto y leer datos binarios de la secuencia, seleccione un protocolo que defina cuidadosamente el límite entre el texto y los datos binarios, como leer bytes y descodificar los datos manualmente.  
  
> [!NOTE]
>  Dado que la <xref:System.IO.Ports.SerialPort> clase almacena en búfer los datos y la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad no es así, los dos pueden estar en conflicto acerca de cuántos bytes están disponibles para leer.  El <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad puede indicar que hay bytes para leer, pero estos bytes no estén accesibles para la secuencia contenida en la <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad porque se ha almacenado en búfer para la <xref:System.IO.Ports.SerialPort> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud del parámetro <paramref name="value" /> es 0.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.TimeoutException">La operación no se ha terminado antes de que transcurriera el tiempo de espera.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceivedBytesThreshold">
      <MemberSignature Language="C#" Value="public int ReceivedBytesThreshold { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceivedBytesThreshold" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReceivedBytesThreshold" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceivedBytesThreshold As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceivedBytesThreshold { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número de bytes en el búfer de entrada interno antes de que ocurra un evento <see cref="E:System.IO.Ports.SerialPort.DataReceived" />.</summary>
        <value>El número de bytes del búfer de entrada interno antes de que se genere un evento <see cref="E:System.IO.Ports.SerialPort.DataReceived" />. El valor predeterminado es 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Ports.SerialPort.DataReceived> evento también se produce si un <xref:System.IO.Ports.SerialData.Eof> se reciben caracteres, sin tener en cuenta el número de bytes en el búfer de entrada interno y el valor de la <xref:System.IO.Ports.SerialPort.ReceivedBytesThreshold%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <see cref="P:System.IO.Ports.SerialPort.ReceivedBytesThreshold" /> es menor o igual que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="RtsEnable">
      <MemberSignature Language="C#" Value="public bool RtsEnable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RtsEnable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.RtsEnable" />
      <MemberSignature Language="VB.NET" Value="Public Property RtsEnable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RtsEnable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la señal Solicitud de envío (RTS) está habilitada durante la comunicación en serie.</summary>
        <value>
          Es <see langword="true" /> para habilitar Solicitud de envío (RTS); de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La solicitud para señal de envío (RTS) se utiliza normalmente en la solicitud de envío/listo para enviar el protocolo de hardware (RTS/CTS).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.RtsEnable" /> se estableció o se recuperó mientras el valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.Handshake" /> se establece en <see cref="F:System.IO.Ports.Handshake.RequestToSend" /> o <see cref="F:System.IO.Ports.Handshake.RequestToSendXOnXOff" />.</exception>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
      </Docs>
    </Member>
    <Member MemberName="StopBits">
      <MemberSignature Language="C#" Value="public System.IO.Ports.StopBits StopBits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.StopBits StopBits" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.StopBits" />
      <MemberSignature Language="VB.NET" Value="Public Property StopBits As StopBits" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::StopBits StopBits { System::IO::Ports::StopBits get(); void set(System::IO::Ports::StopBits value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.StopBits</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número estándar de bits de parada por byte.</summary>
        <value>Uno de los valores de <see cref="T:System.IO.Ports.StopBits" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor predeterminado de <xref:System.IO.Ports.SerialPort.StopBits%2A> es <xref:System.IO.Ports.StopBits.One>.  
  
 El <xref:System.IO.Ports.StopBits.None?displayProperty=nameWithType> valor no es compatible.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.IO.Ports.SerialPort.StopBits%2A> propiedad `One`.  
  
 [!code-cpp[System.IO.Ports.SerialPort#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#20)]
 [!code-csharp[System.IO.Ports.SerialPort#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#20)]
 [!code-vb[System.IO.Ports.SerialPort#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#20)]  
  
 En el ejemplo siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir que dos usuarios puedan charlar desde dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios le pedirá la configuración del puerto y un nombre de usuario antes de chat. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor <see cref="P:System.IO.Ports.SerialPort.StopBits" /> es <see cref="F:System.IO.Ports.StopBits.None" />.</exception>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe datos en el búfer de salida del puerto serie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string text) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (text As String)" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public void Write (string str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string str) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.String)" FrameworkAlternate="xamarinmac-3.0;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (str As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="text">To be added.</param>
        <param name="str">To be added.</param>
        <summary>Escribe la cadena especificada en el puerto serie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando desea escribir una cadena como resultado en un puerto serie.  
  
 Si hay demasiados bytes en el búfer de salida y <xref:System.IO.Ports.SerialPort.Handshake%2A> está establecido en <xref:System.IO.Ports.Handshake.XOnXOff> la <xref:System.IO.Ports.SerialPort> puede producir el objeto un <xref:System.ServiceProcess.TimeoutException> mientras espera a que el dispositivo esté listo para aceptar más datos.  
  
 De forma predeterminada, <xref:System.IO.Ports.SerialPort> utiliza <xref:System.Text.ASCIIEncoding> para codificar los caracteres. <xref:System.Text.ASCIIEncoding> codifica todos los caracteres mayores que 127 como (char) 63 o '?'. Para admitir caracteres adicionales en ese intervalo, establezca <xref:System.IO.Ports.SerialPort.Encoding%2A> a <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>, o <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="text" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">La operación no se ha terminado antes de que transcurriera el tiempo de espera.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de bytes que contiene los datos para escribir en el puerto.</param>
        <param name="offset">Desplazamiento de bytes de base cero del parámetro <c>buffer</c> donde se van a empezar a copiar bytes en el puerto.</param>
        <param name="count">Número de bytes que se van a escribir.</param>
        <summary>Escribe un número especificado de bytes en el puerto serie utilizando los datos de un búfer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando desee escribir en un búfer de bytes para crear la salida de un puerto serie.  
  
 Si hay demasiados bytes en el búfer de salida y <xref:System.IO.Ports.SerialPort.Handshake%2A> está establecido en <xref:System.IO.Ports.Handshake.XOnXOff> la <xref:System.IO.Ports.SerialPort> puede producir el objeto un <xref:System.ServiceProcess.TimeoutException> mientras espera a que el dispositivo esté listo para aceptar más datos.  
  
 De forma predeterminada, <xref:System.IO.Ports.SerialPort> utiliza <xref:System.Text.ASCIIEncoding> para codificar los caracteres. <xref:System.Text.ASCIIEncoding> codifica todos los caracteres mayores que 127 como (char) 63 o '?'. Para admitir caracteres adicionales en ese intervalo, establezca <xref:System.IO.Ports.SerialPort.Encoding%2A> a <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>, o <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="buffer" /> pasado es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Los parámetros <paramref name="offset" /> o <paramref name="count" /> están fuera de una región válida del <paramref name="buffer" /> que se pasa. <paramref name="offset" /> o <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          La suma de <paramref name="offset" /> y <paramref name="count" /> es mayor que la longitud de <paramref name="buffer" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">La operación no se ha terminado antes de que transcurriera el tiempo de espera.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de caracteres que contiene los datos para escribir en el puerto.</param>
        <param name="offset">Desplazamiento de bytes de base cero del parámetro <c>buffer</c> donde se van a empezar a copiar bytes en el puerto.</param>
        <param name="count">Número de caracteres que se van a escribir.</param>
        <summary>Escribe un número especificado de caracteres en el puerto serie utilizando los datos de un búfer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando desee escribir en un búfer de caracteres para crear la salida de un puerto serie.  
  
 Si hay demasiados bytes en el búfer de salida y <xref:System.IO.Ports.SerialPort.Handshake%2A> está establecido en <xref:System.IO.Ports.Handshake.XOnXOff> la <xref:System.IO.Ports.SerialPort> puede producir el objeto un <xref:System.ServiceProcess.TimeoutException> mientras espera a que el dispositivo esté listo para aceptar más datos.  
  
 De forma predeterminada, <xref:System.IO.Ports.SerialPort> utiliza <xref:System.Text.ASCIIEncoding> para codificar los caracteres. <xref:System.Text.ASCIIEncoding> codifica todos los caracteres mayores que 127 como (char) 63 o '?'. Para admitir caracteres adicionales en ese intervalo, establezca <xref:System.IO.Ports.SerialPort.Encoding%2A> a <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>, o <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="buffer" /> pasado es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Los parámetros <paramref name="offset" /> o <paramref name="count" /> están fuera de una región válida del <paramref name="buffer" /> que se pasa. <paramref name="offset" /> o <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          La suma de <paramref name="offset" /> y <paramref name="count" /> es mayor que la longitud de <paramref name="buffer" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">La operación no se ha terminado antes de que transcurriera el tiempo de espera.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteBufferSize">
      <MemberSignature Language="C#" Value="public int WriteBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.WriteBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriteBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(2048)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño del búfer de salida del puerto serie.</summary>
        <value>Tamaño del búfer de salida. El valor predeterminado es 2048.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Ports.SerialPort.WriteBufferSize%2A> propiedad omite cualquier valor inferior a 2048.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> es menor o igual que cero.</exception>
        <exception cref="T:System.InvalidOperationException">Se ha establecido el valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> mientras estaba abierta la secuencia.</exception>
        <exception cref="T:System.IO.IOException">Se ha establecido el valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> en un valor entero impar.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public void WriteLine (string text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteLine(string text) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (text As String)" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteLine(System::String ^ text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public void WriteLine (string str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteLine(string str) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.WriteLine(System.String)" FrameworkAlternate="xamarinmac-3.0;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (str As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteLine(System::String ^ str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="text">To be added.</param>
        <param name="str">To be added.</param>
        <summary>Escribe la cadena especificada y el valor de <see cref="P:System.IO.Ports.SerialPort.NewLine" /> en el búfer de salida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si hay demasiados bytes en el búfer de entrada y <xref:System.IO.Ports.SerialPort.Handshake%2A> está establecido en <xref:System.IO.Ports.Handshake.XOnXOff> la <xref:System.IO.Ports.SerialPort> puede producir el objeto un <xref:System.ServiceProcess.TimeoutException> mientras espera a que el dispositivo esté listo para aceptar más datos.  
  
 La salida escrita incluye la <xref:System.IO.Ports.SerialPort.NewLine%2A> cadena.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir que dos usuarios puedan charlar desde dos equipos independientes conectados mediante un cable de módem nulo. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="text" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.TimeoutException">El método <see cref="M:System.IO.Ports.SerialPort.WriteLine(System.String)" /> no pudo escribir en la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número de milisegundos que transcurren antes de que se agote el tiempo de espera si una operación de escritura no finaliza.</summary>
        <value>El número de milisegundos que transcurren antes de que se agote el tiempo de espera. El valor predeterminado es <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de tiempo de espera de escritura se estableció originalmente en 500 milisegundos en la API de comunicaciones de Win32. Esta propiedad permite establecer este valor. El tiempo de espera se puede establecer en cualquier valor mayor que cero o establecido en <xref:System.IO.Ports.SerialPort.InfiniteTimeout>, en cuyo caso se produce ningún tiempo de espera. <xref:System.IO.Ports.SerialPort.InfiniteTimeout> es el valor predeterminado.  
  
> [!NOTE]
>  Los usuarios de la no administrada `COMMTIMEOUTS` estructura cabría esperar establecer el valor de tiempo de espera en cero para suprimir los tiempos de espera. Para suprimir los tiempos de espera con la <xref:System.IO.Ports.SerialPort.WriteTimeout%2A> propiedad, sin embargo, se debe especificar <xref:System.IO.Ports.SerialPort.InfiniteTimeout>.  
  
 Esta propiedad no afecta a la <xref:System.IO.Stream.BeginWrite%2A> método de la secuencia devuelta por la <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir que dos usuarios puedan charlar desde dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios le pedirá la configuración del puerto y un nombre de usuario antes de chat. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
 \- o -  
  
 Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <see cref="P:System.IO.Ports.SerialPort.WriteTimeout" /> es menor que cero y distinto de <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>