<Type Name="SerialPort" FullName="System.IO.Ports.SerialPort">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0d59d268cffda70d3f8a591609547cdc12b4bcff" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49134766" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SerialPort : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SerialPort extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.IO.Ports.SerialPort" />
  <TypeSignature Language="VB.NET" Value="Public Class SerialPort&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class SerialPort : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type SerialPort = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.Ports</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("SerialPortDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un recurso de puerto serie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta clase para controlar un recurso de archivos de puerto serie. Esta clase proporciona E/S sincrónica y orientada a eventos, acceso a los Estados de conexión e interrupción y acceso a las propiedades del controlador serie. Además, la funcionalidad de esta clase puede colocarse en una instancia interna <xref:System.IO.Stream> objeto, accesible a través de la <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad y se pasa a las clases que ajustan o utilizan secuencias.  
  
 El <xref:System.IO.Ports.SerialPort> clase admite las codificaciones siguientes: <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF32Encoding>y cualquier codificación definida en mscorlib.dll donde la página de códigos es menor que 50000 o la página de códigos es 54936.  Puede utilizar codificaciones alternativas, pero debe usar el <xref:System.IO.Ports.SerialPort.ReadByte%2A> o <xref:System.IO.Ports.SerialPort.Write%2A> método y realizar la codificación por sí mismo.  
  
 Usa el <xref:System.IO.Ports.SerialPort.GetPortNames%2A> método para recuperar los puertos válidos para el equipo actual.  
  
 Si un <xref:System.IO.Ports.SerialPort> objeto queda bloqueado durante una operación de lectura, no anular el subproceso. En su lugar, cierre la base de transmitir o desechar la <xref:System.IO.Ports.SerialPort> objeto.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir a los dos usuarios chat de dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios se le solicitará un nombre de usuario y la configuración de puerto antes de la charla. Ambos equipos deben estar ejecutando el programa para lograr una funcionalidad completa de este ejemplo.  
  
 [!code-cpp[System.IO.Ports.SerialPort#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#10)]
 [!code-csharp[System.IO.Ports.SerialPort#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#10)]
 [!code-vb[System.IO.Ports.SerialPort#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#10)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Ports.SerialPort" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor utiliza los valores de propiedad predeterminados cuando se especifica ninguno. Por ejemplo, el <xref:System.IO.Ports.SerialPort.DataBits%2A> propiedad el valor predeterminado es 8, el <xref:System.IO.Ports.SerialPort.Parity%2A> propiedad como valor predeterminado el `None` valor de enumeración, el <xref:System.IO.Ports.SerialPort.StopBits%2A> propiedad el valor predeterminado es 1 y un nombre de puerto predeterminado de COM1.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir a los dos usuarios chat de dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios se le solicitará un nombre de usuario y la configuración de puerto antes de la charla. Este ejemplo de código forma parte de un ejemplo de código más extenso proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (System.ComponentModel.IContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.ComponentModel.IContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (container As IContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::ComponentModel::IContainer ^ container);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : System.ComponentModel.IContainer -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort container" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
      </Parameters>
      <Docs>
        <param name="container">Interfaz a un contenedor.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Ports.SerialPort" /> utilizando el objeto <see cref="T:System.ComponentModel.IContainer" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor utiliza los valores de propiedad predeterminados cuando se especifica ninguno. Por ejemplo, el <xref:System.IO.Ports.SerialPort.DataBits%2A> propiedad el valor predeterminado es 8, el <xref:System.IO.Ports.SerialPort.Parity%2A> propiedad como valor predeterminado el `None` valor de enumeración, el <xref:System.IO.Ports.SerialPort.StopBits%2A> propiedad el valor predeterminado es 1 y un nombre de puerto predeterminado de COM1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto especificado no se encuentra o no se puede abrir.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort portName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="portName">Puerto que se va a utilizar (por ejemplo, COM1).</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.IO.Ports.SerialPort" /> utilizando el nombre de puerto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para crear una nueva instancia de la <xref:System.IO.Ports.SerialPort> clase cuando desee especificar el nombre del puerto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto especificado no se encuentra o no se puede abrir.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String, baudRate As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="portName">Puerto que se va a utilizar (por ejemplo, COM1).</param>
        <param name="baudRate">Velocidad en baudios.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.IO.Ports.SerialPort" /> utilizando el nombre de puerto y la velocidad en baudios especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para crear una nueva instancia de la <xref:System.IO.Ports.SerialPort> clase cuando desee especificar el nombre del puerto y la velocidad en baudios.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto especificado no se encuentra o no se puede abrir.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
      </Parameters>
      <Docs>
        <param name="portName">Puerto que se va a utilizar (por ejemplo, COM1).</param>
        <param name="baudRate">Velocidad en baudios.</param>
        <param name="parity">Uno de los valores de <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.IO.Ports.SerialPort" /> utilizando el nombre del puerto, la velocidad en baudios y el bit de paridad especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para crear una nueva instancia de la <xref:System.IO.Ports.SerialPort> clase cuando desee especificar el nombre del puerto, la velocidad en baudios y el bit de paridad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto especificado no se encuentra o no se puede abrir.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity, int32 dataBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity, int dataBits);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity * int -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity, dataBits)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
        <Parameter Name="dataBits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="portName">Puerto que se va a utilizar (por ejemplo, COM1).</param>
        <param name="baudRate">Velocidad en baudios.</param>
        <param name="parity">Uno de los valores de <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <param name="dataBits">Valor de bits de datos.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.IO.Ports.SerialPort" /> utilizando el nombre del puerto, la velocidad en baudios, el bit de paridad y los bits de datos especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para crear una nueva instancia de la <xref:System.IO.Ports.SerialPort> clase cuando desee especificar el nombre del puerto, la velocidad en baudios, el bit de paridad y los bits de datos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto especificado no se encuentra o no se puede abrir.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits, System.IO.Ports.StopBits stopBits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity, int32 dataBits, valuetype System.IO.Ports.StopBits stopBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity,System.Int32,System.IO.Ports.StopBits)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity, int dataBits, System::IO::Ports::StopBits stopBits);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity * int * System.IO.Ports.StopBits -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity, dataBits, stopBits)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
        <Parameter Name="dataBits" Type="System.Int32" />
        <Parameter Name="stopBits" Type="System.IO.Ports.StopBits" />
      </Parameters>
      <Docs>
        <param name="portName">Puerto que se va a utilizar (por ejemplo, COM1).</param>
        <param name="baudRate">Velocidad en baudios.</param>
        <param name="parity">Uno de los valores de <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <param name="dataBits">Valor de bits de datos.</param>
        <param name="stopBits">Uno de los valores de <see cref="P:System.IO.Ports.SerialPort.StopBits" />.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.IO.Ports.SerialPort" /> utilizando el nombre del puerto, la velocidad en baudios, el bit de paridad, los bits de datos y el bit de parada especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para crear una nueva instancia de la <xref:System.IO.Ports.SerialPort> clase cuando desee especificar el nombre del puerto, la velocidad en baudios, el bit de paridad, los bits de datos y el bit de parada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto especificado no se encuentra o no se puede abrir.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.Ports.SerialPort.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.IO.Stream" /> subyacente para un objeto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>Un objeto <see cref="T:System.IO.Stream" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta propiedad para las operaciones de E/S asincrónicas explícitas o para pasar el <xref:System.IO.Ports.SerialPort> objeto a un <xref:System.IO.Stream> clase contenedora como <xref:System.IO.StreamWriter>.  
  
 Abra los del puerto serie <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad devuelve un objeto que se deriva de la clase abstracta <xref:System.IO.Stream> clase e implementa, leer y escribir métodos mediante los prototipos se hereda de la <xref:System.IO.Stream> clase: <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.BeginWrite%2A>, <xref:System.IO.Stream.Read%2A> , <xref:System.IO.Stream.ReadByte%2A>, <xref:System.IO.Stream.Write%2A>, y <xref:System.IO.Stream.WriteByte%2A>. Estos métodos pueden ser útiles al pasar de un recurso de la serie ajustado a un <xref:System.IO.Stream> clase contenedora.  
  
 Debido a la inaccesibilidad del identificador de archivo ajustada, el <xref:System.IO.Stream.Length%2A> y <xref:System.IO.Stream.Position%2A> no se admiten las propiedades y el <xref:System.IO.Stream.Seek%2A> y <xref:System.IO.Stream.SetLength%2A> no se admiten métodos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
        <exception cref="T:System.NotSupportedException">La secuencia está en una aplicación .NET Compact Framework y se llamó a uno de los métodos siguientes: 
 <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /><see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /><see cref="M:System.IO.Stream.EndRead(System.IAsyncResult)" /><see cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />  
  
.NET Compact Framework no admite el modelo asincrónico con secuencias base.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaudRate">
      <MemberSignature Language="C#" Value="public int BaudRate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BaudRate" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BaudRate" />
      <MemberSignature Language="VB.NET" Value="Public Property BaudRate As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BaudRate { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BaudRate : int with get, set" Usage="System.IO.Ports.SerialPort.BaudRate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(9600)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("BaudRate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la velocidad en baudios del puerto serie.</summary>
        <value>Velocidad en baudios.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La velocidad en baudios debe ser compatibles con el controlador de serie del usuario. El valor predeterminado es 9600 bits por segundo (bps).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer el <xref:System.IO.Ports.SerialPort.BaudRate%2A> propiedad `9600`.  
  
 [!code-cpp[System.IO.Ports.SerialPort#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#20)]
 [!code-csharp[System.IO.Ports.SerialPort#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#20)]
 [!code-vb[System.IO.Ports.SerialPort#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#20)]  
  
 En el ejemplo siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir a los dos usuarios chat de dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios se le solicitará un nombre de usuario y la configuración de puerto antes de la charla. Este ejemplo de código forma parte de un ejemplo de código más extenso proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La velocidad en baudios especificada es menor o igual que cero o es mayor que la velocidad en baudios máxima permitida para el dispositivo.</exception>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
      </Docs>
    </Member>
    <Member MemberName="BreakState">
      <MemberSignature Language="C#" Value="public bool BreakState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BreakState" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BreakState" />
      <MemberSignature Language="VB.NET" Value="Public Property BreakState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BreakState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BreakState : bool with get, set" Usage="System.IO.Ports.SerialPort.BreakState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el estado de la señal de interrupción.</summary>
        <value>Es <see langword="true" /> si el puerto está en un estado de interrupción; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El estado de la señal de interrupción se produce cuando se suspende una transmisión y la línea se coloca en un estado de interrupción (bajo todas, ningún bit de parada) hasta que publique. Para especificar un estado de interrupción, establezca esta propiedad en `true`. Si el puerto ya está en estado de interrupción, al establecer esta propiedad a `true` no produce una excepción. No es posible escribir en el <xref:System.IO.Ports.SerialPort> objeto mientras <xref:System.IO.Ports.SerialPort.BreakState%2A> es `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesToRead">
      <MemberSignature Language="C#" Value="public int BytesToRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesToRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BytesToRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesToRead As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesToRead { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesToRead : int" Usage="System.IO.Ports.SerialPort.BytesToRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de bytes de datos en el búfer de recepción.</summary>
        <value>El número de bytes de datos en el búfer de recepción.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El búfer de recepción incluye el controlador serie búfer de recepción, así como el almacenamiento en búfer interno en el <xref:System.IO.Ports.SerialPort> propio objeto.  
  
 Dado que el <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad representa tanto la <xref:System.IO.Ports.SerialPort> búfer y el creado en Windows, puede devolver un valor mayor que el <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> propiedad, que representa sólo el búfer creado en Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El puerto no está abierto.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesToWrite">
      <MemberSignature Language="C#" Value="public int BytesToWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesToWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BytesToWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesToWrite As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesToWrite { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesToWrite : int" Usage="System.IO.Ports.SerialPort.BytesToWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de bytes de datos en el búfer de envío.</summary>
        <value>El número de bytes de datos en el búfer de envío.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El búfer de envío incluye el controlador serie búfer de envío, así como el almacenamiento en búfer interno en el <xref:System.IO.Ports.SerialPort> propio objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CDHolding">
      <MemberSignature Language="C#" Value="public bool CDHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CDHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.CDHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CDHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CDHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CDHolding : bool" Usage="System.IO.Ports.SerialPort.CDHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el estado de la línea de detección de portadora para el puerto.</summary>
        <value>Es <see langword="true" /> si se detecta la portadora; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad puede usarse para supervisar el estado de la línea de detección de portadora para un puerto. Ningún operador suele indica que el receptor ha colgado y se ha quitado el transportista.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="serialPort.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra la conexión del puerto, establece el valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> en <see langword="false" /> y elimina el objeto <see cref="T:System.IO.Stream" /> interno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método cierra el <xref:System.IO.Ports.SerialPort> objeto y borra tanto la recepción y búferes de transmisión. Este método llama a la <xref:System.ComponentModel.Component.Dispose?displayProperty=nameWithType> método, que invoca la protegido <xref:System.IO.Ports.SerialPort.Dispose%28System.Boolean%29?displayProperty=nameWithType> método con el `disposing` parámetro establecido en `true`.  
  
 El procedimiento recomendado para cualquier aplicación es esperar durante algún tiempo después de llamar a la <xref:System.IO.Ports.SerialPort.Close%2A> método antes de intentar llamar a la <xref:System.IO.Ports.SerialPort.Open%2A> método, como el puerto no se puede cerrar al instante.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir a los dos usuarios chat de dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios se le solicitará un nombre de usuario y la configuración de puerto antes de la charla. Este ejemplo de código forma parte de un ejemplo de código más extenso proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
      </Docs>
    </Member>
    <Member MemberName="CtsHolding">
      <MemberSignature Language="C#" Value="public bool CtsHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CtsHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.CtsHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CtsHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CtsHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CtsHolding : bool" Usage="System.IO.Ports.SerialPort.CtsHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el estado de la línea Listo para enviar.</summary>
        <value>Es <see langword="true" /> si se detecta la línea Listo para enviar; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La línea Listo para enviar (CTS) se usa en la solicitud de envío/listo para enviar el protocolo de hardware (RTS/CTS). La línea de CTS se consulta por un puerto antes de enviar datos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataBits">
      <MemberSignature Language="C#" Value="public int DataBits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DataBits" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DataBits" />
      <MemberSignature Language="VB.NET" Value="Public Property DataBits As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DataBits { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DataBits : int with get, set" Usage="System.IO.Ports.SerialPort.DataBits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DataBits")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la longitud estándar de los bits de datos por byte.</summary>
        <value>La longitud de los bits de datos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El intervalo de valores para esta propiedad es de 5 a 8. El valor predeterminado es 8.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir a los dos usuarios chat de dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios se le solicitará un nombre de usuario y la configuración de puerto antes de la charla. Este ejemplo de código forma parte de un ejemplo de código más extenso proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de los bits de datos es menor que 5 o mayor que 8.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataReceived">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialDataReceivedEventHandler DataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialDataReceivedEventHandler DataReceived" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.DataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataReceived As SerialDataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialDataReceivedEventHandler ^ DataReceived;" />
      <MemberSignature Language="F#" Value="member this.DataReceived : System.IO.Ports.SerialDataReceivedEventHandler " Usage="member this.DataReceived : System.IO.Ports.SerialDataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialDataReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialDataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica que se recibieron datos a través de un puerto representado por el objeto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventos de datos pueden deberse a alguno de los elementos en el <xref:System.IO.Ports.SerialData> enumeración. Dado que el sistema operativo determina si se produce este evento, o no, no todos los errores de paridad se pueden notificar.  
  
 El <xref:System.IO.Ports.SerialPort.DataReceived> evento también se genera si se recibe un carácter Eof, sin tener en cuenta el número de bytes del búfer de entrada interno y el valor de la <xref:System.IO.Ports.SerialPort.ReceivedBytesThreshold%2A> propiedad.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, y <xref:System.IO.Ports.SerialPort.ErrorReceived> eventos pueden llamarse sin orden, y puede haber un ligero retraso entre cuando la secuencia subyacente notifica el error y cuando se ejecuta el controlador de eventos. Puede ejecutar un solo controlador de eventos a la vez.  
  
 El <xref:System.IO.Ports.SerialPort.DataReceived> no se garantiza que el evento se desencadena para cada byte recibido. Use el <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad para determinar cuántos datos se deja para poder leerse en el búfer.  
  
 El <xref:System.IO.Ports.SerialPort.DataReceived> evento se provoca en un subproceso secundario cuando se reciben datos desde el <xref:System.IO.Ports.SerialPort> objeto. Dado que este evento se provoca en un subproceso secundario, y no es el subproceso principal, se intenta modificar algunos elementos en el subproceso principal, como elementos de interfaz de usuario, podría producirse una excepción. Si es necesario modificar los elementos de los principales <xref:System.Windows.Forms.Form> o <xref:System.Windows.Forms.Control>, con las solicitudes de cambio de post <xref:System.Windows.Forms.Control.Invoke%2A>, que realizará el trabajo en el subproceso adecuado.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Este ejemplo se agrega un <xref:System.IO.Ports.SerialDataReceivedEventHandler> a <xref:System.IO.Ports.SerialPort.DataReceived> para leer todos los datos recibidos en el puerto COM1. Tenga en cuenta que para probar este código es necesario disponer de hardware conectado a COM1 que va a enviar datos.  
  
 [!code-cpp[System.IO.Ports.SerialPort#06](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#06)]
 [!code-csharp[System.IO.Ports.SerialPort#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#06)]
 [!code-vb[System.IO.Ports.SerialPort#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#06)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardInBuffer">
      <MemberSignature Language="C#" Value="public void DiscardInBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardInBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.DiscardInBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardInBuffer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardInBuffer();" />
      <MemberSignature Language="F#" Value="member this.DiscardInBuffer : unit -&gt; unit" Usage="serialPort.DiscardInBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Descarta los datos del búfer de recepción del controlador serie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es equivalente al siguiente código de Visual Basic: `MSComm1.InBufferCount = 0`. Borra el búfer de recepción, pero no afecta el búfer de transmisión.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DiscardNull">
      <MemberSignature Language="C#" Value="public bool DiscardNull { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DiscardNull" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DiscardNull" />
      <MemberSignature Language="VB.NET" Value="Public Property DiscardNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DiscardNull { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DiscardNull : bool with get, set" Usage="System.IO.Ports.SerialPort.DiscardNull" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DiscardNull")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si no se tienen en cuenta los bytes nulos en las transmisiones entre el puerto y el búfer de recepción.</summary>
        <value>Es <see langword="true" /> si los bytes nulos no se tienen en cuenta; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, este valor debe establecerse en `false`, especialmente para las transmisiones binarias.  Establecer esta propiedad en `true` puede producir resultados inesperados de bytes codificados UTF32 y UTF16.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DiscardOutBuffer">
      <MemberSignature Language="C#" Value="public void DiscardOutBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardOutBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.DiscardOutBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardOutBuffer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardOutBuffer();" />
      <MemberSignature Language="F#" Value="member this.DiscardOutBuffer : unit -&gt; unit" Usage="serialPort.DiscardOutBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Descarta los datos del búfer de transmisión del controlador serie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es equivalente al siguiente código de Visual Basic: `MSComm1.OutBufferCount = 0`. Borra el búfer de transmisión, pero no afecta al búfer de recepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="serialPort.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usa <see cref="T:System.IO.Ports.SerialPort" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama por el público <xref:System.ComponentModel.Component.Dispose%2A> método y el <xref:System.Object.Finalize%2A> método. <xref:System.ComponentModel.Component.Dispose%2A> invoca el protegido <xref:System.IO.Ports.SerialPort.Dispose%2A> método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca <xref:System.IO.Ports.SerialPort.Dispose%2A> con `disposing` establecido en `false`.  
  
 Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.IO.Ports.SerialPort> hace referencia. Este método invoca al método <xref:System.ComponentModel.Component.Dispose%2A> de cada uno de los objetos a los que se hace referencia.  
  
 Este método vacía y cierra el objeto de secuencia el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> puede recibir varias llamadas de otros objetos. Al invalidar <see cref="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see cref="M:System.ComponentModel.Component.Dispose" />. Para obtener más información sobre cómo implementar <see cref="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />, consulte [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Para obtener más información acerca de <see cref="M:System.ComponentModel.Component.Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DsrHolding">
      <MemberSignature Language="C#" Value="public bool DsrHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DsrHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DsrHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DsrHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DsrHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DsrHolding : bool" Usage="System.IO.Ports.SerialPort.DsrHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el estado de la señal Conjunto de datos preparado (DSR).</summary>
        <value>Es <see langword="true" /> si se ha enviado al puerto una señal Conjunto de datos preparado; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se usa en el protocolo de enlace de conjunto de datos listo o Terminal de datos preparado (DSR/DTR). La señal conjunto de datos preparado (DSR) normalmente se envía por un módem de acceso a un puerto para indicar que está listo para la transmisión de datos o recibir datos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está cerrada. Esto puede deberse a que no se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Open" /> o a que se ha llamado al método <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DtrEnable">
      <MemberSignature Language="C#" Value="public bool DtrEnable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DtrEnable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DtrEnable" />
      <MemberSignature Language="VB.NET" Value="Public Property DtrEnable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DtrEnable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DtrEnable : bool with get, set" Usage="System.IO.Ports.SerialPort.DtrEnable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DtrEnable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que habilita la señal Terminal de datos preparado (DTR) durante la comunicación en serie.</summary>
        <value>Es <see langword="true" /> para habilitar Terminal de datos preparado (DTR); de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente se habilita el Terminal de datos preparado (DTR) durante el protocolo de software XON/XOFF y solicitud de envío/listo para enviar el protocolo de hardware (RTS/CTS) y las comunicaciones de módem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding Encoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : System.Text.Encoding with get, set" Usage="System.IO.Ports.SerialPort.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Encoding")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la codificación de bytes para la conversión de texto previa y posterior a la transmisión.</summary>
        <value>Un objeto <see cref="T:System.Text.Encoding" />. El valor predeterminado es <see cref="T:System.Text.ASCIIEncoding" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La propiedad <see cref="P:System.IO.Ports.SerialPort.Encoding" /> se estableció en <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.Encoding" /> se estableció en una codificación que no es <see cref="T:System.Text.ASCIIEncoding" />, <see cref="T:System.Text.UTF8Encoding" />, <see cref="T:System.Text.UTF32Encoding" />, <see cref="T:System.Text.UnicodeEncoding" />, una de las codificaciones de byte único de Windows o una de las codificaciones de byte doble de Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="ErrorReceived">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialErrorReceivedEventHandler ErrorReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialErrorReceivedEventHandler ErrorReceived" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.ErrorReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorReceived As SerialErrorReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialErrorReceivedEventHandler ^ ErrorReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorReceived : System.IO.Ports.SerialErrorReceivedEventHandler " Usage="member this.ErrorReceived : System.IO.Ports.SerialErrorReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialErrorReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialErrorReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica que hubo un error en el puerto representado por el objeto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventos de error pueden deberse a alguno de los elementos en el <xref:System.IO.Ports.SerialError> enumeración. Dado que el sistema operativo determina si se produce este evento, o no, no todos los errores de paridad se pueden notificar.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, y <xref:System.IO.Ports.SerialPort.ErrorReceived> eventos pueden llamarse sin orden, y puede haber un ligero retraso entre cuando la secuencia subyacente notifica el error y el momento cuando se ejecuta el controlador de eventos. Puede ejecutar un solo controlador de eventos a la vez.  
  
 Si se produce un error de paridad en el byte final de una secuencia, se agregará un byte adicional para el búfer de entrada con un valor de 126.  
  
 El <xref:System.IO.Ports.SerialPort.ErrorReceived> evento se provoca en un subproceso secundario cuando se recibe un error de la <xref:System.IO.Ports.SerialPort> objeto. Dado que este evento se provoca en un subproceso secundario, y no es el subproceso principal, se intenta modificar algunos elementos en el subproceso principal, como elementos de interfaz de usuario, podría producirse una excepción. Si es necesario modificar los elementos de los principales <xref:System.Windows.Forms.Form> o <xref:System.Windows.Forms.Control>, con las solicitudes de cambio de post <xref:System.Windows.Forms.Control.Invoke%2A>, que realizará el trabajo en el subproceso adecuado.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPortNames">
      <MemberSignature Language="C#" Value="public static string[] GetPortNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetPortNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.GetPortNames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPortNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetPortNames();" />
      <MemberSignature Language="F#" Value="static member GetPortNames : unit -&gt; string[]" Usage="System.IO.Ports.SerialPort.GetPortNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene una matriz con los nombres de los puertos serie del equipo actual.</summary>
        <returns>Una matriz con los nombres de los puertos serie del equipo actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El orden de los nombres de puerto devueltos desde <xref:System.IO.Ports.SerialPort.GetPortNames%2A> no se especifica.  
  
 Use el <xref:System.IO.Ports.SerialPort.GetPortNames%2A> método para consultar el equipo actual para obtener una lista de nombres de puerto serie válido. Por ejemplo, puede usar este método para determinar si COM1 y COM2 son los puertos serie válidos para el equipo actual.  
  
 Los nombres de puerto se obtienen del registro del sistema (por ejemplo, HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\SERIALCOMM). Si el registro contiene datos obsoletos o incorrectos el <xref:System.IO.Ports.SerialPort.GetPortNames%2A> método devolverá datos incorrectos.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.IO.Ports.SerialPort.GetPortNames%2A> método para mostrar los nombres de puerto serie en la consola.  
  
 [!code-cpp[IO.Ports.GetPortNames#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Ports.GetPortNames/cpp/example.cpp#1)]
 [!code-csharp[IO.Ports.GetPortNames#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Ports.GetPortNames/CS/example.cs#1)]
 [!code-vb[IO.Ports.GetPortNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Ports.GetPortNames/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">No se pudieron consultar los nombres de puerto serie.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handshake">
      <MemberSignature Language="C#" Value="public System.IO.Ports.Handshake Handshake { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.Handshake Handshake" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Handshake" />
      <MemberSignature Language="VB.NET" Value="Public Property Handshake As Handshake" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::Handshake Handshake { System::IO::Ports::Handshake get(); void set(System::IO::Ports::Handshake value); };" />
      <MemberSignature Language="F#" Value="member this.Handshake : System.IO.Ports.Handshake with get, set" Usage="System.IO.Ports.SerialPort.Handshake" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handshake")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.Handshake</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el protocolo de enlace para la transmisión de datos a través del puerto serie desde <see cref="T:System.IO.Ports.Handshake" />.</summary>
        <value>Uno de los valores de <see cref="T:System.IO.Ports.Handshake" />. El valor predeterminado es <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se usa el protocolo de enlace, el dispositivo conectado a la <xref:System.IO.Ports.SerialPort> objeto se indica a detener el envío de datos cuando hay al menos (<xref:System.IO.Ports.SerialPort.ReadBufferSize%2A>-1024) bytes del búfer. El dispositivo se indica a empezar a enviar datos de nuevo cuando hay 1024 o menos bytes en el búfer. Si el dispositivo envía datos en bloques de más de 1024 bytes, esto puede provocar el desbordamiento del búfer.  
  
 Si el <xref:System.IO.Ports.SerialPort.Handshake%2A> propiedad está establecida en <xref:System.IO.Ports.Handshake.RequestToSendXOnXOff> y <xref:System.IO.Ports.SerialPort.CtsHolding%2A> está establecido en `false`, no se enviará el carácter XOff. Si <xref:System.IO.Ports.SerialPort.CtsHolding%2A> , a continuación, se establece en `true`, antes de que el carácter XOff se enviarán más datos que se deben enviar.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir a los dos usuarios chat de dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios se le solicitará un nombre de usuario y la configuración de puerto antes de la charla. Este ejemplo de código forma parte de un ejemplo de código más extenso proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor pasado no es un valor válido de la enumeración <see cref="T:System.IO.Ports.Handshake" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public const int InfiniteTimeout = -1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 InfiniteTimeout = (-1)" />
      <MemberSignature Language="DocId" Value="F:System.IO.Ports.SerialPort.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const InfiniteTimeout As Integer  = -1" />
      <MemberSignature Language="C++ CLI" Value="public: int InfiniteTimeout = -1;" />
      <MemberSignature Language="F#" Value="val mutable InfiniteTimeout : int" Usage="System.IO.Ports.SerialPort.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>-1</MemberValue>
      <Docs>
        <summary>Indica que no se debe agotar el tiempo de espera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor se usa con el <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> y <xref:System.IO.Ports.SerialPort.WriteTimeout%2A> propiedades.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOpen">
      <MemberSignature Language="C#" Value="public bool IsOpen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOpen" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.IsOpen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOpen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOpen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOpen : bool" Usage="System.IO.Ports.SerialPort.IsOpen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica el estado abierto o cerrado del objeto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>Es <see langword="true" /> si el puerto serie está abierto; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Ports.SerialPort.IsOpen%2A> propiedad realiza un seguimiento si el puerto está abierto para su uso por el llamador, no si el puerto está abierto por cualquier aplicación en el equipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> pasado es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El valor <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> pasado es una cadena vacía ("").</exception>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public string NewLine { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ NewLine { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string with get, set" Usage="System.IO.Ports.SerialPort.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("\n")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("NewLine")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor utilizado para interpretar el final de una llamada a los métodos <see cref="M:System.IO.Ports.SerialPort.ReadLine" /> y <see cref="M:System.IO.Ports.SerialPort.WriteLine(System.String)" />.</summary>
        <value>Un valor que representa el final de una línea. El valor predeterminado es un avance de línea, <see cref="P:System.Environment.NewLine" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad determina qué valor (bytes) define el final de una línea para el <xref:System.IO.Ports.SerialPort.ReadLine%2A> y <xref:System.IO.Ports.SerialPort.WriteLine%2A> métodos. De forma predeterminada es el valor final de línea <xref:System.Environment.NewLine%2A>. Podría cambiar a un valor diferente si está trabajando con el dispositivo en serie determinado utiliza un valor diferente para el mismo propósito.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de propiedad está vacío.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de la propiedad es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public void Open ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Open() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Open" />
      <MemberSignature Language="VB.NET" Value="Public Sub Open ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Open();" />
      <MemberSignature Language="F#" Value="member this.Open : unit -&gt; unit" Usage="serialPort.Open " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Abre una nueva conexión de puerto serie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede haber solo una conexión abierta cada <xref:System.IO.Ports.SerialPort> objeto.  
  
 El procedimiento recomendado para cualquier aplicación es esperar durante algún tiempo después de llamar a la <xref:System.IO.Ports.SerialPort.Close%2A> método antes de intentar llamar a la <xref:System.IO.Ports.SerialPort.Open%2A> método, como el puerto no se puede cerrar al instante.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir a los dos usuarios chat de dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios se le solicitará un nombre de usuario y la configuración de puerto antes de la charla. Este ejemplo de código forma parte de un ejemplo de código más extenso proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Se deniega el acceso al puerto.  
  
\- o - 
El proceso actual u otro proceso en el sistema ya tiene el puerto COM especificado abierto por una instancia <see cref="T:System.IO.Ports.SerialPort" /> o en código no administrado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una o varias de las propiedades de esta instancia no son válidas. Por ejemplo, las propiedades <see cref="P:System.IO.Ports.SerialPort.Parity" />, <see cref="P:System.IO.Ports.SerialPort.DataBits" /> o <see cref="P:System.IO.Ports.SerialPort.Handshake" /> no tienen valores válidos; el valor de <see cref="P:System.IO.Ports.SerialPort.BaudRate" /> es menor o igual que cero; el valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.ReadTimeout" /> o <see cref="P:System.IO.Ports.SerialPort.WriteTimeout" /> es menor que cero y no es <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre del puerto no empieza por "COM".  
  
\- o - 
No se admite el tipo de archivo del puerto.</exception>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.InvalidOperationException">El puerto especificado en la instancia actual de <see cref="T:System.IO.Ports.SerialPort" /> ya está abierto.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Parity">
      <MemberSignature Language="C#" Value="public System.IO.Ports.Parity Parity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.Parity Parity" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Parity" />
      <MemberSignature Language="VB.NET" Value="Public Property Parity As Parity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::Parity Parity { System::IO::Ports::Parity get(); void set(System::IO::Ports::Parity value); };" />
      <MemberSignature Language="F#" Value="member this.Parity : System.IO.Ports.Parity with get, set" Usage="System.IO.Ports.SerialPort.Parity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Parity")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.Parity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el protocolo de comprobación de la paridad.</summary>
        <value>Uno de los valores de enumeración que representa el protocolo de comprobación de la paridad. El valor predeterminado es <see cref="F:System.IO.Ports.Parity.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Paridad es un procedimiento de comprobación de errores en el que el número de 1 siempre debe ser el mismo, par o impar, para cada grupo de bits que se transmite sin errores. En las comunicaciones al módem, paridad suele ser uno de los parámetros que deben ser acordados por las partes de envío y recepción de colocan las partes antes de realizar la transmisión.  
  
 Si se produce un error de paridad en el byte final de una secuencia, se agregará un byte adicional para el búfer de entrada con un valor de 126.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir a los dos usuarios chat de dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios se le solicitará un nombre de usuario y la configuración de puerto antes de la charla. Este ejemplo de código forma parte de un ejemplo de código más extenso proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <see cref="P:System.IO.Ports.SerialPort.Parity" /> pasado no es un valor válido en la enumeración <see cref="T:System.IO.Ports.Parity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ParityReplace">
      <MemberSignature Language="C#" Value="public byte ParityReplace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8 ParityReplace" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ParityReplace" />
      <MemberSignature Language="VB.NET" Value="Public Property ParityReplace As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Byte ParityReplace { System::Byte get(); void set(System::Byte value); };" />
      <MemberSignature Language="F#" Value="member this.ParityReplace : byte with get, set" Usage="System.IO.Ports.SerialPort.ParityReplace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(63)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ParityReplace")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el byte que reemplaza los bytes no válidos en una secuencia de datos cuando se produce un error de paridad.</summary>
        <value>Un byte que reemplaza los bytes no válidos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor se establece en el carácter null, se deshabilita el reemplazo de paridad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
      </Docs>
    </Member>
    <Member MemberName="PinChanged">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialPinChangedEventHandler PinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialPinChangedEventHandler PinChanged" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.PinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PinChanged As SerialPinChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialPinChangedEventHandler ^ PinChanged;" />
      <MemberSignature Language="F#" Value="member this.PinChanged : System.IO.Ports.SerialPinChangedEventHandler " Usage="member this.PinChanged : System.IO.Ports.SerialPinChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialPinChanged")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialPinChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica que hubo un evento de señal que no es de datos en el puerto representado por el objeto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cambia el punto de conexión serie eventos pueden deberse a alguno de los elementos en el <xref:System.IO.Ports.SerialPinChange> enumeración. Dado que el sistema operativo determina si se produce este evento, o no, no todos los errores de paridad se pueden notificar. Como parte del evento, se establece el valor nuevo del pin.  
  
 El <xref:System.IO.Ports.SerialPort.PinChanged> evento se desencadena cuando un <xref:System.IO.Ports.SerialPort> objeto entra en el <xref:System.IO.Ports.SerialPort.BreakState%2A>, pero no cuando se cierra el puerto el <xref:System.IO.Ports.SerialPort.BreakState%2A>. Este comportamiento no es aplicable a otros valores en el <xref:System.IO.Ports.SerialPinChange> enumeración.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, y <xref:System.IO.Ports.SerialPort.ErrorReceived> eventos pueden llamarse sin orden, y puede haber un ligero retraso entre cuando la secuencia subyacente notifica el error y cuando se ejecuta el controlador de eventos. Puede ejecutar un solo controlador de eventos a la vez.  
  
 El <xref:System.IO.Ports.SerialPort.PinChanged> evento se provoca en un subproceso secundario. Dado que este evento se provoca en un subproceso secundario, y no es el subproceso principal, se intenta modificar algunos elementos en el subproceso principal, como elementos de interfaz de usuario, podría producirse una excepción. Si es necesario modificar los elementos de los principales <xref:System.Windows.Forms.Form> o <xref:System.Windows.Forms.Control>, con las solicitudes de cambio de post <xref:System.Windows.Forms.Control.Invoke%2A>, que realizará el trabajo en el subproceso adecuado.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PortName">
      <MemberSignature Language="C#" Value="public string PortName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PortName" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.PortName" />
      <MemberSignature Language="VB.NET" Value="Public Property PortName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PortName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PortName : string with get, set" Usage="System.IO.Ports.SerialPort.PortName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("COM1")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PortName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el puerto de comunicaciones, incluidos por lo menos todos los puertos COM disponibles.</summary>
        <value>El puerto de comunicaciones. El valor predeterminado es COM1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se puede obtener una lista de nombres de puerto válido mediante la <xref:System.IO.Ports.SerialPort.GetPortNames%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir a los dos usuarios chat de dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios se le solicitará un nombre de usuario y la configuración de puerto antes de la charla. Este ejemplo de código forma parte de un ejemplo de código más extenso proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.IO.Ports.SerialPort.PortName" /> se estableció en un valor con una longitud de cero.  
  
O bien 
La propiedad <see cref="P:System.IO.Ports.SerialPort.PortName" /> se ha establecido en un valor que empieza por "\\\\".  
  
O bien 
El nombre del puerto no era válido.</exception>
        <exception cref="T:System.ArgumentNullException">La propiedad <see cref="P:System.IO.Ports.SerialPort.PortName" /> se estableció en <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El puerto especificado está abierto.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lee datos del búfer de entrada de <see cref="T:System.IO.Ports.SerialPort" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Read : byte[] * int * int -&gt; int" Usage="serialPort.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de bytes en la que se va a escribir la entrada.</param>
        <param name="offset">Desplazamiento de <c>buffer</c> en el que se van a escribir los bytes.</param>
        <param name="count">Número máximo de bytes que se pueden leer. Se leen menos bytes si <c>count</c> es mayor que el número de bytes del búfer de entrada.</param>
        <summary>Lee varios bytes del búfer de entrada de <see cref="T:System.IO.Ports.SerialPort" /> y los escribe en una matriz de bytes en la posición de desplazamiento especificada.</summary>
        <returns>Número de bytes leídos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si es necesario cambiar entre leer texto y leer datos binarios de la secuencia, seleccione un protocolo que defina cuidadosamente el límite entre el texto y datos binarios, como la lectura de bytes y descodificar los datos manualmente.  
  
 Dado que el <xref:System.IO.Ports.SerialPort> clase búferes de datos y la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad no es así, los dos pueden entrar en conflicto acerca de cuántos bytes están disponibles para leer.  El <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad puede indicar que hay bytes para leer, pero estos bytes podrían no ser accesibles para la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad porque se ha almacenado en búfer para el <xref:System.IO.Ports.SerialPort> clase.  
  
 El <xref:System.IO.Ports.SerialPort.Read%2A> método no bloquea las demás operaciones cuando el número de bytes leídos es igual a `count` pero hay bytes todavía no leídos en el puerto serie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El búfer pasado es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Los parámetros <paramref name="offset" /> o <paramref name="count" /> están fuera de una región válida del <paramref name="buffer" /> que se pasa. <paramref name="offset" /> o <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">La suma de <paramref name="offset" /> y <paramref name="count" /> es mayor que la longitud de <paramref name="buffer" />.</exception>
        <exception cref="T:System.TimeoutException">No había ningún byte disponible para la lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public int Read (char[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read(char[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (buffer As Char(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read(cli::array &lt;char&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Read : char[] * int * int -&gt; int" Usage="serialPort.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de caracteres en la que se va a escribir la entrada.</param>
        <param name="offset">Desplazamiento de <c>buffer</c> en el que se van a escribir los caracteres.</param>
        <param name="count">Número máximo de caracteres que se van a leer. Se leen menos caracteres si <c>count</c> es mayor que el número de caracteres del búfer de entrada.</param>
        <summary>Lee un número de caracteres del búfer de entrada de <see cref="T:System.IO.Ports.SerialPort" /> y los escribe en una matriz de caracteres en la posición de desplazamiento especificada.</summary>
        <returns>Número de caracteres que se han leído.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para leer caracteres desde el puerto serie.  
  
 Si es necesario cambiar entre leer texto y leer datos binarios de la secuencia, seleccione un protocolo que defina cuidadosamente el límite entre el texto y datos binarios, como la lectura de bytes y descodificar los datos manualmente.  
  
 Dado que el <xref:System.IO.Ports.SerialPort> clase búferes de datos y la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad no es así, los dos pueden entrar en conflicto sobre cuántos caracteres hay disponibles para su lectura.  El <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad puede indicar que hay caracteres para leer, pero estos caracteres podrían no ser accesibles para la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad porque se ha almacenado en búfer para el <xref:System.IO.Ports.SerialPort> clase.  
  
 El <xref:System.IO.Ports.SerialPort.Read%2A> método no bloquea las demás operaciones cuando el número de bytes leídos es igual a `count` pero hay bytes todavía no leídos en el puerto serie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La suma de <paramref name="offset" /> y <paramref name="count" /> es mayor que la longitud del búfer.  
  
\- o - 
 <paramref name="count" /> es 1 y hay un carácter suplente en el búfer.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="buffer" /> pasado es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Los parámetros <paramref name="offset" /> o <paramref name="count" /> están fuera de una región válida del <paramref name="buffer" /> que se pasa. <paramref name="offset" /> o <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.TimeoutException">No había ningún carácter disponible para la lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBufferSize">
      <MemberSignature Language="C#" Value="public int ReadBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReadBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadBufferSize : int with get, set" Usage="System.IO.Ports.SerialPort.ReadBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(4096)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReadBufferSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño del búfer de entrada de <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>Tamaño del búfer en bytes. El valor predeterminado es 4096; el valor máximo es el de un entero positivo, o 2147483647.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> propiedad omite cualquier valor inferior a 4096.  
  
 Dado que el <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> propiedad representa sólo el búfer creado en Windows, puede devolver un valor menor que el <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad, que representa tanto la <xref:System.IO.Ports.SerialPort> búfer y el creado en Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> es menor o igual que cero.</exception>
        <exception cref="T:System.InvalidOperationException">Se ha establecido el valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> mientras estaba abierta la secuencia.</exception>
        <exception cref="T:System.IO.IOException">Se ha establecido el valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> en un valor entero impar.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadByte();" />
      <MemberSignature Language="F#" Value="member this.ReadByte : unit -&gt; int" Usage="serialPort.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee sincrónicamente un byte del búfer de entrada de <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <returns>El byte, convertido en un <see cref="T:System.Int32" />, o -1 si se ha leído el final de la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee un byte.  
  
 Tenga cuidado cuando utilice <xref:System.IO.Ports.SerialPort.ReadByte%2A> y <xref:System.IO.Ports.SerialPort.ReadChar%2A> juntos. Cambiar entre bytes y leer caracteres puede hacer que los datos adicionales que deben leerse y otros comportamientos no deseados. Si es necesario cambiar entre leer texto y leer datos binarios de la secuencia, seleccione un protocolo que defina cuidadosamente el límite entre el texto y datos binarios, como la lectura de bytes y descodificar los datos manualmente.  
  
> [!NOTE]
>  Dado que el <xref:System.IO.Ports.SerialPort> clase búferes de datos y la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad no es así, los dos pueden entrar en conflicto acerca de cuántos bytes están disponibles para leer.  El <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad puede indicar que hay bytes para leer, pero estos bytes podrían no ser accesibles para la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad porque se ha almacenado en búfer para el <xref:System.IO.Ports.SerialPort> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">La operación no se ha terminado antes de que transcurriera el tiempo de espera.  
  
\- o - 
No se leyó ningún byte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadChar">
      <MemberSignature Language="C#" Value="public int ReadChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadChar" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadChar () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadChar();" />
      <MemberSignature Language="F#" Value="member this.ReadChar : unit -&gt; int" Usage="serialPort.ReadChar " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee sincrónicamente un carácter del búfer de entrada de <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <returns>El carácter leído.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee un carácter completo según la codificación.  
  
 Tenga cuidado cuando utilice <xref:System.IO.Ports.SerialPort.ReadByte%2A> y <xref:System.IO.Ports.SerialPort.ReadChar%2A> juntos. Cambiar entre bytes y leer caracteres puede hacer que los datos adicionales que deben leerse y otros comportamientos no deseados. Si es necesario cambiar entre leer texto y leer datos binarios de la secuencia, seleccione un protocolo que defina cuidadosamente el límite entre el texto y datos binarios, como la lectura de bytes y descodificar los datos manualmente.  
  
> [!NOTE]
>  Dado que el <xref:System.IO.Ports.SerialPort> clase búferes de datos y la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad no es así, los dos pueden entrar en conflicto acerca de cuántos bytes están disponibles para leer.  El <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad puede indicar que hay bytes para leer, pero estos bytes podrían no ser accesibles para la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad porque se ha almacenado en búfer para el <xref:System.IO.Ports.SerialPort> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">La operación no se ha terminado antes de que transcurriera el tiempo de espera.  
  
\- o - 
No estaba disponible ningún carácter en el período del tiempo de espera asignado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadExisting">
      <MemberSignature Language="C#" Value="public string ReadExisting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadExisting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadExisting" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadExisting () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadExisting();" />
      <MemberSignature Language="F#" Value="member this.ReadExisting : unit -&gt; string" Usage="serialPort.ReadExisting " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee todos los bytes inmediatamente disponibles, basándose en la codificación, en la secuencia y el búfer de entrada del objeto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <returns>El contenido de la secuencia y del búfer de entrada del objeto <see cref="T:System.IO.Ports.SerialPort" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve el contenido de la secuencia y el búfer interno de la <xref:System.IO.Ports.SerialPort> objeto como una cadena. Este método no utiliza un tiempo de espera. Tenga en cuenta que este método puede dejar los finales bytes iniciales en el búfer interno, lo que hace que el <xref:System.IO.Ports.SerialPort.BytesToRead%2A> valor mayor que cero.  
  
 Si es necesario cambiar entre leer texto y leer datos binarios de la secuencia, seleccione un protocolo que defina cuidadosamente el límite entre el texto y datos binarios, como la lectura de bytes y descodificar los datos manualmente.  
  
> [!NOTE]
>  El <xref:System.IO.Ports.SerialPort> clase datos en el búfer, pero el objeto stream contenido en el <xref:System.IO.Ports.SerialPort.BaseStream%2A?displayProperty=nameWithType> propiedad no es así. Por lo tanto, la <xref:System.IO.Ports.SerialPort> objeto y el objeto de secuencia pueden diferir en el número de bytes que están disponibles para leer. Cuando se almacenan en búfer los bytes a la <xref:System.IO.Ports.SerialPort> objeto, el <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad incluye estos bytes en su valor; sin embargo, estos bytes podrían no estar accesibles para la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="member this.ReadLine : unit -&gt; string" Usage="serialPort.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee hasta el valor de <see cref="P:System.IO.Ports.SerialPort.NewLine" /> en el búfer de entrada.</summary>
        <returns>El contenido del búfer de entrada hasta la primera vez que aparezca un valor de <see cref="P:System.IO.Ports.SerialPort.NewLine" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que aunque este método no devuelve el <xref:System.IO.Ports.SerialPort.NewLine%2A> valor, el <xref:System.IO.Ports.SerialPort.NewLine%2A> se quita el valor del búfer de entrada.  
  
 De forma predeterminada, el <xref:System.IO.Ports.SerialPort.ReadLine%2A> método se bloqueará hasta que se recibe una línea. Si no desea este comportamiento, establezca el <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> propiedad en cualquier valor distinto de cero para forzar la <xref:System.IO.Ports.SerialPort.ReadLine%2A> método inicie una <xref:System.TimeoutException> si una línea no está disponible en el puerto.  
  
 Si es necesario cambiar entre leer texto y leer datos binarios de la secuencia, seleccione un protocolo que defina cuidadosamente el límite entre el texto y datos binarios, como la lectura de bytes y descodificar los datos manualmente.  
  
> [!NOTE]
>  Dado que el <xref:System.IO.Ports.SerialPort> clase búferes de datos y la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad no es así, los dos pueden entrar en conflicto acerca de cuántos bytes están disponibles para leer.  El <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad puede indicar que hay bytes para leer, pero estos bytes podrían no ser accesibles para la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad porque se ha almacenado en búfer para el <xref:System.IO.Ports.SerialPort> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir a los dos usuarios chat de dos equipos independientes conectados mediante un cable de módem nulo. Este ejemplo de código forma parte de un ejemplo de código más extenso proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.TimeoutException">La operación no se ha terminado antes de que transcurriera el tiempo de espera.  
  
\- o - 
No se leyó ningún byte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.IO.Ports.SerialPort.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReadTimeout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número de milisegundos que transcurren antes de que se agote el tiempo de espera si una operación de lectura no finaliza.</summary>
        <value>El número de milisegundos que transcurren antes de que se agote el tiempo de espera si una operación de lectura no finaliza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de tiempo de espera de lectura se estableció originalmente en 500 milisegundos en la API de comunicaciones de Win32. Esta propiedad permite establecer este valor. El tiempo de espera se puede establecer en cualquier valor mayor que cero, o establecido en <xref:System.IO.Ports.SerialPort.InfiniteTimeout>, en cuyo caso se produce ningún tiempo de espera. <xref:System.IO.Ports.SerialPort.InfiniteTimeout> es el valor predeterminado.  
  
> [!NOTE]
>  Los usuarios de no administrado `COMMTIMEOUTS` estructura cabría esperar establecer el valor de tiempo de espera en cero para suprimir los tiempos de espera. Para suprimir los tiempos de espera con el <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> propiedad, sin embargo, debe especificar <xref:System.IO.Ports.SerialPort.InfiniteTimeout>.  
  
 Esta propiedad no afecta a la <xref:System.IO.Stream.BeginRead%2A> método de la secuencia devuelta por la <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir a los dos usuarios chat de dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios se le solicitará un nombre de usuario y la configuración de puerto antes de la charla. Este ejemplo de código forma parte de un ejemplo de código más extenso proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor del tiempo de espera de lectura es menor que cero y distinto de <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTo">
      <MemberSignature Language="C#" Value="public string ReadTo (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadTo(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadTo (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadTo(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.ReadTo : string -&gt; string" Usage="serialPort.ReadTo value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Valor que indica dónde se detiene la operación de lectura.</param>
        <summary>Lee una cadena hasta el <paramref name="value" /> especificado en el búfer de entrada.</summary>
        <returns>El contenido del búfer de entrada hasta el valor de <paramref name="value" /> especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee una cadena hasta el especificado `value`. Mientras que la cadena devuelta no incluye el `value`, el `value` se quita del búfer de entrada.  
  
 Si es necesario cambiar entre leer texto y leer datos binarios de la secuencia, seleccione un protocolo que defina cuidadosamente el límite entre el texto y datos binarios, como la lectura de bytes y descodificar los datos manualmente.  
  
> [!NOTE]
>  Dado que el <xref:System.IO.Ports.SerialPort> clase búferes de datos y la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad no es así, los dos pueden entrar en conflicto acerca de cuántos bytes están disponibles para leer.  El <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propiedad puede indicar que hay bytes para leer, pero estos bytes podrían no ser accesibles para la secuencia contenida en el <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad porque se ha almacenado en búfer para el <xref:System.IO.Ports.SerialPort> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud del parámetro <paramref name="value" /> es 0.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.TimeoutException">La operación no se ha terminado antes de que transcurriera el tiempo de espera.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceivedBytesThreshold">
      <MemberSignature Language="C#" Value="public int ReceivedBytesThreshold { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceivedBytesThreshold" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReceivedBytesThreshold" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceivedBytesThreshold As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceivedBytesThreshold { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceivedBytesThreshold : int with get, set" Usage="System.IO.Ports.SerialPort.ReceivedBytesThreshold" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReceivedBytesThreshold")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número de bytes en el búfer de entrada interno antes de que ocurra un evento <see cref="E:System.IO.Ports.SerialPort.DataReceived" />.</summary>
        <value>El número de bytes del búfer de entrada interno antes de que se genere un evento <see cref="E:System.IO.Ports.SerialPort.DataReceived" />. El valor predeterminado es 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Ports.SerialPort.DataReceived> evento también se produce si un <xref:System.IO.Ports.SerialData.Eof> recibe carácter, independientemente del número de bytes del búfer de entrada interno y el valor de la <xref:System.IO.Ports.SerialPort.ReceivedBytesThreshold%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <see cref="P:System.IO.Ports.SerialPort.ReceivedBytesThreshold" /> es menor o igual que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="RtsEnable">
      <MemberSignature Language="C#" Value="public bool RtsEnable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RtsEnable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.RtsEnable" />
      <MemberSignature Language="VB.NET" Value="Public Property RtsEnable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RtsEnable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RtsEnable : bool with get, set" Usage="System.IO.Ports.SerialPort.RtsEnable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("RtsEnable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la señal Solicitud de envío (RTS) está habilitada durante la comunicación en serie.</summary>
        <value>Es <see langword="true" /> para habilitar Solicitud de envío (RTS); de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La señal de envío (RTS) solicitud normalmente se usa en la solicitud de envío/listo para enviar el protocolo de hardware (RTS/CTS).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.RtsEnable" /> se estableció o se recuperó mientras el valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.Handshake" /> se establece en <see cref="F:System.IO.Ports.Handshake.RequestToSend" /> o <see cref="F:System.IO.Ports.Handshake.RequestToSendXOnXOff" />.</exception>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
      </Docs>
    </Member>
    <Member MemberName="StopBits">
      <MemberSignature Language="C#" Value="public System.IO.Ports.StopBits StopBits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.StopBits StopBits" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.StopBits" />
      <MemberSignature Language="VB.NET" Value="Public Property StopBits As StopBits" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::StopBits StopBits { System::IO::Ports::StopBits get(); void set(System::IO::Ports::StopBits value); };" />
      <MemberSignature Language="F#" Value="member this.StopBits : System.IO.Ports.StopBits with get, set" Usage="System.IO.Ports.SerialPort.StopBits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("StopBits")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.StopBits</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número estándar de bits de parada por byte.</summary>
        <value>Uno de los valores de <see cref="T:System.IO.Ports.StopBits" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor predeterminado de <xref:System.IO.Ports.SerialPort.StopBits%2A> es <xref:System.IO.Ports.StopBits.One>.  
  
 El <xref:System.IO.Ports.StopBits.None?displayProperty=nameWithType> valor no es compatible.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer el <xref:System.IO.Ports.SerialPort.StopBits%2A> propiedad `One`.  
  
 [!code-cpp[System.IO.Ports.SerialPort#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#20)]
 [!code-csharp[System.IO.Ports.SerialPort#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#20)]
 [!code-vb[System.IO.Ports.SerialPort#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#20)]  
  
 En el ejemplo siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir a los dos usuarios chat de dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios se le solicitará un nombre de usuario y la configuración de puerto antes de la charla. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor <see cref="P:System.IO.Ports.SerialPort.StopBits" /> es <see cref="F:System.IO.Ports.StopBits.None" />.</exception>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe datos en el búfer de salida del puerto serie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string text) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (text As String)" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
      <MemberSignature Language="C#" Value="public void Write (string str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string str) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.String)" FrameworkAlternate="xamarinmac-3.0;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (str As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="serialPort.Write str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="text">Cadena de salida.</param>
        <param name="str">Cadena de salida.</param>
        <summary>Escribe la cadena especificada en el puerto serie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando desea escribir una cadena como salida en un puerto serie.  
  
 Si hay demasiados bytes en el búfer de salida y <xref:System.IO.Ports.SerialPort.Handshake%2A> está establecido en <xref:System.IO.Ports.Handshake.XOnXOff> el <xref:System.IO.Ports.SerialPort> objeto puede generar un <xref:System.ServiceProcess.TimeoutException> mientras se espera el dispositivo esté listo para aceptar más datos.  
  
 De forma predeterminada, <xref:System.IO.Ports.SerialPort> usa <xref:System.Text.ASCIIEncoding> para codificar los caracteres. <xref:System.Text.ASCIIEncoding> codifica todos los caracteres mayores que 127 como (char) 63 o '?'. Para admitir caracteres adicionales en ese intervalo, establezca <xref:System.IO.Ports.SerialPort.Encoding%2A> a <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>, o <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="text" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">La operación no se ha terminado antes de que transcurriera el tiempo de espera.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : byte[] * int * int -&gt; unit" Usage="serialPort.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de bytes que contiene los datos para escribir en el puerto.</param>
        <param name="offset">Desplazamiento de bytes de base cero del parámetro <c>buffer</c> donde se van a empezar a copiar bytes en el puerto.</param>
        <param name="count">Número de bytes que se van a escribir.</param>
        <summary>Escribe un número especificado de bytes en el puerto serie utilizando los datos de un búfer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando desee escribir en un búfer de bytes para crear la salida de un puerto serie.  
  
 Si hay demasiados bytes en el búfer de salida y <xref:System.IO.Ports.SerialPort.Handshake%2A> está establecido en <xref:System.IO.Ports.Handshake.XOnXOff> el <xref:System.IO.Ports.SerialPort> objeto puede generar un <xref:System.ServiceProcess.TimeoutException> mientras se espera el dispositivo esté listo para aceptar más datos.  
  
 De forma predeterminada, <xref:System.IO.Ports.SerialPort> usa <xref:System.Text.ASCIIEncoding> para codificar los caracteres. <xref:System.Text.ASCIIEncoding> codifica todos los caracteres mayores que 127 como (char) 63 o '?'. Para admitir caracteres adicionales en ese intervalo, establezca <xref:System.IO.Ports.SerialPort.Encoding%2A> a <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>, o <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="buffer" /> pasado es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Los parámetros <paramref name="offset" /> o <paramref name="count" /> están fuera de una región válida del <paramref name="buffer" /> que se pasa. <paramref name="offset" /> o <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">La suma de <paramref name="offset" /> y <paramref name="count" /> es mayor que la longitud de <paramref name="buffer" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">La operación no se ha terminado antes de que transcurriera el tiempo de espera.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="serialPort.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de caracteres que contiene los datos para escribir en el puerto.</param>
        <param name="offset">Desplazamiento de bytes de base cero del parámetro <c>buffer</c> donde se van a empezar a copiar bytes en el puerto.</param>
        <param name="count">Número de caracteres que se van a escribir.</param>
        <summary>Escribe un número especificado de caracteres en el puerto serie utilizando los datos de un búfer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando desee escribir en un búfer de caracteres para crear la salida de un puerto serie.  
  
 Si hay demasiados bytes en el búfer de salida y <xref:System.IO.Ports.SerialPort.Handshake%2A> está establecido en <xref:System.IO.Ports.Handshake.XOnXOff> el <xref:System.IO.Ports.SerialPort> objeto puede generar un <xref:System.ServiceProcess.TimeoutException> mientras se espera el dispositivo esté listo para aceptar más datos.  
  
 De forma predeterminada, <xref:System.IO.Ports.SerialPort> usa <xref:System.Text.ASCIIEncoding> para codificar los caracteres. <xref:System.Text.ASCIIEncoding> codifica todos los caracteres mayores que 127 como (char) 63 o '?'. Para admitir caracteres adicionales en ese intervalo, establezca <xref:System.IO.Ports.SerialPort.Encoding%2A> a <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>, o <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="buffer" /> pasado es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Los parámetros <paramref name="offset" /> o <paramref name="count" /> están fuera de una región válida del <paramref name="buffer" /> que se pasa. <paramref name="offset" /> o <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">La suma de <paramref name="offset" /> y <paramref name="count" /> es mayor que la longitud de <paramref name="buffer" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">La operación no se ha terminado antes de que transcurriera el tiempo de espera.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteBufferSize">
      <MemberSignature Language="C#" Value="public int WriteBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.WriteBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriteBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteBufferSize : int with get, set" Usage="System.IO.Ports.SerialPort.WriteBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(2048)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("WriteBufferSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño del búfer de salida del puerto serie.</summary>
        <value>Tamaño del búfer de salida. El valor predeterminado es 2048.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Ports.SerialPort.WriteBufferSize%2A> propiedad omite cualquier valor inferior a 2048.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> es menor o igual que cero.</exception>
        <exception cref="T:System.InvalidOperationException">Se ha establecido el valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> mientras estaba abierta la secuencia.</exception>
        <exception cref="T:System.IO.IOException">Se ha establecido el valor de la propiedad <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> en un valor entero impar.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public void WriteLine (string text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteLine(string text) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (text As String)" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteLine(System::String ^ text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
      <MemberSignature Language="C#" Value="public void WriteLine (string str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteLine(string str) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.WriteLine(System.String)" FrameworkAlternate="xamarinmac-3.0;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (str As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteLine(System::String ^ str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.WriteLine : string -&gt; unit" Usage="serialPort.WriteLine str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="text">Cadena que se va a escribir en el búfer de salida.</param>
        <param name="str">Cadena que se va a escribir en el búfer de salida.</param>
        <summary>Escribe la cadena especificada y el valor de <see cref="P:System.IO.Ports.SerialPort.NewLine" /> en el búfer de salida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si hay demasiados bytes en el búfer de entrada y <xref:System.IO.Ports.SerialPort.Handshake%2A> está establecido en <xref:System.IO.Ports.Handshake.XOnXOff> el <xref:System.IO.Ports.SerialPort> objeto puede generar un <xref:System.ServiceProcess.TimeoutException> mientras se espera el dispositivo esté listo para aceptar más datos.  
  
 La salida escrita incluye la <xref:System.IO.Ports.SerialPort.NewLine%2A> cadena.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir a los dos usuarios chat de dos equipos independientes conectados mediante un cable de módem nulo. Este ejemplo de código forma parte de un ejemplo de código más extenso proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="text" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El puerto especificado no está abierto.</exception>
        <exception cref="T:System.TimeoutException">El método <see cref="M:System.IO.Ports.SerialPort.WriteLine(System.String)" /> no pudo escribir en la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.IO.Ports.SerialPort.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("WriteTimeout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número de milisegundos que transcurren antes de que se agote el tiempo de espera si una operación de escritura no finaliza.</summary>
        <value>El número de milisegundos que transcurren antes de que se agote el tiempo de espera. El valor predeterminado es <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de tiempo de espera de escritura se estableció originalmente en 500 milisegundos en la API de comunicaciones de Win32. Esta propiedad permite establecer este valor. El tiempo de espera se puede establecer en cualquier valor mayor que cero, o establecido en <xref:System.IO.Ports.SerialPort.InfiniteTimeout>, en cuyo caso se produce ningún tiempo de espera. <xref:System.IO.Ports.SerialPort.InfiniteTimeout> es el valor predeterminado.  
  
> [!NOTE]
>  Los usuarios de no administrado `COMMTIMEOUTS` estructura cabría esperar establecer el valor de tiempo de espera en cero para suprimir los tiempos de espera. Para suprimir los tiempos de espera con el <xref:System.IO.Ports.SerialPort.WriteTimeout%2A> propiedad, sin embargo, debe especificar <xref:System.IO.Ports.SerialPort.InfiniteTimeout>.  
  
 Esta propiedad no afecta a la <xref:System.IO.Stream.BeginWrite%2A> método de la secuencia devuelta por la <xref:System.IO.Ports.SerialPort.BaseStream%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.Ports.SerialPort> clase para permitir a los dos usuarios chat de dos equipos independientes conectados mediante un cable de módem nulo. En este ejemplo, los usuarios se le solicitará un nombre de usuario y la configuración de puerto antes de la charla. Este ejemplo de código forma parte de un ejemplo de código más extenso proporcionado para el <xref:System.IO.Ports.SerialPort> clase.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El puerto tiene un estado no válido.  
  
\- o - 
Se ha producido un error al intentar establecer el estado del puerto subyacente. Por ejemplo, los parámetros que se han pasado desde este objeto <see cref="T:System.IO.Ports.SerialPort" /> no eran válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <see cref="P:System.IO.Ports.SerialPort.WriteTimeout" /> es menor que cero y distinto de <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>