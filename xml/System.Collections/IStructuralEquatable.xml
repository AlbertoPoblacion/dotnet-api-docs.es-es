<Type Name="IStructuralEquatable" FullName="System.Collections.IStructuralEquatable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e79517aa8dab302204c461cf349e6d34f100645e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30368699" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStructuralEquatable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.IStructuralEquatable" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>Define los métodos para admitir la comparación de objetos de igualdad estructural.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Igualdad estructural significa que dos objetos son iguales porque tienen valores iguales. Difiere de la igualdad de referencia, lo que indica que dos referencias de objeto son iguales porque hacen referencia al mismo objeto físico. El <xref:System.Collections.IStructuralEquatable> le permite implementar comparaciones personalizadas para comprobar la igualdad estructural de objetos de colección. Es decir, puede crear su propia definición de igualdad estructural y especificar que esta definición se usa con un tipo de colección que acepta el <xref:System.Collections.IStructuralEquatable> interfaz. La interfaz tiene dos miembros: <xref:System.Collections.IStructuralEquatable.Equals%2A>, que comprueba la igualdad mediante el uso de un determinado <xref:System.Collections.IEqualityComparer> implementación, y <xref:System.Collections.IStructuralEquatable.GetHashCode%2A>, que devuelve códigos hash idénticos para los objetos que son iguales.  
  
> [!NOTE]
>  El <xref:System.Collections.IStructuralEquatable> interfaz solo admite comparaciones personalizadas de igualdad estructural. El <xref:System.Collections.IStructuralComparable> interfaz admite comparaciones personalizadas estructurales de ordenación y orden.  
  
 .NET Framework también proporciona predeterminado comparadores de igualdad, que son devueltos por la <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> y <xref:System.Collections.StructuralComparisons.StructuralEqualityComparer%2A?displayProperty=nameWithType> propiedades. Para obtener más información, vea el ejemplo.  
  
 Las clases de tupla genéricas (<xref:System.Tuple%601>, <xref:System.Tuple%602>, <xref:System.Tuple%603>, etc.) y la <xref:System.Array> clase proporcione implementaciones explícitas de la <xref:System.Collections.IStructuralEquatable> interfaz. Conversión (en C#) o convirtiendo (en Visual Basic) de la instancia actual de una matriz o tupla a una <xref:System.Collections.IStructuralEquatable> valor de la interfaz y proporcionar su <xref:System.Collections.IEqualityComparer> implementación como argumento para el <xref:System.Collections.IStructuralEquatable.Equals%2A> método, puede definir una comparación de igualdad personalizada para la matriz o colección.  
  
   
  
## Examples  
 El comparador de igualdad predeterminado, `EqualityComparer<Object>.Default.Equals`, considera que dos `NaN` valores son iguales. Sin embargo, en algunos casos, puede desear la comparación de `NaN` valores de igualdad devolviera `false`, lo que indica que no se pueden comparar los valores. En el ejemplo siguiente se define una clase `NanComparer` que implementa la interfaz <xref:System.Collections.IStructuralEquatable>. Compara dos <xref:System.Double> o dos <xref:System.Single> valores mediante el operador de igualdad. El comparador de igualdad predeterminado pasa valores de cualquier otro tipo.  
  
 [!code-csharp[System.Collections.IStructuralEquatable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.istructuralequatable/cs/nanexample1.cs#1)]
 [!code-vb[System.Collections.IStructuralEquatable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.istructuralequatable/vb/nanexample1.vb#1)]  
  
 El ejemplo siguiente crea dos objetos de tupla de 3 idénticos que se componen de tres <xref:System.Double> valores. El valor del segundo componente es <xref:System.Double.NaN?displayProperty=nameWithType>. El ejemplo, a continuación, se llama la <xref:System.Tuple%603.Equals%2A?displayProperty=nameWithType> método y lo llama el <xref:System.Collections.IStructuralEquatable.Equals%2A?displayProperty=nameWithType> método tres veces. La primera vez, pasa el comparador de igualdad predeterminado que es devuelto por la <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> propiedad. La segunda vez, pasa el comparador de igualdad predeterminado que es devuelto por la <xref:System.Collections.StructuralComparisons.StructuralEqualityComparer%2A?displayProperty=nameWithType> propiedad. La tercera vez, pasa personalizado `NanComparer` objeto. Como se muestra en el resultado del ejemplo, el método tres primeros llama devuelto `true`, mientras que la cuarta llamada devuelve `false`.  
  
 [!code-csharp[System.Collections.IStructuralEquatable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.istructuralequatable/cs/nanexample1.cs#2)]
 [!code-vb[System.Collections.IStructuralEquatable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.istructuralequatable/vb/nanexample1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.IEqualityComparer" />
    <altmember cref="T:System.Collections.IStructuralComparable" />
    <altmember cref="P:System.Collections.StructuralComparisons.StructuralEqualityComparer" />
  </Docs>
  <Members>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Object, comparer As IEqualityComparer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">Objeto que se va a comparar con la instancia actual.</param>
        <param name="comparer">Objeto que determina si la instancia actual y <c>other</c> son iguales.</param>
        <summary>Determina si un objeto es estructuralmente igual que la instancia actual.</summary>
        <returns>
          Es <see langword="true" /> si los dos objetos son iguales; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.IStructuralEquatable.Equals%2A> método admite la comparación estructural personalizada de matriz y objetos de tupla. Este método llama a su vez la `comparer` del objeto <xref:System.Collections.IEqualityComparer.Equals%2A?displayProperty=nameWithType> método para comparar elementos de matriz individuales o componentes de la tupla, empezando por el primer elemento o componente. Las llamadas individuales a <xref:System.Collections.IEqualityComparer.Equals%2A?displayProperty=nameWithType> final y la <xref:System.Collections.IStructuralEquatable.Equals%2A?displayProperty=nameWithType> método devuelve un valor o cuando una llamada al método devuelve `false` o después de todos los elementos de la matriz o han comparado con componentes de la tupla.  
  
   
  
## Examples  
 El comparador de igualdad predeterminado, `EqualityComparer<Object>.Default.Equals`, considera que dos `NaN` valores son iguales. Sin embargo, en algunos casos, puede desear la comparación de `NaN` valores de igualdad devolviera `false`, lo que indica que no se pueden comparar los valores. En el ejemplo siguiente se define una clase `NanComparer` que implementa la interfaz <xref:System.Collections.IStructuralEquatable>. Compara dos <xref:System.Double> o dos <xref:System.Single> valores mediante el operador de igualdad. El comparador de igualdad predeterminado pasa valores de cualquier otro tipo.  
  
 [!code-csharp[System.Collections.IStructuralEquatable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.istructuralequatable/cs/nanexample1.cs#1)]
 [!code-vb[System.Collections.IStructuralEquatable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.istructuralequatable/vb/nanexample1.vb#1)]  
  
 El ejemplo siguiente crea dos objetos de tupla de 3 idénticos que se componen de tres <xref:System.Double> valores. El valor del segundo componente es <xref:System.Double.NaN?displayProperty=nameWithType>. El ejemplo, a continuación, se llama la <xref:System.Tuple%603.Equals%2A?displayProperty=nameWithType> método y lo llama el <xref:System.Collections.IStructuralEquatable.Equals%2A?displayProperty=nameWithType> método tres veces. La primera vez, pasa el comparador de igualdad predeterminado que es devuelto por la <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> propiedad. La segunda vez, pasa el comparador de igualdad predeterminado que es devuelto por la <xref:System.Collections.StructuralComparisons.StructuralEqualityComparer%2A?displayProperty=nameWithType> propiedad. La tercera vez, pasa personalizado `NanComparer` objeto. Como se muestra en el resultado del ejemplo, el método tres primeros llama devuelto `true`, mientras que la cuarta llamada devuelve `false`.  
  
 [!code-csharp[System.Collections.IStructuralEquatable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.istructuralequatable/cs/nanexample1.cs#2)]
 [!code-vb[System.Collections.IStructuralEquatable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.istructuralequatable/vb/nanexample1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.StructuralComparisons.StructuralEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparer As IEqualityComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(System::Collections::IEqualityComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Objeto que calcula el código hash del objeto actual.</param>
        <summary>Devuelve un código hash de la instancia actual.</summary>
        <returns>Código hash de la instancia actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implemente este método para devolver códigos hash personalizados para los objetos de colección que corresponden a la comparación personalizada de igualdad estructural proporcionado por el <xref:System.Collections.IStructuralEquatable.Equals%2A> método.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si el <see cref="M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)" /> método <see langword="true" /> para dos objetos, los valores devueltos por la <see cref="M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)" /> también debe ser el método para los dos objetos.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>