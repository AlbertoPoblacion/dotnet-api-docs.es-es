<Type Name="SortedList" FullName="System.Collections.SortedList">
  <Metadata><Meta Name="ms.openlocfilehash" Value="be729c719d90801bc8d48c06f1885cb99fd4a5fe" /><Meta Name="ms.sourcegitcommit" Value="b0551d7828f015124aca601dbb64bd913cc5067d" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/13/2018" /><Meta Name="ms.locfileid" Value="53334618" /></Metadata><TypeSignature Language="C#" Value="public class SortedList : ICloneable, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedList extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.SortedList" />
  <TypeSignature Language="VB.NET" Value="Public Class SortedList&#xA;Implements ICloneable, IDictionary" />
  <TypeSignature Language="C++ CLI" Value="public ref class SortedList : ICloneable, System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type SortedList = class&#xA;    interface IDictionary&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.SortedList/SortedListDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa una colección de pares de clave y valor ordenados por claves a los que se puede tener acceso por clave y por índice.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

Un <xref:System.Collections.SortedList> elemento puede tener acceso a su clave, como un elemento en cualquier <xref:System.Collections.IDictionary> implementación, o por su índice, como un elemento en cualquier <xref:System.Collections.IList> implementación.  

> [!IMPORTANT]
> No se recomienda que utilice el `SortedList` clase para el nuevo desarrollo. En su lugar, se recomienda que use el tipo genérico <xref:System.Collections.Generic.SortedList%602?displayProperty=nameWithType> clase. Para obtener más información, consulte [no deben usarse las colecciones no genéricas](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md) en GitHub.

 Un <xref:System.Collections.SortedList> objeto mantiene internamente dos matrices para almacenar los elementos de la lista; es decir, una matriz de las claves y otra para los valores asociados. Cada elemento es un par clave/valor que se puede tener acceso como una <xref:System.Collections.DictionaryEntry> objeto. No puede ser una clave `null`, pero puede ser un valor.  
  
 La capacidad de un <xref:System.Collections.SortedList> objeto es el número de elementos de la <xref:System.Collections.SortedList> puede contener. Cuando se agregan elementos a un <xref:System.Collections.SortedList>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación. La capacidad puede reducirse mediante una llamada a <xref:System.Collections.SortedList.TrimToSize%2A> o estableciendo la <xref:System.Collections.SortedList.Capacity%2A> propiedad explícitamente.  
  
 Para grandes <xref:System.Collections.SortedList> objetos, puede aumentar la capacidad máxima de 2 millones de elementos en un sistema de 64 bits estableciendo el `enabled` atributo del elemento de configuración para `true` en el entorno de tiempo de ejecución.  
  
 Los elementos de un <xref:System.Collections.SortedList> objetos se ordenan por claves en función de un determinado <xref:System.Collections.IComparer> implementación que especificó cuando la <xref:System.Collections.SortedList> está creada, o según el <xref:System.IComparable> implementación proporcionada por las propias claves. En cualquier caso, un <xref:System.Collections.SortedList> no se admiten claves duplicadas.  
  
 La secuencia de índice se basa en la secuencia de ordenación. Cuando se agrega un elemento, éste se inserta en <xref:System.Collections.SortedList> en la ordenación correcta orden y la indización se ajusta en consecuencia. Cuando se quita un elemento, la indización también se ajusta según corresponda. Por lo tanto, puede cambiar el índice de un par de clave y valor específico como elementos se agregan o quitan de la <xref:System.Collections.SortedList> objeto.  
  
 Operaciones en un <xref:System.Collections.SortedList> objeto tienden a ser más lento que las operaciones en un <xref:System.Collections.Hashtable> objeto debido a la ordenación. Sin embargo, el <xref:System.Collections.SortedList> ofrece más flexibilidad al permitir el acceso a los valores a través de las claves asociadas o a través de los índices.  
  
 Elementos de esta colección se pueden acceder mediante un índice entero.  Los índices de esta colección son de base cero.  
  
 El `foreach` instrucción del lenguaje C# (`for each` en Visual Basic) devuelve un objeto del tipo de los elementos de la colección. Puesto que cada elemento de la <xref:System.Collections.SortedList> objeto es un par clave/valor, el tipo de elemento no es el tipo de la clave o el tipo del valor. En su lugar, el tipo de elemento es <xref:System.Collections.DictionaryEntry>. Por ejemplo:  
  
 [!code-cpp[Classic SortedList Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic SortedList Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/remarks.cs#2)]
 [!code-vb[Classic SortedList Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/remarks.vb#2)]  
  
 El `foreach` instrucción es un contenedor alrededor del enumerador, que permite solo lectura pero no escribir en la colección.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo crear e inicializar un <xref:System.Collections.SortedList> objeto y cómo imprimir sus claves y valores.  
  
 [!code-cpp[Classic SortedList Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Estáticos públicos (<see langword="Shared" /> en Visual Basic) los miembros de este tipo son seguros para subprocesos. No se garantiza que los miembros de instancias sean seguros para la ejecución de subprocesos.  
  
Un <see cref="T:System.Collections.SortedList" /> objeto puede admitir varios lectores simultáneamente, siempre que no se modifica la colección. Para garantizar la seguridad para subprocesos de la <see cref="T:System.Collections.SortedList" />, todas las operaciones deben realizarse a través del contenedor devuelto por el <see cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" /> método.  
  
Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.Collections.IComparer" />
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.Hashtable" />
    <altmember cref="T:System.Collections.Generic.SortedList`2" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.SortedList" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.SortedList" /> que está vacía, tiene la capacidad inicial predeterminada y está ordenada en función de la interfaz <see cref="T:System.IComparable" /> implementada por cada clave agregada al objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada clave debe implementar la <xref:System.IComparable> interfaz para poder realizar comparaciones con todas las claves de la <xref:System.Collections.SortedList> objeto. Los elementos se ordenan según la <xref:System.IComparable> implementación de cada clave agregada a la <xref:System.Collections.SortedList>.  
  
 La capacidad de un <xref:System.Collections.SortedList> objeto es el número de elementos que la <xref:System.Collections.SortedList> puede contener. Cuando se agregan elementos a un <xref:System.Collections.SortedList>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna.  
  
 Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.SortedList> objeto.  
  
 Este constructor es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea colecciones utilizando diferentes <xref:System.Collections.SortedList> constructores y se muestran las diferencias en el comportamiento de las colecciones.  
  
 [!code-cpp[System.Collections.SortedList_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IComparer -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementación de <see cref="T:System.Collections.IComparer" /> que se va a usar al comparar claves.  
  
O bien 
 <see langword="null" /> para usar la implementación de <see cref="T:System.IComparable" /> para cada una de las claves.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.SortedList" /> que está vacía, tiene la capacidad inicial predeterminada y está ordenada de acuerdo con la interfaz <see cref="T:System.Collections.IComparer" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos se ordenan según la condición especificada <xref:System.Collections.IComparer> implementación. Si el `comparer` parámetro es `null`, el <xref:System.IComparable> se utiliza la implementación de cada clave; por lo tanto, cada clave debe implementar la <xref:System.IComparable> interfaz para poder realizar comparaciones con todas las claves de la <xref:System.Collections.SortedList> objeto.  
  
 La capacidad de un <xref:System.Collections.SortedList> objeto es el número de elementos que la <xref:System.Collections.SortedList> puede contener. Cuando se agregan elementos a un <xref:System.Collections.SortedList>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna.  
  
 Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.SortedList> objeto.  
  
 Este constructor es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea colecciones utilizando diferentes <xref:System.Collections.SortedList> constructores y se muestran las diferencias en el comportamiento de las colecciones.  
  
 [!code-cpp[System.Collections.SortedList_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IDictionary ^ d);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IDictionary -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList d" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="d">Implementación de <see cref="T:System.Collections.IDictionary" /> que se va a copiar en un nuevo objeto <see cref="T:System.Collections.SortedList" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.SortedList" /> que contiene elementos copiados del diccionario especificado, tiene la misma capacidad inicial que el número de elementos copiados y se ordena de acuerdo con la interfaz <see cref="T:System.IComparable" /> implementada por cada clave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada clave debe implementar la <xref:System.IComparable> interfaz para poder realizar comparaciones con todas las claves de la <xref:System.Collections.SortedList> objeto. Los elementos se ordenan según la <xref:System.IComparable> implementación de cada clave agregada a la <xref:System.Collections.SortedList>.  
  
 Un <xref:System.Collections.Hashtable> objeto es un ejemplo de un <xref:System.Collections.IDictionary> implementación que se puede pasar a este constructor. El nuevo <xref:System.Collections.SortedList> objeto contiene una copia de las claves y los valores almacenados en el <xref:System.Collections.Hashtable>.  
  
 La capacidad de un <xref:System.Collections.SortedList> objeto es el número de elementos que la <xref:System.Collections.SortedList> puede contener. Cuando se agregan elementos a un <xref:System.Collections.SortedList>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna.  
  
 Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.SortedList> objeto.  
  
 Este constructor es O (`n`) operación, donde `n` es el número de elementos de `d`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea colecciones utilizando diferentes <xref:System.Collections.SortedList> constructores y se muestran las diferencias en el comportamiento de las colecciones.  
  
 [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="d" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Uno o más elementos de la <paramref name="d" /> no implementan la interfaz de <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int initialCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(int initialCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : int -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList initialCapacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCapacity">Número inicial de elementos que puede contener el objeto <see cref="T:System.Collections.SortedList" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.SortedList" /> que está vacía, tiene la capacidad inicial especificada y está ordenada en función de la interfaz <see cref="T:System.IComparable" /> implementada por cada clave agregada al objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada clave debe implementar la <xref:System.IComparable> interfaz para poder realizar comparaciones con todas las claves de la <xref:System.Collections.SortedList> objeto. Los elementos se ordenan según la <xref:System.IComparable> implementación de cada clave agregada a la <xref:System.Collections.SortedList>.  
  
 La capacidad de un <xref:System.Collections.SortedList> objeto es el número de elementos que la <xref:System.Collections.SortedList> puede contener. Cuando se agregan elementos a un <xref:System.Collections.SortedList>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna.  
  
 Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.SortedList> objeto.  
  
 Este constructor es O (`n`) operación, donde `n` es `initialCapacity`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea colecciones utilizando diferentes <xref:System.Collections.SortedList> constructores y se muestran las diferencias en el comportamiento de las colecciones.  
  
 [!code-cpp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="initialCapacity" /> es menor que cero.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay suficiente memoria disponible para crear un objeto <see cref="T:System.Collections.SortedList" /> con el parámetro <paramref name="initialCapacity" /> especificado.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IComparer ^ comparer, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IComparer * int -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList (comparer, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementación de <see cref="T:System.Collections.IComparer" /> que se va a usar al comparar claves.  
  
O bien 
 <see langword="null" /> para usar la implementación de <see cref="T:System.IComparable" /> para cada una de las claves.</param>
        <param name="capacity">Número inicial de elementos que puede contener el objeto <see cref="T:System.Collections.SortedList" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.SortedList" /> que está vacía, tiene la capacidad inicial especificada y está ordenada de acuerdo con la interfaz <see cref="T:System.Collections.IComparer" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos se ordenan según la condición especificada <xref:System.Collections.IComparer> implementación. Si el `comparer` parámetro es `null`, el <xref:System.IComparable> se utiliza la implementación de cada clave; por lo tanto, cada clave debe implementar la <xref:System.IComparable> interfaz para poder realizar comparaciones con todas las claves de la <xref:System.Collections.SortedList> objeto.  
  
 La capacidad de un <xref:System.Collections.SortedList> objeto es el número de elementos que la <xref:System.Collections.SortedList> puede contener. Cuando se agregan elementos a un <xref:System.Collections.SortedList>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna.  
  
 Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.SortedList> objeto.  
  
 Este constructor es O (`n`) operación, donde `n` es `capacity`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea colecciones utilizando diferentes <xref:System.Collections.SortedList> constructores y se muestran las diferencias en el comportamiento de las colecciones.  
  
 [!code-cpp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> es menor que cero.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay suficiente memoria disponible para crear un objeto <see cref="T:System.Collections.SortedList" /> con el parámetro <paramref name="capacity" /> especificado.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IDictionary ^ d, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IDictionary * System.Collections.IComparer -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList (d, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">Implementación de <see cref="T:System.Collections.IDictionary" /> que se va a copiar en un nuevo objeto <see cref="T:System.Collections.SortedList" />.</param>
        <param name="comparer">Implementación de <see cref="T:System.Collections.IComparer" /> que se va a usar al comparar claves.  
  
O bien 
 <see langword="null" /> para usar la implementación de <see cref="T:System.IComparable" /> para cada una de las claves.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.SortedList" /> que contiene elementos copiados del diccionario especificado, tiene la misma capacidad inicial que el número de elementos copiados y se ordena de acuerdo con la interfaz <see cref="T:System.Collections.IComparer" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos se ordenan según la condición especificada <xref:System.Collections.IComparer> implementación. Si el `comparer` parámetro es `null`, el <xref:System.IComparable> se utiliza la implementación de cada clave; por lo tanto, cada clave debe implementar la <xref:System.IComparable> interfaz para poder realizar comparaciones con todas las claves de la <xref:System.Collections.SortedList> objeto.  
  
 Un <xref:System.Collections.Hashtable> objeto es un ejemplo de un <xref:System.Collections.IDictionary> implementación que se puede pasar a este constructor. El nuevo <xref:System.Collections.SortedList> objeto contiene una copia de las claves y los valores almacenados en el <xref:System.Collections.Hashtable>.  
  
 La capacidad de un <xref:System.Collections.SortedList> objeto es el número de elementos que la <xref:System.Collections.SortedList> puede contener. Cuando se agregan elementos a un <xref:System.Collections.SortedList>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna.  
  
 Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.SortedList> objeto.  
  
 Este constructor es O (`n`) operación, donde `n` es el número de elementos de `d`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea colecciones utilizando diferentes <xref:System.Collections.SortedList> constructores y se muestran las diferencias en el comportamiento de las colecciones.  
  
 [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="d" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="comparer" /> es <see langword="null" /> y uno o más elementos de la <paramref name="d" /> no implementan la interfaz de <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="sortedList.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clave del elemento que se va a agregar.</param>
        <param name="value">Valor del elemento que se va a agregar. El valor puede ser <see langword="null" />.</param>
        <summary>Agrega un elemento con la clave y el valor especificados a un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El punto de inserción se determina según el comparador seleccionado, ya sea explícitamente o de forma predeterminada, cuando el <xref:System.Collections.SortedList> se creó el objeto.  
  
 Si <xref:System.Collections.SortedList.Count%2A> ya es igual a <xref:System.Collections.SortedList.Capacity%2A>, la capacidad de la <xref:System.Collections.SortedList> se incrementa el objeto mediante la reasignación automática de la matriz interna y se copian los elementos existentes en la nueva matriz antes de agrega el nuevo elemento.  
  
 También puede usar el <xref:System.Collections.SortedList.Item%2A> propiedad para agregar nuevos elementos estableciendo el valor de una clave que no existe en el <xref:System.Collections.SortedList> objeto (por ejemplo, `myCollection["myNonexistentKey"] = myValue`). Sin embargo, si la clave especificada ya existe en el <xref:System.Collections.SortedList>, estableciendo el <xref:System.Collections.SortedList.Item%2A> propiedad sobrescribe el valor anterior. En cambio, el <xref:System.Collections.SortedList.Add%2A> método no modifica los elementos existentes.  
  
 Los elementos de un <xref:System.Collections.SortedList> objetos se ordenan por claves en función de un determinado <xref:System.Collections.IComparer> implementación que especificó cuando la <xref:System.Collections.SortedList> está creada, o según el <xref:System.IComparable> implementación proporcionada por las propias claves.  
  
 No puede ser una clave `null`, pero puede ser un valor.  
  
 Este método es O (`n`) operación para datos sin ordenar, donde `n` es <xref:System.Collections.SortedList.Count%2A>. Es O (log `n`) operación si el nuevo elemento se agrega al final de la lista. Si la inserción provoca un cambio de tamaño, la operación es O (`n`).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo agregar elementos a un <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ya existe un elemento con el parámetro <paramref name="key" /> especificado en el objeto <see cref="T:System.Collections.SortedList" />.  
  
O bien 
Se establece <see cref="T:System.Collections.SortedList" /> para utilizar la interfaz <see cref="T:System.IComparable" /> y <paramref name="key" /> no implementa la interfaz <see cref="T:System.IComparable" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.SortedList" /> es de solo lectura.  
  
O bien 
<see cref="T:System.Collections.SortedList" /> tiene un tamaño fijo.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay suficiente memoria disponible para agregar el elemento al objeto <see cref="T:System.Collections.SortedList" />.</exception>
        <exception cref="T:System.InvalidOperationException">El comparador produce una excepción.</exception>
        <altmember cref="P:System.Collections.SortedList.Item(System.Object)" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.SortedList.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la capacidad de un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <value>Número de elementos que el objeto <see cref="T:System.Collections.SortedList" /> puede contener.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList.Capacity%2A> es el número de elementos que la <xref:System.Collections.SortedList> puede almacenar el objeto. <xref:System.Collections.SortedList.Count%2A> es el número de elementos que son en realidad el <xref:System.Collections.SortedList>.  
  
 <xref:System.Collections.SortedList.Capacity%2A> es siempre mayor o igual que <xref:System.Collections.SortedList.Count%2A>. Si <xref:System.Collections.SortedList.Count%2A> supera <xref:System.Collections.SortedList.Capacity%2A> al agregar elementos, automáticamente se aumenta la capacidad mediante la reasignación de la matriz interna antes de copiar los elementos antiguos y agregar los nuevos elementos.  
  
 La capacidad puede reducirse mediante una llamada a <xref:System.Collections.SortedList.TrimToSize%2A> o estableciendo la <xref:System.Collections.SortedList.Capacity%2A> propiedad explícitamente. Cuando el valor de <xref:System.Collections.SortedList.Capacity%2A> se establece explícitamente, la matriz interna se reasigna para dar cabida a la capacidad especificada.  
  
 Recuperar el valor de esta propiedad es una operación o (1); establecer la propiedad es O (`n`) operación, donde `n` es la nueva capacidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor asignado es menor que el número actual de elementos del objeto <see cref="T:System.Collections.SortedList" />.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay memoria suficiente en el sistema.</exception>
        <altmember cref="M:System.Collections.SortedList.TrimToSize" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="sortedList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los elementos de un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList.Count%2A> se establece en cero y también se liberan las referencias a otros objetos de elementos de la colección.  
  
 <xref:System.Collections.SortedList.Capacity%2A> permanece sin cambios. Para restablecer la capacidad de la <xref:System.Collections.SortedList> de objeto, llame a <xref:System.Collections.SortedList.TrimToSize%2A> o establecer el <xref:System.Collections.SortedList.Capacity%2A> propiedad directamente. Recorte vacío <xref:System.Collections.SortedList> establece la capacidad de la <xref:System.Collections.SortedList> a la capacidad predeterminada.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo se recortan las partes no utilizadas de una <xref:System.Collections.SortedList> objeto y cómo borrar los valores de la <xref:System.Collections.SortedList>.  
  
 [!code-cpp[Classic SortedList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El objeto <see cref="T:System.Collections.SortedList" /> es de solo lectura.  
  
O bien 
<see cref="T:System.Collections.SortedList" /> tiene un tamaño fijo.</exception>
        <altmember cref="M:System.Collections.SortedList.TrimToSize" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <altmember cref="P:System.Collections.SortedList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="sortedList.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia superficial de un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Copia superficial del objeto <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una copia superficial de una colección copia solo los elementos de la colección, si son tipos de referencia o tipos de valor, pero no copia los objetos que hacen referencia las referencias. Las referencias de la nueva colección apuntan a los mismos objetos que seleccione las referencias en la colección original.  
  
 En cambio, una copia en profundidad de una colección copia los elementos y todo lo que hacen referencia directa o indirectamente los elementos.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.SortedList.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="sortedList.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clave que se buscará en el objeto <see cref="T:System.Collections.SortedList" />.</param>
        <summary>Determina si un objeto <see cref="T:System.Collections.SortedList" /> contiene una clave específica.</summary>
        <returns>Es <see langword="true" /> si el objeto <see cref="T:System.Collections.SortedList" /> contiene un elemento con el parámetro <paramref name="key" /> especificado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos de un <xref:System.Collections.SortedList> objetos se ordenan por claves en función de un determinado <xref:System.Collections.IComparer> implementación que especificó cuando la <xref:System.Collections.SortedList> está creada, o según el <xref:System.IComparable> implementación proporcionada por las propias claves.  
  
 <xref:System.Collections.SortedList.Contains%2A> implementa <xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType>. Se comporta exactamente como <xref:System.Collections.SortedList.ContainsKey%2A>.  
  
 Este método utiliza un algoritmo de búsqueda binaria; por lo tanto, este método es O (log `n`) operación, donde `n` es <xref:System.Collections.SortedList.Count%2A>.  
  
 A partir de .NET Framework 2.0, este método utiliza los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si existe el elemento. En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo determinar si un <xref:System.Collections.SortedList> objeto contiene un elemento específico.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El comparador produce una excepción.</exception>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsKey (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : obj -&gt; bool&#xA;override this.ContainsKey : obj -&gt; bool" Usage="sortedList.ContainsKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clave que se buscará en el objeto <see cref="T:System.Collections.SortedList" />.</param>
        <summary>Determina si un objeto <see cref="T:System.Collections.SortedList" /> contiene una clave específica.</summary>
        <returns>Es <see langword="true" /> si el objeto <see cref="T:System.Collections.SortedList" /> contiene un elemento con el parámetro <paramref name="key" /> especificado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos de un <xref:System.Collections.SortedList> objetos se ordenan por claves en función de un determinado <xref:System.Collections.IComparer> implementación que especificó cuando la <xref:System.Collections.SortedList> está creada, o según el <xref:System.IComparable> implementación proporcionada por las propias claves.  
  
 Este método se comporta exactamente como el <xref:System.Collections.SortedList.Contains%2A> método.  
  
 Este método utiliza un algoritmo de búsqueda binaria; por lo tanto, este método es O (log `n`) operación, donde `n` es <xref:System.Collections.SortedList.Count%2A>.  
  
 A partir de .NET Framework 2.0, este método utiliza los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si existe el elemento. En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo determinar si un <xref:System.Collections.SortedList> objeto contiene un elemento específico.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El comparador produce una excepción.</exception>
        <altmember cref="M:System.Collections.SortedList.Contains(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.ContainsValue(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public virtual bool ContainsValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member ContainsValue : obj -&gt; bool&#xA;override this.ContainsValue : obj -&gt; bool" Usage="sortedList.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a buscar en el objeto <see cref="T:System.Collections.SortedList" />. El valor puede ser <see langword="null" />.</param>
        <summary>Determina si un objeto <see cref="T:System.Collections.SortedList" /> contiene un valor específico.</summary>
        <returns>Es <see langword="true" /> si el objeto <see cref="T:System.Collections.SortedList" /> contiene un elemento con el parámetro <paramref name="value" /> especificado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los valores de los elementos de la <xref:System.Collections.SortedList> objeto se comparan con el valor especificado mediante el <xref:System.Object.Equals%2A> método.  
  
 Este método realiza una búsqueda lineal; por lo tanto, el tiempo medio de ejecución es proporcional al <xref:System.Collections.SortedList.Count%2A>. Es decir, este método es una E/s (`n`) operación, donde `n` es <xref:System.Collections.SortedList.Count%2A>.  
  
 A partir de .NET Framework 2.0, este método utiliza los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si existe el elemento. En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo determinar si un <xref:System.Collections.SortedList> objeto contiene un elemento específico.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="sortedList.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Objeto <see cref="T:System.Array" /> unidimensional que constituye el destino de los objetos <see cref="T:System.Collections.DictionaryEntry" /> copiados de <see cref="T:System.Collections.SortedList" />. <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
        <param name="arrayIndex">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
        <summary>Copia los elementos <see cref="T:System.Collections.SortedList" /> en un objeto <see cref="T:System.Array" /> unidimensional, empezando en el índice especificado de la matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los pares clave/valor se copian en el <xref:System.Array> objeto en el mismo orden en que el enumerador recorre el <xref:System.Collections.SortedList> objeto.  
  
 Para copiar sólo las claves de la <xref:System.Collections.SortedList>, utilice `SortedList.Keys.CopyTo`.  
  
 Para copiar sólo los valores de la <xref:System.Collections.SortedList>, utilice `SortedList.Values.CopyTo`.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo copiar los valores de un <xref:System.Collections.SortedList> objeto unidimensional <xref:System.Array> objeto.  
  
 [!code-cpp[Classic SortedList.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> es multidimensional.  
  
O bien 
El número de elementos del objeto <see cref="T:System.Collections.SortedList" /> de origen es mayor que el espacio disponible desde <paramref name="arrayIndex" /> hasta el final del parámetro <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.InvalidCastException">El tipo de la <see cref="T:System.Collections.SortedList" /> de origen no puede convertirse automáticamente al tipo de la <paramref name="array" /> de destino.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.SortedList.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.SortedList.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de elementos incluidos en un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <value>Número de elementos incluidos en el objeto <see cref="T:System.Collections.SortedList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento es un par clave/valor que se puede tener acceso como una <xref:System.Collections.DictionaryEntry> objeto.  
  
 <xref:System.Collections.SortedList.Capacity%2A> es el número de elementos que la <xref:System.Collections.SortedList> puede almacenar el objeto. <xref:System.Collections.SortedList.Count%2A> es el número de elementos que son en realidad el <xref:System.Collections.SortedList>.  
  
 <xref:System.Collections.SortedList.Capacity%2A> es siempre mayor o igual que <xref:System.Collections.SortedList.Count%2A>. Si <xref:System.Collections.SortedList.Count%2A> supera <xref:System.Collections.SortedList.Capacity%2A> al agregar elementos, automáticamente se aumenta la capacidad mediante la reasignación de la matriz interna antes de copiar los elementos antiguos y agregar los nuevos elementos.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="GetByIndex">
      <MemberSignature Language="C#" Value="public virtual object GetByIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetByIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetByIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByIndex (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetByIndex(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetByIndex : int -&gt; obj&#xA;override this.GetByIndex : int -&gt; obj" Usage="sortedList.GetByIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del valor que se va a obtener.</param>
        <summary>Obtiene el valor que se encuentra en el índice especificado de un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Valor que se encuentra en el índice especificado del objeto <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La secuencia de índice se basa en la secuencia de ordenación. Cuando se agrega un elemento, éste se inserta en <xref:System.Collections.SortedList> en la ordenación correcta orden y la indización se ajusta en consecuencia. Cuando se quita un elemento, la indización también se ajusta según corresponda. Por lo tanto, puede cambiar el índice de un par de clave y valor específico como elementos se agregan o quitan de la <xref:System.Collections.SortedList> objeto.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 El ejemplo de código siguiente se muestra cómo obtener una o todas las claves o valores en un <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="index" /> está fuera del intervalo de índices válidos para el objeto <see cref="T:System.Collections.SortedList" />.</exception>
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="sortedList.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Collections.IDictionaryEnumerator" /> que itera por un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Objeto <see cref="T:System.Collections.IDictionaryEnumerator" /> para el objeto <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La instrucción `foreach` del lenguaje C# (`for each` en Visual Basic) oculta la complejidad de los enumeradores.  Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. <xref:System.Collections.IEnumerator.Reset%2A> también devuelve el enumerador a esta posición.  En esta posición, el valor de propiedad <xref:System.Collections.IEnumerator.Current%2A> está sin definir. Por lo tanto, debe llamar a <xref:System.Collections.IEnumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A> o a <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.IEnumerator.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`. Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.IEnumerator.Current%2A> es indefinido. Para volver a establecer el valor de <xref:System.Collections.IEnumerator.Current%2A> en el primer elemento de la colección, se puede llamar primero a <xref:System.Collections.IEnumerator.Reset%2A> y después a <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumerador es válido mientras la colección no cambie. Si se hacen cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado permanentemente y su comportamiento es indefinido.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos.  A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetKey">
      <MemberSignature Language="C#" Value="public virtual object GetKey (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetKey(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKey(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetKey (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetKey(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetKey : int -&gt; obj&#xA;override this.GetKey : int -&gt; obj" Usage="sortedList.GetKey index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero de la clave que se va a obtener.</param>
        <summary>Obtiene la clave que se encuentra en el índice especificado de un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Clave que se encuentra en el índice especificado del objeto <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La secuencia de índice se basa en la secuencia de ordenación. Cuando se agrega un elemento, éste se inserta en <xref:System.Collections.SortedList> en la ordenación correcta orden y la indización se ajusta en consecuencia. Cuando se quita un elemento, la indización también se ajusta según corresponda. Por lo tanto, puede cambiar el índice de un par de clave y valor específico como elementos se agregan o quitan de la <xref:System.Collections.SortedList> objeto.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 El ejemplo de código siguiente se muestra cómo obtener una o todas las claves o valores en un <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="index" /> está fuera del intervalo de índices válidos para el objeto <see cref="T:System.Collections.SortedList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetKeyList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetKeyList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetKeyList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKeyList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetKeyList () As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IList ^ GetKeyList();" />
      <MemberSignature Language="F#" Value="abstract member GetKeyList : unit -&gt; System.Collections.IList&#xA;override this.GetKeyList : unit -&gt; System.Collections.IList" Usage="sortedList.GetKeyList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene las claves de un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Objeto <see cref="T:System.Collections.IList" /> que contiene las claves del objeto <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Collections.IList> objeto es una vista de solo lectura de las claves de la <xref:System.Collections.SortedList> objeto. Las modificaciones realizadas en subyacente <xref:System.Collections.SortedList> se reflejan inmediatamente en el <xref:System.Collections.IList>.  
  
 Los elementos de devuelto <xref:System.Collections.IList> se ordenan en el mismo orden que las claves de la <xref:System.Collections.SortedList>.  
  
 Este método es similar a la <xref:System.Collections.SortedList.Keys%2A> propiedad, pero devuelve un <xref:System.Collections.IList> en lugar del objeto un <xref:System.Collections.ICollection> objeto.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 El ejemplo de código siguiente se muestra cómo obtener una o todas las claves o valores en un <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.SortedList.GetValueList" />
        <altmember cref="P:System.Collections.SortedList.Keys" />
      </Docs>
    </Member>
    <Member MemberName="GetValueList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetValueList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetValueList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetValueList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueList () As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IList ^ GetValueList();" />
      <MemberSignature Language="F#" Value="abstract member GetValueList : unit -&gt; System.Collections.IList&#xA;override this.GetValueList : unit -&gt; System.Collections.IList" Usage="sortedList.GetValueList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene los valores de un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Objeto <see cref="T:System.Collections.IList" /> que contiene los valores del objeto <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Collections.IList> objeto es una vista de solo lectura de los valores de la <xref:System.Collections.SortedList> objeto. Las modificaciones realizadas en subyacente <xref:System.Collections.SortedList> se reflejan inmediatamente en el <xref:System.Collections.IList>.  
  
 Los elementos de devuelto <xref:System.Collections.IList> se ordenan en el mismo orden que los valores de la <xref:System.Collections.SortedList>.  
  
 Este método es similar a la <xref:System.Collections.SortedList.Values%2A> propiedad, pero devuelve un <xref:System.Collections.IList> en lugar del objeto un <xref:System.Collections.ICollection> objeto.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 El ejemplo de código siguiente se muestra cómo obtener una o todas las claves o valores en un <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.SortedList.GetKeyList" />
        <altmember cref="P:System.Collections.SortedList.Values" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfKey">
      <MemberSignature Language="C#" Value="public virtual int IndexOfKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOfKey (key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOfKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member IndexOfKey : obj -&gt; int&#xA;override this.IndexOfKey : obj -&gt; int" Usage="sortedList.IndexOfKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clave que se buscará en el objeto <see cref="T:System.Collections.SortedList" />.</param>
        <summary>Devuelve el índice de base cero de la clave especificada en un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Índice de base cero del parámetro <paramref name="key" />, si <paramref name="key" /> se encuentra en el objeto <see cref="T:System.Collections.SortedList" />; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos de un <xref:System.Collections.SortedList> objetos se ordenan por claves en función de un determinado <xref:System.Collections.IComparer> implementación que especificó cuando la <xref:System.Collections.SortedList> está creada, o según el <xref:System.IComparable> implementación proporcionada por las propias claves.  
  
 La secuencia de índice se basa en la secuencia de ordenación. Cuando se agrega un elemento, éste se inserta en <xref:System.Collections.SortedList> en la ordenación correcta orden y la indización se ajusta en consecuencia. Cuando se quita un elemento, la indización también se ajusta según corresponda. Por lo tanto, puede cambiar el índice de un par de clave y valor específico como elementos se agregan o quitan de la <xref:System.Collections.SortedList>.  
  
 Este método utiliza un algoritmo de búsqueda binaria; por lo tanto, este método es O (log `n`) operación, donde `n` es <xref:System.Collections.SortedList.Count%2A>.  
  
 A partir de .NET Framework 2.0, este método utiliza los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si existe el elemento. En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo determinar el índice de una clave o un valor en un <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El comparador produce una excepción.</exception>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOfValue">
      <MemberSignature Language="C#" Value="public virtual int IndexOfValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOfValue (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOfValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOfValue : obj -&gt; int&#xA;override this.IndexOfValue : obj -&gt; int" Usage="sortedList.IndexOfValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a buscar en el objeto <see cref="T:System.Collections.SortedList" />. El valor puede ser <see langword="null" />.</param>
        <summary>Devuelve el índice de base cero de la primera aparición del valor especificado en un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Índice de base cero de la primera aparición del parámetro <paramref name="value" />, si <paramref name="value" /> se encuentra en el objeto <see cref="T:System.Collections.SortedList" />; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La secuencia de índice se basa en la secuencia de ordenación. Cuando se agrega un elemento, éste se inserta en <xref:System.Collections.SortedList> en la ordenación correcta orden y la indización se ajusta en consecuencia. Cuando se quita un elemento, la indización también se ajusta según corresponda. Por lo tanto, puede cambiar el índice de un par de clave y valor específico como elementos se agregan o quitan de la <xref:System.Collections.SortedList> objeto.  
  
 Los valores de los elementos de la <xref:System.Collections.SortedList> se comparan con el valor especificado mediante el <xref:System.Object.Equals%2A> método.  
  
 Este método utiliza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es <xref:System.Collections.SortedList.Count%2A>.  
  
 A partir de .NET Framework 2.0, este método utiliza los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si existe el elemento. En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo determinar el índice de una clave o un valor en un <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.ContainsValue(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Collections.SortedList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si un objeto <see cref="T:System.Collections.SortedList" /> tiene un tamaño fijo.</summary>
        <value>Es <see langword="true" /> si el objeto <see cref="T:System.Collections.SortedList" /> tiene un tamaño fijo; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una colección con un tamaño fijo no permite la adición o eliminación de elementos después de crea la colección, pero permitir la modificación de los elementos existentes.  
  
 Una colección con un tamaño fijo es simplemente una colección con un contenedor que impide agregar y quitar elementos; por lo tanto, si se realizan cambios en la colección subyacente, incluida la adición o eliminación de elementos, la colección de tamaño fijo refleja los cambios.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.SortedList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si un objeto <see cref="T:System.Collections.SortedList" /> es de solo lectura.</summary>
        <value>Es <see langword="true" /> si el objeto <see cref="T:System.Collections.SortedList" /> es de solo lectura; en caso contrario, es <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una colección de solo lectura no permite que se agreguen, quiten o modifiquen elementos una vez que se ha creado.  
  
 Una colección es de solo lectura es simplemente una colección con un contenedor que evita la modificación de la colección; por lo tanto, si se realizan cambios en la colección subyacente, la colección de solo lectura refleja los cambios.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.SortedList.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el acceso a un objeto <see cref="T:System.Collections.SortedList" /> está sincronizado (es seguro para subprocesos).</summary>
        <value>Es <see langword="true" /> si el acceso al objeto <see cref="T:System.Collections.SortedList" /> está sincronizado (es seguro para subprocesos); en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para garantizar la seguridad para subprocesos de un <xref:System.Collections.SortedList> objeto, todas las operaciones deben realizarse a través del contenedor devuelto por el <xref:System.Collections.SortedList.Synchronized%2A> método.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo bloquear una colección mediante el <xref:System.Collections.SortedList.SyncRoot%2A> propiedad durante toda la enumeración.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 El ejemplo de código siguiente muestra cómo sincronizar un <xref:System.Collections.SortedList> de objetos, determinar si un <xref:System.Collections.SortedList> está sincronizada y usar sincronizado <xref:System.Collections.SortedList>.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.SyncRoot" />
        <altmember cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Collections.SortedList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clave asociada al valor que se va a obtener o establecer.</param>
        <summary>Obtiene o establece el valor asociado a una clave específica de un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <value>Valor asociado al parámetro <paramref name="key" /> del objeto <see cref="T:System.Collections.SortedList" /> si se encuentra <paramref name="key" />; en caso contrario, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el <xref:System.Collections.SortedList.Item%2A> propiedad para tener acceso a un elemento específico de una colección mediante la especificación de la siguiente sintaxis: `myCollection[key]`.  
  
 También puede usar esta propiedad para agregar nuevos elementos estableciendo el valor de una clave que no existe en el <xref:System.Collections.SortedList> objeto (por ejemplo, `myCollection["myNonexistentKey"] = myValue)`. Sin embargo, si la clave especificada ya existe en el <xref:System.Collections.SortedList>, estableciendo el <xref:System.Collections.SortedList.Item%2A> propiedad sobrescribe el valor anterior. En cambio, el <xref:System.Collections.SortedList.Add%2A> método no modifica los elementos existentes.  
  
 No puede ser una clave `null`, pero puede ser un valor. Para distinguir entre `null` que se devuelve porque no se encuentra la clave especificada y `null` que se devuelve porque el valor de la clave especificada es `null`, utilice el <xref:System.Collections.SortedList.Contains%2A> método o la <xref:System.Collections.SortedList.ContainsKey%2A> método para determinar si la clave existe en la lista.  
  
 Los elementos de un <xref:System.Collections.SortedList> se ordenan por claves en función de un determinado <xref:System.Collections.IComparer> implementación que especificó cuando la <xref:System.Collections.SortedList> está creada, o según el <xref:System.IComparable> implementación proporcionada por las propias claves.  
  
 El lenguaje C# utiliza la palabra clave para definir los indizadores en lugar de implementar el <xref:System.Collections.SortedList.Keys%2A> propiedad. Visual Basic implementa <xref:System.Collections.SortedList.Item%2A> como propiedad predeterminada, lo que proporciona la misma funcionalidad de indización.  
  
 Recuperar el valor de esta propiedad es O (log `n`) operación, donde `n` es <xref:System.Collections.SortedList.Count%2A>. Establecer la propiedad es O (log `n`) operación si la clave ya está en el <xref:System.Collections.SortedList>. Si la clave no está en la lista, establecer la propiedad es O (`n`) operación para datos no ordenados, u O (log `n`) si el nuevo elemento se agrega al final de la lista. Si la inserción provoca un cambio de tamaño, la operación es O (`n`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La propiedad está establecida y el objeto <see cref="T:System.Collections.SortedList" /> es de solo lectura.  
  
O bien 
La propiedad está establecida, <paramref name="key" /> no existe en la colección y <see cref="T:System.Collections.SortedList" /> tiene un tamaño fijo.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay suficiente memoria disponible para agregar el elemento al objeto <see cref="T:System.Collections.SortedList" />.</exception>
        <exception cref="T:System.InvalidOperationException">El comparador produce una excepción.</exception>
        <altmember cref="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.SortedList.Contains(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Collections.SortedList.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene las claves de un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <value>Objeto <see cref="T:System.Collections.ICollection" /> que contiene las claves del objeto <see cref="T:System.Collections.SortedList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.ICollection> objeto es una vista de solo lectura de las claves de la <xref:System.Collections.SortedList> objeto. Las modificaciones realizadas en subyacente <xref:System.Collections.SortedList> se reflejan inmediatamente en el <xref:System.Collections.ICollection>.  
  
 Los elementos de la <xref:System.Collections.ICollection> se ordenan en el mismo orden que las claves de la <xref:System.Collections.SortedList>.  
  
 Esta propiedad es similar a la <xref:System.Collections.SortedList.GetKeyList%2A> método, pero devuelve un <xref:System.Collections.ICollection> en lugar del objeto un <xref:System.Collections.IList> objeto.  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.SortedList.Values" />
        <altmember cref="M:System.Collections.SortedList.GetKeyList" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="sortedList.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clave del elemento que se va a quitar.</param>
        <summary>Quita el elemento con la clave especificada de un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el objeto <xref:System.Collections.SortedList> no contiene ningún elemento con la clave especificada, la interfaz <xref:System.Collections.SortedList> no sufre ningún cambio. No se inicia ninguna excepción.  
  
 En colecciones de elementos contiguos, como listas, los elementos que van a continuación del elemento eliminado se desplazan hacia arriba para ocupar el espacio libre. Si la colección está indizada, también se actualizan los índices de los elementos que se han movido. Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo quitar los elementos de un <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">El objeto <see cref="T:System.Collections.SortedList" /> es de solo lectura.  
  
O bien 
<see cref="T:System.Collections.SortedList" /> tiene un tamaño fijo.</exception>
        <altmember cref="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="sortedList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se va a quitar.</param>
        <summary>Quita el elemento en el índice especificado de un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La secuencia de índice se basa en la secuencia de ordenación. Cuando se agrega un elemento, éste se inserta en <xref:System.Collections.SortedList> en la ordenación correcta orden y la indización se ajusta en consecuencia. Cuando se quita un elemento, la indización también se ajusta según corresponda. Por lo tanto, puede cambiar el índice de un par de clave y valor específico como elementos se agregan o quitan de la <xref:System.Collections.SortedList> objeto.  
  
 En colecciones de elementos contiguos, como listas, los elementos que van a continuación del elemento eliminado se desplazan hacia arriba para ocupar el espacio libre. Si la colección está indizada, también se actualizan los índices de los elementos que se han movido. Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo quitar los elementos de un <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="index" /> está fuera del intervalo de índices válidos para el objeto <see cref="T:System.Collections.SortedList" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.SortedList" /> es de solo lectura.  
  
O bien 
<see cref="T:System.Collections.SortedList" /> tiene un tamaño fijo.</exception>
        <altmember cref="M:System.Collections.SortedList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SetByIndex">
      <MemberSignature Language="C#" Value="public virtual void SetByIndex (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetByIndex(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetByIndex (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetByIndex(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member SetByIndex : int * obj -&gt; unit&#xA;override this.SetByIndex : int * obj -&gt; unit" Usage="sortedList.SetByIndex (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero en el que se guarda <paramref name="value" />.</param>
        <param name="value"><see cref="T:System.Object" /> que se va a guardar en el objeto <see cref="T:System.Collections.SortedList" />. El valor puede ser <see langword="null" />.</param>
        <summary>Reemplaza el valor de un índice especificado en un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La secuencia de índice se basa en la secuencia de ordenación. Cuando se agrega un elemento, éste se inserta en <xref:System.Collections.SortedList> en la ordenación correcta orden y la indización se ajusta en consecuencia. Cuando se quita un elemento, la indización también se ajusta según corresponda. Por lo tanto, puede cambiar el índice de un par de clave y valor específico como elementos se agregan o quitan de la <xref:System.Collections.SortedList> objeto.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo reemplazar el valor de un elemento existente en un <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.SetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.SetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.SetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="index" /> está fuera del intervalo de índices válidos para el objeto <see cref="T:System.Collections.SortedList" />.</exception>
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.SortedList Synchronized (System.Collections.SortedList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.SortedList Synchronized(class System.Collections.SortedList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As SortedList) As SortedList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::SortedList ^ Synchronized(System::Collections::SortedList ^ list);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.SortedList -&gt; System.Collections.SortedList" Usage="System.Collections.SortedList.Synchronized list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.SortedList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.SortedList" />
      </Parameters>
      <Docs>
        <param name="list">Objeto <see cref="T:System.Collections.SortedList" /> que se va a sincronizar.</param>
        <summary>Devuelve un contenedor sincronizado (seguro para subprocesos) para un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Contenedor sincronizado (seguro para subprocesos) para el objeto <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para garantizar la seguridad para subprocesos de un <xref:System.Collections.SortedList> de objeto, todas las operaciones deben realizarse a través de este contenedor solo.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo bloquear la colección utilizando el <xref:System.Collections.SortedList.SyncRoot%2A> propiedad durante toda la enumeración.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Este método es una operación o (1).  
  
 El ejemplo de código siguiente muestra cómo sincronizar un <xref:System.Collections.SortedList> de objetos, determinar si un <xref:System.Collections.SortedList> está sincronizada y usar sincronizado <xref:System.Collections.SortedList>.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="list" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.SortedList.IsSynchronized" />
        <altmember cref="P:System.Collections.SortedList.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.SortedList.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que se puede utilizar para sincronizar el acceso a un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <value>Objeto que puede utilizarse para sincronizar el acceso al objeto <see cref="T:System.Collections.SortedList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para crear una versión sincronizada de la <xref:System.Collections.SortedList> de objeto, utilice el <xref:System.Collections.SortedList.Synchronized%2A> método. Sin embargo, las clases derivadas pueden proporcionar su propia versión sincronizada de la <xref:System.Collections.SortedList> utilizando el <xref:System.Collections.SortedList.SyncRoot%2A> propiedad. El código de sincronización debe realizar operaciones en el <xref:System.Collections.SortedList.SyncRoot%2A> de la <xref:System.Collections.SortedList>, no directamente en el <xref:System.Collections.SortedList>. De este modo, se garantiza el funcionamiento correcto de las colecciones derivadas de otros objetos. En concreto, mantiene la sincronización correcta con otros subprocesos que podrían modificar simultáneamente la <xref:System.Collections.SortedList> objeto.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo bloquear la colección utilizando el <xref:System.Collections.SortedList.SyncRoot%2A> propiedad durante toda la enumeración.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.IsSynchronized" />
        <altmember cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Collections.IEnumerator" /> que itera a través del objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Estructura <see cref="T:System.Collections.IEnumerator" /> para la colección <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 La instrucción `foreach` del lenguaje C# (`for each` en Visual Basic) oculta la complejidad de los enumeradores.  Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. <xref:System.Collections.IEnumerator.Reset%2A> también devuelve el enumerador a esta posición. En esta posición, una llamada a <xref:System.Collections.IEnumerator.Current%2A> produce una excepción. Por lo tanto, debe llamar a <xref:System.Collections.IEnumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A> o a <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.IEnumerator.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`. Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, al llamar a <xref:System.Collections.IEnumerator.Current%2A> produce una excepción. Para volver a establecer el valor de <xref:System.Collections.IEnumerator.Current%2A> en el primer elemento de la colección, se puede llamar primero a <xref:System.Collections.IEnumerator.Reset%2A> y después a <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumerador es válido mientras la colección no cambie. Si se realizan cambios en la colección, como agregar, modificar, o eliminar elementos, el enumerador queda invalida invalidado y la siguiente llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> produce una <xref:System.InvalidOperationException>. Si la colección se modifica entre <xref:System.Collections.IEnumerator.MoveNext%2A> y <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> devuelve el elemento que está establecido, incluso si el enumerador ya se ha invalidado.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.TrimToSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub TrimToSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void TrimToSize();" />
      <MemberSignature Language="F#" Value="abstract member TrimToSize : unit -&gt; unit&#xA;override this.TrimToSize : unit -&gt; unit" Usage="sortedList.TrimToSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establece la capacidad en el número real de elementos de un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede utilizarse para minimizar la sobrecarga de memoria de una colección si ningún elemento nuevo se agregará a la colección.  
  
 Para restablecer un <xref:System.Collections.SortedList> objeto a su estado inicial, llamada la <xref:System.Collections.SortedList.Clear%2A> método antes de llamar a <xref:System.Collections.SortedList.TrimToSize%2A>. Recorte vacío <xref:System.Collections.SortedList> establece la capacidad de la <xref:System.Collections.SortedList> a la capacidad predeterminada.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo se recortan las partes no utilizadas de una <xref:System.Collections.SortedList> objeto y cómo borrar sus valores.  
  
 [!code-cpp[Classic SortedList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El objeto <see cref="T:System.Collections.SortedList" /> es de solo lectura.  
  
O bien 
<see cref="T:System.Collections.SortedList" /> tiene un tamaño fijo.</exception>
        <altmember cref="M:System.Collections.SortedList.Clear" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <altmember cref="P:System.Collections.SortedList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Values" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Collections.SortedList.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los valores de un objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <value>Objeto <see cref="T:System.Collections.ICollection" /> que contiene los valores del objeto <see cref="T:System.Collections.SortedList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.ICollection> objeto es una vista de solo lectura de los valores de la <xref:System.Collections.SortedList> objeto. Las modificaciones realizadas en subyacente <xref:System.Collections.SortedList> se reflejan inmediatamente en el <xref:System.Collections.ICollection>.  
  
 Los elementos de la <xref:System.Collections.ICollection> se ordenan en el mismo orden que los valores de la <xref:System.Collections.SortedList>.  
  
 Esta propiedad es similar a la <xref:System.Collections.SortedList.GetValueList%2A> método, pero devuelve un <xref:System.Collections.ICollection> en lugar del objeto un <xref:System.Collections.IList> objeto.  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.SortedList.Keys" />
        <altmember cref="M:System.Collections.SortedList.GetValueList" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
  </Members>
</Type>