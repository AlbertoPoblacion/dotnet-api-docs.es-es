<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ArrayList.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac59a105732aa94698f5ea781b6eed29feca20656b5.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9a105732aa94698f5ea781b6eed29feca20656b5</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Implements the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> interface using an array whose size is dynamically increased as required.</source>
          <target state="translated">Implementa la interfaz <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> utilizando una matriz cuyo tamaño aumenta dinámicamente cuando es necesario.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> class is designed to hold heterogeneous collections of objects.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> clase está diseñada para contener heterogéneas colecciones de objetos.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>However, it does not always offer the best performance.</source>
          <target state="translated">Sin embargo, no siempre ofrece el mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Instead, we recommend the following:</source>
          <target state="translated">En su lugar, se recomienda lo siguiente:</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>For a heterogeneous collection of objects, use the <ph id="ph1">`List&lt;Object&gt;`</ph> (in C#) or <ph id="ph2">`List(Of Object)`</ph> (in Visual Basic) type.</source>
          <target state="translated">Para obtener una colección heterogénea de objetos, use la <ph id="ph1">`List&lt;Object&gt;`</ph> (en C#) o <ph id="ph2">`List(Of Object)`</ph> (en Visual Basic), escriba.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>For a homogeneous collection of objects, use the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class.</source>
          <target state="translated">Para obtener una colección homogénea de objetos, use la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>See the "Performance Considerations" section in the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> reference topic for a discussion of the relative performance of these classes.</source>
          <target state="translated">Vea la sección "Consideraciones de rendimiento" en el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> tema de referencia para obtener una explicación del rendimiento relativo de estas clases.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is not guaranteed to be sorted.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> no se garantiza que se ordenen.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>You must sort the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> by calling its <ph id="ph2">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> method prior to performing operations (such as <ph id="ph3">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph>) that require the <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> to be sorted.</source>
          <target state="translated">Se debe ordenar el <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> mediante una llamada a su <ph id="ph2">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> método antes de realizar operaciones (como <ph id="ph3">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph>) que requieren el <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> se ordenen.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>To maintain a collection that is automatically sorted as new elements are added, you can use the <ph id="ph1">&lt;xref:System.Collections.Generic.SortedSet%601&gt;</ph> class.</source>
          <target state="translated">Para mantener una colección que se ordena automáticamente cuando se agregan nuevos elementos, puede usar el <ph id="ph1">&lt;xref:System.Collections.Generic.SortedSet%601&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The capacity of an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is the number of elements the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can hold.</source>
          <target state="translated">La capacidad de un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> es el número de elementos de la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> puede contener.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>As elements are added to an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, the capacity is automatically increased as required through reallocation.</source>
          <target state="translated">Cuando se agregan elementos a un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, la capacidad aumenta automáticamente según sea necesario mediante la reasignación.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The capacity can be decreased by calling <ph id="ph1">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> or by setting the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> property explicitly.</source>
          <target state="translated">La capacidad puede reducirse mediante una llamada a <ph id="ph1">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> o estableciendo la <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> propiedad explícitamente.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>For very large <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the <ph id="ph2">`enabled`</ph> attribute of the  configuration element to <ph id="ph3">`true`</ph> in the run-time environment.</source>
          <target state="translated">Para un gran <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> objetos, puede aumentar la capacidad máxima de 2 millones de elementos en un sistema de 64 bits estableciendo la <ph id="ph2">`enabled`</ph> atributo del elemento de configuración para <ph id="ph3">`true`</ph> en el entorno de tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Elements in this collection can be accessed using an integer index.</source>
          <target state="translated">Pueden tener acceso a los elementos de esta colección utilizando un índice entero.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Indexes in this collection are zero-based.</source>
          <target state="translated">Índices de esta colección son de base cero.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> collection accepts <ph id="ph2">`null`</ph> as a valid value.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> colección acepta <ph id="ph2">`null`</ph> como un valor válido.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>It also allows duplicate elements.</source>
          <target state="translated">También permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Using multidimensional arrays as elements in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> collection is not supported.</source>
          <target state="translated">Utilizar matrices multidimensionales como elementos en una <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> no se admite la recopilación.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The following code example shows how to create and initialize an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and how to display its values.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo crear e inicializar un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> y cómo mostrar sus valores.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">Estático público (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> en Visual Basic) miembros de este tipo son seguros para subprocesos.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Any instance members are not guaranteed to be thread safe.</source>
          <target state="translated">No se garantiza que los miembros de instancias sean seguros para la ejecución de subprocesos.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> can support multiple readers concurrently, as long as the collection is not modified.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> puede admitir varios sistemas de lectura al mismo tiempo, siempre y cuando no se modifica la colección.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>To guarantee the thread safety of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, all operations must be done through the wrapper returned by the <ph id="ph2">&lt;see cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" /&gt;</ph> method.</source>
          <target state="translated">Para garantizar la seguridad para subprocesos de la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, todas las operaciones deben realizarse a través del contenedor devuelto por el <ph id="ph2">&lt;see cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" /&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> class that is empty and has the default initial capacity.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que está vacía y tiene la capacidad inicial predeterminada.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor">
          <source>The capacity of an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can hold.</source>
          <target state="translated">La capacidad de un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> es el número de elementos que la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> puede contener.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor">
          <source>As elements are added to an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Cuando se agregan elementos a un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, la capacidad aumenta automáticamente según sea necesario mediante la reasignación de la matriz interna.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Este constructor es una operación o (1).</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> whose elements are copied to the new list.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> cuyos elementos se copian en la nueva lista.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> class that contains elements copied from the specified collection and that has the same initial capacity as the number of elements copied.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que contiene elementos copiados de la colección especificada y que tiene la misma capacidad inicial que el número de elementos copiados.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>The capacity of an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can hold.</source>
          <target state="translated">La capacidad de un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> es el número de elementos que la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> puede contener.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>As elements are added to an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Cuando se agregan elementos a un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, la capacidad aumenta automáticamente según sea necesario mediante la reasignación de la matriz interna.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>The elements are copied onto the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> in the same order they are read by the <ph id="ph2">&lt;xref:System.Collections.IEnumerator&gt;</ph> of the <ph id="ph3">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
          <target state="translated">Los elementos se copian en el <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> en el mismo orden que los lee la <ph id="ph2">&lt;xref:System.Collections.IEnumerator&gt;</ph> de la <ph id="ph3">&lt;xref:System.Collections.ICollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in <ph id="ph3">`c`</ph>.</source>
          <target state="translated">Este constructor es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es el número de elementos de <ph id="ph3">`c`</ph>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>The number of elements that the new list can initially store.</source>
          <target state="translated">Número de elementos que puede almacenar inicialmente la lista nueva.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> class that is empty and has the specified initial capacity.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que está vacía y tiene la capacidad inicial especificada.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>The capacity of an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can hold.</source>
          <target state="translated">La capacidad de un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> es el número de elementos que la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> puede contener.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>As elements are added to an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Cuando se agregan elementos a un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, la capacidad aumenta automáticamente según sea necesario mediante la reasignación de la matriz interna.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`capacity`</ph>.</source>
          <target state="translated">Este constructor es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">`capacity`</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> to wrap.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> que se va a incluir.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper for a specific <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Crea un contenedor de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> para una interfaz <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph> concreta.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper around the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Contenedor de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> para <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Adapter%2A&gt;</ph> does not copy the contents of <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Adapter%2A&gt;</ph> no copia el contenido de <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>Instead, it only creates an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> wrapper around <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>; therefore, changes to the <ph id="ph3">&lt;xref:System.Collections.IList&gt;</ph> also affect the <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En su lugar, sólo crea un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> envuelve <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>; por lo tanto, cambia a la <ph id="ph3">&lt;xref:System.Collections.IList&gt;</ph> también afectan a la <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> class provides generic <ph id="ph2">&lt;xref:System.Collections.ArrayList.Reverse%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> methods.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> clase proporciona genérico <ph id="ph2">&lt;xref:System.Collections.ArrayList.Reverse%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph> y <ph id="ph4">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>This wrapper can be a means to use those methods on <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph>; however, performing these generic operations through the wrapper might be less efficient than operations applied directly on the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</source>
          <target state="translated">Este contenedor puede ser un medio para utilizar estos métodos en <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph>; sin embargo, realizar estas operaciones genéricas a través del contenedor puede ser menos eficiente que las operaciones aplicadas directamente en el <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>Version Compatibility</source>
          <target state="translated">Compatibilidad de versiones</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>In the .NET Framework version 1.0 and 1.1, calling the <ph id="ph1">&lt;xref:System.Collections.ArrayList.GetEnumerator%28System.Int32%2CSystem.Int32%29&gt;</ph> method overload on the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> wrapper returned an enumerator that treated the second argument as an upper bound rather than as a count.</source>
          <target state="translated">En .NET Framework versiones 1.0 y 1.1, al llamar a la <ph id="ph1">&lt;xref:System.Collections.ArrayList.GetEnumerator%28System.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga del método en el <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> contenedor devuelve un enumerador que trata el segundo argumento como un límite superior en lugar de como un recuento.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> the second argument is correctly treated as a count.</source>
          <target state="translated">En el <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> el segundo argumento se trata correctamente como un número.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to be added to the end of the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a agregar al final de la colección <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>Adds an object to the end of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Agrega un objeto al final de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> index at which the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> has been added.</source>
          <target state="translated">Índice de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> en el que se ha agregado <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> acepta <ph id="ph2">`null`</ph> como un valor válido y permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> already equals <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> ya es igual a <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, la capacidad de la <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> se incrementa mediante la reasignación automática de la matriz interna, y se copian los elementos existentes en la nueva matriz antes de agrega el nuevo elemento.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> is less than <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, this method is an O(1) operation.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> es menor que <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>If the capacity needs to be increased to accommodate the new element, this method becomes an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Si la capacidad debe aumentarse para alojar el nuevo elemento, este método se convierte en una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The following code example shows how to add elements to the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo agregar elementos a la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tiene un tamaño fijo.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> whose elements should be added to the end of the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> cuyos elementos deben agregarse al final de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The collection itself cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>, but it can contain elements that are <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propia colección no puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>, pero puede contener elementos que sean <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>Adds the elements of an <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> to the end of the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Agrega los elementos de <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> al final de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> acepta <ph id="ph2">`null`</ph> como un valor válido y permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The order of the elements in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is preserved in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">El orden de los elementos de la <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> se conserva en el <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>If the new <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> (the current <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> plus the size of the collection) will be greater than <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> is increased by automatically reallocating the internal array to accommodate the new elements, and the existing elements are copied to the new array before the new elements are added.</source>
          <target state="translated">Si el nuevo <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> (actual <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> más el tamaño de la colección) será mayor que <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, la capacidad de la <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> se incrementa mediante la reasignación automática de la matriz interna para dar cabida a los nuevos elementos, y se copian los elementos existentes en la nueva matriz antes de que se agregan los nuevos elementos.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> can accommodate the new elements without increasing the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, this method is an O(<ph id="ph3">`n`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements to be added.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> puede dar cabida a los nuevos elementos sin aumentar la <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, este método es una O (<ph id="ph3">`n`</ph>) operación, donde <ph id="ph4">`n`</ph> es el número de elementos que se va a agregar.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>If the capacity needs to be increased to accommodate the new elements, this method becomes an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements to be added and <ph id="ph5">`m`</ph> is <ph id="ph6">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Si la capacidad debe aumentarse para dar cabida a los nuevos elementos, este método se convierte en una O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operación, donde <ph id="ph4">`n`</ph> es el número de elementos que se va a agregarse y <ph id="ph5">`m`</ph> es <ph id="ph6">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The following code example shows how to add elements to the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo agregar elementos a la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tiene un tamaño fijo.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Uses a binary search algorithm to locate a specific element in the sorted <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Utiliza un algoritmo de búsqueda binaria para localizar un elemento concreto en la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ordenada o en una parte de ella.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate.</source>
          <target state="translated">Clase <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a localizar.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>Searches the entire sorted <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> for an element using the default comparer and returns the zero-based index of the element.</source>
          <target state="translated">Busca la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> completa ordenada para un elemento usando el comparador predeterminado y devuelve el índice de base cero del elemento.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The zero-based index of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the sorted <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph> or, if there is no larger element, the bitwise complement of <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated">Índice de base cero de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> en la <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ordenada si se encuentra <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; en caso contrario, número negativo, que es el complemento bit a bit del índice del siguiente elemento mayor que <ph id="ph4">&lt;paramref name="value" /&gt;</ph> o, si no hay ningún elemento mayor, el complemento bit a bit de la propiedad <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The <ph id="ph1">`value`</ph> parameter and each element of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, which is used for comparisons.</source>
          <target state="translated">El <ph id="ph1">`value`</ph> parámetro y cada elemento de la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> debe implementar la <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interfaz, que se usa para las comparaciones.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Los elementos de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por el <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementación; en caso contrario, el resultado puede ser incorrecto.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>Comparing <ph id="ph1">`null`</ph> with any type is allowed and does not generate an exception when using <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Comparar <ph id="ph1">`null`</ph> se permite con cualquier tipo y no genera una excepción cuando se usa <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>When sorting, <ph id="ph1">`null`</ph> is considered to be less than any other object.</source>
          <target state="translated">Al ordenar, <ph id="ph1">`null`</ph> se considera menor que cualquier otro objeto.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contiene más de un elemento con el mismo valor, el método devuelve solo una de las apariciones y puede devolver cualquiera de ellas, pero no necesariamente la primera de ellas.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> no contiene el valor especificado, el método devuelve un entero negativo.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value.</source>
          <target state="translated">Puede aplicar la operación de complemento bit a bit (~) a este entero negativo para obtener el índice del primer elemento que es mayor que el valor de búsqueda.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>When inserting the value into the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, this index should be used as the insertion point to maintain the sort order.</source>
          <target state="translated">Cuando se inserta el valor en el <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, este índice se debe utilizar como punto de inserción para mantener el criterio de ordenación.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (registro <ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The following code example shows how to use <ph id="ph1">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph> to locate a specific object in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo utilizar <ph id="ph1">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph> para localizar un objeto específico en el <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>Neither <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nor the elements of <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Ni <ph id="ph1">&lt;paramref name="value" /&gt;</ph> ni los elementos de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> implementan la interfaz <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not of the same type as the elements of the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> no es del mismo tipo que los elementos de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate.</source>
          <target state="translated">Clase <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a localizar.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implementación de <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> que se va a usar al comparar elementos.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer that is the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> para utilizar el comparador predeterminado, que es la implementación de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de cada elemento.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>Searches the entire sorted <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> for an element using the specified comparer and returns the zero-based index of the element.</source>
          <target state="translated">Busca la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> completa ordenada para un elemento usando el comparador especificado y devuelve el índice de base cero del elemento.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The zero-based index of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the sorted <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph> or, if there is no larger element, the bitwise complement of <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated">Índice de base cero de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> en la <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ordenada si se encuentra <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; en caso contrario, número negativo, que es el complemento bit a bit del índice del siguiente elemento mayor que <ph id="ph4">&lt;paramref name="value" /&gt;</ph> o, si no hay ningún elemento mayor, el complemento bit a bit de la propiedad <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">El comparador personaliza cómo se comparan los elementos.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> instance as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Por ejemplo, puede usar un <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> instancia como comparador para realizar búsquedas de cadenas entre mayúsculas y minúsculas.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is provided, the elements of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> are compared to the specified value using the specified <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> se proporciona, los elementos de la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> se comparan con el valor especificado utilizando el parámetro <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementación.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Los elementos de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por <ph id="ph2">`comparer`</ph>; en caso contrario, el resultado puede ser incorrecto.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> es <ph id="ph2">`null`</ph>, la comparación se realiza mediante el <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementación proporcionada por el propio elemento o por el valor especificado.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Los elementos de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por el <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementación; en caso contrario, el resultado puede ser incorrecto.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>Comparing <ph id="ph1">`null`</ph> with any type is allowed and does not generate an exception when using <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Comparar <ph id="ph1">`null`</ph> se permite con cualquier tipo y no genera una excepción cuando se usa <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>When sorting, <ph id="ph1">`null`</ph> is considered to be less than any other object.</source>
          <target state="translated">Al ordenar, <ph id="ph1">`null`</ph> se considera menor que cualquier otro objeto.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contiene más de un elemento con el mismo valor, el método devuelve solo una de las apariciones y puede devolver cualquiera de ellas, pero no necesariamente la primera de ellas.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> no contiene el valor especificado, el método devuelve un entero negativo.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value.</source>
          <target state="translated">Puede aplicar la operación de complemento bit a bit (~) a este entero negativo para obtener el índice del primer elemento que es mayor que el valor de búsqueda.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>When inserting the value into the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, this index should be used as the insertion point to maintain the sort order.</source>
          <target state="translated">Cuando se inserta el valor en el <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, este índice se debe utilizar como punto de inserción para mantener el criterio de ordenación.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (registro <ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The following example creates an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> of colored animals.</source>
          <target state="translated">En el ejemplo siguiente se crea un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> de animales color.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The provided <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> performs the string comparison for the binary search.</source>
          <target state="translated">Proporcionado <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> realiza la comparación de cadenas para la búsqueda binaria.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The results of both an iterative search and a binary search are displayed.</source>
          <target state="translated">Se muestran los resultados de una búsqueda iterativa y una búsqueda binaria.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and neither <ph id="ph3">&lt;paramref name="value" /&gt;</ph> nor the elements of <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph> y ni <ph id="ph3">&lt;paramref name="value" /&gt;</ph> ni los elementos de <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> implementan la interfaz de <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is not of the same type as the elements of the <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph> y <ph id="ph3">&lt;paramref name="value" /&gt;</ph> no es del mismo tipo que los elementos de <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The zero-based starting index of the range to search.</source>
          <target state="translated">Índice inicial de base cero del intervalo que se va a buscar.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The length of the range to search.</source>
          <target state="translated">Longitud del intervalo en el que se va a buscar.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate.</source>
          <target state="translated">Clase <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a localizar.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implementación de <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> que se va a usar al comparar elementos.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer that is the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> para utilizar el comparador predeterminado, que es la implementación de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de cada elemento.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Searches a range of elements in the sorted <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> for an element using the specified comparer and returns the zero-based index of the element.</source>
          <target state="translated">Busca un elemento en un intervalo de elementos del objeto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ordenado usando el comparador especificado y devuelve el índice de base cero del elemento.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The zero-based index of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the sorted <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph> or, if there is no larger element, the bitwise complement of <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated">Índice de base cero de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> en la <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ordenada si se encuentra <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; en caso contrario, número negativo, que es el complemento bit a bit del índice del siguiente elemento mayor que <ph id="ph4">&lt;paramref name="value" /&gt;</ph> o, si no hay ningún elemento mayor, el complemento bit a bit de la propiedad <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">El comparador personaliza cómo se comparan los elementos.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> instance as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Por ejemplo, puede usar un <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> instancia como comparador para realizar búsquedas de cadenas entre mayúsculas y minúsculas.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is provided, the elements of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> are compared to the specified value using the specified <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> se proporciona, los elementos de la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> se comparan con el valor especificado utilizando el parámetro <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementación.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Los elementos de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por <ph id="ph2">`comparer`</ph>; en caso contrario, el resultado puede ser incorrecto.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> es <ph id="ph2">`null`</ph>, la comparación se realiza mediante el <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementación proporcionada por el propio elemento o por el valor especificado.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Los elementos de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por el <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementación; en caso contrario, el resultado puede ser incorrecto.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Comparing <ph id="ph1">`null`</ph> with any type is allowed and does not generate an exception when using <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Comparar <ph id="ph1">`null`</ph> se permite con cualquier tipo y no genera una excepción cuando se usa <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>When sorting, <ph id="ph1">`null`</ph> is considered to be less than any other object.</source>
          <target state="translated">Al ordenar, <ph id="ph1">`null`</ph> se considera menor que cualquier otro objeto.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contiene más de un elemento con el mismo valor, el método devuelve solo una de las apariciones y puede devolver cualquiera de ellas, pero no necesariamente la primera de ellas.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> no contiene el valor especificado, el método devuelve un entero negativo.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value.</source>
          <target state="translated">Puede aplicar la operación de complemento bit a bit (~) a este entero negativo para obtener el índice del primer elemento que es mayor que el valor de búsqueda.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>When inserting the value into the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, this index should be used as the insertion point to maintain the sort order.</source>
          <target state="translated">Cuando se inserta el valor en el <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, este índice se debe utilizar como punto de inserción para mantener el criterio de ordenación.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Este método es una O (registro <ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no denotan un intervalo válido en <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and neither <ph id="ph3">&lt;paramref name="value" /&gt;</ph> nor the elements of <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph> y ni <ph id="ph3">&lt;paramref name="value" /&gt;</ph> ni los elementos de <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> implementan la interfaz de <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is not of the same type as the elements of the <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph> y <ph id="ph3">&lt;paramref name="value" /&gt;</ph> no es del mismo tipo que los elementos de <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Capacity">
          <source>Gets or sets the number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> can contain.</source>
          <target state="translated">Obtiene o establece el número de elementos que puede contener <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source>The number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> can contain.</source>
          <target state="translated">Número de elementos que puede contener <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can store.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> es el número de elementos que la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> puede almacenar.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> is the number of elements that are actually in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> es el número de elementos que están realmente en la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> is always greater than or equal to <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> es siempre mayor o igual que <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source>If <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> exceeds <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> while adding elements, the capacity is automatically increased by reallocating the internal array before copying the old elements and adding the new elements.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> supera <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> al agregar elementos, la capacidad aumenta automáticamente mediante la reasignación de la matriz interna antes de copiar los elementos antiguos y agregar los nuevos elementos.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source>The capacity can be decreased by calling <ph id="ph1">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> or by setting the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> property explicitly.</source>
          <target state="translated">La capacidad puede reducirse mediante una llamada a <ph id="ph1">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> o estableciendo la <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> propiedad explícitamente.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source>When the value of <ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> is set explicitly, the internal array is also reallocated to accommodate the specified capacity.</source>
          <target state="translated">Cuando el valor de <ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> se establece explícitamente, la matriz interna se reasigna para alojar la capacidad especificada.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the new capacity.</source>
          <target state="translated">La recuperación del valor de esta propiedad es una operación o (1); establecer la propiedad es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es la capacidad de nuevo.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Capacity">
          <source><ph id="ph1">&lt;see cref="P:System.Collections.ArrayList.Capacity" /&gt;</ph> is set to a value that is less than <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Collections.ArrayList.Capacity" /&gt;</ph> se establece en un valor que es menor que <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Capacity">
          <source>There is not enough memory available on the system.</source>
          <target state="translated">No hay memoria suficiente en el sistema.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clear">
          <source>Removes all elements from the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Quita todos los elementos de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> is set to zero, and references to other objects from elements of the collection are also released.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> está establecido en cero, y también se liberan las referencias a otros objetos desde los elementos de la colección.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> remains unchanged.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> No cambie.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source>To reset the capacity of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, call <ph id="ph2">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> or set the <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> property directly.</source>
          <target state="translated">Para restablecer la capacidad de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, llame a <ph id="ph2">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> o establecer el <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> propiedad directamente.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source>Trimming an empty <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> sets the capacity of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> to the default capacity.</source>
          <target state="translated">Recortar vacío <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> establece la capacidad de la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> en la capacidad predeterminada.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source>The following code example shows how to trim the unused portions of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and how to clear the values of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo se recortan las partes no utilizadas de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> y cómo se borran los valores de la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clear">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clear">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clear">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tiene un tamaño fijo.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clone">
          <source>Creates a shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Crea una copia superficial de la colección <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clone">
          <source>A shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Copia superficial de la colección <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clone">
          <source>A shallow copy of a collection copies only the elements of the collection, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
          <target state="translated">Una copia superficial de una colección copia únicamente los elementos de la colección, si son tipos de referencia o tipos de valor, pero no copia los objetos que hacen referencia las referencias.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clone">
          <source>The references in the new collection point to the same objects that the references in the original collection point to.</source>
          <target state="translated">Las referencias de la nueva colección apuntan a los mismos objetos que apuntan las referencias de la colección original.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clone">
          <source>In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">En cambio, una copia en profundidad de una colección copia los elementos y todo lo que hacen referencia directa o indirectamente el elementos.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clone">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a buscar en la interfaz <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>Determines whether an element is in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Determina si un elemento se encuentra en <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="item" /&gt;</ph> is found in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="item" /&gt;</ph> se encuentra en la matriz <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>; en caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método determina la igualdad llamando a <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">A partir de .NET Framework 2.0, este método usa los objetos de la colección <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> métodos en <ph id="ph3">`item`</ph> para determinar si existe cualquier elemento.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">En las versiones anteriores de .NET Framework, esta determinación se realizó utilizando el <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> métodos de la <ph id="ph3">`item`</ph> parámetro en los objetos de la colección.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Copies the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or a portion of it to a one-dimensional array.</source>
          <target state="translated">Copia la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> o una parte de la misma en una matriz unidimensional.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional que constituye el destino de los elementos copiados de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated">La matriz <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> debe tener una indización de base cero.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>Copies the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a compatible one-dimensional <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>, starting at the beginning of the target array.</source>
          <target state="translated">Copia la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> completa en una <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional compatible, empezando en el principio de la matriz de destino.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The specified array must be of a compatible type.</source>
          <target state="translated">La matriz especificada debe ser de un tipo compatible.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> to copy the elements.</source>
          <target state="translated">Este método usa <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> para copiar los elementos.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Los elementos se copian en el <ph id="ph1">&lt;xref:System.Array&gt;</ph> en el mismo orden en el que el enumerador recorre en iteración la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> into a one-dimensional <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo copiar un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> en un unidimensional <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is greater than the number of elements that the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph> can contain.</source>
          <target state="translated">El número de elementos del <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origen es mayor que el número de elementos que puede contener el <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">El tipo de la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origen no puede convertirse automáticamente al tipo de la <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional que constituye el destino de los elementos copiados de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated">La matriz <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> debe tener una indización de base cero.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Índice de base cero de <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> donde comienza la copia.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>Copies the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a compatible one-dimensional <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>, starting at the specified index of the target array.</source>
          <target state="translated">Copia la totalidad de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> en una matriz <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional compatible, comenzando en el índice especificado de la matriz de destino.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The specified array must be of a compatible type.</source>
          <target state="translated">La matriz especificada debe ser de un tipo compatible.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> to copy the elements.</source>
          <target state="translated">Este método usa <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> para copiar los elementos.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Los elementos se copian en el <ph id="ph1">&lt;xref:System.Array&gt;</ph> en el mismo orden en el que el enumerador recorre en iteración la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> into a one-dimensional <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo copiar un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> en un unidimensional <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is greater than the available space from <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> to the end of the destination <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">El número de elementos de la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origen es mayor que el espacio disponible desde <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> hasta el final de la <ph id="ph3">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">El tipo de la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origen no puede convertirse automáticamente al tipo de la <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The zero-based index in the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> at which copying begins.</source>
          <target state="translated">Índice de base cero de la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origen donde comienza la copia.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional que constituye el destino de los elementos copiados de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated">La matriz <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> debe tener una indización de base cero.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Índice de base cero de <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> donde comienza la copia.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The number of elements to copy.</source>
          <target state="translated">Número de elementos que se van a copiar.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Copies a range of elements from the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a compatible one-dimensional <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>, starting at the specified index of the target array.</source>
          <target state="translated">Copia un intervalo de elementos de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> en una <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional compatible, empezando en el índice especificado de la matriz de destino.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The specified array must be of a compatible type.</source>
          <target state="translated">La matriz especificada debe ser de un tipo compatible.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> to copy the elements.</source>
          <target state="translated">Este método usa <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> para copiar los elementos.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Los elementos se copian en el <ph id="ph1">&lt;xref:System.Array&gt;</ph> en el mismo orden en el que el enumerador recorre en iteración la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> into a one-dimensional <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo copiar un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> en un unidimensional <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than the <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph> of the source <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es mayor o igual que el valor de <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph> de la <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origen.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The number of elements from <ph id="ph1">&lt;paramref name="index" /&gt;</ph> to the end of the source <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is greater than the available space from <ph id="ph3">&lt;paramref name="arrayIndex" /&gt;</ph> to the end of the destination <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">El número de elementos de <ph id="ph1">&lt;paramref name="index" /&gt;</ph> hasta el final de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origen es mayor que el espacio disponible desde <ph id="ph3">&lt;paramref name="arrayIndex" /&gt;</ph> hasta el final de <ph id="ph4">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">El tipo de la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origen no puede convertirse automáticamente al tipo de la <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Count">
          <source>Gets the number of elements actually contained in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Obtiene el número de elementos contenido realmente en <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source>The number of elements actually contained in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Número de elementos contenido realmente en <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can store.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> es el número de elementos que la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> puede almacenar.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> is the number of elements that are actually in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> es el número de elementos que están realmente en la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> is always greater than or equal to <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> es siempre mayor o igual que <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source>If <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> exceeds <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> while adding elements, the capacity is automatically increased by reallocating the internal array before copying the old elements and adding the new elements.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> supera <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> al agregar elementos, la capacidad aumenta automáticamente mediante la reasignación de la matriz interna antes de copiar los elementos antiguos y agregar los nuevos elementos.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La recuperación del valor de esta propiedad es una operación O(1).</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns a list wrapper with a fixed size, where elements are allowed to be modified, but not added or removed.</source>
          <target state="translated">Devuelve un contenedor de lista con un tamaño fijo, donde se permite modificar elementos pero no agregarlos ni quitarlos.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to wrap.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que se va a incluir.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper with a fixed size.</source>
          <target state="translated">Devuelve un contenedor de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> con un tamaño fijo.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper with a fixed size.</source>
          <target state="translated">Contenedor de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> con un tamaño fijo.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>This wrapper can be used to prevent additions to and deletions from the original <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Este contenedor se puede utilizar para evitar adiciones y eliminaciones de los originales <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>The elements can still be modified or replaced.</source>
          <target state="translated">Todavía se pueden modificar o reemplazar los elementos.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
          <target state="translated">Una colección con un tamaño fijo es simplemente una colección con un contenedor que impide agregar y quitar elementos; por lo tanto, si se realizan cambios en la colección subyacente, incluida la adición o eliminación de elementos, la colección de tamaño fijo refleja esos cambios.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>The following code example shows how to create a fixed-size wrapper around an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo crear un contenedor de tamaño fijo alrededor de un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> to wrap.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> que se va a incluir.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper with a fixed size.</source>
          <target state="translated">Devuelve un contenedor de <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> con un tamaño fijo.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper with a fixed size.</source>
          <target state="translated">Contenedor de <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> con un tamaño fijo.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>This wrapper can be used to prevent additions to and deletions from the original <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph>.</source>
          <target state="translated">Este contenedor se puede utilizar para evitar adiciones y eliminaciones de los originales <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>The elements can still be modified or replaced.</source>
          <target state="translated">Todavía se pueden modificar o reemplazar los elementos.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
          <target state="translated">Una colección con un tamaño fijo es simplemente una colección con un contenedor que impide agregar y quitar elementos; por lo tanto, si se realizan cambios en la colección subyacente, incluida la adición o eliminación de elementos, la colección de tamaño fijo refleja esos cambios.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns an enumerator that iterates through the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Devuelve un enumerador que recorre en iteración la colección <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>Returns an enumerator for the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Devuelve un enumerador para la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> completa.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the entire <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Interfaz <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> para toda la colección <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">La instrucción <ph id="ph1">`foreach`</ph> del lenguaje C# (<ph id="ph2">`for each`</ph> en Visual Basic) oculta la complejidad de los enumeradores.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Por lo tanto, se recomienda el uso de <ph id="ph1">`foreach`</ph>, en lugar de manipular directamente el enumerador.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">En principio, el enumerador se coloca antes del primer elemento de la colección.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> también devuelve el enumerador a esta posición.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">En esta posición, el valor de propiedad <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> está sin definir.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Por lo tanto, debe llamar a <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> devuelve el mismo objeto hasta que se llama a <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> o a <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> establece <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> en el siguiente elemento.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> devuelve <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Mientras el enumerador permanezca en esta posición, las llamadas subsiguientes a <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> también devolver <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Si la última llamada a <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> devuelve <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> no está definido.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Para volver a establecer el valor de <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> en el primer elemento de la colección, se puede llamar primero a <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> y después a <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Un enumerador es válido mientras la colección no cambie.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Si se hacen cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado permanentemente y su comportamiento es indefinido.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>The following example gets the enumerator for an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, and the enumerator for a range of elements in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se obtiene el enumerador para un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>y el enumerador para un intervalo de elementos de la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>The zero-based starting index of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> section that the enumerator should refer to.</source>
          <target state="translated">Índice inicial de base cero de la sección de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> a la que debe hacer referencia el enumerador.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>The number of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> section that the enumerator should refer to.</source>
          <target state="translated">Número de elementos de la sección de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> a la que debe hacer referencia el enumerador.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Returns an enumerator for a range of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Devuelve un enumerador para un intervalo de elementos de la matriz <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the specified range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> para el intervalo de elementos especificado de la matriz <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual C++, <ph id="ph3">`For Each`</ph> Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">El <ph id="ph1">`foreach`</ph> instrucción del lenguaje C# (<ph id="ph2">`for each`</ph> en Visual C++, <ph id="ph3">`For Each`</ph> Visual Basic) oculta la complejidad de los enumeradores.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Por lo tanto, se recomienda el uso de <ph id="ph1">`foreach`</ph>, en lugar de manipular directamente el enumerador.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">En principio, el enumerador se coloca antes del primer elemento de la colección.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> también devuelve el enumerador a esta posición.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">En esta posición, el valor de propiedad <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> está sin definir.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Por lo tanto, debe llamar a <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> devuelve el mismo objeto hasta que se llama a <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> o a <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> establece <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> en el siguiente elemento.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> devuelve <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Mientras el enumerador permanezca en esta posición, las llamadas subsiguientes a <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> también devolver <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Si la última llamada a <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> devuelve <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> no está definido.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Para volver a establecer el valor de <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> en el primer elemento de la colección, se puede llamar primero a <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> y después a <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Un enumerador es válido mientras la colección no cambie.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Si se hacen cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado permanentemente y su comportamiento es indefinido.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Version Compatibility</source>
          <target state="translated">Compatibilidad de versiones</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>In the .NET Framework versions 1.0 and 1.1, the enumerator for an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> wrapper returned by the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Adapter%2A&gt;</ph> method treated the second argument as an upper bound rather than as a count.</source>
          <target state="translated">En las versiones de .NET Framework 1.0 y 1.1, el enumerador para un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contenedor devuelto por el <ph id="ph2">&lt;xref:System.Collections.ArrayList.Adapter%2A&gt;</ph> método trata el segundo argumento como un límite superior en lugar de como un recuento.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> the second argument is correctly treated as a count.</source>
          <target state="translated">En el <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> el segundo argumento se trata correctamente como un número.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>The following example gets the enumerator for an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, and the enumerator for a range of elements in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se obtiene el enumerador para un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>y el enumerador para un intervalo de elementos de la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no especifican un intervalo válido en <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>The zero-based <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> index at which the range starts.</source>
          <target state="translated">Índice de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de base cero en el que empieza el intervalo.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>The number of elements in the range.</source>
          <target state="translated">Número de elementos del intervalo.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> which represents a subset of the elements in the source <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Devuelve una <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que representa un subconjunto de los elementos de la <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origen.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> which represents a subset of the elements in the source <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que representa un subconjunto de los elementos de la <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origen.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>This method does not create copies of the elements.</source>
          <target state="translated">Este método no crea copias de los elementos.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>The new <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is only a view window into the source <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">El nuevo <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> es sólo una ventana de vista en el origen de <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>However, all subsequent changes to the source <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must be done through this view window <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Sin embargo, todos los cambios subsiguientes en el origen de <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> debe realizarse a través de esta ventana de vista <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>If changes are made directly to the source <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, the view window <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> is invalidated and any operations on it will return an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Si se realizan cambios directamente en el origen de <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, la ventana de vista <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> se invalida cualquier operación en él, se devolverá un <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>The following code example shows how to set and get a range of elements in the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo establecer y obtener un intervalo de elementos de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range of elements in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no denotan un intervalo válido de elementos en <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns the zero-based index of the first occurrence of a value in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or in a portion of it.</source>
          <target state="translated">Devuelve el índice de base cero de la primera aparición de un valor en la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> o en una parte de ella.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a buscar en la interfaz <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the first occurrence within the entire <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Busca el objeto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> especificado y devuelve el índice de base cero de la primera aparición en toda la colección <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Índice de base cero de la primera aparición de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> en la totalidad de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, si se encuentra; en caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched forward starting at the first element and ending at the last element.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> se busca hacia delante a partir del primer elemento y terminando con el último elemento.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método determina la igualdad llamando a <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">A partir de .NET Framework 2.0, este método usa los objetos de la colección <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> métodos en <ph id="ph3">`item`</ph> para determinar si existe cualquier elemento.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">En las versiones anteriores de .NET Framework, esta determinación se realizó utilizando el <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> métodos de la <ph id="ph3">`item`</ph> parámetro en los objetos de la colección.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>The following code example shows how to determine the index of the first occurrence of a specified element.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo se determina el índice de la primera aparición de un elemento especificado.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a buscar en la interfaz <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Índice inicial de base cero de la búsqueda.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>0 (zero) is valid in an empty list.</source>
          <target state="translated">0 (cero) es válido en una lista vacía.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that extends from the specified index to the last element.</source>
          <target state="translated">Busca el objeto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> especificado y devuelve el índice de base cero de la primera aparición dentro del intervalo de elementos de la matriz <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que abarca desde el índice especificado hasta el último elemento.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that extends from <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to the last element, if found; otherwise, -1.</source>
          <target state="translated">Índice de base cero de la primera aparición de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dentro del intervalo de elementos de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que abarca desde <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> hasta el último elemento, si se encuentra; de lo contrario, -1.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at the last element.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> se busca hacia delante, empezando en <ph id="ph2">`startIndex`</ph> y terminando con el último elemento.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of the <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es el número de elementos de <ph id="ph3">`startIndex`</ph> al final de la <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método determina la igualdad llamando a <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">A partir de .NET Framework 2.0, este método usa los objetos de la colección <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> métodos en <ph id="ph3">`item`</ph> para determinar si existe cualquier elemento.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">En las versiones anteriores de .NET Framework, esta determinación se realizó utilizando el <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> métodos de la <ph id="ph3">`item`</ph> parámetro en los objetos de la colección.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The following code example shows how to determine the index of the first occurrence of a specified element.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo se determina el índice de la primera aparición de un elemento especificado.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> está fuera del intervalo de índices válidos para <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a buscar en la interfaz <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Índice inicial de base cero de la búsqueda.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>0 (zero) is valid in an empty list.</source>
          <target state="translated">0 (cero) es válido en una lista vacía.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Número de elementos de la sección en la que se va a realizar la búsqueda.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that starts at the specified index and contains the specified number of elements.</source>
          <target state="translated">Busca el objeto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> especificado y devuelve el índice de base cero de la primera aparición dentro del intervalo de elementos de la matriz <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que comienza en el índice especificado y contiene el número especificado de elementos.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that starts at <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and contains <ph id="ph4">&lt;paramref name="count" /&gt;</ph> number of elements, if found; otherwise, -1.</source>
          <target state="translated">Índice de base cero de la primera aparición de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dentro del intervalo de elementos de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que comienza en <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> y contiene el número de elementos de <ph id="ph4">&lt;paramref name="count" /&gt;</ph>, si se encuentra; de lo contrario, -1.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> plus <ph id="ph4">`count`</ph> minus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> se busca hacia delante, empezando en <ph id="ph2">`startIndex`</ph> y terminando en <ph id="ph3">`startIndex`</ph> más <ph id="ph4">`count`</ph> menos 1, si <ph id="ph5">`count`</ph> es mayor que 0.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método determina la igualdad llamando a <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">A partir de .NET Framework 2.0, este método usa los objetos de la colección <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> métodos en <ph id="ph3">`item`</ph> para determinar si existe cualquier elemento.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">En las versiones anteriores de .NET Framework, esta determinación se realizó utilizando el <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> métodos de la <ph id="ph3">`item`</ph> parámetro en los objetos de la colección.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The following code example shows how to determine the index of the first occurrence of a specified element.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo se determina el índice de la primera aparición de un elemento especificado.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> está fuera del intervalo de índices válidos para <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no especifican una sección válida en <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The zero-based index at which <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> should be inserted.</source>
          <target state="translated">Índice de base cero en el que se debe insertar <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to insert.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a insertar.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>Inserts an element into the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> at the specified index.</source>
          <target state="translated">Inserta un elemento en <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, en el índice especificado.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> acepta <ph id="ph2">`null`</ph> como un valor válido y permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> already equals <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> ya es igual a <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, la capacidad de la <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> se incrementa mediante la reasignación automática de la matriz interna, y se copian los elementos existentes en la nueva matriz antes de agrega el nuevo elemento.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>If <ph id="ph1">`index`</ph> is equal to <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>, <ph id="ph3">`value`</ph> is added to the end of <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`index`</ph> es igual a <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>, <ph id="ph3">`value`</ph> se agrega al final de <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the insertion point move down to accommodate the new element.</source>
          <target state="translated">En colecciones de elementos contiguos, como listas, los elementos que van a continuación del punto de inserción se desplazan hacia abajo para alojar el elemento nuevo.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Si la colección está indizada, también se actualizan los índices de los elementos que se han movido.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The following code example shows how to insert elements into the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo insertar elementos en el <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es mayor que <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tiene un tamaño fijo.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The zero-based index at which the new elements should be inserted.</source>
          <target state="translated">Índice de base cero donde se deben insertar los nuevos elementos.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> whose elements should be inserted into the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> cuyos elementos se deben insertar en <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The collection itself cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>, but it can contain elements that are <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propia colección no puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>, pero puede contener elementos que sean <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>Inserts the elements of a collection into the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> at the specified index.</source>
          <target state="translated">Inserta los elementos de una colección en <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> en el índice especificado.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> acepta <ph id="ph2">`null`</ph> como un valor válido y permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>If the new <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> (the current <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> plus the size of the collection) will be greater than <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> is increased by automatically reallocating the internal array to accommodate the new elements, and the existing elements are copied to the new array before the new elements are added.</source>
          <target state="translated">Si el nuevo <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> (actual <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> más el tamaño de la colección) será mayor que <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, la capacidad de la <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> se incrementa mediante la reasignación automática de la matriz interna para dar cabida a los nuevos elementos, y se copian los elementos existentes en la nueva matriz antes de que se agregan los nuevos elementos.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>If <ph id="ph1">`index`</ph> is equal to <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>, the elements are added to the end of <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`index`</ph> es igual a <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>, los elementos se agregan al final de <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The order of the elements in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is preserved in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">El orden de los elementos de la <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> se conserva en el <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the insertion point move down to accommodate the new element.</source>
          <target state="translated">En colecciones de elementos contiguos, como listas, los elementos que van a continuación del punto de inserción se desplazan hacia abajo para alojar el elemento nuevo.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Si la colección está indizada, también se actualizan los índices de los elementos que se han movido.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>This method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements to be added and <ph id="ph5">`m`</ph> is <ph id="ph6">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operación, donde <ph id="ph4">`n`</ph> es el número de elementos que se va a agregarse y <ph id="ph5">`m`</ph> es <ph id="ph6">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The following code example shows how to insert elements into the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo insertar elementos en el <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es mayor que <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tiene un tamaño fijo.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Obtiene un valor que indica si la interfaz <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tiene un tamaño fijo.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la interfaz <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tiene un tamaño fijo; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>A collection with a fixed size does not allow the addition or removal of elements after the collection is created, but it allows the modification of existing elements.</source>
          <target state="translated">Una colección de tamaño fijo no permite agregar o quitar elementos una vez que se ha creado, pero sí permite modificar los elementos existentes.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
          <target state="translated">Una colección con un tamaño fijo es simplemente una colección con un contenedor que impide agregar y quitar elementos; por lo tanto, si se realizan cambios en la colección subyacente, incluida la adición o eliminación de elementos, la colección de tamaño fijo refleja esos cambios.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La recuperación del valor de esta propiedad es una operación O(1).</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>The following code example shows how to create a fixed-size wrapper around an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo crear un contenedor de tamaño fijo alrededor de un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la interfaz <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</source>
          <target state="translated">Una colección de solo lectura no permite que se agreguen, quiten o modifiquen elementos una vez que se ha creado.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Una colección que es de solo lectura es simplemente una colección con un contenedor que impide modificar la colección; por lo tanto, si se realizan cambios en la colección subyacente, la colección de solo lectura refleja esos cambios.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La recuperación del valor de esta propiedad es una operación O(1).</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>The following code example shows how to create a read-only wrapper around an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and how to determine if an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> is read-only.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo crear un contenedor de solo lectura para un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> y cómo determinar si un <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is synchronized (thread safe).</source>
          <target state="translated">Obtiene un valor que indica si el acceso a la interfaz <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> está sincronizado (es seguro para subprocesos).</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is synchronized (thread safe); otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el acceso a <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> está sincronizado (es seguro para subprocesos); de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>To guarantee the thread safety of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, all operations must be done through the wrapper returned by the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Synchronized%2A&gt;</ph> method.</source>
          <target state="translated">Para garantizar la seguridad para subprocesos de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, todas las operaciones deben realizarse a través del contenedor devuelto por el <ph id="ph2">&lt;xref:System.Collections.ArrayList.Synchronized%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo bloquear la colección utilizando el <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> durante toda la enumeración.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La recuperación del valor de esta propiedad es una operación O(1).</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>The following code example shows how to synchronize an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, determine if an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> is synchronized and use a synchronized <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo sincronizar un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, determinar si un <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> está sincronizado y utilizar un sincronizada <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The zero-based index of the element to get or set.</source>
          <target state="translated">Índice de base cero del elemento que se va a obtener o establecer.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>Gets or sets the element at the specified index.</source>
          <target state="translated">Obtiene o establece el elemento en el índice especificado.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The element at the specified index.</source>
          <target state="translated">Elemento en el índice especificado.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> returns an <ph id="ph2">&lt;xref:System.Object&gt;</ph>, so you may need to cast the returned value to the original type in order to manipulate it.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> devuelve un <ph id="ph2">&lt;xref:System.Object&gt;</ph>, por lo que puede que necesite convertir el valor devuelto al tipo original para procesarlos.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>It is important to note that <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is not a strongly-typed collection.</source>
          <target state="translated">Es importante tener en cuenta que <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> no es una colección fuertemente tipada.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>For a strongly-typed alternative, see <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Para obtener una alternativa fuertemente tipado, consulte <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> acepta <ph id="ph2">`null`</ph> como un valor válido y permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>This property provides the ability to access a specific element in the collection by using the following syntax: <ph id="ph1">`myCollection[index]`</ph>.</source>
          <target state="translated">Esta propiedad permite obtener acceso a un elemento específico de la colección utilizando la sintaxis siguiente: <ph id="ph1">`myCollection[index]`</ph>.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The C# language uses the  keyword to define the indexers instead of implementing the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> property.</source>
          <target state="translated">El lenguaje C# utiliza la palabra clave para definir los indizadores en lugar de implementar la <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>Visual Basic implements <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> as a default property, which provides the same indexing functionality.</source>
          <target state="translated">Visual Basic implementa <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> como propiedad predeterminada, lo que proporciona la misma funcionalidad de indización.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.</source>
          <target state="translated">La recuperación del valor de esta propiedad es una operación o (1); establecer la propiedad también es una operación o (1).</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The following code example creates an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and adds several items.</source>
          <target state="translated">En el ejemplo de código siguiente se crea un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> y se agregan varios elementos.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The example demonstrates accessing elements with the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> property (the indexer in C#), and changing an element by assigning a new value to the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> property for a specified index.</source>
          <target state="translated">En el ejemplo se muestra cómo tener acceso a elementos con el <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> propiedad (el indizador en C#) y cambia un elemento mediante la asignación de un nuevo valor para el <ph id="ph2">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> propiedad para un índice especificado.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The example also shows that the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> property cannot be used to access or add elements outside the current size of the list.</source>
          <target state="translated">El ejemplo también muestra que el <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> propiedad no puede usarse para obtener acceso o agregar elementos fuera del tamaño actual de la lista.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> property explicitly to assign values to items in the list.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> propiedad explícitamente para asignar valores a los elementos de la lista.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The example defines a class that inherits an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and adds a method to scramble the list items.</source>
          <target state="translated">En el ejemplo se define una clase que hereda un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> y agrega un método para codificar los elementos de lista.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es igual o mayor que <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns the zero-based index of the last occurrence of a value in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or in a portion of it.</source>
          <target state="translated">Devuelve el índice de base cero de la última aparición de un valor en la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> o en una parte de ella.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a buscar en la interfaz <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the last occurrence within the entire <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Busca el <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> especificado y devuelve el índice de base cero de la última aparición en la <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> completa.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Índice de base cero de la última aparición de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> en todo el objeto <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, si se encuentra; en caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> se realiza hacia atrás, empezando en el último elemento y terminando en el primer elemento.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">A partir de .NET Framework 2.0, este método usa los objetos de la colección <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> métodos en <ph id="ph3">`item`</ph> para determinar si existe cualquier elemento.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">En las versiones anteriores de .NET Framework, esta determinación se realizó utilizando el <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> métodos de la <ph id="ph3">`item`</ph> parámetro en los objetos de la colección.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo se determina el índice de la última aparición de un elemento especificado.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a buscar en la interfaz <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Índice inicial de base cero de la búsqueda hacia atrás.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Busca el objeto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> especificado y devuelve el índice de base cero de la última aparición dentro del intervalo de elementos de la matriz <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que abarca desde el primer elemento hasta el último índice especificado.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that extends from the first element to <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Índice de base cero de la última aparición de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dentro del intervalo de elementos de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que abarca desde el primer elemento hasta <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, si se encuentra; de lo contrario, -1.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> es la búsqueda hacia atrás, empezando en <ph id="ph2">`startIndex`</ph> y finaliza con el primer elemento.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es el número de elementos desde el principio de la <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> a <ph id="ph4">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método determina la igualdad llamando a <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">A partir de .NET Framework 2.0, este método usa los objetos de la colección <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> métodos en <ph id="ph3">`item`</ph> para determinar si existe cualquier elemento.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">En las versiones anteriores de .NET Framework, esta determinación se realizó utilizando el <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> métodos de la <ph id="ph3">`item`</ph> parámetro en los objetos de la colección.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo se determina el índice de la última aparición de un elemento especificado.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> está fuera del intervalo de índices válidos para <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a buscar en la interfaz <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Índice inicial de base cero de la búsqueda hacia atrás.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Número de elementos de la sección en la que se va a realizar la búsqueda.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Busca el objeto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> especificado y devuelve el índice de base cero de la última aparición dentro del intervalo de elementos de la matriz <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que contiene el número de elementos especificado y termina en el índice especificado.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that contains <ph id="ph3">&lt;paramref name="count" /&gt;</ph> number of elements and ends at <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Índice de base cero de la última aparición de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dentro del intervalo de elementos de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que contiene el número de elementos de <ph id="ph3">&lt;paramref name="count" /&gt;</ph> y termina en <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, si se encuentra; de lo contrario, -1.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> es la búsqueda hacia atrás, empezando en <ph id="ph2">`startIndex`</ph> y terminando en <ph id="ph3">`startIndex`</ph> menos <ph id="ph4">`count`</ph> más 1, si <ph id="ph5">`count`</ph> es mayor que 0.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método determina la igualdad llamando a <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">A partir de .NET Framework 2.0, este método usa los objetos de la colección <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> métodos en <ph id="ph3">`item`</ph> para determinar si existe cualquier elemento.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">En las versiones anteriores de .NET Framework, esta determinación se realizó utilizando el <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> métodos de la <ph id="ph3">`item`</ph> parámetro en los objetos de la colección.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo se determina el índice de la última aparición de un elemento especificado.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>Note that <ph id="ph1">`LastIndexOf`</ph> is a backward search; therefore, <ph id="ph2">`count`</ph> must be less than or equal to <ph id="ph3">`startIndex`</ph> + 1.</source>
          <target state="translated">Tenga en cuenta que <ph id="ph1">`LastIndexOf`</ph> es una búsqueda hacia atrás; por lo tanto, <ph id="ph2">`count`</ph> debe ser menor o igual que <ph id="ph3">`startIndex`</ph> + 1.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> está fuera del intervalo de índices válidos para <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no especifican una sección válida en <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns a list wrapper that is read-only.</source>
          <target state="translated">Devuelve un contenedor de lista de solo lectura.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to wrap.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que se va a incluir.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>Returns a read-only <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper.</source>
          <target state="translated">Devuelve un contenedor de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de solo lectura.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>A read-only <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper around <ph id="ph2">&lt;paramref name="list" /&gt;</ph>.</source>
          <target state="translated">Contenedor de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de solo lectura para <ph id="ph2">&lt;paramref name="list" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>To prevent any modifications to <ph id="ph1">`list`</ph>, expose <ph id="ph2">`list`</ph> only through this wrapper.</source>
          <target state="translated">Para evitar que las modificaciones a <ph id="ph1">`list`</ph>, exponer <ph id="ph2">`list`</ph> sólo a través de este contenedor.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection.</source>
          <target state="translated">Una colección que es de solo lectura es simplemente una colección con un contenedor que impide modificar la colección.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>If changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Si se realizan cambios en la colección subyacente, la colección de solo lectura refleja esos cambios.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>The following code example shows how to create a read-only wrapper around an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and how to determine if an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> is read-only.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo crear un contenedor de solo lectura para un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> y cómo determinar si un <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> to wrap.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> que se va a incluir.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>Returns a read-only <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper.</source>
          <target state="translated">Devuelve un contenedor de <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> de solo lectura.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>A read-only <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper around <ph id="ph2">&lt;paramref name="list" /&gt;</ph>.</source>
          <target state="translated">Contenedor de <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> de solo lectura para <ph id="ph2">&lt;paramref name="list" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>To prevent any modifications to <ph id="ph1">`list`</ph>, expose <ph id="ph2">`list`</ph> only through this wrapper.</source>
          <target state="translated">Para evitar que las modificaciones a <ph id="ph1">`list`</ph>, exponer <ph id="ph2">`list`</ph> sólo a través de este contenedor.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection.</source>
          <target state="translated">Una colección que es de solo lectura es simplemente una colección con un contenedor que impide modificar la colección.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>If changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Si se realizan cambios en la colección subyacente, la colección de solo lectura refleja esos cambios.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to remove from the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a quitar de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>Removes the first occurrence of a specific object from the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Quita la primera aparición de un objeto específico de la interfaz <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> does not contain the specified object, the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> remains unchanged.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> no contiene el objeto especificado, el <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> permanece sin cambios.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>No exception is thrown.</source>
          <target state="translated">No se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método determina la igualdad llamando a <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot.</source>
          <target state="translated">En colecciones de elementos contiguos, como listas, los elementos que van a continuación del elemento eliminado se desplazan hacia arriba para ocupar el espacio libre.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Si la colección está indizada, también se actualizan los índices de los elementos que se han movido.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>The following code example shows how to remove elements from the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo quitar elementos de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tiene un tamaño fijo.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>The zero-based index of the element to remove.</source>
          <target state="translated">Índice de base cero del elemento que se va a quitar.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>Removes the element at the specified index of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Quita el elemento situado en el índice especificado de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>After the element is removed, the size of the collection is adjusted and the value of the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> property is decreased by one.</source>
          <target state="translated">Después de quita el elemento, se ajusta el tamaño de la colección y el valor de la <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> propiedad disminuye en uno.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot.</source>
          <target state="translated">En colecciones de elementos contiguos, como listas, los elementos que van a continuación del elemento eliminado se desplazan hacia arriba para ocupar el espacio libre.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Si la colección está indizada, también se actualizan los índices de los elementos que se han movido.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>The following code example shows how to remove elements from the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo quitar elementos de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es igual o mayor que <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tiene un tamaño fijo.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>The zero-based starting index of the range of elements to remove.</source>
          <target state="translated">Índice inicial de base cero del intervalo de elementos que se va a quitar.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>The number of elements to remove.</source>
          <target state="translated">Número de elementos que se va a quitar.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>Removes a range of elements from the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Quita todos los elementos de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot.</source>
          <target state="translated">En colecciones de elementos contiguos, como listas, los elementos que van a continuación del elemento eliminado se desplazan hacia arriba para ocupar el espacio libre.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Si la colección está indizada, también se actualizan los índices de los elementos que se han movido.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>The following code example shows how to remove elements from the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo quitar elementos de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range of elements in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no denotan un intervalo válido de elementos en <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tiene un tamaño fijo.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to copy multiple times in the new <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a copiar varias veces en la nueva <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>The number of times <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> should be copied.</source>
          <target state="translated">Número de veces que se debe copiar <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> whose elements are copies of the specified value.</source>
          <target state="translated">Devuelve una <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> cuyos elementos son copias del valor especificado.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> with <ph id="ph2">&lt;paramref name="count" /&gt;</ph> number of elements, all of which are copies of <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> con un número <ph id="ph2">&lt;paramref name="count" /&gt;</ph> de elementos que son todos ellos copias de <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> acepta <ph id="ph2">`null`</ph> como un valor válido y permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>The following code example shows how to create and initialize a new <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> with the same value.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo crear e inicializar una nueva <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> con el mismo valor.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Reverses the order of the elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Invierte el orden de los elementos en la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> o en una parte de ella.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse">
          <source>Reverses the order of the elements in the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Invierte el orden de los elementos en la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> completa.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=nameWithType&gt;</ph> to reverse the order of the elements, such that the element at <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> [i], where i is any index within the range, moves to <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> [j], where j equals <ph id="ph4">`index`</ph><ph id="ph5"> + </ph><ph id="ph6">`index`</ph><ph id="ph7"> + </ph><ph id="ph8">`count`</ph> - i - 1.</source>
          <target state="translated">Este método usa <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=nameWithType&gt;</ph> para invertir el orden de los elementos que el elemento situado en <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> [i], donde i es un índice dentro del intervalo, se mueve a <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> [j], donde j es igual a <ph id="ph4">`index`</ph> <ph id="ph5"> + </ph> <ph id="ph6">`index`</ph> <ph id="ph7"> + </ph> <ph id="ph8">`count`</ph> - i - 1.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse">
          <source>The following code example shows how to reverse the sort order of the values in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo se invierte el criterio de ordenación de los valores de un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>The zero-based starting index of the range to reverse.</source>
          <target state="translated">Índice inicial de base cero del intervalo que se va a invertir.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>The number of elements in the range to reverse.</source>
          <target state="translated">Número de elementos del intervalo que se va a invertir.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>Reverses the order of the elements in the specified range.</source>
          <target state="translated">Invierte el orden de los elementos en el intervalo especificado.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=nameWithType&gt;</ph> to reverse the order of the elements, such that the element at <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> [i], where i is any index within the range, moves to <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> [j], where j equals <ph id="ph4">`index`</ph><ph id="ph5"> + </ph><ph id="ph6">`index`</ph><ph id="ph7"> + </ph><ph id="ph8">`count`</ph> - i - 1.</source>
          <target state="translated">Este método usa <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=nameWithType&gt;</ph> para invertir el orden de los elementos que el elemento situado en <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> [i], donde i es un índice dentro del intervalo, se mueve a <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> [j], donde j es igual a <ph id="ph4">`index`</ph> <ph id="ph5"> + </ph> <ph id="ph6">`index`</ph> <ph id="ph7"> + </ph> <ph id="ph8">`count`</ph> - i - 1.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>The following code example shows how to reverse the sort order of the values in a range of elements in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo se invierte el criterio de ordenación de los valores de un intervalo de elementos en una <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range of elements in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no denotan un intervalo válido de elementos en <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The zero-based <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> index at which to start copying the elements of <bpt id="p1">&lt;c&gt;</bpt>c<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Índice de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de base cero en el que empiezan a copiarse los elementos de <bpt id="p1">&lt;c&gt;</bpt>c<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> whose elements to copy to the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> cuyos elementos se copian en <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The collection itself cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>, but it can contain elements that are <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propia colección no puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>, pero puede contener elementos que sean <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>Copies the elements of a collection over a range of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Copia los elementos de una colección en un intervalo de elementos de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> acepta <ph id="ph2">`null`</ph> como un valor válido y permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The order of the elements in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is preserved in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">El orden de los elementos de la <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> se conserva en el <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>This method is an O(<ph id="ph1">`n`</ph> + 1) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<ph id="ph1">`n`</ph> + 1) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The following code example shows how to set and get a range of elements in the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo establecer y obtener un intervalo de elementos de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> plus the number of elements in <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is greater than <ph id="ph3">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> más el número de elementos de <ph id="ph2">&lt;paramref name="c" /&gt;</ph> es mayor que <ph id="ph3">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Sorts the elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Ordena los elementos en la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> o en una parte de ella.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort">
          <source>Sorts the elements in the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Ordena todos los elementos de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>, which uses the QuickSort algorithm.</source>
          <target state="translated">Este método usa <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>, que utiliza el algoritmo QuickSort.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>The QuickSort algorithm is a comparison sort (also called an unstable sort), which means that a "less than or equal to" comparison operation determines which of two elements should occur first in the final sorted list.</source>
          <target state="translated">El algoritmo QuickSort verás una comparación de ordenación (también denominada ordenación inestable), lo que significa que un "menor o igual a" operación de comparación determina cuál de los dos elementos se realizarán en primer lugar en la lista ordenada final.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>However, if two elements are equal, their original order might not be preserved.</source>
          <target state="translated">Sin embargo, si dos elementos son iguales, puede que no se conserve su orden original.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En cambio, una ordenación estable conserva el orden de los elementos que son iguales.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>To perform a stable sort, you must implement a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interface to use with the other overloads of this method.</source>
          <target state="translated">Para realizar una ordenación estable, debe implementar un personalizado <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interfaz que se utiliza con las otras sobrecargas de este método.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>On average, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>; in the worst case it is an O(<ph id="ph5">`n`</ph>^2) operation.</source>
          <target state="translated">En promedio, este método es una O (<ph id="ph1">`n`</ph> registro <ph id="ph2">`n`</ph>) operación, donde <ph id="ph3">`n`</ph> es <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>; en el peor de los casos es una O (<ph id="ph5">`n`</ph>^ 2) operación.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo ordenar los valores de un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implementación de <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> que se va a usar al comparar elementos.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated">Referencia nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic) para usar la implementación de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de cada elemento.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>Sorts the elements in the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> using the specified comparer.</source>
          <target state="translated">Ordena los elementos en la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> completa usando el comparador especificado.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>Use the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> method to  sort a list of objects with a custom comparer that implements the <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> interface.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> método para ordenar una lista de objetos con un comparador personalizado que implementa el <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>If you pass <ph id="ph1">`null`</ph> for <ph id="ph2">`comparer`</ph>, this method uses the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation of each element.</source>
          <target state="translated">Si se pasa <ph id="ph1">`null`</ph> para <ph id="ph2">`comparer`</ph>, este método usa la <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementación de cada elemento.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>In this case, you must make sure that the objects contained in the list implement the <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interface or an exception will occur.</source>
          <target state="translated">En este caso, debe asegurarse de que los objetos contenidos en la lista implementan la <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interfaz o una excepción se producirá.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>In addition, using the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation means the list performs a comparison sort (also called an unstable sort); that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Además, usando la <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementación significa que la lista realiza una ordenación de la comparación (también denominada ordenación inestable); es decir, si dos elementos son iguales, su orden podría no conservarse.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En cambio, una ordenación estable conserva el orden de los elementos que son iguales.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>To perform a stable sort, you must implement a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interface.</source>
          <target state="translated">Para realizar una ordenación estable, debe implementar un personalizado <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>On average, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>; in the worst case it is an O(<ph id="ph5">`n`</ph>^2) operation.</source>
          <target state="translated">En promedio, este método es una O (<ph id="ph1">`n`</ph> registro <ph id="ph2">`n`</ph>) operación, donde <ph id="ph3">`n`</ph> es <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>; en el peor de los casos es una O (<ph id="ph5">`n`</ph>^ 2) operación.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo ordenar los valores de un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> utilizando el comparador predeterminado y un comparador personalizado que invierte el criterio de ordenación.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>An error occurred while comparing two elements.</source>
          <target state="translated">Se produjo un error al comparar dos elementos.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> is passed for <ph id="ph2">&lt;paramref name="comparer" /&gt;</ph>, and the elements in the list do not implement <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> se pasa para <ph id="ph2">&lt;paramref name="comparer" /&gt;</ph> y los elementos de la lista no implementan <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The zero-based starting index of the range to sort.</source>
          <target state="translated">Índice inicial de base cero del intervalo que se va a ordenar.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The length of the range to sort.</source>
          <target state="translated">Longitud del intervalo que se va a ordenar.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implementación de <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> que se va a usar al comparar elementos.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated">Referencia nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic) para usar la implementación de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de cada elemento.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts the elements in a range of elements in <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> using the specified comparer.</source>
          <target state="translated">Ordena los elementos en un intervalo de elementos de la matriz <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> usando el comparador especificado.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is set to <ph id="ph2">`null`</ph>, this method performs a comparison sort (also called an unstable sort); that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> se establece en <ph id="ph2">`null`</ph>, este método realiza una ordenación de la comparación (también denominada ordenación inestable); es decir, si dos elementos son iguales, su orden podría no conservarse.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En cambio, una ordenación estable conserva el orden de los elementos que son iguales.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>To perform a stable sort, you must implement a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interface.</source>
          <target state="translated">Para realizar una ordenación estable, debe implementar un personalizado <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>On average, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`count`</ph>; in the worst case it is an O(n^2) operation.</source>
          <target state="translated">En promedio, este método es una O (<ph id="ph1">`n`</ph> registro <ph id="ph2">`n`</ph>) operación, donde <ph id="ph3">`n`</ph> es <ph id="ph4">`count`</ph>; en el peor de los casos, es una operación O(n^2).</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The following code example shows how to sort the values in a range of elements in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo ordenar los valores en un intervalo de elementos en una <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> utilizando el comparador predeterminado y un comparador personalizado que invierte el criterio de ordenación.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no especifican un intervalo válido en <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>An error occurred while comparing two elements.</source>
          <target state="translated">Se produjo un error al comparar dos elementos.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns a list wrapper that is synchronized (thread safe).</source>
          <target state="translated">Devuelve un contenedor de lista que está sincronizado (es seguro para subprocesos).</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to synchronize.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que se va a sincronizar.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper that is synchronized (thread safe).</source>
          <target state="translated">Devuelve un contenedor de la clase <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que está sincronizado (es seguro para subprocesos).</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper that is synchronized (thread safe).</source>
          <target state="translated">Contenedor de la clase <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que está sincronizado (es seguro para subprocesos).</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>To guarantee the thread safety of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, all operations must be done through this wrapper.</source>
          <target state="translated">Para garantizar la seguridad para subprocesos de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, todas las operaciones deben realizarse a través de este contenedor.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo bloquear la colección utilizando el <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> durante toda la enumeración.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>The following code example shows how to synchronize an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, determine if an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> is synchronized and use a synchronized <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo sincronizar un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, determinar si un <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> está sincronizado y utilizar un sincronizada <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> to synchronize.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> que se va a sincronizar.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper that is synchronized (thread safe).</source>
          <target state="translated">Devuelve un contenedor de la clase <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> que está sincronizado (es seguro para subprocesos).</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper that is synchronized (thread safe).</source>
          <target state="translated">Contenedor de la clase <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> que está sincronizado (es seguro para subprocesos).</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>To guarantee the thread safety of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, all operations must be done through this wrapper.</source>
          <target state="translated">Para garantizar la seguridad para subprocesos de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, todas las operaciones deben realizarse a través de este contenedor.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo bloquear la colección utilizando el <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> durante toda la enumeración.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Obtiene un objeto que se puede usar para sincronizar el acceso a <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Objeto que se puede usar para sincronizar el acceso a <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>To create a synchronized version of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Synchronized%2A&gt;</ph> method.</source>
          <target state="translated">Para crear una versión sincronizada de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, use el <ph id="ph2">&lt;xref:System.Collections.ArrayList.Synchronized%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>However, derived classes can provide their own synchronized version of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> using the <ph id="ph2">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Sin embargo, las clases derivadas pueden proporcionar su propia versión sincronizada de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> mediante el <ph id="ph2">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>The synchronizing code must perform operations on the <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, not directly on the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">El código de sincronización debe realizar las operaciones en el <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> de la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>y no directamente en el <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">De este modo, se garantiza el funcionamiento correcto de las colecciones derivadas de otros objetos.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> object.</source>
          <target state="translated">En concreto, mantiene la sincronización correcta con otros subprocesos que podrían modificar al mismo tiempo la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo bloquear la colección utilizando el <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> durante toda la enumeración.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La recuperación del valor de esta propiedad es una operación O(1).</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Copies the elements of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a new array.</source>
          <target state="translated">Copia los elementos de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> en una nueva matriz.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray">
          <source>Copies the elements of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a new <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> array.</source>
          <target state="translated">Copia los elementos de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> en una nueva matriz de <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> array containing copies of the elements of the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Matriz de <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que contiene copias de los elementos de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ToArray">
          <source>The elements are copied using <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph>, which is an O(<ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Los elementos se copian utilizando <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph>, que es una O (<ph id="ph2">`n`</ph>) operación, donde <ph id="ph3">`n`</ph> es <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>The element <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the destination array to create and copy elements to.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de elemento de la matriz de destino que se va a crear y en la que se van a copiar los elementos.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>Copies the elements of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a new array of the specified element type.</source>
          <target state="translated">Copia los elementos de la matriz <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> a una nueva matriz del tipo de elemento especificado.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>An array of the specified element type containing copies of the elements of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Una matriz del tipo de elemento especificado que contiene copias de los elementos de la matriz <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>All of the objects in the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> object will be cast to the <ph id="ph2">&lt;xref:System.Type&gt;</ph> specified in the <ph id="ph3">`type`</ph> parameter.</source>
          <target state="translated">Todos los objetos en el <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> objeto se convertirán a la <ph id="ph2">&lt;xref:System.Type&gt;</ph> especificado en el <ph id="ph3">`type`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>The elements are copied using <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph>, which is an O(<ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Los elementos se copian utilizando <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph>, que es una O (<ph id="ph2">`n`</ph>) operación, donde <ph id="ph3">`n`</ph> es <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>The following copy example shows how to copy the elements of an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> to a string array.</source>
          <target state="translated">En el siguiente ejemplo copia muestra cómo copiar los elementos de una <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> a una matriz de cadenas.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> cannot be cast automatically to the specified type.</source>
          <target state="translated">El tipo de la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origen no puede convertirse automáticamente en el tipo especificado.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>Sets the capacity to the actual number of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Establece la capacidad en el número real de elementos que hay en la colección <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>This method can be used to minimize a collection's memory overhead if no new elements will be added to the collection.</source>
          <target state="translated">Este método se puede utilizar para minimizar la sobrecarga de memoria de la colección si ningún elemento nuevo se agregará a la colección.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>To reset a <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> to its initial state, call the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Clear%2A&gt;</ph> method before calling <ph id="ph3">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph>.</source>
          <target state="translated">Para restablecer un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> a su estado inicial, llame a la <ph id="ph2">&lt;xref:System.Collections.ArrayList.Clear%2A&gt;</ph> método antes de llamar a <ph id="ph3">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>Trimming an empty <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> sets the capacity of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> to the default capacity.</source>
          <target state="translated">Recortar vacío <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> establece la capacidad de la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> en la capacidad predeterminada.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>The following code example shows how to trim the unused portions of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and how to clear the values of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo se recortan las partes no utilizadas de la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> y cómo se borran los valores de la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tiene un tamaño fijo.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>