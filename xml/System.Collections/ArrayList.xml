<Type Name="ArrayList" FullName="System.Collections.ArrayList">
  <Metadata><Meta Name="ms.openlocfilehash" Value="928d8d72e6df9a907d147f3aa2f7dda7c3b3cfe9" /><Meta Name="ms.sourcegitcommit" Value="1bb00d2f4343e73ae8d58668f02297a3cf10a4c1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="06/15/2019" /><Meta Name="ms.locfileid" Value="63907041" /></Metadata><TypeSignature Language="C#" Value="public class ArrayList : ICloneable, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ArrayList extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ArrayList" />
  <TypeSignature Language="VB.NET" Value="Public Class ArrayList&#xA;Implements ICloneable, IList" />
  <TypeSignature Language="C++ CLI" Value="public ref class ArrayList : ICloneable, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type ArrayList = class&#xA;    interface IList&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.ArrayList/ArrayListDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementa la interfaz <see cref="T:System.Collections.IList" /> utilizando una matriz cuyo tamaño aumenta dinámicamente cuando es necesario.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

> [!IMPORTANT]
>  No se recomienda que utilice el `ArrayList` clase para el nuevo desarrollo. En su lugar, se recomienda que use el tipo genérico <xref:System.Collections.Generic.List%601> clase.
> La <xref:System.Collections.ArrayList> clase está diseñada para contener colecciones heterogéneas de objetos. Sin embargo, no siempre ofrece el mejor rendimiento. En su lugar, se recomienda lo siguiente:  
> - Para obtener una colección heterogénea de objetos, utilice el `List<Object>` (en C#) o `List(Of Object)` (en Visual Basic), escriba.  
> - Para obtener una colección homogénea de objetos, utilice el <xref:System.Collections.Generic.List%601> clase.  
> Consulte [consideraciones de rendimiento](xref:System.Collections.Generic.List%601#performance-considerations) en el <xref:System.Collections.Generic.List%601> tema de referencia para obtener una explicación del rendimiento relativo de estas clases.  Consulte [no deben usarse las colecciones no genéricas](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md) en GitHub para obtener información general sobre el uso de genéricos en lugar de tipos de colección no genérica. 
  
 El <xref:System.Collections.ArrayList> no se garantiza que se va a ordenar.  Se debe ordenar el <xref:System.Collections.ArrayList> mediante una llamada a su <xref:System.Collections.ArrayList.Sort%2A> método antes de realizar operaciones (como <xref:System.Collections.ArrayList.BinarySearch%2A>) que requieren el <xref:System.Collections.ArrayList> esté ordenada. Para mantener una colección que se ordena automáticamente cuando se agregan nuevos elementos, puede usar el <xref:System.Collections.Generic.SortedSet%601> clase.  
  
 La capacidad de un <xref:System.Collections.ArrayList> es el número de elementos de la <xref:System.Collections.ArrayList> puede contener. Cuando se agregan elementos a un <xref:System.Collections.ArrayList>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación. La capacidad puede reducirse mediante una llamada a <xref:System.Collections.ArrayList.TrimToSize%2A> o estableciendo la <xref:System.Collections.ArrayList.Capacity%2A> propiedad explícitamente.  
  
 **Solo para .NET framework:** Para gran <xref:System.Collections.ArrayList> objetos, puede aumentar la capacidad máxima de 2 millones de elementos en un sistema de 64 bits mediante el establecimiento la `enabled` atributo de la [ `<gcAllowVeryLargeObjects>` ](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) elemento de configuración a `true` en el entorno de tiempo de ejecución.  
  
 Elementos de esta colección se pueden acceder mediante un índice entero.  Los índices de esta colección son de base cero.  
  
 El <xref:System.Collections.ArrayList> colección acepta `null` como un valor válido. También permite elementos duplicados.  
  
 Uso de matrices multidimensionales como elementos en una <xref:System.Collections.ArrayList> no se admite la colección.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo crear e inicializar un <xref:System.Collections.ArrayList> y cómo mostrar sus valores.  
  
 [!code-cpp[Classic ArrayList Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Estáticos públicos (<see langword="Shared" /> en Visual Basic) los miembros de este tipo son seguros para subprocesos. No se garantiza que los miembros de instancias sean seguros para la ejecución de subprocesos.  
  
Un <see cref="T:System.Collections.ArrayList" /> puede admitir varios lectores simultáneamente, siempre y cuando no se modifica la colección. Para garantizar la seguridad para subprocesos de la <see cref="T:System.Collections.ArrayList" />, todas las operaciones deben realizarse a través del contenedor devuelto por el <see cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" /> método.  
  
Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Generic.List`1" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.ArrayList" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ArrayList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArrayList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.ArrayList" /> que está vacía y tiene la capacidad inicial predeterminada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacidad de un <xref:System.Collections.ArrayList> es el número de elementos que la <xref:System.Collections.ArrayList> puede contener. Cuando se agregan elementos a un <xref:System.Collections.ArrayList>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna.  
  
 Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.ArrayList>.  
  
 Este constructor es una operación o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ArrayList (System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArrayList(System::Collections::ICollection ^ c);" />
      <MemberSignature Language="F#" Value="new System.Collections.ArrayList : System.Collections.ICollection -&gt; System.Collections.ArrayList" Usage="new System.Collections.ArrayList c" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="c"><see cref="T:System.Collections.ICollection" /> cuyos elementos se copian en la nueva lista.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.ArrayList" /> que contiene elementos copiados de la colección especificada y que tiene la misma capacidad inicial que el número de elementos copiados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacidad de un <xref:System.Collections.ArrayList> es el número de elementos que la <xref:System.Collections.ArrayList> puede contener. Cuando se agregan elementos a un <xref:System.Collections.ArrayList>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna.  
  
 Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.ArrayList>.  
  
 Los elementos se copian en el <xref:System.Collections.ArrayList> en el mismo orden que los lee el <xref:System.Collections.IEnumerator> de la <xref:System.Collections.ICollection>.  
  
 Este constructor es O (`n`) operación, donde `n` es el número de elementos de `c`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ArrayList (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArrayList(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.ArrayList : int -&gt; System.Collections.ArrayList" Usage="new System.Collections.ArrayList capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Número de elementos que puede almacenar inicialmente la lista nueva.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.ArrayList" /> que está vacía y tiene la capacidad inicial especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacidad de un <xref:System.Collections.ArrayList> es el número de elementos que la <xref:System.Collections.ArrayList> puede contener. Cuando se agregan elementos a un <xref:System.Collections.ArrayList>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna.  
  
 Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.ArrayList>.  
  
 Este constructor es O (`n`) operación, donde `n` es `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> es menor que cero.</exception>
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Adapter">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList Adapter (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList Adapter(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Adapter(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Adapter (list As IList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ Adapter(System::Collections::IList ^ list);" />
      <MemberSignature Language="F#" Value="static member Adapter : System.Collections.IList -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.Adapter list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list"><see cref="T:System.Collections.IList" /> que se va a incluir.</param>
        <summary>Crea un contenedor de <see cref="T:System.Collections.ArrayList" /> para una interfaz <see cref="T:System.Collections.IList" /> concreta.</summary>
        <returns>Contenedor de <see cref="T:System.Collections.ArrayList" /> para <see cref="T:System.Collections.IList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Adapter%2A> no copia el contenido de <xref:System.Collections.IList>. En su lugar, solo crea un <xref:System.Collections.ArrayList> contenedor en torno a <xref:System.Collections.IList>; por lo tanto, cambia a la <xref:System.Collections.IList> también afectan a la <xref:System.Collections.ArrayList>.  
  
 El <xref:System.Collections.ArrayList> clase proporciona genérico <xref:System.Collections.ArrayList.Reverse%2A>, <xref:System.Collections.ArrayList.BinarySearch%2A> y <xref:System.Collections.ArrayList.Sort%2A> métodos. Este contenedor puede ser un medio para utilizar estos métodos en <xref:System.Collections.IList>; sin embargo, realizar estas operaciones genéricas a través del contenedor podría ser menos eficiente que las operaciones aplicadas directamente en el <xref:System.Collections.IList>.  
  
 Este método es una operación o (1).  
  
## <a name="version-compatibility"></a>Compatibilidad de versiones  
 En .NET Framework versiones 1.0 y 1.1, una llamada a la <xref:System.Collections.ArrayList.GetEnumerator%28System.Int32%2CSystem.Int32%29> sobrecarga del método en el <xref:System.Collections.ArrayList> contenedor devuelve un enumerador que trata el segundo argumento como un límite superior en lugar de como un recuento. En el [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] el segundo argumento se trata correctamente como un recuento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
        <altmember cref="M:System.Collections.ArrayList.Reverse" />
        <altmember cref="M:System.Collections.ArrayList.Sort" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual int Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Add(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj -&gt; int&#xA;override this.Add : obj -&gt; int" Usage="arrayList.Add value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto <see cref="T:System.Object" /> que se va a agregar al final de la colección <see cref="T:System.Collections.ArrayList" />. El valor puede ser <see langword="null" />.</param>
        <summary>Agrega un objeto al final de <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>Índice de <see cref="T:System.Collections.ArrayList" /> en el que se ha agregado <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> acepta `null` como un valor válido y permite elementos duplicados.  
  
 Si <xref:System.Collections.ArrayList.Count%2A> ya es igual a <xref:System.Collections.ArrayList.Capacity%2A>, la capacidad de la <xref:System.Collections.ArrayList> incrementando reasignación automática de la matriz interna, y se copian los elementos existentes en la nueva matriz antes de agrega el nuevo elemento.  
  
 Si <xref:System.Collections.ArrayList.Count%2A> es menor que <xref:System.Collections.ArrayList.Capacity%2A>, este método es una operación o (1). Si la capacidad debe aumentarse para alojar el nuevo elemento, este método se convierte en una O (`n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo agregar elementos a la <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> es de solo lectura.  
  
O bien 
<see cref="T:System.Collections.ArrayList" /> tiene un tamaño fijo.</exception>
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public virtual void AddRange (System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddRange(class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddRange (c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddRange(System::Collections::ICollection ^ c);" />
      <MemberSignature Language="F#" Value="abstract member AddRange : System.Collections.ICollection -&gt; unit&#xA;override this.AddRange : System.Collections.ICollection -&gt; unit" Usage="arrayList.AddRange c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="c"><see cref="T:System.Collections.ICollection" /> cuyos elementos deben agregarse al final de <see cref="T:System.Collections.ArrayList" />. La propia colección no puede ser <see langword="null" />, pero puede contener elementos que sean <see langword="null" />.</param>
        <summary>Agrega los elementos de <see cref="T:System.Collections.ICollection" /> al final de <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> acepta `null` como un valor válido y permite elementos duplicados.  
  
 El orden de los elementos de la <xref:System.Collections.ICollection> se conserva en el <xref:System.Collections.ArrayList>.  
  
 Si el nuevo <xref:System.Collections.ArrayList.Count%2A> (actual <xref:System.Collections.ArrayList.Count%2A> más el tamaño de la colección) será mayor que <xref:System.Collections.ArrayList.Capacity%2A>, la capacidad de la <xref:System.Collections.ArrayList> incrementando reasignación automática de la matriz interna para dar cabida a los nuevos elementos y la los elementos existentes se copian en la nueva matriz antes de que se agregan los nuevos elementos.  
  
 Si el <xref:System.Collections.ArrayList> puede alojar los nuevos elementos sin aumentar la <xref:System.Collections.ArrayList.Capacity%2A>, este método es O (`n`) operación, donde `n` es el número de elementos que se agregarán. Si la capacidad debe aumentarse para alojar los nuevos elementos, este método se convierte en una O (`n` + `m`) operación, donde `n` es el número de elementos que se agregarán y `m` es <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo agregar elementos a la <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> es de solo lectura.  
  
O bien 
<see cref="T:System.Collections.ArrayList" /> tiene un tamaño fijo.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Utiliza un algoritmo de búsqueda binaria para localizar un elemento concreto en la <see cref="T:System.Collections.ArrayList" /> ordenada o en una parte de ella.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public virtual int BinarySearch (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BinarySearch(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.BinarySearch(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BinarySearch (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int BinarySearch(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member BinarySearch : obj -&gt; int&#xA;override this.BinarySearch : obj -&gt; int" Usage="arrayList.BinarySearch value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Clase <see cref="T:System.Object" /> que se va a localizar. El valor puede ser <see langword="null" />.</param>
        <summary>Busca la <see cref="T:System.Collections.ArrayList" /> completa ordenada para un elemento usando el comparador predeterminado y devuelve el índice de base cero del elemento.</summary>
        <returns>Índice de base cero de <paramref name="value" /> en la <see cref="T:System.Collections.ArrayList" /> ordenada si se encuentra <paramref name="value" />; en caso contrario, número negativo, que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="value" /> o, si no hay ningún elemento mayor, el complemento bit a bit de la propiedad <see cref="P:System.Collections.ArrayList.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `value` parámetro y cada elemento de la <xref:System.Collections.ArrayList> debe implementar la <xref:System.IComparable> interfaz, que se usa para las comparaciones. Los elementos de la <xref:System.Collections.ArrayList> ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por el <xref:System.IComparable> implementación; de lo contrario, el resultado puede ser incorrecto.  
  
 Comparar `null` se permite con cualquier tipo y no genera una excepción cuando se usa <xref:System.IComparable>. Al ordenar, `null` se considera menor que cualquier otro objeto.  
  
 Si el <xref:System.Collections.ArrayList> contiene más de un elemento con el mismo valor, el método devuelve solo una de las apariciones y, puede devolver cualquiera de ellas, pero no necesariamente la primera de ellas.  
  
 Si el <xref:System.Collections.ArrayList> no contiene el valor especificado, el método devuelve un entero negativo. Puede aplicar la operación de complemento bit a bit (~) a este entero negativo para obtener el índice del primer elemento que es mayor que el valor de búsqueda. Cuando se inserta el valor en el <xref:System.Collections.ArrayList>, este índice se debe usar como punto de inserción para mantener el criterio de ordenación.  
  
 Este método es O (log `n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo usar <xref:System.Collections.ArrayList.BinarySearch%2A> para localizar un objeto específico en el <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.BinarySearch1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.BinarySearch1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.BinarySearch1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ni <paramref name="value" /> ni los elementos de <see cref="T:System.Collections.ArrayList" /> implementan la interfaz <see cref="T:System.IComparable" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> no es del mismo tipo que los elementos de <see cref="T:System.Collections.ArrayList" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public virtual int BinarySearch (object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BinarySearch(object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BinarySearch (value As Object, comparer As IComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int BinarySearch(System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="abstract member BinarySearch : obj * System.Collections.IComparer -&gt; int&#xA;override this.BinarySearch : obj * System.Collections.IComparer -&gt; int" Usage="arrayList.BinarySearch (value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="value">Clase <see cref="T:System.Object" /> que se va a localizar. El valor puede ser <see langword="null" />.</param>
        <param name="comparer">Implementación de <see cref="T:System.Collections.IComparer" /> que se va a usar al comparar elementos.  
  
O bien 
 <see langword="null" /> para utilizar el comparador predeterminado, que es la implementación de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Busca la <see cref="T:System.Collections.ArrayList" /> completa ordenada para un elemento usando el comparador especificado y devuelve el índice de base cero del elemento.</summary>
        <returns>Índice de base cero de <paramref name="value" /> en la <see cref="T:System.Collections.ArrayList" /> ordenada si se encuentra <paramref name="value" />; en caso contrario, número negativo, que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="value" /> o, si no hay ningún elemento mayor, el complemento bit a bit de la propiedad <see cref="P:System.Collections.ArrayList.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comparador personaliza cómo se comparan los elementos. Por ejemplo, puede usar un <xref:System.Collections.CaseInsensitiveComparer> instancia como comparador para realizar búsquedas de cadenas entre mayúsculas y minúsculas.  
  
 Si `comparer` se proporciona, los elementos de la <xref:System.Collections.ArrayList> se comparan con el valor especificado mediante especificado <xref:System.Collections.IComparer> implementación. Los elementos de la <xref:System.Collections.ArrayList> ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por `comparer`; en caso contrario, el resultado puede ser incorrecto.  
  
 Si `comparer` es `null`, la comparación se realiza mediante el <xref:System.IComparable> implementación proporcionada por el propio elemento o el valor especificado. Los elementos de la <xref:System.Collections.ArrayList> ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por el <xref:System.IComparable> implementación; de lo contrario, el resultado puede ser incorrecto.  
  
 Comparar `null` se permite con cualquier tipo y no genera una excepción cuando se usa <xref:System.IComparable>. Al ordenar, `null` se considera menor que cualquier otro objeto.  
  
 Si el <xref:System.Collections.ArrayList> contiene más de un elemento con el mismo valor, el método devuelve solo una de las apariciones y, puede devolver cualquiera de ellas, pero no necesariamente la primera de ellas.  
  
 Si el <xref:System.Collections.ArrayList> no contiene el valor especificado, el método devuelve un entero negativo. Puede aplicar la operación de complemento bit a bit (~) a este entero negativo para obtener el índice del primer elemento que es mayor que el valor de búsqueda. Cuando se inserta el valor en el <xref:System.Collections.ArrayList>, este índice se debe usar como punto de inserción para mantener el criterio de ordenación.  
  
 Este método es O (log `n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Collections.ArrayList> de animales coloreados. Proporcionado <xref:System.Collections.IComparer> realiza la comparación de cadenas para la búsqueda binaria. Se muestran los resultados de una búsqueda iterativa y una búsqueda binaria.  
  
 [!code-cpp[Classic ArrayList.BinarySearch1 Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.BinarySearch1 Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.BinarySearch1 Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> es <see langword="null" /> y ni <paramref name="value" /> ni los elementos de <see cref="T:System.Collections.ArrayList" /> implementan la interfaz de <see cref="T:System.IComparable" /></exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> es <see langword="null" /> y <paramref name="value" /> no es del mismo tipo que los elementos de <see cref="T:System.Collections.ArrayList" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public virtual int BinarySearch (int index, int count, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BinarySearch(int32 index, int32 count, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BinarySearch (index As Integer, count As Integer, value As Object, comparer As IComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int BinarySearch(int index, int count, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="abstract member BinarySearch : int * int * obj * System.Collections.IComparer -&gt; int&#xA;override this.BinarySearch : int * int * obj * System.Collections.IComparer -&gt; int" Usage="arrayList.BinarySearch (index, count, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="index">Índice inicial de base cero del intervalo que se va a buscar.</param>
        <param name="count">Longitud del intervalo en el que se va a buscar.</param>
        <param name="value">Clase <see cref="T:System.Object" /> que se va a localizar. El valor puede ser <see langword="null" />.</param>
        <param name="comparer">Implementación de <see cref="T:System.Collections.IComparer" /> que se va a usar al comparar elementos.  
  
O bien 
 <see langword="null" /> para utilizar el comparador predeterminado, que es la implementación de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Busca un elemento en un intervalo de elementos del objeto <see cref="T:System.Collections.ArrayList" /> ordenado usando el comparador especificado y devuelve el índice de base cero del elemento.</summary>
        <returns>Índice de base cero de <paramref name="value" /> en la <see cref="T:System.Collections.ArrayList" /> ordenada si se encuentra <paramref name="value" />; en caso contrario, número negativo, que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="value" /> o, si no hay ningún elemento mayor, el complemento bit a bit de la propiedad <see cref="P:System.Collections.ArrayList.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comparador personaliza cómo se comparan los elementos. Por ejemplo, puede usar un <xref:System.Collections.CaseInsensitiveComparer> instancia como comparador para realizar búsquedas de cadenas entre mayúsculas y minúsculas.  
  
 Si `comparer` se proporciona, los elementos de la <xref:System.Collections.ArrayList> se comparan con el valor especificado mediante especificado <xref:System.Collections.IComparer> implementación. Los elementos de la <xref:System.Collections.ArrayList> ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por `comparer`; en caso contrario, el resultado puede ser incorrecto.  
  
 Si `comparer` es `null`, la comparación se realiza mediante el <xref:System.IComparable> implementación proporcionada por el propio elemento o el valor especificado. Los elementos de la <xref:System.Collections.ArrayList> ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por el <xref:System.IComparable> implementación; de lo contrario, el resultado puede ser incorrecto.  
  
 Comparar `null` se permite con cualquier tipo y no genera una excepción cuando se usa <xref:System.IComparable>. Al ordenar, `null` se considera menor que cualquier otro objeto.  
  
 Si el <xref:System.Collections.ArrayList> contiene más de un elemento con el mismo valor, el método devuelve solo una de las apariciones y, puede devolver cualquiera de ellas, pero no necesariamente la primera de ellas.  
  
 Si el <xref:System.Collections.ArrayList> no contiene el valor especificado, el método devuelve un entero negativo. Puede aplicar la operación de complemento bit a bit (~) a este entero negativo para obtener el índice del primer elemento que es mayor que el valor de búsqueda. Cuando se inserta el valor en el <xref:System.Collections.ArrayList>, este índice se debe usar como punto de inserción para mantener el criterio de ordenación.  
  
 Este método es O (log `n`) operación, donde `n` es `count`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <see cref="T:System.Collections.ArrayList" />.  
  
O bien 
 <paramref name="comparer" /> es <see langword="null" /> y ni <paramref name="value" /> ni los elementos de <see cref="T:System.Collections.ArrayList" /> implementan la interfaz de <see cref="T:System.IComparable" /></exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> es <see langword="null" /> y <paramref name="value" /> no es del mismo tipo que los elementos de <see cref="T:System.Collections.ArrayList" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="count" /> es menor que cero.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.ArrayList.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número de elementos que puede contener <see cref="T:System.Collections.ArrayList" />.</summary>
        <value>Número de elementos que puede contener <see cref="T:System.Collections.ArrayList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Capacity%2A> es el número de elementos que la <xref:System.Collections.ArrayList> puede almacenar. <xref:System.Collections.ArrayList.Count%2A> es el número de elementos que son en realidad el <xref:System.Collections.ArrayList>.  
  
 <xref:System.Collections.ArrayList.Capacity%2A> es siempre mayor o igual que <xref:System.Collections.ArrayList.Count%2A>. Si <xref:System.Collections.ArrayList.Count%2A> supera <xref:System.Collections.ArrayList.Capacity%2A> al agregar elementos, automáticamente se aumenta la capacidad mediante la reasignación de la matriz interna antes de copiar los elementos antiguos y agregar los nuevos elementos.  
  
 La capacidad puede reducirse mediante una llamada a <xref:System.Collections.ArrayList.TrimToSize%2A> o estableciendo la <xref:System.Collections.ArrayList.Capacity%2A> propiedad explícitamente. Cuando el valor de <xref:System.Collections.ArrayList.Capacity%2A> se establece explícitamente, la matriz interna se reasigna para dar cabida a la capacidad especificada.  
  
 Recuperar el valor de esta propiedad es una operación o (1); establecer la propiedad es O (`n`) operación, donde `n` es la nueva capacidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Collections.ArrayList.Capacity" /> se establece en un valor que es menor que <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay memoria suficiente en el sistema.</exception>
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="arrayList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los elementos de <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Count%2A> está establecido en cero y también se liberan las referencias a otros objetos de elementos de la colección.  
  
 <xref:System.Collections.ArrayList.Capacity%2A> permanece sin cambios.  Para restablecer la capacidad de la <xref:System.Collections.ArrayList>, llame a <xref:System.Collections.ArrayList.TrimToSize%2A> o establecer el <xref:System.Collections.ArrayList.Capacity%2A> propiedad directamente. Recorte vacío <xref:System.Collections.ArrayList> establece la capacidad de la <xref:System.Collections.ArrayList> a la capacidad predeterminada.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo se recortan las partes no utilizadas de la <xref:System.Collections.ArrayList> y cómo borrar los valores de la <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> es de solo lectura.  
  
O bien 
<see cref="T:System.Collections.ArrayList" /> tiene un tamaño fijo.</exception>
        <altmember cref="M:System.Collections.ArrayList.TrimToSize" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="arrayList.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia superficial de la colección <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>Copia superficial de la colección <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una copia superficial de una colección copia solo los elementos de la colección, si son tipos de referencia o tipos de valor, pero no copia los objetos que hacen referencia las referencias. Las referencias de la nueva colección apuntan a los mismos objetos que seleccione las referencias en la colección original.  
  
 En cambio, una copia en profundidad de una colección copia los elementos y todo lo que hacen referencia directa o indirectamente los elementos.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="arrayList.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Objeto <see cref="T:System.Object" /> que se va a buscar en la interfaz <see cref="T:System.Collections.ArrayList" />. El valor puede ser <see langword="null" />.</param>
        <summary>Determina si un elemento se encuentra en <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns><see langword="true" /> si <paramref name="item" /> se encuentra en la matriz <see cref="T:System.Collections.ArrayList" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
 Este método determina la igualdad llamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 A partir de .NET Framework 2.0, este método utiliza los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si existe el elemento. En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia la <see cref="T:System.Collections.ArrayList" /> o una parte de la misma en una matriz unidimensional.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.CopyTo(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array -&gt; unit&#xA;override this.CopyTo : Array -&gt; unit" Usage="arrayList.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados de <see cref="T:System.Collections.ArrayList" />. <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
        <summary>Copia la <see cref="T:System.Collections.ArrayList" /> completa en una <see cref="T:System.Array" /> unidimensional compatible, empezando en el principio de la matriz de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz especificada debe ser de un tipo compatible.  
  
 Este método usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> para copiar los elementos.  
  
 Los elementos se copian en el <xref:System.Array> en el mismo orden en que el enumerador recorre el <xref:System.Collections.ArrayList>.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo copiar un <xref:System.Collections.ArrayList> en unidimensional <xref:System.Array?displayProperty=nameWithType>.  
  
 [!code-cpp[Classic ArrayList.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> es multidimensional.  
  
O bien 
El número de elementos del <see cref="T:System.Collections.ArrayList" /> de origen es mayor que el número de elementos que puede contener el <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.InvalidCastException">El tipo de la <see cref="T:System.Collections.ArrayList" /> de origen no puede convertirse automáticamente al tipo de la <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="arrayList.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados de <see cref="T:System.Collections.ArrayList" />. La matriz <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
        <param name="arrayIndex">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
        <summary>Copia la totalidad de <see cref="T:System.Collections.ArrayList" /> en una matriz <see cref="T:System.Array" /> unidimensional compatible, comenzando en el índice especificado de la matriz de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz especificada debe ser de un tipo compatible.  
  
 Este método usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> para copiar los elementos.  
  
 Los elementos se copian en el <xref:System.Array> en el mismo orden en que el enumerador recorre el <xref:System.Collections.ArrayList>.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo copiar un <xref:System.Collections.ArrayList> en unidimensional <xref:System.Array?displayProperty=nameWithType>.  
  
 [!code-cpp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> es multidimensional.  
  
O bien 
El número de elementos de la <see cref="T:System.Collections.ArrayList" /> de origen es mayor que el espacio disponible desde <paramref name="arrayIndex" /> hasta el final de la <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.InvalidCastException">El tipo de la <see cref="T:System.Collections.ArrayList" /> de origen no puede convertirse automáticamente al tipo de la <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (int index, Array array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(int32 index, class System.Array array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(int index, Array ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : int * Array * int * int -&gt; unit&#xA;override this.CopyTo : int * Array * int * int -&gt; unit" Usage="arrayList.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero de la <see cref="T:System.Collections.ArrayList" /> de origen donde comienza la copia.</param>
        <param name="array"><see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados de <see cref="T:System.Collections.ArrayList" />. La matriz <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
        <param name="arrayIndex">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
        <param name="count">Número de elementos que se van a copiar.</param>
        <summary>Copia un intervalo de elementos de <see cref="T:System.Collections.ArrayList" /> en una <see cref="T:System.Array" /> unidimensional compatible, empezando en el índice especificado de la matriz de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz especificada debe ser de un tipo compatible.  
  
 Este método usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> para copiar los elementos.  
  
 Los elementos se copian en el <xref:System.Array> en el mismo orden en que el enumerador recorre el <xref:System.Collections.ArrayList>.  
  
 Este método es O (`n`) operación, donde `n` es `count`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo copiar un <xref:System.Collections.ArrayList> en unidimensional <xref:System.Array?displayProperty=nameWithType>.  
  
 [!code-cpp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="arrayIndex" /> es menor que cero.  
  
O bien 
 <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> es multidimensional.  
  
O bien 
 <paramref name="index" /> es igual o mayor que la longitud de <see cref="P:System.Collections.ArrayList.Count" /> de <see cref="T:System.Collections.ArrayList" /> de origen.  
  
O bien 
El número de elementos de <paramref name="index" /> hasta el final de <see cref="T:System.Collections.ArrayList" /> de origen es mayor que el espacio disponible desde <paramref name="arrayIndex" /> hasta el final de <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.InvalidCastException">El tipo de la <see cref="T:System.Collections.ArrayList" /> de origen no puede convertirse automáticamente al tipo de la <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.ArrayList.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de elementos contenido realmente en <see cref="T:System.Collections.ArrayList" />.</summary>
        <value>Número de elementos contenido realmente en <see cref="T:System.Collections.ArrayList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Capacity%2A> es el número de elementos que la <xref:System.Collections.ArrayList> puede almacenar. <xref:System.Collections.ArrayList.Count%2A> es el número de elementos que son en realidad el <xref:System.Collections.ArrayList>.  
  
 <xref:System.Collections.ArrayList.Capacity%2A> es siempre mayor o igual que <xref:System.Collections.ArrayList.Count%2A>. Si <xref:System.Collections.ArrayList.Count%2A> supera <xref:System.Collections.ArrayList.Capacity%2A> al agregar elementos, automáticamente se aumenta la capacidad mediante la reasignación de la matriz interna antes de copiar los elementos antiguos y agregar los nuevos elementos.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FixedSize">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un contenedor de lista con un tamaño fijo, donde se permite modificar elementos pero no agregarlos ni quitarlos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FixedSize">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList FixedSize (System.Collections.ArrayList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList FixedSize(class System.Collections.ArrayList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FixedSize (list As ArrayList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ FixedSize(System::Collections::ArrayList ^ list);" />
      <MemberSignature Language="F#" Value="static member FixedSize : System.Collections.ArrayList -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.FixedSize list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="list"><see cref="T:System.Collections.ArrayList" /> que se va a incluir.</param>
        <summary>Devuelve un contenedor de <see cref="T:System.Collections.ArrayList" /> con un tamaño fijo.</summary>
        <returns>Contenedor de <see cref="T:System.Collections.ArrayList" /> con un tamaño fijo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este contenedor se puede utilizar para evitar adiciones y eliminaciones de los originales <xref:System.Collections.ArrayList>. Todavía se pueden modificar o reemplazar los elementos.  
  
 Una colección con un tamaño fijo es simplemente una colección con un contenedor que impide agregar y quitar elementos; por lo tanto, si se realizan cambios en la colección subyacente, incluida la adición o eliminación de elementos, la colección de tamaño fijo refleja los cambios.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo crear un contenedor de tamaño fijo alrededor de un <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FixedSize">
      <MemberSignature Language="C#" Value="public static System.Collections.IList FixedSize (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList FixedSize(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FixedSize (list As IList) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ FixedSize(System::Collections::IList ^ list);" />
      <MemberSignature Language="F#" Value="static member FixedSize : System.Collections.IList -&gt; System.Collections.IList" Usage="System.Collections.ArrayList.FixedSize list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list"><see cref="T:System.Collections.IList" /> que se va a incluir.</param>
        <summary>Devuelve un contenedor de <see cref="T:System.Collections.IList" /> con un tamaño fijo.</summary>
        <returns>Contenedor de <see cref="T:System.Collections.IList" /> con un tamaño fijo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este contenedor se puede utilizar para evitar adiciones y eliminaciones de los originales <xref:System.Collections.IList>. Todavía se pueden modificar o reemplazar los elementos.  
  
 Una colección con un tamaño fijo es simplemente una colección con un contenedor que impide agregar y quitar elementos; por lo tanto, si se realizan cambios en la colección subyacente, incluida la adición o eliminación de elementos, la colección de tamaño fijo refleja los cambios.  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un enumerador que recorre en iteración la colección <see cref="T:System.Collections.ArrayList" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="arrayList.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador para la <see cref="T:System.Collections.ArrayList" /> completa.</summary>
        <returns>Interfaz <see cref="T:System.Collections.IEnumerator" /> para toda la colección <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La instrucción `foreach` del lenguaje C# (`for each` en Visual Basic) oculta la complejidad de los enumeradores.  Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. <xref:System.Collections.IEnumerator.Reset%2A> también devuelve el enumerador a esta posición.  En esta posición, el valor de propiedad <xref:System.Collections.IEnumerator.Current%2A> está sin definir. Por lo tanto, debe llamar a <xref:System.Collections.IEnumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A> o a <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.IEnumerator.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`. Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.IEnumerator.Current%2A> es indefinido. Para volver a establecer el valor de <xref:System.Collections.IEnumerator.Current%2A> en el primer elemento de la colección, se puede llamar primero a <xref:System.Collections.IEnumerator.Reset%2A> y después a <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumerador es válido mientras la colección no cambie. Si se hacen cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado permanentemente y su comportamiento es indefinido.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos.  A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene el enumerador para un <xref:System.Collections.ArrayList>y el enumerador para un intervalo de elementos de la <xref:System.Collections.ArrayList>.  
  
 [!code-csharp[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR/collections.arraylist.getenumerator/cs/program.cs#1)]
 [!code-vb[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/collections.arraylist.getenumerator/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator (index As Integer, count As Integer) As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : int * int -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : int * int -&gt; System.Collections.IEnumerator" Usage="arrayList.GetEnumerator (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice inicial de base cero de la sección de <see cref="T:System.Collections.ArrayList" /> a la que debe hacer referencia el enumerador.</param>
        <param name="count">Número de elementos de la sección de <see cref="T:System.Collections.ArrayList" /> a la que debe hacer referencia el enumerador.</param>
        <summary>Devuelve un enumerador para un intervalo de elementos de la matriz <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> para el intervalo de elementos especificado de la matriz <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `foreach` instrucción del lenguaje C# (`for each` en Visual C++, `For Each` Visual Basic) oculta la complejidad de los enumeradores.  Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. <xref:System.Collections.IEnumerator.Reset%2A> también devuelve el enumerador a esta posición.  En esta posición, el valor de propiedad <xref:System.Collections.IEnumerator.Current%2A> está sin definir. Por lo tanto, debe llamar a <xref:System.Collections.IEnumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A> o a <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.IEnumerator.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`. Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.IEnumerator.Current%2A> es indefinido. Para volver a establecer el valor de <xref:System.Collections.IEnumerator.Current%2A> en el primer elemento de la colección, se puede llamar primero a <xref:System.Collections.IEnumerator.Reset%2A> y después a <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumerador es válido mientras la colección no cambie. Si se hacen cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado permanentemente y su comportamiento es indefinido.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos.  A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 Este método es una operación o (1).  
  
## <a name="version-compatibility"></a>Compatibilidad de versiones  
 En las versiones de .NET Framework 1.0 y 1.1, el enumerador para un <xref:System.Collections.ArrayList> contenedor devuelto por el <xref:System.Collections.ArrayList.Adapter%2A> método trata el segundo argumento como un límite superior en lugar de como un recuento. En el [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] el segundo argumento se trata correctamente como un recuento.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene el enumerador para un <xref:System.Collections.ArrayList>y el enumerador para un intervalo de elementos de la <xref:System.Collections.ArrayList>.  
  
 [!code-csharp[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR/collections.arraylist.getenumerator/cs/program.cs#1)]
 [!code-vb[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/collections.arraylist.getenumerator/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> y <paramref name="count" /> no especifican un intervalo válido en <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ArrayList GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ArrayList GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRange (index As Integer, count As Integer) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ArrayList ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetRange : int * int -&gt; System.Collections.ArrayList&#xA;override this.GetRange : int * int -&gt; System.Collections.ArrayList" Usage="arrayList.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de <see cref="T:System.Collections.ArrayList" /> de base cero en el que empieza el intervalo.</param>
        <param name="count">Número de elementos del intervalo.</param>
        <summary>Devuelve una <see cref="T:System.Collections.ArrayList" /> que representa un subconjunto de los elementos de la <see cref="T:System.Collections.ArrayList" /> de origen.</summary>
        <returns><see cref="T:System.Collections.ArrayList" /> que representa un subconjunto de los elementos de la <see cref="T:System.Collections.ArrayList" /> de origen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no crea copias de los elementos. El nuevo <xref:System.Collections.ArrayList> es sólo una ventana de vista en el origen <xref:System.Collections.ArrayList>. Sin embargo, todos los cambios posteriores en el origen <xref:System.Collections.ArrayList> debe realizarse a través de esta ventana de vista <xref:System.Collections.ArrayList>. Si se realizan cambios directamente en el origen <xref:System.Collections.ArrayList>, la ventana de vista <xref:System.Collections.ArrayList> se invalida y se devolverá ninguna operación en él un <xref:System.InvalidOperationException>.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un intervalo de elementos de la <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.SetRange Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.SetRange Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.SetRange Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido de elementos en la <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el índice de base cero de la primera aparición de un valor en <see cref="T:System.Collections.ArrayList" /> o en una parte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj -&gt; int&#xA;override this.IndexOf : obj -&gt; int" Usage="arrayList.IndexOf value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto <see cref="T:System.Object" /> que se va a buscar en la interfaz <see cref="T:System.Collections.ArrayList" />. El valor puede ser <see langword="null" />.</param>
        <summary>Busca el objeto <see cref="T:System.Object" /> especificado y devuelve el índice de base cero de la primera aparición en toda la colección <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>Índice de base cero de la primera aparición de <paramref name="value" /> en la totalidad de <see cref="T:System.Collections.ArrayList" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.ArrayList> se buscará hacia delante a partir del primer elemento y terminando en el último elemento.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
 Este método determina la igualdad llamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 A partir de .NET Framework 2.0, este método utiliza los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si existe el elemento. En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo determinar el índice de la primera aparición de un elemento especificado.  
  
 [!code-cpp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj * int -&gt; int&#xA;override this.IndexOf : obj * int -&gt; int" Usage="arrayList.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Objeto <see cref="T:System.Object" /> que se va a buscar en la interfaz <see cref="T:System.Collections.ArrayList" />. El valor puede ser <see langword="null" />.</param>
        <param name="startIndex">Índice inicial de base cero de la búsqueda. 0 (cero) es válido en una lista vacía.</param>
        <summary>Busca el objeto <see cref="T:System.Object" /> especificado y devuelve el índice de base cero de la primera aparición dentro del intervalo de elementos de la matriz <see cref="T:System.Collections.ArrayList" /> que abarca desde el índice especificado hasta el último elemento.</summary>
        <returns>Índice de base cero de la primera aparición de <paramref name="value" /> dentro del intervalo de elementos de <see cref="T:System.Collections.ArrayList" /> que abarca desde <paramref name="startIndex" /> hasta el último elemento, si se encuentra; de lo contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.ArrayList> se buscará hacia delante, empezando en `startIndex` y terminando en el último elemento.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es el número de elementos de `startIndex` al final de la <xref:System.Collections.ArrayList>.  
  
 Este método determina la igualdad llamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 A partir de .NET Framework 2.0, este método utiliza los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si existe el elemento. En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo determinar el índice de la primera aparición de un elemento especificado.  
  
 [!code-cpp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fuera del intervalo de índices válidos para <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj * int * int -&gt; int&#xA;override this.IndexOf : obj * int * int -&gt; int" Usage="arrayList.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Objeto <see cref="T:System.Object" /> que se va a buscar en la interfaz <see cref="T:System.Collections.ArrayList" />. El valor puede ser <see langword="null" />.</param>
        <param name="startIndex">Índice inicial de base cero de la búsqueda. 0 (cero) es válido en una lista vacía.</param>
        <param name="count">Número de elementos de la sección en la que se va a realizar la búsqueda.</param>
        <summary>Busca el objeto <see cref="T:System.Object" /> especificado y devuelve el índice de base cero de la primera aparición dentro del intervalo de elementos de la matriz <see cref="T:System.Collections.ArrayList" /> que comienza en el índice especificado y contiene el número especificado de elementos.</summary>
        <returns>Índice de base cero de la primera aparición de <paramref name="value" /> dentro del intervalo de elementos de <see cref="T:System.Collections.ArrayList" /> que comienza en <paramref name="startIndex" /> y contiene el número de elementos de <paramref name="count" />, si se encuentra; de lo contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.ArrayList> se buscará hacia delante, empezando en `startIndex` hasta `startIndex` plus `count` menos 1, si `count` es mayor que 0.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es `count`.  
  
 Este método determina la igualdad llamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 A partir de .NET Framework 2.0, este método utiliza los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si existe el elemento. En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo determinar el índice de la primera aparición de un elemento especificado.  
  
 [!code-cpp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fuera del intervalo de índices válidos para <see cref="T:System.Collections.ArrayList" />.  
  
O bien 
 <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="startIndex" /> y <paramref name="count" /> no especifican una sección válida en <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public virtual void Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Insert (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * obj -&gt; unit&#xA;override this.Insert : int * obj -&gt; unit" Usage="arrayList.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Índice basado en cero en el que debe insertarse <paramref name="value" />.</param>
        <param name="value"><see cref="T:System.Object" /> que se va a insertar. El valor puede ser <see langword="null" />.</param>
        <summary>Inserta un elemento en <see cref="T:System.Collections.ArrayList" /> en el índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> acepta `null` como un valor válido y permite elementos duplicados.  
  
 Si <xref:System.Collections.ArrayList.Count%2A> ya es igual a <xref:System.Collections.ArrayList.Capacity%2A>, la capacidad de la <xref:System.Collections.ArrayList> incrementando reasignación automática de la matriz interna, y se copian los elementos existentes en la nueva matriz antes de agrega el nuevo elemento.  
  
 Si `index` es igual a <xref:System.Collections.ArrayList.Count%2A>, `value` se agrega al final de <xref:System.Collections.ArrayList>.  
  
 En colecciones de elementos contiguos, como listas, los elementos que van a continuación del punto de inserción se desplazan hacia abajo para alojar el elemento nuevo. Si la colección está indizada, también se actualizan los índices de los elementos que se han movido. Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo insertar elementos en el <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Insert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Insert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Insert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> es mayor que <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> es de solo lectura.  
  
O bien 
<see cref="T:System.Collections.ArrayList" /> tiene un tamaño fijo.</exception>
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public virtual void InsertRange (int index, System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertRange(int32 index, class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub InsertRange (index As Integer, c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void InsertRange(int index, System::Collections::ICollection ^ c);" />
      <MemberSignature Language="F#" Value="abstract member InsertRange : int * System.Collections.ICollection -&gt; unit&#xA;override this.InsertRange : int * System.Collections.ICollection -&gt; unit" Usage="arrayList.InsertRange (index, c)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero donde se deben insertar los nuevos elementos.</param>
        <param name="c"><see cref="T:System.Collections.ICollection" /> cuyos elementos se deben insertar en <see cref="T:System.Collections.ArrayList" />. La propia colección no puede ser <see langword="null" />, pero puede contener elementos que sean <see langword="null" />.</param>
        <summary>Inserta los elementos de una colección en <see cref="T:System.Collections.ArrayList" /> en el índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> acepta `null` como un valor válido y permite elementos duplicados.  
  
 Si el nuevo <xref:System.Collections.ArrayList.Count%2A> (actual <xref:System.Collections.ArrayList.Count%2A> más el tamaño de la colección) será mayor que <xref:System.Collections.ArrayList.Capacity%2A>, la capacidad de la <xref:System.Collections.ArrayList> incrementando reasignación automática de la matriz interna para dar cabida a los nuevos elementos y la los elementos existentes se copian en la nueva matriz antes de que se agregan los nuevos elementos.  
  
 Si `index` es igual a <xref:System.Collections.ArrayList.Count%2A>, los elementos se agregan al final de <xref:System.Collections.ArrayList>.  
  
 El orden de los elementos de la <xref:System.Collections.ICollection> se conserva en el <xref:System.Collections.ArrayList>.  
  
 En colecciones de elementos contiguos, como listas, los elementos que van a continuación del punto de inserción se desplazan hacia abajo para alojar el elemento nuevo. Si la colección está indizada, también se actualizan los índices de los elementos que se han movido. Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.  
  
 Este método es O (`n` + `m`) operación, donde `n` es el número de elementos que se agregarán y `m` es <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo insertar elementos en el <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Insert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Insert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Insert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> es mayor que <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> es de solo lectura.  
  
O bien 
<see cref="T:System.Collections.ArrayList" /> tiene un tamaño fijo.</exception>
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Collections.ArrayList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la interfaz <see cref="T:System.Collections.ArrayList" /> tiene un tamaño fijo.</summary>
        <value>Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.ArrayList" /> tiene un tamaño fijo; de lo contrario, es <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una colección de tamaño fijo no permite agregar o quitar elementos una vez que se ha creado, pero sí permite modificar los elementos existentes.  
  
 Una colección con un tamaño fijo es simplemente una colección con un contenedor que impide agregar y quitar elementos; por lo tanto, si se realizan cambios en la colección subyacente, incluida la adición o eliminación de elementos, la colección de tamaño fijo refleja los cambios.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo crear un contenedor de tamaño fijo alrededor de un <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.ArrayList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Collections.ArrayList" /> es de solo lectura.</summary>
        <value>Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.ArrayList" /> es de solo lectura; de lo contrario, es <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una colección de solo lectura no permite que se agreguen, quiten o modifiquen elementos una vez que se ha creado.  
  
 Una colección es de solo lectura es simplemente una colección con un contenedor que evita la modificación de la colección; por lo tanto, si se realizan cambios en la colección subyacente, la colección de solo lectura refleja los cambios.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo crear un contenedor de solo lectura en torno a un <xref:System.Collections.ArrayList> y cómo determinar si un <xref:System.Collections.ArrayList> es de solo lectura.  
  
 [!code-cpp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.ArrayList.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el acceso a la interfaz <see cref="T:System.Collections.ArrayList" /> está sincronizado (es seguro para subprocesos).</summary>
        <value>Es <see langword="true" /> si el acceso a <see cref="T:System.Collections.ArrayList" /> está sincronizado (es seguro para subprocesos); de lo contrario, es <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para garantizar la seguridad para subprocesos de la <xref:System.Collections.ArrayList>, todas las operaciones deben realizarse a través del contenedor devuelto por el <xref:System.Collections.ArrayList.Synchronized%2A> método.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo bloquear la colección utilizando el <xref:System.Collections.ArrayList.SyncRoot%2A> durante toda la enumeración.  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 El ejemplo de código siguiente muestra cómo sincronizar un <xref:System.Collections.ArrayList>, determinar si un <xref:System.Collections.ArrayList> está sincronizada y usar sincronizado <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.SyncRoot" />
        <altmember cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj with get, set" Usage="System.Collections.ArrayList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se va a obtener o establecer.</param>
        <summary>Obtiene o establece el elemento en el índice especificado.</summary>
        <value>Elemento en el índice especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.ArrayList.Item%2A> devuelve un <xref:System.Object>, por lo que es posible que deba convertir el valor devuelto al tipo original con el fin de procesarlos. Es importante tener en cuenta que <xref:System.Collections.ArrayList> no es una colección fuertemente tipada. Para obtener una alternativa fuertemente tipados, vea <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.ArrayList> acepta `null` como un valor válido y permite elementos duplicados.  
  
 Esta propiedad permite obtener acceso a un elemento específico de la colección utilizando la sintaxis siguiente: `myCollection[index]`.  
  
 El C# lenguaje usa el [ `this` ](~/docs/csharp/language-reference/keywords/this.md) palabra clave para definir los indizadores en lugar de implementar la <xref:System.Collections.ArrayList.Item%2A> propiedad. Visual Basic implementa <xref:System.Collections.ArrayList.Item%2A> como propiedad predeterminada, lo que proporciona la misma funcionalidad de indización.  
  
 Recuperar el valor de esta propiedad es una operación o (1); establecer la propiedad también es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Collections.ArrayList> y se agregan varios elementos. El ejemplo muestra cómo tener acceso a elementos con el <xref:System.Collections.ArrayList.Item%2A> propiedad (el indizador en C#) y cambiar un elemento mediante la asignación de un nuevo valor para el <xref:System.Collections.ArrayList.Item%2A> propiedad correspondiente al índice especificado. El ejemplo también muestra que el <xref:System.Collections.ArrayList.Item%2A> propiedad no se puede usar para tener acceso o agregar elementos fuera del tamaño actual de la lista.  
  
 [!code-cpp[System.Collections.ArrayList.Item#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/cpp/source.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.Item#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/CS/source.cs#1)]
 [!code-vb[System.Collections.ArrayList.Item#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/VB/source.vb#1)]  
  
 En el ejemplo siguiente se usa el <xref:System.Collections.ArrayList.Item%2A> propiedad explícitamente para asignar valores a los elementos de la lista. El ejemplo define una clase que hereda un <xref:System.Collections.ArrayList> y agrega un método para codificar los elementos de lista.  
  
 [!code-cpp[System.Collections.ArrayList.Item#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/cpp/source2.cpp#2)]
 [!code-csharp[System.Collections.ArrayList.Item#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/CS/source2.cs#2)]
 [!code-vb[System.Collections.ArrayList.Item#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> es igual o mayor que <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el índice de base cero de la última aparición de un valor en la <see cref="T:System.Collections.ArrayList" /> o en una parte de ella.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : obj -&gt; int&#xA;override this.LastIndexOf : obj -&gt; int" Usage="arrayList.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto <see cref="T:System.Object" /> que se va a buscar en la interfaz <see cref="T:System.Collections.ArrayList" />. El valor puede ser <see langword="null" />.</param>
        <summary>Busca el <see cref="T:System.Object" /> especificado y devuelve el índice de base cero de la última aparición en la <see cref="T:System.Collections.ArrayList" /> completa.</summary>
        <returns>Índice de base cero de la última aparición de <paramref name="value" /> en todo el objeto <see cref="T:System.Collections.ArrayList" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.ArrayList> se realiza hacia atrás a partir del último elemento y terminando en el primer elemento.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
 A partir de .NET Framework 2.0, este método utiliza los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si existe el elemento. En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo determinar el índice de la última aparición de un elemento especificado.  
  
 [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (value As Object, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : obj * int -&gt; int&#xA;override this.LastIndexOf : obj * int -&gt; int" Usage="arrayList.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Objeto <see cref="T:System.Object" /> que se va a buscar en la interfaz <see cref="T:System.Collections.ArrayList" />. El valor puede ser <see langword="null" />.</param>
        <param name="startIndex">Índice inicial de base cero de la búsqueda hacia atrás.</param>
        <summary>Busca el objeto <see cref="T:System.Object" /> especificado y devuelve el índice de base cero de la última aparición dentro del intervalo de elementos de la matriz <see cref="T:System.Collections.ArrayList" /> que abarca desde el primer elemento hasta el último índice especificado.</summary>
        <returns>Índice de base cero de la última aparición de <paramref name="value" /> dentro del intervalo de elementos de <see cref="T:System.Collections.ArrayList" /> que abarca desde el primer elemento hasta <paramref name="startIndex" />, si se encuentra; de lo contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.ArrayList> es la búsqueda hacia atrás, empezando en `startIndex` y terminando en el primer elemento.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es el número de elementos desde el principio de la <xref:System.Collections.ArrayList> a `startIndex`.  
  
 Este método determina la igualdad llamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 A partir de .NET Framework 2.0, este método utiliza los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si existe el elemento. En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo determinar el índice de la última aparición de un elemento especificado.  
  
 [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fuera del intervalo de índices válidos para <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (value As Object, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : obj * int * int -&gt; int&#xA;override this.LastIndexOf : obj * int * int -&gt; int" Usage="arrayList.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Objeto <see cref="T:System.Object" /> que se va a buscar en la interfaz <see cref="T:System.Collections.ArrayList" />. El valor puede ser <see langword="null" />.</param>
        <param name="startIndex">Índice inicial de base cero de la búsqueda hacia atrás.</param>
        <param name="count">Número de elementos de la sección en la que se va a realizar la búsqueda.</param>
        <summary>Busca el objeto <see cref="T:System.Object" /> especificado y devuelve el índice de base cero de la última aparición dentro del intervalo de elementos de la matriz <see cref="T:System.Collections.ArrayList" /> que contiene el número de elementos especificado y termina en el índice especificado.</summary>
        <returns>Índice de base cero de la última aparición de <paramref name="value" /> dentro del intervalo de elementos de <see cref="T:System.Collections.ArrayList" /> que contiene el número de elementos de <paramref name="count" /> y termina en <paramref name="startIndex" />, si se encuentra; de lo contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.ArrayList> es la búsqueda hacia atrás, empezando en `startIndex` hasta `startIndex` menos `count` más 1, si `count` es mayor que 0.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es `count`.  
  
 Este método determina la igualdad llamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 A partir de .NET Framework 2.0, este método utiliza los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si existe el elemento. En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo determinar el índice de la última aparición de un elemento especificado. Tenga en cuenta que `LastIndexOf` es una búsqueda hacia atrás; por lo tanto, `count` debe ser menor o igual que `startIndex` + 1.  
  
 [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fuera del intervalo de índices válidos para <see cref="T:System.Collections.ArrayList" />.  
  
O bien 
 <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="startIndex" /> y <paramref name="count" /> no especifican una sección válida en <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadOnly">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un contenedor de lista de solo lectura.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList ReadOnly (System.Collections.ArrayList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList ReadOnly(class System.Collections.ArrayList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadOnly (list As ArrayList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ ReadOnly(System::Collections::ArrayList ^ list);" />
      <MemberSignature Language="F#" Value="static member ReadOnly : System.Collections.ArrayList -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.ReadOnly list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="list"><see cref="T:System.Collections.ArrayList" /> que se va a incluir.</param>
        <summary>Devuelve un contenedor de <see cref="T:System.Collections.ArrayList" /> de solo lectura.</summary>
        <returns>Contenedor de <see cref="T:System.Collections.ArrayList" /> de solo lectura para <paramref name="list" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para evitar modificaciones en `list`, exponer `list` únicamente a través de este contenedor.  
  
 Una colección es de solo lectura es simplemente una colección con un contenedor que evita la modificación de la colección. Si se realizan cambios en la colección subyacente, la colección de solo lectura refleja los cambios.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo crear un contenedor de solo lectura en torno a un <xref:System.Collections.ArrayList> y cómo determinar si un <xref:System.Collections.ArrayList> es de solo lectura.  
  
 [!code-cpp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.ArrayList.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public static System.Collections.IList ReadOnly (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList ReadOnly(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadOnly (list As IList) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ ReadOnly(System::Collections::IList ^ list);" />
      <MemberSignature Language="F#" Value="static member ReadOnly : System.Collections.IList -&gt; System.Collections.IList" Usage="System.Collections.ArrayList.ReadOnly list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list"><see cref="T:System.Collections.IList" /> que se va a incluir.</param>
        <summary>Devuelve un contenedor de <see cref="T:System.Collections.IList" /> de solo lectura.</summary>
        <returns>Contenedor de <see cref="T:System.Collections.IList" /> de solo lectura para <paramref name="list" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para evitar modificaciones en `list`, exponer `list` únicamente a través de este contenedor.  
  
 Una colección es de solo lectura es simplemente una colección con un contenedor que evita la modificación de la colección. Si se realizan cambios en la colección subyacente, la colección de solo lectura refleja los cambios.  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.ArrayList.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="arrayList.Remove obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.Object" /> que se va a quitar de <see cref="T:System.Collections.ArrayList" />. El valor puede ser <see langword="null" />.</param>
        <summary>Quita la primera aparición de un objeto específico de la interfaz <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Collections.ArrayList> no contiene el objeto especificado, el <xref:System.Collections.ArrayList> permanece sin cambios. No se inicia ninguna excepción.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
 Este método determina la igualdad llamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 En colecciones de elementos contiguos, como listas, los elementos que van a continuación del elemento eliminado se desplazan hacia arriba para ocupar el espacio libre. Si la colección está indizada, también se actualizan los índices de los elementos que se han movido. Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo quitar los elementos de la <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> es de solo lectura.  
  
O bien 
<see cref="T:System.Collections.ArrayList" /> tiene un tamaño fijo.</exception>
        <altmember cref="M:System.Collections.ArrayList.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="arrayList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se va a quitar.</param>
        <summary>Quita el elemento situado en el índice especificado de <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de quita el elemento, se ajusta el tamaño de la colección y el valor de la <xref:System.Collections.ArrayList.Count%2A> propiedad se reduce en uno.  
  
 En colecciones de elementos contiguos, como listas, los elementos que van a continuación del elemento eliminado se desplazan hacia arriba para ocupar el espacio libre. Si la colección está indizada, también se actualizan los índices de los elementos que se han movido. Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo quitar los elementos de la <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> es igual o mayor que <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> es de solo lectura.  
  
O bien 
<see cref="T:System.Collections.ArrayList" /> tiene un tamaño fijo.</exception>
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public virtual void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member RemoveRange : int * int -&gt; unit&#xA;override this.RemoveRange : int * int -&gt; unit" Usage="arrayList.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice inicial de base cero del intervalo de elementos que se va a quitar.</param>
        <param name="count">Número de elementos que se va a quitar.</param>
        <summary>Quita todos los elementos de <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En colecciones de elementos contiguos, como listas, los elementos que van a continuación del elemento eliminado se desplazan hacia arriba para ocupar el espacio libre. Si la colección está indizada, también se actualizan los índices de los elementos que se han movido. Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo quitar los elementos de la <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido de elementos en la <see cref="T:System.Collections.ArrayList" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> es de solo lectura.  
  
O bien 
<see cref="T:System.Collections.ArrayList" /> tiene un tamaño fijo.</exception>
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
      </Docs>
    </Member>
    <Member MemberName="Repeat">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList Repeat (object value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList Repeat(object value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Repeat (value As Object, count As Integer) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ Repeat(System::Object ^ value, int count);" />
      <MemberSignature Language="F#" Value="static member Repeat : obj * int -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.Repeat (value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> que se va a copiar varias veces en la nueva <see cref="T:System.Collections.ArrayList" />. El valor puede ser <see langword="null" />.</param>
        <param name="count">Número de veces que se debe copiar el parámetro <paramref name="value" />.</param>
        <summary>Devuelve una <see cref="T:System.Collections.ArrayList" /> cuyos elementos son copias del valor especificado.</summary>
        <returns><see cref="T:System.Collections.ArrayList" /> con un número <paramref name="count" /> de elementos que son todos ellos copias de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> acepta `null` como un valor válido y permite elementos duplicados.  
  
 Este método es O (`n`) operación, donde `n` es `count`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo crear e inicializar una nueva <xref:System.Collections.ArrayList> con el mismo valor.  
  
 [!code-cpp[Classic ArrayList.Repeat Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Repeat Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Repeat Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Repeat Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Repeat Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Repeat Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> es menor que cero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invierte el orden de los elementos en la <see cref="T:System.Collections.ArrayList" /> o en una parte de ella.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public virtual void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reverse();" />
      <MemberSignature Language="F#" Value="abstract member Reverse : unit -&gt; unit&#xA;override this.Reverse : unit -&gt; unit" Usage="arrayList.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Invierte el orden de los elementos en la <see cref="T:System.Collections.ArrayList" /> completa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa <xref:System.Array.Reverse%2A?displayProperty=nameWithType> para invertir el orden de los elementos, tal que el elemento situado <xref:System.Collections.ArrayList> [i], donde i es un índice dentro del intervalo, se mueve a <xref:System.Collections.ArrayList> [j], que es igual j `index`  +  `index`  +  `count` - i - 1.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo se invierte el criterio de ordenación de los valores de un <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> es de solo lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public virtual void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member Reverse : int * int -&gt; unit&#xA;override this.Reverse : int * int -&gt; unit" Usage="arrayList.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice inicial de base cero del intervalo que se va a invertir.</param>
        <param name="count">Número de elementos del intervalo que se va a invertir.</param>
        <summary>Invierte el orden de los elementos en el intervalo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa <xref:System.Array.Reverse%2A?displayProperty=nameWithType> para invertir el orden de los elementos, tal que el elemento situado <xref:System.Collections.ArrayList> [i], donde i es un índice dentro del intervalo, se mueve a <xref:System.Collections.ArrayList> [j], que es igual j `index`  +  `index`  +  `count` - i - 1.  
  
 Este método es O (`n`) operación, donde `n` es `count`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo se invierte el criterio de ordenación de los valores de un intervalo de elementos de un <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido de elementos en la <see cref="T:System.Collections.ArrayList" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> es de solo lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetRange">
      <MemberSignature Language="C#" Value="public virtual void SetRange (int index, System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetRange(int32 index, class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetRange (index As Integer, c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetRange(int index, System::Collections::ICollection ^ c);" />
      <MemberSignature Language="F#" Value="abstract member SetRange : int * System.Collections.ICollection -&gt; unit&#xA;override this.SetRange : int * System.Collections.ICollection -&gt; unit" Usage="arrayList.SetRange (index, c)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="index">Índice de <see cref="T:System.Collections.ArrayList" /> de base cero en el que empiezan a copiarse los elementos de <paramref name="c" />.</param>
        <param name="c"><see cref="T:System.Collections.ICollection" /> cuyos elementos se copian en <see cref="T:System.Collections.ArrayList" />. La propia colección no puede ser <see langword="null" />, pero puede contener elementos que sean <see langword="null" />.</param>
        <summary>Copia los elementos de una colección en un intervalo de elementos de <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> acepta `null` como un valor válido y permite elementos duplicados.  
  
 El orden de los elementos de la <xref:System.Collections.ICollection> se conserva en el <xref:System.Collections.ArrayList>.  
  
 Este método es O (`n` + 1) la operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un intervalo de elementos de la <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.SetRange Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.SetRange Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.SetRange Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> más el número de elementos de <paramref name="c" /> es mayor que <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> es de solo lectura.</exception>
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ordena los elementos en <see cref="T:System.Collections.ArrayList" /> o en una parte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public virtual void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Sort();" />
      <MemberSignature Language="F#" Value="abstract member Sort : unit -&gt; unit&#xA;override this.Sort : unit -&gt; unit" Usage="arrayList.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ordena todos los elementos de <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa <xref:System.Array.Sort%2A?displayProperty=nameWithType>, que utiliza el algoritmo QuickSort. El algoritmo QuickSort es una comparación de ordenación (también denominada ordenación inestable), lo que significa que un "menor que o igual a" operación de comparación determina cuál de dos elementos debe realizarse en primer lugar en la lista clasificada final. Sin embargo, si dos elementos son iguales, es posible que no se conserve su orden original. En cambio, una ordenación estable conserva el orden de los elementos que son iguales. Para realizar una ordenación estable, debe implementar un personalizado <xref:System.Collections.IComparer> interfaz que se utiliza con las demás sobrecargas de este método.  
  
 En promedio, este método es O (`n` registro `n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>; en el peor de los casos, es una O (`n`^ 2) operación.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo ordenar los valores de un <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Sort Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Sort Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Sort Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Sort Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Sort Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Sort Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> es de solo lectura.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public virtual void Sort (System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort(class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Sort (comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Sort(System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="abstract member Sort : System.Collections.IComparer -&gt; unit&#xA;override this.Sort : System.Collections.IComparer -&gt; unit" Usage="arrayList.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementación de <see cref="T:System.Collections.IComparer" /> que se va a usar al comparar elementos.  
  
O bien 
Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la implementación de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Ordena los elementos en la <see cref="T:System.Collections.ArrayList" /> completa usando el comparador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Collections.ArrayList.Sort%2A> método para ordenar una lista de objetos con un comparador personalizado que implementa el <xref:System.Collections.IComparer> interfaz. Si se pasa `null` para `comparer`, este método utiliza el <xref:System.IComparable> implementación de cada elemento. En este caso, debe asegurarse de que los objetos contenidos en la lista de implementan el <xref:System.Collections.IComparer> se producirá una excepción o interfaz.  
  
 Además, al usar el <xref:System.IComparable> implementación significa que la lista realiza una ordenación de comparación (también denominada ordenación inestable); es decir, si dos elementos son iguales, su orden podría no conservarse. En cambio, una ordenación estable conserva el orden de los elementos que son iguales. Para realizar una ordenación estable, debe implementar un personalizado <xref:System.Collections.IComparer> interfaz.  
  
 En promedio, este método es O (`n` registro `n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>; en el peor de los casos, es una O (`n`^ 2) operación.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo ordenar los valores de un <xref:System.Collections.ArrayList> utilizando el comparador predeterminado y un comparador personalizado que invierte el criterio de ordenación.  
  
 [!code-cpp[System.Collections.ArrayList.Sort_2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_2/CPP/arraylist_sort2.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.Sort_2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_2/CS/arraylist_sort2.cs#1)]
 [!code-vb[System.Collections.ArrayList.Sort_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_2/VB/arraylist_sort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> es de solo lectura.</exception>
        <exception cref="T:System.InvalidOperationException">Se produjo un error al comparar dos elementos.</exception>
        <exception cref="T:System.ArgumentException"><see langword="null" /> se pasa para <paramref name="comparer" />, y los elementos de la lista no implementan <see cref="T:System.IComparable" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public virtual void Sort (int index, int count, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort(int32 index, int32 count, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Sort (index As Integer, count As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Sort(int index, int count, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="abstract member Sort : int * int * System.Collections.IComparer -&gt; unit&#xA;override this.Sort : int * int * System.Collections.IComparer -&gt; unit" Usage="arrayList.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="index">Índice inicial de base cero del intervalo que se va a ordenar.</param>
        <param name="count">Longitud del intervalo que se va a ordenar.</param>
        <param name="comparer">Implementación de <see cref="T:System.Collections.IComparer" /> que se va a usar al comparar elementos.  
  
O bien 
Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la implementación de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Ordena los elementos en un intervalo de elementos de la matriz <see cref="T:System.Collections.ArrayList" /> usando el comparador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparer` está establecido en `null`, este método realiza una ordenación de comparación (también denominada ordenación inestable); es decir, si dos elementos son iguales, su orden podría no conservarse. En cambio, una ordenación estable conserva el orden de los elementos que son iguales. Para realizar una ordenación estable, debe implementar un personalizado <xref:System.Collections.IComparer> interfaz.  
  
 En promedio, este método es O (`n` registro `n`) operación, donde `n` es `count`; en el peor de los casos, es una operación O(n^2).  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo ordenar los valores de un intervalo de elementos de un <xref:System.Collections.ArrayList> utilizando el comparador predeterminado y un comparador personalizado que invierte el criterio de ordenación.  
  
 [!code-cpp[System.Collections.ArrayList.Sort_3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_3/CPP/arraylist_sort3.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.Sort_3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_3/CS/arraylist_sort3.cs#1)]
 [!code-vb[System.Collections.ArrayList.Sort_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_3/VB/arraylist_sort3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> y <paramref name="count" /> no especifican un intervalo válido en <see cref="T:System.Collections.ArrayList" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> es de solo lectura.</exception>
        <exception cref="T:System.InvalidOperationException">Se produjo un error al comparar dos elementos.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Synchronized">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un contenedor de lista que está sincronizado (es seguro para subprocesos).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList Synchronized (System.Collections.ArrayList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList Synchronized(class System.Collections.ArrayList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As ArrayList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ Synchronized(System::Collections::ArrayList ^ list);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.ArrayList -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.Synchronized list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="list"><see cref="T:System.Collections.ArrayList" /> que se va a sincronizar.</param>
        <summary>Devuelve un contenedor de la clase <see cref="T:System.Collections.ArrayList" /> que está sincronizado (es seguro para subprocesos).</summary>
        <returns>Contenedor de la clase <see cref="T:System.Collections.ArrayList" /> que está sincronizado (es seguro para subprocesos).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para garantizar la seguridad para subprocesos de la <xref:System.Collections.ArrayList>, todas las operaciones deben realizarse a través de este contenedor.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo bloquear la colección utilizando el <xref:System.Collections.ArrayList.SyncRoot%2A> durante toda la enumeración.  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Este método es una operación o (1).  
  
 El ejemplo de código siguiente muestra cómo sincronizar un <xref:System.Collections.ArrayList>, determinar si un <xref:System.Collections.ArrayList> está sincronizada y usar sincronizado <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.ArrayList.SyncRoot" />
        <altmember cref="P:System.Collections.ArrayList.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.IList Synchronized (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList Synchronized(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As IList) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ Synchronized(System::Collections::IList ^ list);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.IList -&gt; System.Collections.IList" Usage="System.Collections.ArrayList.Synchronized list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list"><see cref="T:System.Collections.IList" /> que se va a sincronizar.</param>
        <summary>Devuelve un contenedor de la clase <see cref="T:System.Collections.IList" /> que está sincronizado (es seguro para subprocesos).</summary>
        <returns>Contenedor de la clase <see cref="T:System.Collections.IList" /> que está sincronizado (es seguro para subprocesos).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para garantizar la seguridad para subprocesos de la <xref:System.Collections.ArrayList>, todas las operaciones deben realizarse a través de este contenedor.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo bloquear la colección utilizando el <xref:System.Collections.ArrayList.SyncRoot%2A> durante toda la enumeración.  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.ArrayList.SyncRoot" />
        <altmember cref="P:System.Collections.ArrayList.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.ArrayList.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ArrayList" />.</summary>
        <value>Objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ArrayList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para crear una versión sincronizada de la <xref:System.Collections.ArrayList>, utilice el <xref:System.Collections.ArrayList.Synchronized%2A> método. Sin embargo, las clases derivadas pueden proporcionar su propia versión sincronizada de la <xref:System.Collections.ArrayList> utilizando el <xref:System.Collections.ArrayList.SyncRoot%2A> propiedad. El código de sincronización debe realizar operaciones en el <xref:System.Collections.ArrayList.SyncRoot%2A> de la <xref:System.Collections.ArrayList>, no directamente en el <xref:System.Collections.ArrayList>. De este modo, se garantiza el funcionamiento correcto de las colecciones derivadas de otros objetos. En concreto, mantiene la sincronización correcta con otros subprocesos que podrían modificar simultáneamente la <xref:System.Collections.ArrayList> objeto.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo bloquear la colección utilizando el <xref:System.Collections.ArrayList.SyncRoot%2A> durante toda la enumeración.  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.IsSynchronized" />
        <altmember cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToArray">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia los elementos de <see cref="T:System.Collections.ArrayList" /> en una nueva matriz.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual object[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="abstract member ToArray : unit -&gt; obj[]&#xA;override this.ToArray : unit -&gt; obj[]" Usage="arrayList.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia los elementos de <see cref="T:System.Collections.ArrayList" /> en una nueva matriz de <see cref="T:System.Object" />.</summary>
        <returns>Matriz de <see cref="T:System.Object" /> que contiene copias de los elementos de <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos se copian con <xref:System.Array.Copy%2A?displayProperty=nameWithType>, que es O (`n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual Array ToArray (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array ToArray(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ToArray(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ ToArray(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member ToArray : Type -&gt; Array&#xA;override this.ToArray : Type -&gt; Array" Usage="arrayList.ToArray type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de elemento de la matriz de destino que se va a crear y en la que se van a copiar los elementos.</param>
        <summary>Copia los elementos de la matriz <see cref="T:System.Collections.ArrayList" /> a una nueva matriz del tipo de elemento especificado.</summary>
        <returns>Una matriz del tipo de elemento especificado que contiene copias de los elementos de la matriz <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los objetos en el <xref:System.Collections.ArrayList> objeto se convertirá a la <xref:System.Type> especificado en el `type` parámetro.  
  
 Los elementos se copian con <xref:System.Array.Copy%2A?displayProperty=nameWithType>, que es O (`n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 En el siguiente ejemplo de copia se muestra cómo copiar los elementos de un <xref:System.Collections.ArrayList> a una matriz de cadenas.  
  
 [!code-cpp[System.Collections.ArrayList.ToArray#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.ToArray/CPP/arraylist_toarray.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.ToArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.ToArray/CS/arraylist_toarray.cs#1)]
 [!code-vb[System.Collections.ArrayList.ToArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.ToArray/VB/arraylist_toarray.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">El tipo del origen <see cref="T:System.Collections.ArrayList" /> no puede convertirse automáticamente al tipo especificado.</exception>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.TrimToSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub TrimToSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void TrimToSize();" />
      <MemberSignature Language="F#" Value="abstract member TrimToSize : unit -&gt; unit&#xA;override this.TrimToSize : unit -&gt; unit" Usage="arrayList.TrimToSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establece la capacidad en el número real de elementos que hay en <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede utilizarse para minimizar la sobrecarga de memoria de una colección si ningún elemento nuevo se agregará a la colección.  
  
 Para restablecer un <xref:System.Collections.ArrayList> a su estado inicial, llame a la <xref:System.Collections.ArrayList.Clear%2A> método antes de llamar a <xref:System.Collections.ArrayList.TrimToSize%2A>. Recorte vacío <xref:System.Collections.ArrayList> establece la capacidad de la <xref:System.Collections.ArrayList> a la capacidad predeterminada.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo se recortan las partes no utilizadas de la <xref:System.Collections.ArrayList> y cómo borrar los valores de la <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> es de solo lectura.  
  
O bien 
<see cref="T:System.Collections.ArrayList" /> tiene un tamaño fijo.</exception>
        <altmember cref="M:System.Collections.ArrayList.Clear" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
  </Members>
</Type>