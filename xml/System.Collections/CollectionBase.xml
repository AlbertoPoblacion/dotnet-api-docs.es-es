<Type Name="CollectionBase" FullName="System.Collections.CollectionBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="80ff5e8299867b5db91c9a6fdae284a05e9d6980" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37700627" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CollectionBase : System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit CollectionBase extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.CollectionBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CollectionBase&#xA;Implements IList" />
  <TypeSignature Language="C++ CLI" Value="public ref class CollectionBase abstract : System::Collections::IList" />
  <TypeSignature Language="F#" Value="type CollectionBase = class&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="d56a0-101">Proporciona la clase base <see langword="abstract" /> para una colección fuertemente tipada.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d56a0-101">Provides the <see langword="abstract" /> base class for a strongly typed collection.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-102">Un <xref:System.Collections.CollectionBase> instancia siempre es modificable.</span><span class="sxs-lookup"><span data-stu-id="d56a0-102">A <xref:System.Collections.CollectionBase> instance is always modifiable.</span></span> <span data-ttu-id="d56a0-103">Consulte <xref:System.Collections.ReadOnlyCollectionBase> para obtener una versión de solo lectura de esta clase.</span><span class="sxs-lookup"><span data-stu-id="d56a0-103">See <xref:System.Collections.ReadOnlyCollectionBase> for a read-only version of this class.</span></span>  
  
 <span data-ttu-id="d56a0-104">La capacidad de un <xref:System.Collections.CollectionBase> es el número de elementos de la <xref:System.Collections.CollectionBase> puede contener.</span><span class="sxs-lookup"><span data-stu-id="d56a0-104">The capacity of a <xref:System.Collections.CollectionBase> is the number of elements the <xref:System.Collections.CollectionBase> can hold.</span></span> <span data-ttu-id="d56a0-105">Cuando se agregan elementos a un <xref:System.Collections.CollectionBase>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación.</span><span class="sxs-lookup"><span data-stu-id="d56a0-105">As elements are added to a <xref:System.Collections.CollectionBase>, the capacity is automatically increased as required through reallocation.</span></span> <span data-ttu-id="d56a0-106">La capacidad puede reducirse mediante el establecimiento del <xref:System.Collections.CollectionBase.Capacity%2A> propiedad explícitamente.</span><span class="sxs-lookup"><span data-stu-id="d56a0-106">The capacity can be decreased by setting the <xref:System.Collections.CollectionBase.Capacity%2A> property explicitly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d56a0-107">El siguiente ejemplo de código implementa la <xref:System.Collections.CollectionBase> clase y utiliza esa implementación para crear una colección de <xref:System.Int16> objetos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-107">The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.</span></span>  
  
 [!code-cpp[System.Collections.CollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CPP/collectionbase.cpp#1)]
 [!code-csharp[System.Collections.CollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CS/collectionbase.cs#1)]
 [!code-vb[System.Collections.CollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.CollectionBase/VB/collectionbase.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="d56a0-108">Estáticos públicos (<see langword="Shared" /> en Visual Basic) los miembros de este tipo son seguros para subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d56a0-108">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span>
      </span>
      <span data-ttu-id="d56a0-109">No se garantiza que los miembros de instancias sean seguros para la ejecución de subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d56a0-109">Any instance members are not guaranteed to be thread safe.</span>
      </span>
      <span data-ttu-id="d56a0-110">Esta implementación no proporciona un sincronizados contenedor (es seguro para subprocesos) para un <see cref="T:System.Collections.CollectionBase" />, pero las clases derivadas pueden crear sus propias versiones sincronizadas de los <see cref="T:System.Collections.CollectionBase" /> utilizando el <see cref="P:System.Collections.ICollection.SyncRoot" /> propiedad.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d56a0-110">This implementation does not provide a synchronized (thread safe) wrapper for a <see cref="T:System.Collections.CollectionBase" />, but derived classes can create their own synchronized versions of the <see cref="T:System.Collections.CollectionBase" /> using the <see cref="P:System.Collections.ICollection.SyncRoot" /> property.</span>
      </span>
      <span data-ttu-id="d56a0-111">Enumerar una colección no es un procedimiento seguro para subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d56a0-111">Enumerating through a collection is intrinsically not a thread safe procedure.</span>
      </span>
      <span data-ttu-id="d56a0-112">Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d56a0-112">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span>
      </span>
      <span data-ttu-id="d56a0-113">Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d56a0-113">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span>
      </span>
    </threadsafe>
    <block subset="none" type="overrides">
      <span data-ttu-id="d56a0-114">
        <para>Esta clase base se proporciona para facilitar a los implementadores que creen una colección fuertemente tipada personalizada. Se recomienda para extender esta clase base en lugar de crear sus propios los implementadores.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="d56a0-114">
          <para>This base class is provided to make it easier for implementers to create a strongly typed custom collection. Implementers are encouraged to extend this base class instead of creating their own.</para>
        </span>
      </span>
    </block>
    <altmember cref="T:System.Collections.ArrayList" />
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.ReadOnlyCollectionBase" />
    <altmember cref="N:System.Collections.Generic" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d56a0-115">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-115">Initializes a new instance of the <see cref="T:System.Collections.CollectionBase" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CollectionBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CollectionBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d56a0-116">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.CollectionBase" /> con la funcionalidad inicial predeterminada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-116">Initializes a new instance of the <see cref="T:System.Collections.CollectionBase" /> class with the default initial capacity.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-117">La capacidad de un <xref:System.Collections.CollectionBase> es el número de elementos que la <xref:System.Collections.CollectionBase> puede contener.</span><span class="sxs-lookup"><span data-stu-id="d56a0-117">The capacity of a <xref:System.Collections.CollectionBase> is the number of elements that the <xref:System.Collections.CollectionBase> can hold.</span></span> <span data-ttu-id="d56a0-118">Cuando se agregan elementos a un <xref:System.Collections.CollectionBase>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna.</span><span class="sxs-lookup"><span data-stu-id="d56a0-118">As elements are added to a <xref:System.Collections.CollectionBase>, the capacity is automatically increased as required by reallocating the internal array.</span></span>  
  
 <span data-ttu-id="d56a0-119">Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.CollectionBase>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-119">If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.CollectionBase>.</span></span>  
  
 <span data-ttu-id="d56a0-120">Este constructor es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-120">This constructor is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.CollectionBase.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CollectionBase (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CollectionBase(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.CollectionBase : int -&gt; System.Collections.CollectionBase" Usage="new System.Collections.CollectionBase capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <span data-ttu-id="d56a0-121">Número de elementos que puede almacenar inicialmente la lista nueva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-121">The number of elements that the new list can initially store.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d56a0-122">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.CollectionBase" /> con la capacidad especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-122">Initializes a new instance of the <see cref="T:System.Collections.CollectionBase" /> class with the specified capacity.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-123">La capacidad de un <xref:System.Collections.CollectionBase> es el número de elementos que la <xref:System.Collections.CollectionBase> puede contener.</span><span class="sxs-lookup"><span data-stu-id="d56a0-123">The capacity of a <xref:System.Collections.CollectionBase> is the number of elements that the <xref:System.Collections.CollectionBase> can hold.</span></span> <span data-ttu-id="d56a0-124">Cuando se agregan elementos a un <xref:System.Collections.CollectionBase>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna.</span><span class="sxs-lookup"><span data-stu-id="d56a0-124">As elements are added to a <xref:System.Collections.CollectionBase>, the capacity is automatically increased as required by reallocating the internal array.</span></span>  
  
 <span data-ttu-id="d56a0-125">Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.CollectionBase>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-125">If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.CollectionBase>.</span></span>  
  
 <span data-ttu-id="d56a0-126">Este constructor es O (`n`) operación, donde `n` es `capacity`.</span><span class="sxs-lookup"><span data-stu-id="d56a0-126">This constructor is an O(`n`) operation, where `n` is `capacity`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.CollectionBase.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.CollectionBase.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.CollectionBase.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d56a0-127">Obtiene o establece el número de elementos que puede contener <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-127">Gets or sets the number of elements that the <see cref="T:System.Collections.CollectionBase" /> can contain.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d56a0-128">Número de elementos que puede contener <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-128">The number of elements that the <see cref="T:System.Collections.CollectionBase" /> can contain.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-129"><xref:System.Collections.CollectionBase.Capacity%2A> es el número de elementos que la <xref:System.Collections.CollectionBase> puede almacenar.</span><span class="sxs-lookup"><span data-stu-id="d56a0-129"><xref:System.Collections.CollectionBase.Capacity%2A> is the number of elements that the <xref:System.Collections.CollectionBase> can store.</span></span> <span data-ttu-id="d56a0-130"><xref:System.Collections.CollectionBase.Count%2A> es el número de elementos que son en realidad el <xref:System.Collections.CollectionBase>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-130"><xref:System.Collections.CollectionBase.Count%2A> is the number of elements that are actually in the <xref:System.Collections.CollectionBase>.</span></span>  
  
 <span data-ttu-id="d56a0-131"><xref:System.Collections.CollectionBase.Capacity%2A> es siempre mayor o igual que <xref:System.Collections.CollectionBase.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-131"><xref:System.Collections.CollectionBase.Capacity%2A> is always greater than or equal to <xref:System.Collections.CollectionBase.Count%2A>.</span></span> <span data-ttu-id="d56a0-132">Si <xref:System.Collections.CollectionBase.Count%2A> supera <xref:System.Collections.CollectionBase.Capacity%2A> al agregar elementos, automáticamente se aumenta la capacidad mediante la reasignación de la matriz interna antes de copiar los elementos antiguos y agregar los nuevos elementos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-132">If <xref:System.Collections.CollectionBase.Count%2A> exceeds <xref:System.Collections.CollectionBase.Capacity%2A> while adding elements, the capacity is automatically increased by reallocating the internal array before copying the old elements and adding the new elements.</span></span>  
  
 <span data-ttu-id="d56a0-133">La capacidad puede reducirse mediante el establecimiento del <xref:System.Collections.CollectionBase.Capacity%2A> propiedad explícitamente.</span><span class="sxs-lookup"><span data-stu-id="d56a0-133">The capacity can be decreased by setting the <xref:System.Collections.CollectionBase.Capacity%2A> property explicitly.</span></span> <span data-ttu-id="d56a0-134">Cuando el valor de <xref:System.Collections.CollectionBase.Capacity%2A> se establece explícitamente, la matriz interna se reasigna para dar cabida a la capacidad especificada.</span><span class="sxs-lookup"><span data-stu-id="d56a0-134">When the value of <xref:System.Collections.CollectionBase.Capacity%2A> is set explicitly, the internal array is also reallocated to accommodate the specified capacity.</span></span>  
  
 <span data-ttu-id="d56a0-135">Recuperar el valor de esta propiedad es una operación o (1); establecer la propiedad es O (`n`) operación, donde `n` es la nueva capacidad.</span><span class="sxs-lookup"><span data-stu-id="d56a0-135">Retrieving the value of this property is an O(1) operation; setting the property is an O(`n`) operation, where `n` is the new capacity.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d56a0-136">
            <see cref="P:System.Collections.CollectionBase.Capacity" /> se establece en un valor que es menor que <see cref="P:System.Collections.CollectionBase.Count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-136">
              <see cref="P:System.Collections.CollectionBase.Capacity" /> is set to a value that is less than <see cref="P:System.Collections.CollectionBase.Count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="d56a0-137">No hay memoria suficiente en el sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-137">There is not enough memory available on the system.</span>
          </span>
        </exception>
        <altmember cref="P:System.Collections.CollectionBase.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="collectionBase.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d56a0-138">Elimina todos los objetos de la instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-138">Removes all objects from the <see cref="T:System.Collections.CollectionBase" /> instance.</span>
          </span>
          <span data-ttu-id="d56a0-139">Este método no se puede invalidar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-139">This method cannot be overridden.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-140"><xref:System.Collections.CollectionBase.Count%2A> se establece en cero.</span><span class="sxs-lookup"><span data-stu-id="d56a0-140"><xref:System.Collections.CollectionBase.Count%2A> is set to zero.</span></span>  
  
 <span data-ttu-id="d56a0-141">Este método es O (`n`) operación, donde `n` es <xref:System.Collections.CollectionBase.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-141">This method is an O(`n`) operation, where `n` is <xref:System.Collections.CollectionBase.Count%2A>.</span></span>  
  
 <span data-ttu-id="d56a0-142">Para realizar acciones personalizadas antes o después de la colección se borra, invalidar protegido <xref:System.Collections.CollectionBase.OnClear%2A> o <xref:System.Collections.CollectionBase.OnClearComplete%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d56a0-142">To perform custom actions before or after the collection is cleared, override the protected <xref:System.Collections.CollectionBase.OnClear%2A> or <xref:System.Collections.CollectionBase.OnClearComplete%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.CollectionBase.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.CollectionBase.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d56a0-143">Obtiene el número de elementos incluidos en la instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-143">Gets the number of elements contained in the <see cref="T:System.Collections.CollectionBase" /> instance.</span>
          </span>
          <span data-ttu-id="d56a0-144">Esta propiedad no se puede invalidar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-144">This property cannot be overridden.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d56a0-145">Número de elementos incluidos en la instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-145">The number of elements contained in the <see cref="T:System.Collections.CollectionBase" /> instance.</span>
          </span>
          <span data-ttu-id="d56a0-146">La recuperación del valor de esta propiedad es una operación O(1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-146">Retrieving the value of this property is an O(1) operation.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d56a0-147">El siguiente ejemplo de código implementa la <xref:System.Collections.CollectionBase> clase y utiliza esa implementación para crear una colección de <xref:System.Int16> objetos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-147">The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.</span></span>  
  
 [!code-cpp[System.Collections.CollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CPP/collectionbase.cpp#1)]
 [!code-csharp[System.Collections.CollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CS/collectionbase.cs#1)]
 [!code-vb[System.Collections.CollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.CollectionBase/VB/collectionbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="collectionBase.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d56a0-148">Devuelve un enumerador que recorre en iteración la instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-148">Returns an enumerator that iterates through the <see cref="T:System.Collections.CollectionBase" /> instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d56a0-149">
            <see cref="T:System.Collections.IEnumerator" /> correspondiente a la instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-149">An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Collections.CollectionBase" /> instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-150">[Visual Basic, C#]</span><span class="sxs-lookup"><span data-stu-id="d56a0-150">[Visual Basic, C#]</span></span>  
  
 <span data-ttu-id="d56a0-151">La instrucción `foreach` del lenguaje C# (`for each` en Visual Basic) oculta la complejidad de los enumeradores.</span><span class="sxs-lookup"><span data-stu-id="d56a0-151">The `foreach` statement of the C# language (`for each` in Visual Basic) hides the complexity of the enumerators.</span></span>  <span data-ttu-id="d56a0-152">Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.</span><span class="sxs-lookup"><span data-stu-id="d56a0-152">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="d56a0-153">Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.</span><span class="sxs-lookup"><span data-stu-id="d56a0-153">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="d56a0-154">En principio, el enumerador se coloca antes del primer elemento de la colección.</span><span class="sxs-lookup"><span data-stu-id="d56a0-154">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="d56a0-155"><xref:System.Collections.IEnumerator.Reset%2A> también devuelve el enumerador a esta posición.</span><span class="sxs-lookup"><span data-stu-id="d56a0-155"><xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.</span></span> <span data-ttu-id="d56a0-156">En esta posición, una llamada a <xref:System.Collections.IEnumerator.Current%2A> produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="d56a0-156">At this position, calling <xref:System.Collections.IEnumerator.Current%2A> throws an exception.</span></span> <span data-ttu-id="d56a0-157">Por lo tanto, debe llamar a <xref:System.Collections.IEnumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.IEnumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-157">Therefore, you must call <xref:System.Collections.IEnumerator.MoveNext%2A> to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="d56a0-158"><xref:System.Collections.IEnumerator.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A> o a <xref:System.Collections.IEnumerator.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-158"><xref:System.Collections.IEnumerator.Current%2A> returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called.</span></span> <span data-ttu-id="d56a0-159"><xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.IEnumerator.Current%2A> en el siguiente elemento.</span><span class="sxs-lookup"><span data-stu-id="d56a0-159"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="d56a0-160">Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="d56a0-160">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="d56a0-161">Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`.</span><span class="sxs-lookup"><span data-stu-id="d56a0-161">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="d56a0-162">Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, al llamar a <xref:System.Collections.IEnumerator.Current%2A> produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="d56a0-162">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, calling <xref:System.Collections.IEnumerator.Current%2A> throws an exception.</span></span> <span data-ttu-id="d56a0-163">Para volver a establecer el valor de <xref:System.Collections.IEnumerator.Current%2A> en el primer elemento de la colección, se puede llamar primero a <xref:System.Collections.IEnumerator.Reset%2A> y después a <xref:System.Collections.IEnumerator.MoveNext%2A>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-163">To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.</span></span>  
  
 <span data-ttu-id="d56a0-164">Un enumerador es válido mientras la colección no cambie.</span><span class="sxs-lookup"><span data-stu-id="d56a0-164">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="d56a0-165">Si se realizan cambios en la colección, como agregar, modificar, o eliminar elementos, el enumerador queda invalida invalidado y la siguiente llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> produce una <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-165">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and the next call to <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> throws an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="d56a0-166">Si la colección se modifica entre <xref:System.Collections.IEnumerator.MoveNext%2A> y <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> devuelve el elemento que está establecido, incluso si el enumerador ya se ha invalidado.</span><span class="sxs-lookup"><span data-stu-id="d56a0-166">If the collection is modified between <xref:System.Collections.IEnumerator.MoveNext%2A> and <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> returns the element that it is set to, even if the enumerator is already invalidated.</span></span>  
  
 <span data-ttu-id="d56a0-167">La enumeración en una colección no es un procedimiento seguro para subprocesos ya que el enumerador carece de acceso exclusivo.</span><span class="sxs-lookup"><span data-stu-id="d56a0-167">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</span></span> <span data-ttu-id="d56a0-168">Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción.</span><span class="sxs-lookup"><span data-stu-id="d56a0-168">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="d56a0-169">Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-169">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="d56a0-170">Mientras el <xref:System.Collections.CollectionBase.GetEnumerator%2A> método no es visible para los clientes COM de forma predeterminada, hereda la <xref:System.Collections.CollectionBase> clase puede quedar expuesto y provocar un comportamiento no deseado en los clientes COM.</span><span class="sxs-lookup"><span data-stu-id="d56a0-170">While the <xref:System.Collections.CollectionBase.GetEnumerator%2A> method is not visible to COM clients by default, inheriting the <xref:System.Collections.CollectionBase> class can expose it and can cause undesirable behavior in COM clients.</span></span>  
  
 <span data-ttu-id="d56a0-171">Este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-171">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d56a0-172">El siguiente ejemplo de código implementa la <xref:System.Collections.CollectionBase> clase y utiliza esa implementación para crear una colección de <xref:System.Int16> objetos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-172">The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.</span></span>  
  
 [!code-cpp[System.Collections.CollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CPP/collectionbase.cpp#1)]
 [!code-csharp[System.Collections.CollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CS/collectionbase.cs#1)]
 [!code-vb[System.Collections.CollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.CollectionBase/VB/collectionbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="InnerList">
      <MemberSignature Language="C#" Value="protected System.Collections.ArrayList InnerList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ArrayList InnerList" />
      <MemberSignature Language="DocId" Value="P:System.Collections.CollectionBase.InnerList" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property InnerList As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::ArrayList ^ InnerList { System::Collections::ArrayList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerList : System.Collections.ArrayList" Usage="System.Collections.CollectionBase.InnerList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d56a0-173">Obtiene una colección <see cref="T:System.Collections.ArrayList" /> que contiene la lista de elementos incluidos en la instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-173">Gets an <see cref="T:System.Collections.ArrayList" /> containing the list of elements in the <see cref="T:System.Collections.CollectionBase" /> instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d56a0-174">
            <see cref="T:System.Collections.ArrayList" /> que representa la propia instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-174">An <see cref="T:System.Collections.ArrayList" /> representing the <see cref="T:System.Collections.CollectionBase" /> instance itself.</span>
          </span>
          <span data-ttu-id="d56a0-175">La recuperación del valor de esta propiedad es una operación O(1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-175">Retrieving the value of this property is an O(1) operation.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-176">Los métodos On \* sólo se invocan en la instancia devuelta por la <xref:System.Collections.CollectionBase.List%2A> propiedad, pero no en la instancia devuelta por la <xref:System.Collections.CollectionBase.InnerList%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d56a0-176">The On\* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="List">
      <MemberSignature Language="C#" Value="protected System.Collections.IList List { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList List" />
      <MemberSignature Language="DocId" Value="P:System.Collections.CollectionBase.List" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property List As IList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IList ^ List { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.List : System.Collections.IList" Usage="System.Collections.CollectionBase.List" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d56a0-177">Obtiene una colección <see cref="T:System.Collections.IList" /> que contiene la lista de elementos incluidos en la instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-177">Gets an <see cref="T:System.Collections.IList" /> containing the list of elements in the <see cref="T:System.Collections.CollectionBase" /> instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d56a0-178">
            <see cref="T:System.Collections.IList" /> que representa la propia instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-178">An <see cref="T:System.Collections.IList" /> representing the <see cref="T:System.Collections.CollectionBase" /> instance itself.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-179">Los métodos On \* sólo se invocan en la instancia devuelta por la <xref:System.Collections.CollectionBase.List%2A> propiedad, pero no en la instancia devuelta por la <xref:System.Collections.CollectionBase.InnerList%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d56a0-179">The On\* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.</span></span>  
  
 <span data-ttu-id="d56a0-180">La recuperación del valor de esta propiedad es una operación O(1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-180">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d56a0-181">El siguiente ejemplo de código implementa la <xref:System.Collections.CollectionBase> clase y utiliza esa implementación para crear una colección de <xref:System.Int16> objetos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-181">The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.</span></span>  
  
 [!code-cpp[System.Collections.CollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CPP/collectionbase.cpp#1)]
 [!code-csharp[System.Collections.CollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CS/collectionbase.cs#1)]
 [!code-vb[System.Collections.CollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.CollectionBase/VB/collectionbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClear">
      <MemberSignature Language="C#" Value="protected virtual void OnClear ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.OnClear" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClear ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClear();" />
      <MemberSignature Language="F#" Value="abstract member OnClear : unit -&gt; unit&#xA;override this.OnClear : unit -&gt; unit" Usage="collectionBase.OnClear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d56a0-182">Realiza procesos de personalización adicionales al borrar el contenido de la instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-182">Performs additional custom processes when clearing the contents of the <see cref="T:System.Collections.CollectionBase" /> instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-183">La implementación predeterminada de este método está pensada para ser reemplazado por una clase derivada para realizar alguna acción antes de que se borra la colección.</span><span class="sxs-lookup"><span data-stu-id="d56a0-183">The default implementation of this method is intended to be overridden by a derived class to perform some action before the collection is cleared.</span></span>  
  
 <span data-ttu-id="d56a0-184">Los métodos On \* sólo se invocan en la instancia devuelta por la <xref:System.Collections.CollectionBase.List%2A> propiedad, pero no en la instancia devuelta por la <xref:System.Collections.CollectionBase.InnerList%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d56a0-184">The On\* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.</span></span>  
  
 <span data-ttu-id="d56a0-185">Si se produce un error en el proceso, la colección se vuelve a su estado anterior.</span><span class="sxs-lookup"><span data-stu-id="d56a0-185">If the process fails, the collection reverts back to its previous state.</span></span>  
  
 <span data-ttu-id="d56a0-186">La implementación predeterminada de este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-186">The default implementation of this method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="d56a0-187">
            <para>Este método permite a los implementadores definir procesos que deben realizarse antes de eliminar todos los elementos de subyacente <see cref="T:System.Collections.ArrayList" />. Al definir este método, los implementadores pueden agregar funcionalidad a los métodos heredados, sin tener que reemplazar todos los demás métodos.  <see cref="M:System.Collections.CollectionBase.OnClear" /> se invoca antes del comportamiento Clear estándar, mientras que <see cref="M:System.Collections.CollectionBase.OnClearComplete" /> se invoca después del comportamiento estándar de Clear.  Por ejemplo, los implementadores pueden excluir determinados elementos de la eliminación de un método Clear global.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-187">
              <para>This method allows implementers to define processes that must be performed before deleting all the elements from the underlying <see cref="T:System.Collections.ArrayList" />. By defining this method, implementers can add functionality to inherited methods without having to override all other methods.  <see cref="M:System.Collections.CollectionBase.OnClear" /> is invoked before the standard Clear behavior, whereas <see cref="M:System.Collections.CollectionBase.OnClearComplete" /> is invoked after the standard Clear behavior.  For example, implementers can exempt certain elements from deletion by a global Clear.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Collections.CollectionBase.OnClearComplete" />
        <altmember cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnClearComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnClearComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClearComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.OnClearComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClearComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClearComplete();" />
      <MemberSignature Language="F#" Value="abstract member OnClearComplete : unit -&gt; unit&#xA;override this.OnClearComplete : unit -&gt; unit" Usage="collectionBase.OnClearComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d56a0-188">Realiza procesos personalizados adicionales después de borrar el contenido de la instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-188">Performs additional custom processes after clearing the contents of the <see cref="T:System.Collections.CollectionBase" /> instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-189">La implementación predeterminada de este método está pensada para ser reemplazado por una clase derivada para realizar alguna acción después de que se borra la colección.</span><span class="sxs-lookup"><span data-stu-id="d56a0-189">The default implementation of this method is intended to be overridden by a derived class to perform some action after the collection is cleared.</span></span>  
  
 <span data-ttu-id="d56a0-190">Los métodos On \* sólo se invocan en la instancia devuelta por la <xref:System.Collections.CollectionBase.List%2A> propiedad, pero no en la instancia devuelta por la <xref:System.Collections.CollectionBase.InnerList%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d56a0-190">The On\* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.</span></span>  
  
 <span data-ttu-id="d56a0-191">La implementación predeterminada de este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-191">The default implementation of this method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="d56a0-192">
            <para>Este método permite a los implementadores definir procesos que deben realizarse después de eliminar todos los elementos del subyacente <see cref="T:System.Collections.ArrayList" />. Al definir este método, los implementadores pueden agregar funcionalidad a los métodos heredados, sin tener que reemplazar todos los demás métodos.  <see cref="M:System.Collections.CollectionBase.OnClear" /> se invoca antes del comportamiento Clear estándar, mientras que <see cref="M:System.Collections.CollectionBase.OnClearComplete" /> se invoca después del comportamiento estándar de Clear.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-192">
              <para>This method allows implementers to define processes that must be performed after deleting all the elements from the underlying <see cref="T:System.Collections.ArrayList" />. By defining this method, implementers can add functionality to inherited methods without having to override all other methods.  <see cref="M:System.Collections.CollectionBase.OnClear" /> is invoked before the standard Clear behavior, whereas <see cref="M:System.Collections.CollectionBase.OnClearComplete" /> is invoked after the standard Clear behavior.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Collections.CollectionBase.OnClear" />
        <altmember cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnInsert">
      <MemberSignature Language="C#" Value="protected virtual void OnInsert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInsert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInsert (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInsert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnInsert : int * obj -&gt; unit&#xA;override this.OnInsert : int * obj -&gt; unit" Usage="collectionBase.OnInsert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">
          <span data-ttu-id="d56a0-193">Índice de base cero donde se va a insertar <c>value</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-193">The zero-based index at which to insert <c>value</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="d56a0-194">Nuevo valor del elemento situado en <c>index</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-194">The new value of the element at <c>index</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d56a0-195">Realiza procesos personalizados adicionales antes de insertar un nuevo elemento en la instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-195">Performs additional custom processes before inserting a new element into the <see cref="T:System.Collections.CollectionBase" /> instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-196">La implementación predeterminada de este método está pensada para ser reemplazado por una clase derivada para realizar alguna acción antes de que se inserta el elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="d56a0-196">The default implementation of this method is intended to be overridden by a derived class to perform some action before the specified element is inserted.</span></span>  
  
 <span data-ttu-id="d56a0-197">Los métodos On \* sólo se invocan en la instancia devuelta por la <xref:System.Collections.CollectionBase.List%2A> propiedad, pero no en la instancia devuelta por la <xref:System.Collections.CollectionBase.InnerList%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d56a0-197">The On\* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.</span></span>  
  
 <span data-ttu-id="d56a0-198">Si se produce un error en el proceso, la colección se vuelve a su estado anterior.</span><span class="sxs-lookup"><span data-stu-id="d56a0-198">If the process fails, the collection reverts back to its previous state.</span></span>  
  
 <span data-ttu-id="d56a0-199">La implementación predeterminada de este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-199">The default implementation of this method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d56a0-200">El siguiente ejemplo de código implementa la <xref:System.Collections.CollectionBase> clase y utiliza esa implementación para crear una colección de <xref:System.Int16> objetos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-200">The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.</span></span>  
  
 [!code-cpp[System.Collections.CollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CPP/collectionbase.cpp#1)]
 [!code-csharp[System.Collections.CollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CS/collectionbase.cs#1)]
 [!code-vb[System.Collections.CollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.CollectionBase/VB/collectionbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="d56a0-201">
            <para>Este método permite a los implementadores definir procesos que deben realizarse antes de insertar el elemento subyacente <see cref="T:System.Collections.ArrayList" />. Al definir este método, los implementadores pueden agregar funcionalidad a los métodos heredados, sin tener que reemplazar todos los demás métodos.  <see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" /> se invoca antes del comportamiento de inserción estándar, mientras que <see cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" /> se invoca después del comportamiento de inserción estándar.  Por ejemplo, los implementadores pueden restringir los tipos de objetos se pueden insertar en el <see cref="T:System.Collections.ArrayList" />.  <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /> se llama antes de este método.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-201">
              <para>This method allows implementers to define processes that must be performed before inserting the element into the underlying <see cref="T:System.Collections.ArrayList" />. By defining this method, implementers can add functionality to inherited methods without having to override all other methods.  <see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" /> is invoked before the standard Insert behavior, whereas <see cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" /> is invoked after the standard Insert behavior.  For example, implementers can restrict which types of objects can be inserted into the <see cref="T:System.Collections.ArrayList" />.  <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /> is called prior to this method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" />
        <altmember cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" />
        <altmember cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnInsertComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnInsertComplete (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInsertComplete(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInsertComplete (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInsertComplete(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnInsertComplete : int * obj -&gt; unit&#xA;override this.OnInsertComplete : int * obj -&gt; unit" Usage="collectionBase.OnInsertComplete (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">
          <span data-ttu-id="d56a0-202">Índice de base cero donde se va a insertar <c>value</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-202">The zero-based index at which to insert <c>value</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="d56a0-203">Nuevo valor del elemento situado en <c>index</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-203">The new value of the element at <c>index</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d56a0-204">Realiza procesos personalizados adicionales después de insertar un nuevo elemento en la instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-204">Performs additional custom processes after inserting a new element into the <see cref="T:System.Collections.CollectionBase" /> instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-205">La implementación predeterminada de este método está pensada para ser reemplazado por una clase derivada para realizar alguna acción después de inserta el elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="d56a0-205">The default implementation of this method is intended to be overridden by a derived class to perform some action after the specified element is inserted.</span></span>  
  
 <span data-ttu-id="d56a0-206">Los métodos On \* sólo se invocan en la instancia devuelta por la <xref:System.Collections.CollectionBase.List%2A> propiedad, pero no en la instancia devuelta por la <xref:System.Collections.CollectionBase.InnerList%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d56a0-206">The On\* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.</span></span>  
  
 <span data-ttu-id="d56a0-207">La colección se vuelve a su estado anterior si se produce uno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="d56a0-207">The collection reverts back to its previous state if one of the following occurs:</span></span>  
  
-   <span data-ttu-id="d56a0-208">Se produce un error en el proceso.</span><span class="sxs-lookup"><span data-stu-id="d56a0-208">The process fails.</span></span>  
  
-   <span data-ttu-id="d56a0-209">Este método se invalida para producir una excepción.</span><span class="sxs-lookup"><span data-stu-id="d56a0-209">This method is overridden to throw an exception.</span></span>  
  
 <span data-ttu-id="d56a0-210">La implementación predeterminada de este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-210">The default implementation of this method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="d56a0-211">
            <para>Este método permite a los implementadores definir procesos que deben realizarse después de insertar el elemento subyacente <see cref="T:System.Collections.ArrayList" />. Al definir este método, los implementadores pueden agregar funcionalidad a los métodos heredados, sin tener que reemplazar todos los demás métodos.  <see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" /> se invoca antes del comportamiento de inserción estándar, mientras que <see cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" /> se invoca después del comportamiento de inserción estándar.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-211">
              <para>This method allows implementers to define processes that must be performed after inserting the element into the underlying <see cref="T:System.Collections.ArrayList" />. By defining this method, implementers can add functionality to inherited methods without having to override all other methods.  <see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" /> is invoked before the standard Insert behavior, whereas <see cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" /> is invoked after the standard Insert behavior.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" />
        <altmember cref="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnRemove">
      <MemberSignature Language="C#" Value="protected virtual void OnRemove (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemove(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemove (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemove(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnRemove : int * obj -&gt; unit&#xA;override this.OnRemove : int * obj -&gt; unit" Usage="collectionBase.OnRemove (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">
          <span data-ttu-id="d56a0-212">Índice de base cero en el que se puede encontrar <c>value</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-212">The zero-based index at which <c>value</c> can be found.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="d56a0-213">Valor del elemento que se va a quitar de <c>index</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-213">The value of the element to remove from <c>index</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d56a0-214">Realiza procesos de personalización adicionales al quitar un elemento de la instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-214">Performs additional custom processes when removing an element from the <see cref="T:System.Collections.CollectionBase" /> instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-215">La implementación predeterminada de este método está pensada para ser reemplazado por una clase derivada para realizar alguna acción antes de que se quita el elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="d56a0-215">The default implementation of this method is intended to be overridden by a derived class to perform some action before the specified element is removed.</span></span>  
  
 <span data-ttu-id="d56a0-216">Los métodos On \* sólo se invocan en la instancia devuelta por la <xref:System.Collections.CollectionBase.List%2A> propiedad, pero no en la instancia devuelta por la <xref:System.Collections.CollectionBase.InnerList%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d56a0-216">The On\* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.</span></span>  
  
 <span data-ttu-id="d56a0-217">Si se produce un error en el proceso, la colección se vuelve a su estado anterior.</span><span class="sxs-lookup"><span data-stu-id="d56a0-217">If the process fails, the collection reverts back to its previous state.</span></span>  
  
 <span data-ttu-id="d56a0-218">La implementación predeterminada de este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-218">The default implementation of this method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d56a0-219">El siguiente ejemplo de código implementa la <xref:System.Collections.CollectionBase> clase y utiliza esa implementación para crear una colección de <xref:System.Int16> objetos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-219">The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.</span></span>  
  
 [!code-cpp[System.Collections.CollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CPP/collectionbase.cpp#1)]
 [!code-csharp[System.Collections.CollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CS/collectionbase.cs#1)]
 [!code-vb[System.Collections.CollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.CollectionBase/VB/collectionbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="d56a0-220">
            <para>Este método permite a los implementadores definir procesos que deben realizarse antes de quitar el elemento subyacente <see cref="T:System.Collections.ArrayList" />. Al definir este método, los implementadores pueden agregar funcionalidad a los métodos heredados, sin tener que reemplazar todos los demás métodos.  <see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" /> se invoca antes del comportamiento estándar de Remove, mientras que <see cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" /> se invoca después del comportamiento Remove estándar.  Por ejemplo, los implementadores pueden impedir la eliminación de elementos siempre iniciando una excepción <see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" />.  <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /> se llama antes de este método.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-220">
              <para>This method allows implementers to define processes that must be performed before removing the element from the underlying <see cref="T:System.Collections.ArrayList" />. By defining this method, implementers can add functionality to inherited methods without having to override all other methods.  <see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" /> is invoked before the standard Remove behavior, whereas <see cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" /> is invoked after the standard Remove behavior.  For example, implementers can prevent removal of elements by always throwing an exception in <see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" />.  <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /> is called prior to this method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" />
        <altmember cref="M:System.Collections.CollectionBase.OnClear" />
      </Docs>
    </Member>
    <Member MemberName="OnRemoveComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveComplete (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveComplete(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveComplete (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveComplete(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveComplete : int * obj -&gt; unit&#xA;override this.OnRemoveComplete : int * obj -&gt; unit" Usage="collectionBase.OnRemoveComplete (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">
          <span data-ttu-id="d56a0-221">Índice de base cero en el que se puede encontrar <c>value</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-221">The zero-based index at which <c>value</c> can be found.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="d56a0-222">Valor del elemento que se va a quitar de <c>index</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-222">The value of the element to remove from <c>index</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d56a0-223">Realiza procesos personalizados adicionales después de quitar un elemento de la instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-223">Performs additional custom processes after removing an element from the <see cref="T:System.Collections.CollectionBase" /> instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-224">La implementación predeterminada de este método está pensada para ser reemplazado por una clase derivada para realizar alguna acción cuando se haya quitado el elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="d56a0-224">The default implementation of this method is intended to be overridden by a derived class to perform some action after the specified element is removed.</span></span>  
  
 <span data-ttu-id="d56a0-225">Los métodos On \* sólo se invocan en la instancia devuelta por la <xref:System.Collections.CollectionBase.List%2A> propiedad, pero no en la instancia devuelta por la <xref:System.Collections.CollectionBase.InnerList%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d56a0-225">The On\* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.</span></span>  
  
 <span data-ttu-id="d56a0-226">La colección se vuelve a su estado anterior si se produce uno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="d56a0-226">The collection reverts back to its previous state if one of the following occurs:</span></span>  
  
-   <span data-ttu-id="d56a0-227">Se produce un error en el proceso.</span><span class="sxs-lookup"><span data-stu-id="d56a0-227">The process fails.</span></span>  
  
-   <span data-ttu-id="d56a0-228">Este método se invalida para producir una excepción.</span><span class="sxs-lookup"><span data-stu-id="d56a0-228">This method is overridden to throw an exception.</span></span>  
  
 <span data-ttu-id="d56a0-229">La implementación predeterminada de este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-229">The default implementation of this method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="d56a0-230">
            <para>Este método permite a los implementadores definir procesos que deben realizarse después de quitar el elemento subyacente <see cref="T:System.Collections.ArrayList" />. Al definir este método, los implementadores pueden agregar funcionalidad a los métodos heredados, sin tener que reemplazar todos los demás métodos.  <see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" /> se invoca antes del comportamiento estándar de Remove, mientras que <see cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" /> se invoca después del comportamiento Remove estándar.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-230">
              <para>This method allows implementers to define processes that must be performed after removing the element from the underlying <see cref="T:System.Collections.ArrayList" />. By defining this method, implementers can add functionality to inherited methods without having to override all other methods.  <see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" /> is invoked before the standard Remove behavior, whereas <see cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" /> is invoked after the standard Remove behavior.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" />
        <altmember cref="M:System.Collections.CollectionBase.OnClearComplete" />
      </Docs>
    </Member>
    <Member MemberName="OnSet">
      <MemberSignature Language="C#" Value="protected virtual void OnSet (int index, object oldValue, object newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSet(int32 index, object oldValue, object newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSet (index As Integer, oldValue As Object, newValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSet(int index, System::Object ^ oldValue, System::Object ^ newValue);" />
      <MemberSignature Language="F#" Value="abstract member OnSet : int * obj * obj -&gt; unit&#xA;override this.OnSet : int * obj * obj -&gt; unit" Usage="collectionBase.OnSet (index, oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="oldValue" Type="System.Object" />
        <Parameter Name="newValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">
          <span data-ttu-id="d56a0-231">Índice de base cero en el que se puede encontrar <c>oldValue</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-231">The zero-based index at which <c>oldValue</c> can be found.</span>
          </span>
        </param>
        <param name="oldValue">
          <span data-ttu-id="d56a0-232">Valor que se va a reemplazar por <c>newValue</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-232">The value to replace with <c>newValue</c>.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="d56a0-233">Nuevo valor del elemento situado en <c>index</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-233">The new value of the element at <c>index</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d56a0-234">Realiza procesos personalizados adicionales antes de establecer un valor en la instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-234">Performs additional custom processes before setting a value in the <see cref="T:System.Collections.CollectionBase" /> instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-235">La implementación predeterminada de este método está pensada para ser reemplazado por una clase derivada para realizar alguna acción antes de establece el elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="d56a0-235">The default implementation of this method is intended to be overridden by a derived class to perform some action before the specified element is set.</span></span>  
  
 <span data-ttu-id="d56a0-236">Los métodos On \* sólo se invocan en la instancia devuelta por la <xref:System.Collections.CollectionBase.List%2A> propiedad, pero no en la instancia devuelta por la <xref:System.Collections.CollectionBase.InnerList%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d56a0-236">The On\* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.</span></span>  
  
 <span data-ttu-id="d56a0-237">Si se produce un error en el proceso, la colección se vuelve a su estado anterior.</span><span class="sxs-lookup"><span data-stu-id="d56a0-237">If the process fails, the collection reverts back to its previous state.</span></span>  
  
 <span data-ttu-id="d56a0-238">La implementación predeterminada de este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-238">The default implementation of this method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d56a0-239">El siguiente ejemplo de código implementa la <xref:System.Collections.CollectionBase> clase y utiliza esa implementación para crear una colección de <xref:System.Int16> objetos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-239">The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.</span></span>  
  
 [!code-cpp[System.Collections.CollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CPP/collectionbase.cpp#1)]
 [!code-csharp[System.Collections.CollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CS/collectionbase.cs#1)]
 [!code-vb[System.Collections.CollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.CollectionBase/VB/collectionbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="d56a0-240">
            <para>Este método permite a los implementadores definir procesos que deben realizarse antes de establecer el elemento especificado en subyacente <see cref="T:System.Collections.ArrayList" />. Al definir este método, los implementadores pueden agregar funcionalidad a los métodos heredados, sin tener que reemplazar todos los demás métodos.  <see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" /> se invoca antes del comportamiento estándar de Set, mientras que <see cref="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)" /> se invoca después del comportamiento estándar del conjunto.  Por ejemplo, los implementadores pueden restringir los valores que pueden sobrescribirse mediante la realización de una comprobación dentro de <see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" />.  <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /> se llama antes de este método.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-240">
              <para>This method allows implementers to define processes that must be performed before setting the specified element in the underlying <see cref="T:System.Collections.ArrayList" />. By defining this method, implementers can add functionality to inherited methods without having to override all other methods.  <see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" /> is invoked before the standard Set behavior, whereas <see cref="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)" /> is invoked after the standard Set behavior.  For example, implementers can restrict which values can be overwritten by performing a check inside <see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" />.  <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /> is called prior to this method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)" />
        <altmember cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" />
        <altmember cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnSetComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnSetComplete (int index, object oldValue, object newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetComplete(int32 index, object oldValue, object newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetComplete (index As Integer, oldValue As Object, newValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetComplete(int index, System::Object ^ oldValue, System::Object ^ newValue);" />
      <MemberSignature Language="F#" Value="abstract member OnSetComplete : int * obj * obj -&gt; unit&#xA;override this.OnSetComplete : int * obj * obj -&gt; unit" Usage="collectionBase.OnSetComplete (index, oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="oldValue" Type="System.Object" />
        <Parameter Name="newValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">
          <span data-ttu-id="d56a0-241">Índice de base cero en el que se puede encontrar <c>oldValue</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-241">The zero-based index at which <c>oldValue</c> can be found.</span>
          </span>
        </param>
        <param name="oldValue">
          <span data-ttu-id="d56a0-242">Valor que se va a reemplazar por <c>newValue</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-242">The value to replace with <c>newValue</c>.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="d56a0-243">Nuevo valor del elemento situado en <c>index</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-243">The new value of the element at <c>index</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d56a0-244">Realiza procesos personalizados adicionales después de establecer un valor en la instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-244">Performs additional custom processes after setting a value in the <see cref="T:System.Collections.CollectionBase" /> instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-245">La implementación predeterminada de este método está pensada para ser reemplazado por una clase derivada para realizar alguna acción después de establece el elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="d56a0-245">The default implementation of this method is intended to be overridden by a derived class to perform some action after the specified element is set.</span></span>  
  
 <span data-ttu-id="d56a0-246">Los métodos On \* sólo se invocan en la instancia devuelta por la <xref:System.Collections.CollectionBase.List%2A> propiedad, pero no en la instancia devuelta por la <xref:System.Collections.CollectionBase.InnerList%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d56a0-246">The On\* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.</span></span>  
  
 <span data-ttu-id="d56a0-247">La colección se vuelve a su estado anterior si se produce uno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="d56a0-247">The collection reverts back to its previous state if one of the following occurs:</span></span>  
  
-   <span data-ttu-id="d56a0-248">Se produce un error en el proceso.</span><span class="sxs-lookup"><span data-stu-id="d56a0-248">The process fails.</span></span>  
  
-   <span data-ttu-id="d56a0-249">Este método se invalida para producir una excepción.</span><span class="sxs-lookup"><span data-stu-id="d56a0-249">This method is overridden to throw an exception.</span></span>  
  
 <span data-ttu-id="d56a0-250">La implementación predeterminada de este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-250">The default implementation of this method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="d56a0-251">
            <para>Este método permite a los implementadores definir procesos que deben realizarse después de establecer el elemento especificado en subyacente <see cref="T:System.Collections.ArrayList" />. Al definir este método, los implementadores pueden agregar funcionalidad a los métodos heredados, sin tener que reemplazar todos los demás métodos.  <see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" /> se invoca antes del comportamiento estándar de Set, mientras que <see cref="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)" /> se invoca después del comportamiento estándar del conjunto.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-251">
              <para>This method allows implementers to define processes that must be performed after setting the specified element in the underlying <see cref="T:System.Collections.ArrayList" />. By defining this method, implementers can add functionality to inherited methods without having to override all other methods.  <see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" /> is invoked before the standard Set behavior, whereas <see cref="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)" /> is invoked after the standard Set behavior.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" />
        <altmember cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnValidate">
      <MemberSignature Language="C#" Value="protected virtual void OnValidate (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidate(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.OnValidate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidate (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidate(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnValidate : obj -&gt; unit&#xA;override this.OnValidate : obj -&gt; unit" Usage="collectionBase.OnValidate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="d56a0-252">Objeto que se va a validar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-252">The object to validate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d56a0-253">Realiza procesos de personalización adicionales al validar un valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-253">Performs additional custom processes when validating a value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-254">La implementación predeterminada de este método determina si `value` es `null`y, si es así, genera <xref:System.ArgumentNullException>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-254">The default implementation of this method determines whether `value` is `null`, and, if so, throws <xref:System.ArgumentNullException>.</span></span> <span data-ttu-id="d56a0-255">Se pretende ser reemplazado por una clase derivada para realizar acciones adicionales cuando se valida el elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="d56a0-255">It is intended to be overridden by a derived class to perform additional action when the specified element is validated.</span></span>  
  
 <span data-ttu-id="d56a0-256">Los métodos On \* sólo se invocan en la instancia devuelta por la <xref:System.Collections.CollectionBase.List%2A> propiedad, pero no en la instancia devuelta por la <xref:System.Collections.CollectionBase.InnerList%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d56a0-256">The On\* methods are invoked only on the instance returned by the <xref:System.Collections.CollectionBase.List%2A> property, but not on the instance returned by the <xref:System.Collections.CollectionBase.InnerList%2A> property.</span></span>  
  
 <span data-ttu-id="d56a0-257">La implementación predeterminada de este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-257">The default implementation of this method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d56a0-258">El siguiente ejemplo de código implementa la <xref:System.Collections.CollectionBase> clase y utiliza esa implementación para crear una colección de <xref:System.Int16> objetos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-258">The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.</span></span>  
  
 [!code-cpp[System.Collections.CollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CPP/collectionbase.cpp#1)]
 [!code-csharp[System.Collections.CollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CS/collectionbase.cs#1)]
 [!code-vb[System.Collections.CollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.CollectionBase/VB/collectionbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d56a0-259">
            <paramref name="value" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-259">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="d56a0-260">
            <para>Este método permite a los implementadores definir procesos que deben realizarse cuando se ejecuta el comportamiento estándar de subyacente <see cref="T:System.Collections.ArrayList" />. Al definir este método, los implementadores pueden agregar funcionalidad a los métodos heredados, sin tener que reemplazar todos los demás métodos.  <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /> sirve para imponer restricciones sobre el tipo de objetos que se aceptan en la colección. Impide que la implementación predeterminada <see langword="null" /> se agregue o se quitarán subyacente <see cref="T:System.Collections.ArrayList" />.  <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /> se denomina anteriores a <see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" />, <see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" />, y <see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-260">
              <para>This method allows implementers to define processes that must be performed when executing the standard behavior of the underlying <see cref="T:System.Collections.ArrayList" />. By defining this method, implementers can add functionality to inherited methods without having to override all other methods.  <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /> can be used to impose restrictions on the type of objects that are accepted into the collection. The default implementation prevents <see langword="null" /> from being added to or removed from the underlying <see cref="T:System.Collections.ArrayList" />.  <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /> is called prior to <see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" />, <see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" />, and <see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" />
        <altmember cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="collectionBase.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">
          <span data-ttu-id="d56a0-261">Índice de base cero del elemento que se va a quitar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-261">The zero-based index of the element to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d56a0-262">Quita el elemento que se encuentra en el índice especificado de la instancia de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-262">Removes the element at the specified index of the <see cref="T:System.Collections.CollectionBase" /> instance.</span>
          </span>
          <span data-ttu-id="d56a0-263">Este método no se puede reemplazar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-263">This method is not overridable.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-264">En colecciones de elementos contiguos, como listas, los elementos que van a continuación del elemento eliminado se desplazan hacia arriba para ocupar el espacio libre.</span><span class="sxs-lookup"><span data-stu-id="d56a0-264">In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot.</span></span> <span data-ttu-id="d56a0-265">Si la colección está indizada, también se actualizan los índices de los elementos que se han movido.</span><span class="sxs-lookup"><span data-stu-id="d56a0-265">If the collection is indexed, the indexes of the elements that are moved are also updated.</span></span> <span data-ttu-id="d56a0-266">Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.</span><span class="sxs-lookup"><span data-stu-id="d56a0-266">This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</span></span>  
  
 <span data-ttu-id="d56a0-267">Este método es O (`n`) operación, donde `n` es <xref:System.Collections.CollectionBase.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-267">This method is an O(`n`) operation, where `n` is <xref:System.Collections.CollectionBase.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d56a0-268">
            <paramref name="index" /> es menor que cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-268">
              <paramref name="index" /> is less than zero.</span>
          </span>
          <span data-ttu-id="d56a0-269">- o bien- <paramref name="index" /> es igual o mayor que <see cref="P:System.Collections.CollectionBase.Count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-269">-or-  <paramref name="index" /> is equal to or greater than <see cref="P:System.Collections.CollectionBase.Count" />.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="d56a0-270">
            <para>Este método llama a <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" />, <see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" />, y <see cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-270">
              <para>This method calls <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" />, <see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" />, and <see cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" />.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="d56a0-271">
            <see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-271">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.CollectionBase" />.</span>
          </span>
          <span data-ttu-id="d56a0-272">La matriz <see cref="T:System.Array" /> debe tener una indización de base cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-272">The <see cref="T:System.Array" /> must have zero-based indexing.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="d56a0-273">Índice de base cero de <c>array</c> donde comienza la copia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-273">The zero-based index in <c>array</c> at which copying begins.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d56a0-274">Copia la totalidad de <see cref="T:System.Collections.CollectionBase" /> en una matriz <see cref="T:System.Array" /> unidimensional compatible, comenzando en el índice especificado de la matriz de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-274">Copies the entire <see cref="T:System.Collections.CollectionBase" /> to a compatible one-dimensional <see cref="T:System.Array" />, starting at the specified index of the target array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-275">La matriz especificada debe ser de un tipo compatible.</span><span class="sxs-lookup"><span data-stu-id="d56a0-275">The specified array must be of a compatible type.</span></span>  
  
 <span data-ttu-id="d56a0-276">Este método usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> para copiar los elementos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-276">This method uses <xref:System.Array.Copy%2A?displayProperty=nameWithType> to copy the elements.</span></span>  
  
 <span data-ttu-id="d56a0-277">Este método es O (`n`) operación, donde `n` es <xref:System.Collections.CollectionBase.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-277">This method is an O(`n`) operation, where `n` is <xref:System.Collections.CollectionBase.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d56a0-278">
            <paramref name="array" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-278">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d56a0-279">
            <paramref name="index" /> es menor que cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-279">
              <paramref name="index" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d56a0-280">
            <paramref name="array" /> es multidimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-280">
              <paramref name="array" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="d56a0-281">-o bien- El número de elementos de la colección <see cref="T:System.Collections.CollectionBase" /> de origen es mayor que el espacio disponible desde <paramref name="index" /> hasta el final del parámetro <paramref name="array" /> de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-281">-or-  The number of elements in the source <see cref="T:System.Collections.CollectionBase" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="d56a0-282">El tipo de la <see cref="T:System.Collections.CollectionBase" /> de origen no puede convertirse automáticamente al tipo de la <paramref name="array" /> de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-282">The type of the source <see cref="T:System.Collections.CollectionBase" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.CollectionBase.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.CollectionBase.System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d56a0-283">Obtiene un valor que indica si el acceso a la interfaz <see cref="T:System.Collections.CollectionBase" /> está sincronizado (es seguro para subprocesos).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-283">Gets a value indicating whether access to the <see cref="T:System.Collections.CollectionBase" /> is synchronized (thread safe).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d56a0-284">Es <see langword="true" /> si el acceso a <see cref="T:System.Collections.CollectionBase" /> está sincronizado (es seguro para subprocesos); de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-284">
              <see langword="true" /> if access to the <see cref="T:System.Collections.CollectionBase" /> is synchronized (thread safe); otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d56a0-285">El valor predeterminado es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-285">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-286">Un <xref:System.Collections.CollectionBase> instancia no está sincronizada.</span><span class="sxs-lookup"><span data-stu-id="d56a0-286">A <xref:System.Collections.CollectionBase> instance is not synchronized.</span></span> <span data-ttu-id="d56a0-287">Las clases derivadas pueden proporcionar una versión sincronizada de la <xref:System.Collections.CollectionBase> utilizando el <xref:System.Collections.ICollection.SyncRoot%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d56a0-287">Derived classes can provide a synchronized version of the <xref:System.Collections.CollectionBase> using the <xref:System.Collections.ICollection.SyncRoot%2A> property.</span></span>  
  
 <span data-ttu-id="d56a0-288">Enumerar una colección no es un procedimiento seguro para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-288">Enumerating through a collection is intrinsically not a thread safe procedure.</span></span> <span data-ttu-id="d56a0-289">Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción.</span><span class="sxs-lookup"><span data-stu-id="d56a0-289">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="d56a0-290">Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-290">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="d56a0-291">El ejemplo de código siguiente muestra cómo bloquear la colección utilizando el <xref:System.Collections.ICollection.SyncRoot%2A> durante toda la enumeración:</span><span class="sxs-lookup"><span data-stu-id="d56a0-291">The following code example shows how to lock the collection using the <xref:System.Collections.ICollection.SyncRoot%2A> during the entire enumeration:</span></span>  
  
 [!code-cpp[System.Collections.CollectionBase#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CPP/remarks.cpp#2)]
 [!code-csharp[System.Collections.CollectionBase#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CS/remarks.cs#2)]
 [!code-vb[System.Collections.CollectionBase#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.CollectionBase/VB/remarks.vb#2)]  
  
 <span data-ttu-id="d56a0-292">La recuperación del valor de esta propiedad es una operación O(1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-292">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.CollectionBase.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.CollectionBase.System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d56a0-293">Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-293">Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.CollectionBase" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d56a0-294">Objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-294">An object that can be used to synchronize access to the <see cref="T:System.Collections.CollectionBase" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-295">Las clases derivadas pueden proporcionar su propia versión sincronizada de la <xref:System.Collections.CollectionBase> utilizando el <xref:System.Collections.ICollection.SyncRoot%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d56a0-295">Derived classes can provide their own synchronized version of the <xref:System.Collections.CollectionBase> using the <xref:System.Collections.ICollection.SyncRoot%2A> property.</span></span> <span data-ttu-id="d56a0-296">El código de sincronización debe realizar operaciones en el <xref:System.Collections.ICollection.SyncRoot%2A> de la <xref:System.Collections.CollectionBase>, no directamente en el <xref:System.Collections.CollectionBase>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-296">The synchronizing code must perform operations on the <xref:System.Collections.ICollection.SyncRoot%2A> of the <xref:System.Collections.CollectionBase>, not directly on the <xref:System.Collections.CollectionBase>.</span></span> <span data-ttu-id="d56a0-297">De este modo, se garantiza el funcionamiento correcto de las colecciones derivadas de otros objetos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-297">This ensures proper operation of collections that are derived from other objects.</span></span> <span data-ttu-id="d56a0-298">En concreto, mantiene la sincronización correcta con otros subprocesos que podrían modificar simultáneamente la <xref:System.Collections.CollectionBase> objeto.</span><span class="sxs-lookup"><span data-stu-id="d56a0-298">Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <xref:System.Collections.CollectionBase> object.</span></span>  
  
 <span data-ttu-id="d56a0-299">Enumerar una colección no es un procedimiento seguro para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-299">Enumerating through a collection is intrinsically not a thread safe procedure.</span></span> <span data-ttu-id="d56a0-300">Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción.</span><span class="sxs-lookup"><span data-stu-id="d56a0-300">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="d56a0-301">Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-301">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="d56a0-302">El ejemplo de código siguiente muestra cómo bloquear la colección utilizando el <xref:System.Collections.ICollection.SyncRoot%2A> durante toda la enumeración:</span><span class="sxs-lookup"><span data-stu-id="d56a0-302">The following code example shows how to lock the collection using the <xref:System.Collections.ICollection.SyncRoot%2A> during the entire enumeration:</span></span>  
  
 [!code-cpp[System.Collections.CollectionBase#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CPP/remarks.cpp#2)]
 [!code-csharp[System.Collections.CollectionBase#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CS/remarks.cs#2)]
 [!code-vb[System.Collections.CollectionBase#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.CollectionBase/VB/remarks.vb#2)]  
  
 <span data-ttu-id="d56a0-303">La recuperación del valor de esta propiedad es una operación O(1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-303">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="d56a0-304">Objeto <see cref="T:System.Object" /> que se va a agregar al final de la colección <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-304">The <see cref="T:System.Object" /> to be added to the end of the <see cref="T:System.Collections.CollectionBase" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d56a0-305">Agrega un objeto al final de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-305">Adds an object to the end of the <see cref="T:System.Collections.CollectionBase" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d56a0-306">Índice de <see cref="T:System.Collections.CollectionBase" /> en el que se ha agregado <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-306">The <see cref="T:System.Collections.CollectionBase" /> index at which the <paramref name="value" /> has been added.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-307">Si <xref:System.Collections.CollectionBase.Count%2A> ya es igual a la capacidad, la capacidad de la lista se duplica mediante la reasignación de la matriz interna y copiar los elementos existentes a la nueva matriz antes de que el nuevo elemento se agrega automáticamente.</span><span class="sxs-lookup"><span data-stu-id="d56a0-307">If <xref:System.Collections.CollectionBase.Count%2A> already equals the capacity, the capacity of the list is doubled by automatically reallocating the internal array and copying the existing elements to the new array before the new element is added.</span></span>  
  
 <span data-ttu-id="d56a0-308">Si <xref:System.Collections.CollectionBase.Count%2A> es menor que la capacidad, este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-308">If <xref:System.Collections.CollectionBase.Count%2A> is less than the capacity, this method is an O(1) operation.</span></span> <span data-ttu-id="d56a0-309">Si la capacidad debe aumentarse para alojar el nuevo elemento, este método se convierte en una O (`n`) operación, donde `n` es <xref:System.Collections.CollectionBase.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-309">If the capacity needs to be increased to accommodate the new element, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.CollectionBase.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d56a0-310">El siguiente ejemplo de código implementa la <xref:System.Collections.CollectionBase> clase y utiliza esa implementación para crear una colección de <xref:System.Int16> objetos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-310">The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.</span></span>  
  
 [!code-cpp[System.Collections.CollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CPP/collectionbase.cpp#1)]
 [!code-csharp[System.Collections.CollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CS/collectionbase.cs#1)]
 [!code-vb[System.Collections.CollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.CollectionBase/VB/collectionbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d56a0-311">
            <see cref="T:System.Collections.CollectionBase" /> es de solo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-311">The <see cref="T:System.Collections.CollectionBase" /> is read-only.</span>
          </span>
          <span data-ttu-id="d56a0-312">-o bien- <see cref="T:System.Collections.CollectionBase" /> tiene un tamaño fijo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-312">-or-  The <see cref="T:System.Collections.CollectionBase" /> has a fixed size.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="d56a0-313">
            <para>Este método llama a <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" />, <see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" />, y <see cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-313">
              <para>This method calls <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" />, <see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" />, and <see cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="P:System.Collections.CollectionBase.Count" />
        <altmember cref="M:System.Collections.IList.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Collections.IList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="d56a0-314">Objeto <see cref="T:System.Object" /> que se va a buscar en la interfaz <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-314">The <see cref="T:System.Object" /> to locate in the <see cref="T:System.Collections.CollectionBase" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d56a0-315">Determina si <see cref="T:System.Collections.CollectionBase" /> contiene un elemento específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-315">Determines whether the <see cref="T:System.Collections.CollectionBase" /> contains a specific element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d56a0-316">
            <see langword="true" /> si <see cref="T:System.Collections.CollectionBase" /> contiene el objeto <paramref name="value" /> especificado; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-316">
              <see langword="true" /> if the <see cref="T:System.Collections.CollectionBase" /> contains the specified <paramref name="value" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-317">Este método realiza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es <xref:System.Collections.CollectionBase.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-317">This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.CollectionBase.Count%2A>.</span></span>  
  
 <span data-ttu-id="d56a0-318">Este método determina la igualdad llamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-318">This method determines equality by calling <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d56a0-319">A partir de .NET Framework 2.0, este método utiliza los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si `item` existe.</span><span class="sxs-lookup"><span data-stu-id="d56a0-319">Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods on `item` to determine whether `item` exists.</span></span> <span data-ttu-id="d56a0-320">En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.</span><span class="sxs-lookup"><span data-stu-id="d56a0-320">In the earlier versions of the .NET Framework, this determination was made by using the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the `item` parameter on the objects in the collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d56a0-321">El siguiente ejemplo de código implementa la <xref:System.Collections.CollectionBase> clase y utiliza esa implementación para crear una colección de <xref:System.Int16> objetos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-321">The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.</span></span>  
  
 [!code-cpp[System.Collections.CollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CPP/collectionbase.cpp#1)]
 [!code-csharp[System.Collections.CollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CS/collectionbase.cs#1)]
 [!code-vb[System.Collections.CollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.CollectionBase/VB/collectionbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.IList.IndexOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="d56a0-322">Objeto <see cref="T:System.Object" /> que se va a buscar en la interfaz <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-322">The <see cref="T:System.Object" /> to locate in the <see cref="T:System.Collections.CollectionBase" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d56a0-323">Busca el objeto <see cref="T:System.Object" /> especificado y devuelve el índice de base cero de la primera aparición en toda la colección <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-323">Searches for the specified <see cref="T:System.Object" /> and returns the zero-based index of the first occurrence within the entire <see cref="T:System.Collections.CollectionBase" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d56a0-324">Índice de base cero de la primera aparición de <paramref name="value" /> en la totalidad de <see cref="T:System.Collections.CollectionBase" />, si se encuentra; en caso contrario, -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-324">The zero-based index of the first occurrence of <paramref name="value" /> within the entire <see cref="T:System.Collections.CollectionBase" />, if found; otherwise, -1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-325">Este método realiza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es <xref:System.Collections.CollectionBase.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-325">This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.CollectionBase.Count%2A>.</span></span>  
  
 <span data-ttu-id="d56a0-326">Este método determina la igualdad llamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-326">This method determines equality by calling <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d56a0-327">A partir de .NET Framework 2.0, este método utiliza los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si `item` existe.</span><span class="sxs-lookup"><span data-stu-id="d56a0-327">Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods on `item` to determine whether `item` exists.</span></span> <span data-ttu-id="d56a0-328">En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.</span><span class="sxs-lookup"><span data-stu-id="d56a0-328">In the earlier versions of the .NET Framework, this determination was made by using the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the `item` parameter on the objects in the collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d56a0-329">El siguiente ejemplo de código implementa la <xref:System.Collections.CollectionBase> clase y utiliza esa implementación para crear una colección de <xref:System.Int16> objetos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-329">The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.</span></span>  
  
 [!code-cpp[System.Collections.CollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CPP/collectionbase.cpp#1)]
 [!code-csharp[System.Collections.CollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CS/collectionbase.cs#1)]
 [!code-vb[System.Collections.CollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.CollectionBase/VB/collectionbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.IList.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">
          <span data-ttu-id="d56a0-330">Índice de base cero en el que se debe insertar <c>value</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-330">The zero-based index at which <c>value</c> should be inserted.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="d56a0-331">
            <see cref="T:System.Object" /> que se va a insertar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-331">The <see cref="T:System.Object" /> to insert.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d56a0-332">Inserta un elemento en <see cref="T:System.Collections.CollectionBase" />, en el índice especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-332">Inserts an element into the <see cref="T:System.Collections.CollectionBase" /> at the specified index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-333">Si <xref:System.Collections.CollectionBase.Count%2A> ya es igual a la capacidad, se duplica la capacidad de la lista mediante la reasignación automática de la matriz interna antes de que se insertó el nuevo elemento.</span><span class="sxs-lookup"><span data-stu-id="d56a0-333">If <xref:System.Collections.CollectionBase.Count%2A> already equals the capacity, the capacity of the list is doubled by automatically reallocating the internal array before the new element is inserted.</span></span>  
  
 <span data-ttu-id="d56a0-334">Si `index` es igual a <xref:System.Collections.CollectionBase.Count%2A>, `value` se agrega al final de <xref:System.Collections.CollectionBase>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-334">If `index` is equal to <xref:System.Collections.CollectionBase.Count%2A>, `value` is added to the end of <xref:System.Collections.CollectionBase>.</span></span>  
  
 <span data-ttu-id="d56a0-335">En colecciones de elementos contiguos, como listas, los elementos que van a continuación del punto de inserción se desplazan hacia abajo para alojar el elemento nuevo.</span><span class="sxs-lookup"><span data-stu-id="d56a0-335">In collections of contiguous elements, such as lists, the elements that follow the insertion point move down to accommodate the new element.</span></span> <span data-ttu-id="d56a0-336">Si la colección está indizada, también se actualizan los índices de los elementos que se han movido.</span><span class="sxs-lookup"><span data-stu-id="d56a0-336">If the collection is indexed, the indexes of the elements that are moved are also updated.</span></span> <span data-ttu-id="d56a0-337">Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.</span><span class="sxs-lookup"><span data-stu-id="d56a0-337">This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</span></span>  
  
 <span data-ttu-id="d56a0-338">Este método es O (`n`) operación, donde `n` es <xref:System.Collections.CollectionBase.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-338">This method is an O(`n`) operation, where `n` is <xref:System.Collections.CollectionBase.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d56a0-339">El siguiente ejemplo de código implementa la <xref:System.Collections.CollectionBase> clase y utiliza esa implementación para crear una colección de <xref:System.Int16> objetos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-339">The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.</span></span>  
  
 [!code-cpp[System.Collections.CollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CPP/collectionbase.cpp#1)]
 [!code-csharp[System.Collections.CollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CS/collectionbase.cs#1)]
 [!code-vb[System.Collections.CollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.CollectionBase/VB/collectionbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d56a0-340">
            <paramref name="index" /> es menor que cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-340">
              <paramref name="index" /> is less than zero.</span>
          </span>
          <span data-ttu-id="d56a0-341">-o bien- <paramref name="index" /> es mayor que <see cref="P:System.Collections.CollectionBase.Count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-341">-or-  <paramref name="index" /> is greater than <see cref="P:System.Collections.CollectionBase.Count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d56a0-342">
            <see cref="T:System.Collections.CollectionBase" /> es de solo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-342">The <see cref="T:System.Collections.CollectionBase" /> is read-only.</span>
          </span>
          <span data-ttu-id="d56a0-343">-o bien- <see cref="T:System.Collections.CollectionBase" /> tiene un tamaño fijo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-343">-or-  The <see cref="T:System.Collections.CollectionBase" /> has a fixed size.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="d56a0-344">
            <para>Este método llama a <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" />, <see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" />, y <see cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-344">
              <para>This method calls <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" />, <see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" />, and <see cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Collections.IList.Add(System.Object)" />
        <altmember cref="M:System.Collections.IList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.CollectionBase.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.CollectionBase.System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d56a0-345">Obtiene un valor que indica si la interfaz <see cref="T:System.Collections.CollectionBase" /> tiene un tamaño fijo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-345">Gets a value indicating whether the <see cref="T:System.Collections.CollectionBase" /> has a fixed size.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d56a0-346">Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.CollectionBase" /> tiene un tamaño fijo; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-346">
              <see langword="true" /> if the <see cref="T:System.Collections.CollectionBase" /> has a fixed size; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d56a0-347">El valor predeterminado es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-347">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-348">Una colección de tamaño fijo no permite agregar o quitar elementos una vez que se ha creado, pero sí permite modificar los elementos existentes.</span><span class="sxs-lookup"><span data-stu-id="d56a0-348">A collection with a fixed size does not allow the addition or removal of elements after the collection is created, but it allows the modification of existing elements.</span></span>  
  
 <span data-ttu-id="d56a0-349">Una colección con un tamaño fijo es simplemente una colección con un contenedor que impide agregar y quitar elementos; por lo tanto, si se realizan cambios en la colección subyacente, incluida la adición o eliminación de elementos, la colección de tamaño fijo refleja los cambios.</span><span class="sxs-lookup"><span data-stu-id="d56a0-349">A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</span></span>  
  
 <span data-ttu-id="d56a0-350">La recuperación del valor de esta propiedad es una operación O(1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-350">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.CollectionBase.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.CollectionBase.System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d56a0-351">Obtiene un valor que indica si <see cref="T:System.Collections.CollectionBase" /> es de solo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-351">Gets a value indicating whether the <see cref="T:System.Collections.CollectionBase" /> is read-only.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d56a0-352">Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.CollectionBase" /> es de solo lectura; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-352">
              <see langword="true" /> if the <see cref="T:System.Collections.CollectionBase" /> is read-only; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d56a0-353">El valor predeterminado es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-353">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-354">Una colección de solo lectura no permite que se agreguen, quiten o modifiquen elementos una vez que se ha creado.</span><span class="sxs-lookup"><span data-stu-id="d56a0-354">A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</span></span>  
  
 <span data-ttu-id="d56a0-355">Una colección es de solo lectura es simplemente una colección con un contenedor que evita la modificación de la colección; por lo tanto, si se realizan cambios en la colección subyacente, la colección de solo lectura refleja los cambios.</span><span class="sxs-lookup"><span data-stu-id="d56a0-355">A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</span></span>  
  
 <span data-ttu-id="d56a0-356">La recuperación del valor de esta propiedad es una operación O(1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-356">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.CollectionBase.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.CollectionBase.System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">
          <span data-ttu-id="d56a0-357">Índice de base cero del elemento que se va a obtener o establecer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-357">The zero-based index of the element to get or set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d56a0-358">Obtiene o establece el elemento en el índice especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-358">Gets or sets the element at the specified index.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d56a0-359">Elemento en el índice especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-359">The element at the specified index.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-360">Esta propiedad permite obtener acceso a un elemento específico de la colección utilizando la sintaxis siguiente: `myCollection[index]`.</span><span class="sxs-lookup"><span data-stu-id="d56a0-360">This property provides the ability to access a specific element in the collection by using the following syntax: `myCollection[index]`.</span></span>  
  
 <span data-ttu-id="d56a0-361">Recuperar el valor de esta propiedad es una operación o (1); establecer la propiedad también es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="d56a0-361">Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d56a0-362">El siguiente ejemplo de código implementa la <xref:System.Collections.CollectionBase> clase y utiliza esa implementación para crear una colección de <xref:System.Int16> objetos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-362">The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.</span></span>  
  
 [!code-cpp[System.Collections.CollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CPP/collectionbase.cpp#1)]
 [!code-csharp[System.Collections.CollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CS/collectionbase.cs#1)]
 [!code-vb[System.Collections.CollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.CollectionBase/VB/collectionbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d56a0-363">
            <paramref name="index" /> es menor que cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-363">
              <paramref name="index" /> is less than zero.</span>
          </span>
          <span data-ttu-id="d56a0-364">- o bien- <paramref name="index" /> es igual o mayor que <see cref="P:System.Collections.CollectionBase.Count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-364">-or-  <paramref name="index" /> is equal to or greater than <see cref="P:System.Collections.CollectionBase.Count" />.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="d56a0-365">
            <para>Cuando se establece esta propiedad, los métodos <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" />, <see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" />, y <see cref="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)" /> se denominan.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-365">
              <para>When this property is set, the methods <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" />, <see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" />, and <see cref="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)" /> are called.</para>
            </span>
          </span>
        </block>
        <altmember cref="P:System.Collections.CollectionBase.Count" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.CollectionBase.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="d56a0-366">
            <see cref="T:System.Object" /> que se va a quitar de <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-366">The <see cref="T:System.Object" /> to remove from the <see cref="T:System.Collections.CollectionBase" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d56a0-367">Quita la primera aparición de un objeto específico de la interfaz <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-367">Removes the first occurrence of a specific object from the <see cref="T:System.Collections.CollectionBase" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d56a0-368">Si el <xref:System.Collections.CollectionBase> no contiene el objeto especificado, el <xref:System.Collections.CollectionBase> permanece sin cambios.</span><span class="sxs-lookup"><span data-stu-id="d56a0-368">If the <xref:System.Collections.CollectionBase> does not contain the specified object, the <xref:System.Collections.CollectionBase> remains unchanged.</span></span> <span data-ttu-id="d56a0-369">No se inicia ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="d56a0-369">No exception is thrown.</span></span>  
  
 <span data-ttu-id="d56a0-370">Este método realiza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es <xref:System.Collections.CollectionBase.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-370">This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.CollectionBase.Count%2A>.</span></span>  
  
 <span data-ttu-id="d56a0-371">Este método determina la igualdad llamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d56a0-371">This method determines equality by calling <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d56a0-372">En colecciones de elementos contiguos, como listas, los elementos que van a continuación del elemento eliminado se desplazan hacia arriba para ocupar el espacio libre.</span><span class="sxs-lookup"><span data-stu-id="d56a0-372">In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot.</span></span> <span data-ttu-id="d56a0-373">Si la colección está indizada, también se actualizan los índices de los elementos que se han movido.</span><span class="sxs-lookup"><span data-stu-id="d56a0-373">If the collection is indexed, the indexes of the elements that are moved are also updated.</span></span> <span data-ttu-id="d56a0-374">Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.</span><span class="sxs-lookup"><span data-stu-id="d56a0-374">This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d56a0-375">El siguiente ejemplo de código implementa la <xref:System.Collections.CollectionBase> clase y utiliza esa implementación para crear una colección de <xref:System.Int16> objetos.</span><span class="sxs-lookup"><span data-stu-id="d56a0-375">The following code example implements the <xref:System.Collections.CollectionBase> class and uses that implementation to create a collection of <xref:System.Int16> objects.</span></span>  
  
 [!code-cpp[System.Collections.CollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CPP/collectionbase.cpp#1)]
 [!code-csharp[System.Collections.CollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.CollectionBase/CS/collectionbase.cs#1)]
 [!code-vb[System.Collections.CollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.CollectionBase/VB/collectionbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d56a0-376">No se ha encontrado el parámetro <paramref name="value" /> en el objeto <see cref="T:System.Collections.CollectionBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-376">The <paramref name="value" /> parameter was not found in the <see cref="T:System.Collections.CollectionBase" /> object.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d56a0-377">
            <see cref="T:System.Collections.CollectionBase" /> es de solo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-377">The <see cref="T:System.Collections.CollectionBase" /> is read-only.</span>
          </span>
          <span data-ttu-id="d56a0-378">-o bien- <see cref="T:System.Collections.CollectionBase" /> tiene un tamaño fijo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-378">-or-  The <see cref="T:System.Collections.CollectionBase" /> has a fixed size.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="d56a0-379">
            <para>Este método llama a <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" />, <see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" />, y <see cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d56a0-379">
              <para>This method calls <see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" />, <see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" />, and <see cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Collections.CollectionBase.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.IList.Add(System.Object)" />
        <altmember cref="M:System.Collections.IList.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
  </Members>
</Type>