<Type Name="Hashtable" FullName="System.Collections.Hashtable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4c6adcdcf0768c2d073d568527998677360d621e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30370899" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Hashtable : ICloneable, System.Collections.IDictionary, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Hashtable extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ICloneable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Hashtable" />
  <TypeSignature Language="VB.NET" Value="Public Class Hashtable&#xA;Implements ICloneable, IDeserializationCallback, IDictionary, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Hashtable : ICloneable, System::Collections::IDictionary, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Hashtable/HashtableDebugView))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa una colección de pares de clave y valor que se organizan por código hash de la clave.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento es un par de clave/valor que se almacena en un <xref:System.Collections.DictionaryEntry> objeto. No puede ser una clave `null`, pero puede ser un valor.  
  
 Los objetos utilizados como claves por un <xref:System.Collections.Hashtable> es necesario que invalide la <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> método (o la <xref:System.Collections.IHashCodeProvider> interfaz) y la <xref:System.Object.Equals%2A?displayProperty=nameWithType> método (o el <xref:System.Collections.IComparer> interfaz). La implementación de métodos e interfaces debe tratar entre mayúsculas y minúsculas del mismo modo; en caso contrario, el <xref:System.Collections.Hashtable> podrían comportarse de manera incorrecta. Por ejemplo, al crear un <xref:System.Collections.Hashtable>, debe utilizar el <xref:System.Collections.CaseInsensitiveHashCodeProvider> clase (o cualquier entre mayúsculas y minúsculas <xref:System.Collections.IHashCodeProvider> implementación) con el <xref:System.Collections.CaseInsensitiveComparer> clase (o cualquier entre mayúsculas y minúsculas <xref:System.Collections.IComparer> implementación).  
  
 Además, estos métodos deben dar los mismos resultados cuando se llama con los mismos parámetros mientras la clave existe en el <xref:System.Collections.Hashtable>. Una alternativa consiste en utilizar un <xref:System.Collections.Hashtable> constructor con un <xref:System.Collections.IEqualityComparer> parámetro. Si la igualdad de clave fuera solamente igualdad de referencia, la implementación heredada de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> y <xref:System.Object.Equals%2A?displayProperty=nameWithType> sería suficiente.  
  
 Objetos de clave deben ser inmutables siempre y cuando se usan como claves en el <xref:System.Collections.Hashtable>.  
  
 Cuando se agrega un elemento a la <xref:System.Collections.Hashtable>, el elemento se coloca en un depósito en función del código hash de la clave. Las búsquedas subsiguientes de la clave utilizarán el código hash de la clave para buscar en solo un depósito concreto, lo que reduce considerablemente el número de comparaciones claves necesarias para buscar un elemento.  
  
 El factor de carga de un <xref:System.Collections.Hashtable> determina la relación máxima de elementos por sectores de almacenamiento. Factores de carga más pequeños provocar tiempos de con mayor rapidez promedio búsqueda a costa de consumo de memoria mayor. El factor de carga predeterminado de 1,0 suele proporciona el mejor equilibrio entre la velocidad y tamaño. También puede ser un factor de carga diferente especificado cuando el <xref:System.Collections.Hashtable> se crea.  
  
 Cuando se agregan elementos a un <xref:System.Collections.Hashtable>, el factor de carga real de la <xref:System.Collections.Hashtable> aumenta. Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos en la <xref:System.Collections.Hashtable> aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de <xref:System.Collections.Hashtable> depósitos.  
  
 Cada objeto de clave en el <xref:System.Collections.Hashtable> debe proporcionar su propia función hash, que se puede acceder mediante una llamada a <xref:System.Collections.Hashtable.GetHash%2A>. Sin embargo, cualquier objeto que implemente <xref:System.Collections.IHashCodeProvider> puede pasarse a una <xref:System.Collections.Hashtable> constructor y que se usa la función hash para todos los objetos de la tabla.  
  
 La capacidad de un <xref:System.Collections.Hashtable> es el número de elementos de la <xref:System.Collections.Hashtable> puede contener. Cuando se agregan elementos a un <xref:System.Collections.Hashtable>, la capacidad aumenta automáticamente según sea necesario mediante la reasignación.  
  
 Para un gran <xref:System.Collections.Hashtable> objetos, puede aumentar la capacidad máxima de 2 millones de elementos en un sistema de 64 bits estableciendo la `enabled` atributo del elemento de configuración para `true` en el entorno de tiempo de ejecución.  
  
 El `foreach` instrucción del lenguaje C# (`For Each` en Visual Basic) devuelve un objeto del tipo de los elementos de la colección. Puesto que cada elemento de la <xref:System.Collections.Hashtable> es un par clave/valor, el tipo de elemento no es el tipo de la clave o el tipo del valor. En su lugar, el tipo de elemento es <xref:System.Collections.DictionaryEntry>. Por ejemplo:  
  
 [!code-cpp[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cpp/remarks.cpp#01)]
 [!code-csharp[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cs/remarks.cs#01)]
 [!code-vb[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/vb/remarks.vb#01)]  
  
 El `foreach` instrucción es un contenedor del enumerador, que sólo permite la lectura de no escritura a la colección.  
  
 Dado que serializar y deserializar un enumerador para una <xref:System.Collections.Hashtable> puede hacer que los elementos que se van a ordenar de nuevo se convierten en, no es posible continuar la enumeración sin llamar a la <xref:System.Collections.IEnumerator.Reset%2A> método.  
  
> [!NOTE]
>  Dado que las claves se pueden heredar y su comportamiento puede cambiar, no se puede garantizar su unicidad absoluta mediante comparaciones utilizando el <xref:System.Type.Equals%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo crear, inicializar y realizan diversas funciones para un <xref:System.Collections.Hashtable> y cómo imprimir sus claves y valores.  
  
 [!code-cpp[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cpp/hashtable_example.cpp#00)]
 [!code-csharp[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cs/hashtable_example.cs#00)]
 [!code-vb[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/vb/hashtable_example.vb#00)]
 [!code-powershell[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/powershell/VS_Snippets_CLR_System/system.collections.hashtable.class/ps/hashtable.ps1#00)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <see cref="T:System.Collections.Hashtable" /> es un subproceso seguro para su uso por varios subprocesos de lector y un único subproceso de escritura. Es seguro para subprocesos multiproceso use cuando solo uno de los subprocesos realizan operaciones de escritura (actualización), que permite lecturas sin bloqueo siempre que se serializan los sistemas de escritura a la <see cref="T:System.Collections.Hashtable" />. Para admitir todas las operaciones de varios sistemas de escritura en el <see cref="T:System.Collections.Hashtable" /> debe realizarse a través del contenedor devuelto por el <see cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" /> método, proporcionado que no hay ningún subproceso leyendo el <see cref="T:System.Collections.Hashtable" /> objeto.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.</threadsafe>
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.IHashCodeProvider" />
    <altmember cref="M:System.Object.GetHashCode" />
    <altmember cref="M:System.Object.Equals(System.Object)" />
    <altmember cref="T:System.Collections.DictionaryEntry" />
    <altmember cref="T:System.Collections.Generic.Dictionary`2" />
    <altmember cref="T:System.Collections.IEqualityComparer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Hashtable" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia vacía de la clase <see cref="T:System.Collections.Hashtable" /> utilizando la capacidad inicial, el factor de carga, el proveedor de código hash y el comparador predeterminados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capacidad de una tabla hash se utiliza para calcular el número óptimo de depósitos de la tabla hash según el factor de carga. Se aumenta automáticamente la capacidad según sea necesario.  
  
 El factor de carga es la relación máxima de elementos por sectores de almacenamiento. Un factor de carga menor significa una búsqueda más rápida a costa de consumo de memoria mayor.  
  
 Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de depósitos.  
  
 El proveedor de código hash asigna códigos hash para las claves en el <xref:System.Collections.Hashtable> objeto. El proveedor de código hash predeterminado es la implementación de la clave <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 El comparador determina si dos claves son iguales. Todas las claves de un <xref:System.Collections.Hashtable> deben ser únicos. El comparador predeterminado es la implementación de la clave <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Este constructor es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea tablas hash utilizando diferentes <xref:System.Collections.Hashtable> constructores y muestra las diferencias en el comportamiento de las tablas hash, aunque cada una de ellas contiene los mismos elementos.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="d">Objeto <see cref="T:System.Collections.IDictionary" /> que debe copiarse a un nuevo objeto <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Hashtable" /> copiando los elementos del diccionario especificado en el nuevo objeto <see cref="T:System.Collections.Hashtable" />. El nuevo objeto <see cref="T:System.Collections.Hashtable" /> tiene una capacidad inicial igual al número de elementos copiados, y utiliza el factor de carga, el proveedor de código hash y comparador predeterminados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacidad inicial se establece en el número de elementos en el diccionario de origen. La capacidad es automáticamente aumenta según sea necesario según el factor de carga.  
  
 El factor de carga es la relación máxima de elementos por sectores de almacenamiento. Un factor de carga menor significa una búsqueda más rápida a costa de consumo de memoria mayor.  
  
 Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de depósitos.  
  
 El proveedor de código hash asigna códigos hash para las claves en el <xref:System.Collections.Hashtable> objeto. El proveedor de código hash predeterminado es la implementación de la clave <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 El comparador determina si dos claves son iguales. Todas las claves de un <xref:System.Collections.Hashtable> deben ser únicos. El comparador predeterminado es la implementación de la clave <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Los elementos de la nueva <xref:System.Collections.Hashtable> se ordenan en el mismo orden en el que el enumerador recorre en iteración la <xref:System.Collections.IDictionary> objeto.  
  
 Este constructor es una O (`n`) operación, donde `n` es el número de elementos de la `d` parámetro.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea tablas hash utilizando diferentes <xref:System.Collections.Hashtable> constructores y muestra las diferencias en el comportamiento de las tablas hash, aunque cada una de ellas contiene los mismos elementos.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="equalityComparer">Objeto <see cref="T:System.Collections.IEqualityComparer" /> que define el proveedor de código hash y el comparador que se van a utilizar con el objeto <see cref="T:System.Collections.Hashtable" />.  
  
 O bien  
  
 <see langword="null" /> para utilizar el proveedor de código hash y el comparador predeterminados. El proveedor de código hash predeterminado es la implementación del método <see cref="M:System.Object.GetHashCode" /> de cada clave y el comparador predeterminado es la implementación del método <see cref="M:System.Object.Equals(System.Object)" /> de cada clave.</param>
        <summary>Inicializa una nueva instancia vacía de la clase <see cref="T:System.Collections.Hashtable" /> utilizando la capacidad inicial y el factor de carga predeterminados, y el objeto <see cref="T:System.Collections.IEqualityComparer" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capacidad de una tabla hash se utiliza para calcular el número óptimo de depósitos de la tabla hash según el factor de carga. Se aumenta automáticamente la capacidad según sea necesario.  
  
 El factor de carga es la relación máxima de elementos por sectores de almacenamiento. Un factor de carga menor significa una búsqueda más rápida a costa de consumo de memoria mayor.  
  
 Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de depósitos.  
  
 La <xref:System.Collections.IEqualityComparer> objeto incluye el proveedor de código hash y el comparador. Si un <xref:System.Collections.IEqualityComparer> se utiliza en el <xref:System.Collections.Hashtable> constructor, los objetos utilizados como claves en el <xref:System.Collections.Hashtable> objeto no es necesario que invalide la <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> y <xref:System.Object.Equals%2A?displayProperty=nameWithType> métodos.  
  
 El proveedor de código hash asigna códigos hash para las claves en el <xref:System.Collections.Hashtable>. El proveedor de código hash predeterminado es la implementación de la clave <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 El comparador determina si dos claves son iguales. Todas las claves de un <xref:System.Collections.Hashtable> deben ser únicos. El comparador predeterminado es la implementación de la clave <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 El <xref:System.Collections.IEqualityComparer> habilita escenarios como realizar búsquedas con cadenas entre mayúsculas y minúsculas.  
  
 Este constructor es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea tablas hash utilizando diferentes <xref:System.Collections.Hashtable> constructores y muestra las diferencias en el comportamiento de las tablas hash, aunque cada una de ellas contiene los mismos elementos.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Número aproximado de elementos que el objeto <see cref="T:System.Collections.Hashtable" /> puede contener inicialmente.</param>
        <summary>Inicializa una nueva instancia vacía de la clase <see cref="T:System.Collections.Hashtable" /> utilizando la capacidad inicial especificada, y el factor de carga, el proveedor de código hash y el comparador predeterminados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especificar la capacidad inicial, elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.Hashtable> objeto. La capacidad es automáticamente aumenta según sea necesario según el factor de carga.  
  
 El factor de carga es la relación máxima de elementos por sectores de almacenamiento. Un factor de carga menor significa una búsqueda más rápida a costa de consumo de memoria mayor.  
  
 Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de depósitos.  
  
 El proveedor de código hash asigna códigos hash para las claves en el <xref:System.Collections.Hashtable>. El proveedor de código hash predeterminado es la implementación de la clave <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 El comparador determina si dos claves son iguales. Todas las claves de un <xref:System.Collections.Hashtable> deben ser únicos. El comparador predeterminado es la implementación de la clave <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Este constructor es una O (`n`) operación, donde `n` es `capacity`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea tablas hash utilizando diferentes <xref:System.Collections.Hashtable> constructores y muestra las diferencias en el comportamiento de las tablas hash, aunque cada una de ellas contiene los mismos elementos.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es menor que cero.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="d">Objeto <see cref="T:System.Collections.IDictionary" /> que debe copiarse a un nuevo objeto <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="equalityComparer">Objeto <see cref="T:System.Collections.IEqualityComparer" /> que define el proveedor de código hash y el comparador que se van a usar con <see cref="T:System.Collections.Hashtable" />.  
  
 O bien  
  
 <see langword="null" /> para utilizar el proveedor de código hash y el comparador predeterminados. El proveedor de código hash predeterminado es la implementación del método <see cref="M:System.Object.GetHashCode" /> de cada clave y el comparador predeterminado es la implementación del método <see cref="M:System.Object.Equals(System.Object)" /> de cada clave.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Hashtable" /> copiando los elementos del diccionario especificado en un nuevo objeto <see cref="T:System.Collections.Hashtable" />. El nuevo objeto <see cref="T:System.Collections.Hashtable" /> tiene una capacidad inicial igual al número de elementos copiados, y utiliza el factor de carga predeterminado y el objeto <see cref="T:System.Collections.IEqualityComparer" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacidad inicial se establece en el número de elementos en el diccionario de origen. La capacidad es automáticamente aumenta según sea necesario según el factor de carga.  
  
 El factor de carga es la relación máxima de elementos por sectores de almacenamiento. Un factor de carga menor significa una búsqueda más rápida a costa de consumo de memoria mayor.  
  
 Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de depósitos.  
  
 La <xref:System.Collections.IEqualityComparer> objeto incluye el proveedor de código hash y el comparador. Si un <xref:System.Collections.IEqualityComparer> se utiliza en el <xref:System.Collections.Hashtable> constructor, los objetos utilizados como claves en el <xref:System.Collections.Hashtable> objeto no es necesario que invalide la <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> y <xref:System.Object.Equals%2A?displayProperty=nameWithType> métodos.  
  
 El proveedor de código hash asigna códigos hash para las claves en el <xref:System.Collections.Hashtable>. El proveedor de código hash predeterminado es la implementación de la clave <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 El comparador determina si dos claves son iguales. Todas las claves de un <xref:System.Collections.Hashtable> deben ser únicos. El comparador predeterminado es la implementación de la clave <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 El <xref:System.Collections.IEqualityComparer> habilita escenarios como realizar búsquedas con cadenas entre mayúsculas y minúsculas.  
  
 Los elementos de la nueva <xref:System.Collections.Hashtable> se ordenan en el mismo orden en el que el enumerador recorre en iteración la <xref:System.Collections.IDictionary> objeto.  
  
 Este constructor es una O (`n`) operación, donde `n` es el número de elementos de la `d` parámetro.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea tablas hash utilizando diferentes <xref:System.Collections.Hashtable> constructores y muestra las diferencias en el comportamiento de las tablas hash, aunque cada una de ellas contiene los mismos elementos.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="d">Objeto <see cref="T:System.Collections.IDictionary" /> que debe copiarse a un nuevo objeto <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="loadFactor">Número incluido en el intervalo de 0,1 a 1,0 que se multiplica por el valor predeterminado que proporciona el mejor rendimiento. El resultado es la relación máxima de elementos por sectores de almacenamiento.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Hashtable" /> copiando los elementos del diccionario especificado en el nuevo objeto <see cref="T:System.Collections.Hashtable" />. El nuevo objeto <see cref="T:System.Collections.Hashtable" /> tiene una capacidad inicial igual al número de elementos copiados, utiliza el factor de carga especificado, y el proveedor de código hash y comparador predeterminados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacidad inicial se establece en el número de elementos en el diccionario de origen. La capacidad es automáticamente aumenta según sea necesario según el factor de carga.  
  
 El factor de carga es la relación máxima de elementos por sectores de almacenamiento. Un factor de carga menor significa una búsqueda más rápida a costa de consumo de memoria mayor. Un factor de carga de 1,0 es el mejor equilibrio entre la velocidad y tamaño.  
  
 Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de depósitos.  
  
 El proveedor de código hash asigna códigos hash para las claves en el <xref:System.Collections.Hashtable> objeto. El proveedor de código hash predeterminado es la implementación de la clave <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 El comparador determina si dos claves son iguales. Todas las claves de un <xref:System.Collections.Hashtable> deben ser únicos. El comparador predeterminado es la implementación de la clave <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Los elementos de la nueva <xref:System.Collections.Hashtable> se ordenan en el mismo orden en el que el enumerador recorre en iteración la <xref:System.Collections.IDictionary> objeto.  
  
 Este constructor es una O (`n`) operación, donde `n` es el número de elementos de la `d` parámetro.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea tablas hash utilizando diferentes <xref:System.Collections.Hashtable> constructores y muestra las diferencias en el comportamiento de las tablas hash, aunque cada una de ellas contiene los mismos elementos.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="loadFactor" /> es menor que 0,1.  
  
 O bien  
  
 <paramref name="loadFactor" /> es mayor que 1,0.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use Hashtable(IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="hcp">Objeto <see cref="T:System.Collections.IHashCodeProvider" /> que suministra los códigos hash de todas las claves del objeto <see cref="T:System.Collections.Hashtable" />.  
  
 O bien  
  
 <see langword="null" /> para utilizar el proveedor predeterminado de código hash, que es la implementación de <see cref="M:System.Object.GetHashCode" /> de cada clave.</param>
        <param name="comparer">Objeto <see cref="T:System.Collections.IComparer" /> que se va a usar para determinar si dos claves son iguales.  
  
 O bien  
  
 <see langword="null" /> para utilizar el comparador predeterminado, que es la implementación de cada clave de <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicializa una nueva instancia vacía de la clase <see cref="T:System.Collections.Hashtable" /> utilizando la capacidad inicial y el factor de carga predeterminados, y el proveedor de código hash y el comparador especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capacidad de una tabla hash se utiliza para calcular el número óptimo de depósitos de la tabla hash según el factor de carga. Se aumenta automáticamente la capacidad según sea necesario.  
  
 El factor de carga es la relación máxima de elementos por sectores de almacenamiento. Un factor de carga menor significa una búsqueda más rápida a costa de consumo de memoria mayor.  
  
 Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de depósitos.  
  
 El proveedor de código hash asigna códigos hash para las claves en el <xref:System.Collections.Hashtable> objeto. El proveedor de código hash predeterminado es la implementación de la clave <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 El comparador determina si dos claves son iguales. Todas las claves de un <xref:System.Collections.Hashtable> deben ser únicos. El comparador predeterminado es la implementación de la clave <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 El proveedor de código hash y el comparador personalizado habilitar escenarios como realizar búsquedas con cadenas entre mayúsculas y minúsculas.  
  
 Este constructor es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea tablas hash utilizando diferentes <xref:System.Collections.Hashtable> constructores y muestra las diferencias en el comportamiento de las tablas hash, aunque cada una de ellas contiene los mismos elementos.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Número aproximado de elementos que el objeto <see cref="T:System.Collections.Hashtable" /> puede contener inicialmente.</param>
        <param name="equalityComparer">Objeto <see cref="T:System.Collections.IEqualityComparer" /> que define el proveedor de código hash y el comparador que se van a usar con <see cref="T:System.Collections.Hashtable" />.  
  
 O bien  
  
 <see langword="null" /> para utilizar el proveedor de código hash y el comparador predeterminados. El proveedor de código hash predeterminado es la implementación del método <see cref="M:System.Object.GetHashCode" /> de cada clave y el comparador predeterminado es la implementación del método <see cref="M:System.Object.Equals(System.Object)" /> de cada clave.</param>
        <summary>Inicializa una nueva instancia vacía de la clase <see cref="T:System.Collections.Hashtable" /> utilizando la capacidad inicial y el objeto <see cref="T:System.Collections.IEqualityComparer" /> especificados, y el factor de carga predeterminado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especificar la capacidad inicial, elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.Hashtable> objeto. La capacidad es automáticamente aumenta según sea necesario según el factor de carga.  
  
 El factor de carga es la relación máxima de elementos por sectores de almacenamiento. Un factor de carga menor significa una búsqueda más rápida a costa de consumo de memoria mayor.  
  
 Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de depósitos.  
  
 La <xref:System.Collections.IEqualityComparer> objeto incluye el proveedor de código hash y el comparador. Si un <xref:System.Collections.IEqualityComparer> se utiliza en el <xref:System.Collections.Hashtable> constructor, los objetos utilizados como claves en el <xref:System.Collections.Hashtable> no es necesario que invalide la <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> y <xref:System.Object.Equals%2A?displayProperty=nameWithType> métodos.  
  
 El proveedor de código hash asigna códigos hash para las claves en el <xref:System.Collections.Hashtable>. El proveedor de código hash predeterminado es la implementación de la clave <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 El comparador determina si dos claves son iguales. Todas las claves de un <xref:System.Collections.Hashtable> deben ser únicos. El comparador predeterminado es la implementación de la clave <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 El <xref:System.Collections.IEqualityComparer> habilita escenarios como realizar búsquedas con cadenas entre mayúsculas y minúsculas.  
  
 Este constructor es una O (`n`) operación, donde `n` es el `capacity` parámetro.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea tablas hash utilizando diferentes <xref:System.Collections.Hashtable> constructores y muestra las diferencias en el comportamiento de las tablas hash, aunque cada una de ellas contiene los mismos elementos.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es menor que cero.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="capacity">Número aproximado de elementos que el objeto <see cref="T:System.Collections.Hashtable" /> puede contener inicialmente.</param>
        <param name="loadFactor">Número incluido en el intervalo de 0,1 a 1,0 que se multiplica por el valor predeterminado que proporciona el mejor rendimiento. El resultado es la relación máxima de elementos por sectores de almacenamiento.</param>
        <summary>Inicializa una nueva instancia vacía de la clase <see cref="T:System.Collections.Hashtable" /> utilizando la capacidad inicial y el factor de carga especificados, y el proveedor de código hash y el comparador predeterminados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especificar la capacidad inicial, elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.Hashtable> objeto. La capacidad es automáticamente aumenta según sea necesario según el factor de carga.  
  
 El factor de carga es la relación máxima de elementos por sectores de almacenamiento. Un factor de carga menor significa una búsqueda más rápida a costa de consumo de memoria mayor. Un factor de carga de 1,0 es el mejor equilibrio entre la velocidad y tamaño.  
  
 Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de depósitos.  
  
 El proveedor de código hash asigna códigos hash para las claves en el <xref:System.Collections.Hashtable>. El proveedor de código hash predeterminado es la implementación de la clave <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 El comparador determina si dos claves son iguales. Todas las claves de un <xref:System.Collections.Hashtable> deben ser únicos. El comparador predeterminado es la implementación de la clave <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Este constructor es una O (`n`) operación, donde `n` es el `capacity` parámetro.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea tablas hash utilizando diferentes <xref:System.Collections.Hashtable> constructores y muestra las diferencias en el comportamiento de las tablas hash, aunque cada una de ellas contiene los mismos elementos.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es menor que cero.  
  
 O bien  
  
 <paramref name="loadFactor" /> es menor que 0,1.  
  
 O bien  
  
 <paramref name="loadFactor" /> es mayor que 1,0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="capacity" /> está produciendo un desbordamiento.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Hashtable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Hashtable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene la información que se requiere para serializar el objeto <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="context">Objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene el origen y el destino de la secuencia serializada asociada al <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Inicializa una nueva instancia vacía de la clase <see cref="T:System.Collections.Hashtable" /> que es serializable, utilizando los objetos <see cref="T:System.Runtime.Serialization.SerializationInfo" /> y <see cref="T:System.Runtime.Serialization.StreamingContext" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capacidad de una tabla hash se utiliza para calcular el número óptimo de depósitos de la tabla hash según el factor de carga. Se aumenta automáticamente la capacidad según sea necesario.  
  
 El factor de carga es la relación máxima de elementos por sectores de almacenamiento. Un factor de carga menor significa una búsqueda más rápida a costa de consumo de memoria mayor.  
  
 Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de depósitos.  
  
 El proveedor de código hash asigna códigos hash para las claves en el <xref:System.Collections.Hashtable> objeto. El proveedor de código hash predeterminado es la implementación de la clave <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 El comparador determina si dos claves son iguales. Todas las claves de un <xref:System.Collections.Hashtable> deben ser únicos. El comparador predeterminado es la implementación de la clave <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Este constructor es una O (`n`) operación, donde `n` es <xref:System.Collections.Hashtable.Count%2A>.  
  
 Dado que serializar y deserializar un enumerador para una <xref:System.Collections.Hashtable> puede hacer que los elementos que se van a ordenar de nuevo se convierten en, no es posible continuar la enumeración sin llamar a la <xref:System.Collections.IEnumerator.Reset%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use Hashtable(IDictionary, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">Objeto <see cref="T:System.Collections.IDictionary" /> que debe copiarse a un nuevo objeto <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="hcp">Objeto <see cref="T:System.Collections.IHashCodeProvider" /> que suministra los códigos hash de todas las claves de <see cref="T:System.Collections.Hashtable" />.  
  
 O bien  
  
 <see langword="null" /> para utilizar el proveedor predeterminado de código hash, que es la implementación de <see cref="M:System.Object.GetHashCode" /> de cada clave.</param>
        <param name="comparer">Objeto <see cref="T:System.Collections.IComparer" /> que se va a usar para determinar si dos claves son iguales.  
  
 O bien  
  
 <see langword="null" /> para utilizar el comparador predeterminado, que es la implementación de cada clave de <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Hashtable" /> copiando los elementos del diccionario especificado en el nuevo objeto <see cref="T:System.Collections.Hashtable" />. El nuevo objeto <see cref="T:System.Collections.Hashtable" /> tiene una capacidad inicial igual al número de elementos copiados, utiliza el factor de carga predeterminado, y el proveedor de código hash y comparador especificados. Esta API está obsoleta. Para una alternativa, vea <see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacidad inicial se establece en el número de elementos en el diccionario de origen. La capacidad es automáticamente aumenta según sea necesario según el factor de carga.  
  
 El factor de carga es la relación máxima de elementos por sectores de almacenamiento. Un factor de carga menor significa una búsqueda más rápida a costa de consumo de memoria mayor.  
  
 Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de depósitos.  
  
 El proveedor de código hash asigna códigos hash para las claves en el <xref:System.Collections.Hashtable> objeto. El proveedor de código hash predeterminado es la implementación de la clave <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 El comparador determina si dos claves son iguales. Todas las claves de un <xref:System.Collections.Hashtable> deben ser únicos. El comparador predeterminado es la implementación de la clave <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 El proveedor de código hash y el comparador personalizado habilitar escenarios como realizar búsquedas con cadenas entre mayúsculas y minúsculas.  
  
 Los elementos de la nueva <xref:System.Collections.Hashtable> se ordenan en el mismo orden en el que el enumerador recorre en iteración la <xref:System.Collections.IDictionary> objeto.  
  
 Este constructor es una O (`n`) operación, donde `n` es el número de elementos de la `d` parámetro.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea tablas hash utilizando diferentes <xref:System.Collections.Hashtable> constructores y muestra las diferencias en el comportamiento de las tablas hash, aunque cada una de ellas contiene los mismos elementos.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="d">Objeto <see cref="T:System.Collections.IDictionary" /> que debe copiarse a un nuevo objeto <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="loadFactor">Número incluido en el intervalo de 0,1 a 1,0 que se multiplica por el valor predeterminado que proporciona el mejor rendimiento. El resultado es la relación máxima de elementos por sectores de almacenamiento.</param>
        <param name="equalityComparer">Objeto <see cref="T:System.Collections.IEqualityComparer" /> que define el proveedor de código hash y el comparador que se van a usar con <see cref="T:System.Collections.Hashtable" />.  
  
 O bien  
  
 <see langword="null" /> para utilizar el proveedor de código hash y el comparador predeterminados. El proveedor de código hash predeterminado es la implementación del método <see cref="M:System.Object.GetHashCode" /> de cada clave y el comparador predeterminado es la implementación del método <see cref="M:System.Object.Equals(System.Object)" /> de cada clave.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Hashtable" /> copiando los elementos del diccionario especificado en el nuevo objeto <see cref="T:System.Collections.Hashtable" />. El nuevo objeto <see cref="T:System.Collections.Hashtable" /> tiene una capacidad inicial igual al número de elementos copiados, y utiliza el factor de carga y el objeto <see cref="T:System.Collections.IEqualityComparer" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacidad inicial se establece en el número de elementos en el diccionario de origen. La capacidad es automáticamente aumenta según sea necesario según el factor de carga.  
  
 El factor de carga es la relación máxima de elementos por sectores de almacenamiento. Un factor de carga menor significa una búsqueda más rápida a costa de consumo de memoria mayor. Un factor de carga de 1,0 es el mejor equilibrio entre la velocidad y tamaño.  
  
 Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de depósitos.  
  
 La <xref:System.Collections.IEqualityComparer> objeto incluye el proveedor de código hash y el comparador. Si un <xref:System.Collections.IEqualityComparer> se utiliza en el <xref:System.Collections.Hashtable> constructor, los objetos utilizados como claves en el <xref:System.Collections.Hashtable> objeto no es necesario que invalide la <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> y <xref:System.Object.Equals%2A?displayProperty=nameWithType> métodos.  
  
 El proveedor de código hash asigna códigos hash para las claves en el <xref:System.Collections.Hashtable>. El proveedor de código hash predeterminado es la implementación de la clave <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 El comparador determina si dos claves son iguales. Todas las claves de un <xref:System.Collections.Hashtable> deben ser únicos. El comparador predeterminado es la implementación de la clave <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 El <xref:System.Collections.IEqualityComparer> habilita escenarios como realizar búsquedas con cadenas entre mayúsculas y minúsculas.  
  
 Los elementos de la nueva <xref:System.Collections.Hashtable> se ordenan en el mismo orden en el que el enumerador recorre en iteración la <xref:System.Collections.IDictionary> objeto.  
  
 Este constructor es una O (`n`) operación, donde `n` es el número de elementos de la `d` parámetro.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea tablas hash utilizando diferentes <xref:System.Collections.Hashtable> constructores y muestra las diferencias en el comportamiento de las tablas hash, aunque cada una de ellas contiene los mismos elementos.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="loadFactor" /> es menor que 0,1.  
  
 O bien  
  
 <paramref name="loadFactor" /> es mayor que 1,0.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use Hashtable(int, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Número aproximado de elementos que el objeto <see cref="T:System.Collections.Hashtable" /> puede contener inicialmente.</param>
        <param name="hcp">Objeto <see cref="T:System.Collections.IHashCodeProvider" /> que suministra los códigos hash de todas las claves de <see cref="T:System.Collections.Hashtable" />.  
  
 O bien  
  
 <see langword="null" /> para utilizar el proveedor predeterminado de código hash, que es la implementación de <see cref="M:System.Object.GetHashCode" /> de cada clave.</param>
        <param name="comparer">Objeto <see cref="T:System.Collections.IComparer" /> que se va a usar para determinar si dos claves son iguales.  
  
 O bien  
  
 <see langword="null" /> para utilizar el comparador predeterminado, que es la implementación de cada clave de <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicializa una nueva instancia vacía de la clase <see cref="T:System.Collections.Hashtable" /> utilizando la capacidad inicial, el proveedor de código hash y el comparador especificados, y el factor de carga predeterminado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especificar la capacidad inicial, elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.Hashtable> objeto. La capacidad es automáticamente aumenta según sea necesario según el factor de carga.  
  
 El factor de carga es la relación máxima de elementos por sectores de almacenamiento. Un factor de carga menor significa una búsqueda más rápida a costa de consumo de memoria mayor.  
  
 Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de depósitos.  
  
 El proveedor de código hash asigna códigos hash para las claves en el <xref:System.Collections.Hashtable>. El proveedor de código hash predeterminado es la implementación de la clave <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 El comparador determina si dos claves son iguales. Todas las claves de un <xref:System.Collections.Hashtable> deben ser únicos. El comparador predeterminado es la implementación de la clave <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 El proveedor de código hash y el comparador personalizado habilitar escenarios como realizar búsquedas con cadenas entre mayúsculas y minúsculas.  
  
 Este constructor es una O (`n`) operación, donde `n` es el `capacity` parámetro.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea tablas hash utilizando diferentes <xref:System.Collections.Hashtable> constructores y muestra las diferencias en el comportamiento de las tablas hash, aunque cada una de ellas contiene los mismos elementos.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es menor que cero.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Número aproximado de elementos que el objeto <see cref="T:System.Collections.Hashtable" /> puede contener inicialmente.</param>
        <param name="loadFactor">Número incluido en el intervalo de 0,1 a 1,0 que se multiplica por el valor predeterminado que proporciona el mejor rendimiento. El resultado es la relación máxima de elementos por sectores de almacenamiento.</param>
        <param name="equalityComparer">Objeto <see cref="T:System.Collections.IEqualityComparer" /> que define el proveedor de código hash y el comparador que se van a usar con <see cref="T:System.Collections.Hashtable" />.  
  
 O bien  
  
 <see langword="null" /> para utilizar el proveedor de código hash y el comparador predeterminados. El proveedor de código hash predeterminado es la implementación del método <see cref="M:System.Object.GetHashCode" /> de cada clave y el comparador predeterminado es la implementación del método <see cref="M:System.Object.Equals(System.Object)" /> de cada clave.</param>
        <summary>Inicializa una nueva instancia vacía de la clase <see cref="T:System.Collections.Hashtable" /> utilizando la capacidad inicial, el factor de carga y el objeto <see cref="T:System.Collections.IEqualityComparer" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especificar la capacidad inicial, elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.Hashtable> objeto. La capacidad es automáticamente aumenta según sea necesario según el factor de carga.  
  
 El factor de carga es la relación máxima de elementos por sectores de almacenamiento. Un factor de carga menor significa una búsqueda más rápida a costa de consumo de memoria mayor. Un factor de carga de 1,0 es el mejor equilibrio entre la velocidad y tamaño.  
  
 Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de depósitos.  
  
 La <xref:System.Collections.IEqualityComparer> objeto incluye el proveedor de código hash y el comparador. Si un <xref:System.Collections.IEqualityComparer> se utiliza en el <xref:System.Collections.Hashtable> constructor, los objetos utilizados como claves en el <xref:System.Collections.Hashtable> no es necesario que invalide la <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> y <xref:System.Object.Equals%2A?displayProperty=nameWithType> métodos.  
  
 El proveedor de código hash asigna códigos hash para las claves en el <xref:System.Collections.Hashtable>. El proveedor de código hash predeterminado es la implementación de la clave <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 El comparador determina si dos claves son iguales. Todas las claves de un <xref:System.Collections.Hashtable> deben ser únicos. El comparador predeterminado es la implementación de la clave <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 El <xref:System.Collections.IEqualityComparer> habilita escenarios como realizar búsquedas con cadenas entre mayúsculas y minúsculas.  
  
 Este constructor es una O (`n`) operación, donde `n` es el `capacity` parámetro.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea tablas hash utilizando diferentes <xref:System.Collections.Hashtable> constructores y muestra las diferencias en el comportamiento de las tablas hash, aunque cada una de ellas contiene los mismos elementos.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es menor que cero.  
  
 O bien  
  
 <paramref name="loadFactor" /> es menor que 0,1.  
  
 O bien  
  
 <paramref name="loadFactor" /> es mayor que 1,0.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use Hashtable(IDictionary, float, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">Objeto <see cref="T:System.Collections.IDictionary" /> que debe copiarse a un nuevo objeto <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="loadFactor">Número incluido en el intervalo de 0,1 a 1,0 que se multiplica por el valor predeterminado que proporciona el mejor rendimiento. El resultado es la relación máxima de elementos por sectores de almacenamiento.</param>
        <param name="hcp">Objeto <see cref="T:System.Collections.IHashCodeProvider" /> que suministra los códigos hash de todas las claves de <see cref="T:System.Collections.Hashtable" />.  
  
 O bien  
  
 <see langword="null" /> para utilizar el proveedor predeterminado de código hash, que es la implementación de <see cref="M:System.Object.GetHashCode" /> de cada clave.</param>
        <param name="comparer">Objeto <see cref="T:System.Collections.IComparer" /> que se va a usar para determinar si dos claves son iguales.  
  
 O bien  
  
 <see langword="null" /> para utilizar el comparador predeterminado, que es la implementación de cada clave de <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Hashtable" /> copiando los elementos del diccionario especificado en el nuevo objeto <see cref="T:System.Collections.Hashtable" />. El nuevo objeto <see cref="T:System.Collections.Hashtable" /> tiene una capacidad inicial igual al número de elementos copiados, y utiliza el factor de carga, el proveedor de código hash y el comparador especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacidad inicial se establece en el número de elementos en el diccionario de origen. La capacidad es automáticamente aumenta según sea necesario según el factor de carga.  
  
 El factor de carga es la relación máxima de elementos por sectores de almacenamiento. Un factor de carga menor significa una búsqueda más rápida a costa de consumo de memoria mayor. Un factor de carga de 1,0 es el mejor equilibrio entre la velocidad y tamaño.  
  
 Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de depósitos.  
  
 El proveedor de código hash asigna códigos hash para las claves en el <xref:System.Collections.Hashtable> objeto. El proveedor de código hash predeterminado es la implementación de la clave <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 El comparador determina si dos claves son iguales. Todas las claves de un <xref:System.Collections.Hashtable> deben ser únicos. El comparador predeterminado es la implementación de la clave <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 El proveedor de código hash y el comparador personalizado habilitar escenarios como realizar búsquedas con cadenas entre mayúsculas y minúsculas.  
  
 Los elementos de la nueva <xref:System.Collections.Hashtable> se ordenan en el mismo orden en el que el enumerador recorre en iteración la <xref:System.Collections.IDictionary> objeto.  
  
 Este constructor es una O (`n`) operación, donde `n` es el número de elementos de la `d` parámetro.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea tablas hash utilizando diferentes <xref:System.Collections.Hashtable> constructores y muestra las diferencias en el comportamiento de las tablas hash, aunque cada una de ellas contiene los mismos elementos.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="loadFactor" /> es menor que 0,1.  
  
 O bien  
  
 <paramref name="loadFactor" /> es mayor que 1,0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use Hashtable(int, float, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Número aproximado de elementos que el objeto <see cref="T:System.Collections.Hashtable" /> puede contener inicialmente.</param>
        <param name="loadFactor">Número incluido en el intervalo de 0,1 a 1,0 que se multiplica por el valor predeterminado que proporciona el mejor rendimiento. El resultado es la relación máxima de elementos por sectores de almacenamiento.</param>
        <param name="hcp">Objeto <see cref="T:System.Collections.IHashCodeProvider" /> que suministra los códigos hash de todas las claves de <see cref="T:System.Collections.Hashtable" />.  
  
 O bien  
  
 <see langword="null" /> para utilizar el proveedor predeterminado de código hash, que es la implementación de <see cref="M:System.Object.GetHashCode" /> de cada clave.</param>
        <param name="comparer">Objeto <see cref="T:System.Collections.IComparer" /> que se va a usar para determinar si dos claves son iguales.  
  
 O bien  
  
 <see langword="null" /> para utilizar el comparador predeterminado, que es la implementación de cada clave de <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicializa una nueva instancia vacía de la clase <see cref="T:System.Collections.Hashtable" /> utilizando la capacidad inicial, el factor de carga, el proveedor de código hash y el comparador especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especificar la capacidad inicial, elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.Hashtable> objeto. La capacidad es automáticamente aumenta según sea necesario según el factor de carga.  
  
 El factor de carga es la relación máxima de elementos por sectores de almacenamiento. Un factor de carga menor significa una búsqueda más rápida a costa de consumo de memoria mayor. Un factor de carga de 1,0 es el mejor equilibrio entre la velocidad y tamaño.  
  
 Cuando el factor de carga real alcanza el factor de carga especificado, el número de depósitos aumenta automáticamente hasta el número primo más pequeño que es mayor que el doble del número actual de depósitos.  
  
 El proveedor de código hash asigna códigos hash para las claves en el <xref:System.Collections.Hashtable>. El proveedor de código hash predeterminado es la implementación de la clave <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 El comparador determina si dos claves son iguales. Todas las claves de un <xref:System.Collections.Hashtable> deben ser únicos. El comparador predeterminado es la implementación de la clave <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 El proveedor de código hash y el comparador personalizado habilitar escenarios como realizar búsquedas con cadenas entre mayúsculas y minúsculas.  
  
 Este constructor es una O (`n`) operación, donde `n` es el `capacity` parámetro.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea tablas hash utilizando diferentes <xref:System.Collections.Hashtable> constructores y muestra las diferencias en el comportamiento de las tablas hash, aunque cada una de ellas contiene los mismos elementos.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es menor que cero.  
  
 O bien  
  
 <paramref name="loadFactor" /> es menor que 0,1.  
  
 O bien  
  
 <paramref name="loadFactor" /> es mayor que 1,0.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clave del elemento que se va a agregar.</param>
        <param name="value">Valor del elemento que se va a agregar. El valor puede ser <see langword="null" />.</param>
        <summary>Agrega un elemento con la clave y el valor especificados a <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No puede ser una clave `null`, pero puede ser un valor.  
  
 Un objeto que no tiene ninguna correlación entre su estado y su valor de código hash debe general no se utiliza como clave. Por ejemplo, objetos de cadena son mejores que los objetos StringBuilder para su uso como claves.  
  
 También puede usar el <xref:System.Collections.Hashtable.Item%2A> propiedad para agregar nuevos elementos estableciendo el valor de una clave que no existe en el <xref:System.Collections.Hashtable>; por ejemplo, `myCollection["myNonexistentKey"] = myValue`. Sin embargo, si la clave especificada ya existe en el <xref:System.Collections.Hashtable>, y establece el <xref:System.Collections.Hashtable.Item%2A> propiedad sobrescribe el valor anterior. En cambio, la <xref:System.Collections.Hashtable.Add%2A> método no modifica los elementos existentes.  
  
 Si <xref:System.Collections.Hashtable.Count%2A> es menor que la capacidad de la <xref:System.Collections.Hashtable>, este método es una operación o (1). Si la capacidad debe aumentarse para alojar el nuevo elemento, este método se convierte en una O (`n`) operación, donde `n` es <xref:System.Collections.Hashtable.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo agregar elementos a la <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ya existe un elemento con la misma clave en <see cref="T:System.Collections.Hashtable" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.Hashtable" /> es de solo lectura.  
  
 O bien  
  
 <see cref="T:System.Collections.Hashtable" /> tiene un tamaño fijo.</exception>
        <altmember cref="M:System.Collections.Hashtable.Remove(System.Object)" />
        <altmember cref="P:System.Collections.Hashtable.Item(System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los elementos de <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Hashtable.Count%2A> está establecido en cero, y también se liberan las referencias a otros objetos desde los elementos de la colección. La capacidad permanece sin cambios.  
  
 Este método es una O (`n`) operación, donde `n` es <xref:System.Collections.Hashtable.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo borrar los valores de la <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.Hashtable" /> es de solo lectura.</exception>
        <altmember cref="M:System.Collections.IDictionary.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia superficial de la colección <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>Copia superficial de la colección <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una copia superficial de una colección copia únicamente los elementos de la colección, si son tipos de referencia o tipos de valor, pero no copia los objetos que hacen referencia las referencias. Las referencias de la nueva colección apuntan a los mismos objetos que apuntan las referencias de la colección original.  
  
 En cambio, una copia en profundidad de una colección copia los elementos y todo lo que hacen referencia directa o indirectamente el elementos.  
  
 El <xref:System.Collections.Hashtable> duplicado tiene el mismo número, la misma capacidad, la misma <xref:System.Collections.IHashCodeProvider> implementación y el mismo <xref:System.Collections.IComparer> implementación que el original <xref:System.Collections.Hashtable>.  
  
 Este método es una O (`n`) operación, donde `n` es <xref:System.Collections.Hashtable.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="comparer">
      <MemberSignature Language="C#" Value="protected System.Collections.IComparer comparer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IComparer comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.comparer" />
      <MemberSignature Language="VB.NET" Value="Protected Property comparer As IComparer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IComparer ^ comparer { System::Collections::IComparer ^ get(); void set(System::Collections::IComparer ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use KeyComparer properties.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Collections.IComparer" /> que se usará para <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>
          <see cref="T:System.Collections.IComparer" /> que se va a usar para <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La propiedad está establecida en un valor, pero la tabla hash se creó utilizando una interfaz <see cref="T:System.Collections.IEqualityComparer" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clave que se buscará en <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Determina si <see cref="T:System.Collections.Hashtable" /> contiene una clave específica.</summary>
        <returns>
          <see langword="true" /> si la colección <see cref="T:System.Collections.Hashtable" /> contiene un elemento con la clave especificada; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Hashtable.Contains%2A> implementa <xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType>. Se comporta exactamente igual que <xref:System.Collections.Hashtable.ContainsKey%2A>.  
  
 Este método es una operación o (1).  
  
 A partir de .NET Framework 2.0, este método usa los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si existe cualquier elemento. En las versiones anteriores de .NET Framework, esta determinación se realizó utilizando el <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo determinar si la <xref:System.Collections.Hashtable> contiene un elemento específico.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsKey (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clave que se buscará en <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Determina si <see cref="T:System.Collections.Hashtable" /> contiene una clave específica.</summary>
        <returns>
          <see langword="true" /> si la colección <see cref="T:System.Collections.Hashtable" /> contiene un elemento con la clave especificada; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se comporta exactamente como <xref:System.Collections.Hashtable.Contains%2A>.  
  
 Este método es una operación o (1).  
  
 A partir de .NET Framework 2.0, este método usa los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si existe cualquier elemento. En las versiones anteriores de .NET Framework, esta determinación se realizó utilizando el <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo determinar si la <xref:System.Collections.Hashtable> contiene un elemento específico.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Hashtable.Contains(System.Object)" />
        <altmember cref="M:System.Collections.Hashtable.ContainsValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public virtual bool ContainsValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.ContainsValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsValue(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a buscar en la colección <see cref="T:System.Collections.Hashtable" />. El valor puede ser <see langword="null" />.</param>
        <summary>Determina si <see cref="T:System.Collections.Hashtable" /> contiene un valor específico.</summary>
        <returns>
          Es <see langword="true" /> si <see cref="T:System.Collections.Hashtable" /> contiene un elemento con <paramref name="value" /> especificado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los valores de los elementos de la <xref:System.Collections.Hashtable> se comparan con el valor especificado mediante el <xref:System.Object.Equals%2A?displayProperty=nameWithType> método.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es una O (`n`) operación, donde `n` es <xref:System.Collections.Hashtable.Count%2A>.  
  
 A partir de .NET Framework 2.0, este método usa los objetos de la colección <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos en `item` para determinar si existe cualquier elemento. En las versiones anteriores de .NET Framework, esta determinación se realizó utilizando el <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo determinar si la <xref:System.Collections.Hashtable> contiene un elemento específico.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional que constituye el destino de los objetos <see cref="T:System.Collections.DictionaryEntry" /> copiados de <see cref="T:System.Collections.Hashtable" />. La matriz <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
        <param name="arrayIndex">Índice de base cero de <c>array</c> donde comienza la copia.</param>
        <summary>Copia los elementos de <see cref="T:System.Collections.Hashtable" /> a una instancia unidimensional de <see cref="T:System.Array" /> en el índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos se copian en el <xref:System.Array> en el mismo orden en el que el enumerador recorre en iteración la <xref:System.Collections.Hashtable>.  
  
 Para copiar sólo las claves de la <xref:System.Collections.Hashtable>, utilice `Hashtable.Keys.CopyTo`.  
  
 Para copiar sólo los valores de la <xref:System.Collections.Hashtable>, utilice `Hashtable.Values.CopyTo`.  
  
 Este método es una O (`n`) operación, donde `n` es <xref:System.Collections.Hashtable.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo copiar la lista de claves o la lista de valores en un <xref:System.Collections.Hashtable> en un unidimensional <xref:System.Array>.  
  
 [!code-cpp[Classic Hashtable.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> es multidimensional.  
  
 O bien  
  
 El número de elementos de la <see cref="T:System.Collections.Hashtable" /> de origen es mayor que el espacio disponible desde <paramref name="arrayIndex" /> hasta el final de la <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.InvalidCastException">El tipo de la <see cref="T:System.Collections.Hashtable" /> de origen no puede convertirse automáticamente al tipo de la <paramref name="array" /> de destino.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.Hashtable.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de pares clave-valor incluidos en <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>Número de pares clave-valor incluidos en <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualityComparer">
      <MemberSignature Language="C#" Value="protected System.Collections.IEqualityComparer EqualityComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEqualityComparer EqualityComparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.EqualityComparer" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property EqualityComparer As IEqualityComparer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IEqualityComparer ^ EqualityComparer { System::Collections::IEqualityComparer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEqualityComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el <see cref="T:System.Collections.IEqualityComparer" /> que se va a utilizar para <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>
          <see cref="T:System.Collections.IEqualityComparer" /> que se va a usar para <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.IEqualityComparer> incluye el comparador y el proveedor de código hash. Si un <xref:System.Collections.IEqualityComparer> se utiliza en el <xref:System.Collections.Hashtable> constructor, los objetos utilizados como claves en el <xref:System.Collections.Hashtable> no es necesario que invalide la <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> y <xref:System.Object.Equals%2A?displayProperty=nameWithType> métodos.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La propiedad está establecida en un valor, pero la tabla hash se creó utilizando un <see cref="T:System.Collections.IHashCodeProvider" /> y un <see cref="T:System.Collections.IComparer" />.</exception>
        <altmember cref="T:System.Collections.Comparer" />
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Collections.IDictionaryEnumerator" /> que itera a través del objeto <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>Estructura <see cref="T:System.Collections.IDictionaryEnumerator" /> para la colección <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 La instrucción `foreach` del lenguaje C# (`for each` en Visual Basic) oculta la complejidad de los enumeradores.  Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. <xref:System.Collections.IEnumerator.Reset%2A> también devuelve el enumerador a esta posición.  En esta posición, el valor de propiedad <xref:System.Collections.IEnumerator.Current%2A> está sin definir. Por lo tanto, debe llamar a <xref:System.Collections.IEnumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A> o a <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.IEnumerator.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`. Mientras el enumerador permanezca en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.IEnumerator.Current%2A> no está definido. Para volver a establecer el valor de <xref:System.Collections.IEnumerator.Current%2A> en el primer elemento de la colección, se puede llamar primero a <xref:System.Collections.IEnumerator.Reset%2A> y después a <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumerador es válido mientras la colección no cambie. Si se hacen cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado permanentemente y su comportamiento es indefinido.  
  
 La enumeración en una colección no es un procedimiento seguro para subprocesos ya que el enumerador carece de acceso exclusivo.  A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 Este método es una operación o (1).  
  
 Dado que serializar y deserializar un enumerador para una <xref:System.Collections.Hashtable> puede hacer que los elementos que se van a ordenar de nuevo se convierten en, no es posible continuar la enumeración sin llamar a la <xref:System.Collections.IEnumerator.Reset%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se compara el uso de <xref:System.Collections.Hashtable.GetEnumerator%2A> y `foreach` para enumerar el contenido de un <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Hashtable Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable Example/CS/source2.cs#2)]
 [!code-vb[Classic Hashtable Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable Example/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetHash">
      <MemberSignature Language="C#" Value="protected virtual int GetHash (object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 GetHash(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetHash(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetHash (key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int GetHash(System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Object" /> para el que se va a devolver un código hash.</param>
        <summary>Devuelve el código hash de la clave especificada.</summary>
        <returns>Código hash de <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se creó la tabla hash con un valor concreto <xref:System.Collections.IHashCodeProvider> implementación, este método utiliza ese proveedor de código hash; en caso contrario, utiliza el <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> implementación de `key`.  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="key" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.Collections.IHashCodeProvider" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene la información necesaria para serializar el <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="context">Objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene el origen y el destino de la secuencia serializada asociada al <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Implementa la interfaz de <see cref="T:System.Runtime.Serialization.ISerializable" /> y devuelve los datos necesarios para serializar <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una O (`n`) operación, donde `n` es <xref:System.Collections.Hashtable.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se modificó la colección.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="hcp">
      <MemberSignature Language="C#" Value="protected System.Collections.IHashCodeProvider hcp { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IHashCodeProvider hcp" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.hcp" />
      <MemberSignature Language="VB.NET" Value="Protected Property hcp As IHashCodeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IHashCodeProvider ^ hcp { System::Collections::IHashCodeProvider ^ get(); void set(System::Collections::IHashCodeProvider ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use EqualityComparer property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IHashCodeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto que puede dispensar códigos hash.</summary>
        <value>Objeto que puede dispensar códigos hash.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La propiedad está establecida en un valor, pero la tabla hash se creó utilizando una interfaz <see cref="T:System.Collections.IEqualityComparer" />.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la interfaz <see cref="T:System.Collections.Hashtable" /> tiene un tamaño fijo.</summary>
        <value>
          Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.Hashtable" /> tiene un tamaño fijo; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una colección de tamaño fijo no permite agregar o quitar elementos una vez que se ha creado, pero sí permite modificar los elementos existentes.  
  
 Una colección con un tamaño fijo es simplemente una colección con un contenedor que impide agregar y quitar elementos; por lo tanto, si se realizan cambios en la colección subyacente, incluida la adición o eliminación de elementos, la colección de tamaño fijo refleja esos cambios.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Collections.Hashtable" /> es de solo lectura.</summary>
        <value>
          Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.Hashtable" /> es de solo lectura; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una colección de solo lectura no permite que se agreguen, quiten o modifiquen elementos una vez que se ha creado.  
  
 Una colección que es de solo lectura es simplemente una colección con un contenedor que impide modificar la colección; por lo tanto, si se realizan cambios en la colección subyacente, la colección de solo lectura refleja esos cambios.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el acceso a la interfaz <see cref="T:System.Collections.Hashtable" /> está sincronizado (es seguro para subprocesos).</summary>
        <value>
          Es <see langword="true" /> si el acceso a <see cref="T:System.Collections.Hashtable" /> está sincronizado (es seguro para subprocesos); de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Collections.Hashtable> puede admitir un escritor y varios lectores simultáneamente. Para admitir varios sistemas de escritura, todas las operaciones deben realizarse a través del contenedor devuelto por el <xref:System.Collections.Hashtable.Synchronized%2A> método.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
 En el ejemplo de código siguiente se muestra cómo bloquear la colección utilizando el <xref:System.Collections.Hashtable.SyncRoot%2A> durante toda la enumeración:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo sincronizar un <xref:System.Collections.Hashtable>, determinar si un <xref:System.Collections.Hashtable> se sincronizan y usar un sincronizada <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
        <altmember cref="P:System.Collections.Hashtable.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clave cuyo valor se va a obtener o a establecer.</param>
        <summary>Obtiene o establece el valor asociado a la clave especificada.</summary>
        <value>Valor asociado a la clave especificada. Si no se encuentra la clave especificada, al intentar obtenerla se devuelve <see langword="null" /> y al intentar establecerla se crea una nueva entrada con la clave especificada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad permite obtener acceso a un elemento específico de la colección utilizando la sintaxis siguiente: `myCollection[key]`.  
  
 También puede usar el <xref:System.Collections.Hashtable.Item%2A> propiedad para agregar nuevos elementos estableciendo el valor de una clave que no existe en el <xref:System.Collections.Hashtable>; por ejemplo, `myCollection["myNonexistentKey"] = myValue`. Sin embargo, si la clave especificada ya existe en el <xref:System.Collections.Hashtable>, y establece el <xref:System.Collections.Hashtable.Item%2A> propiedad sobrescribe el valor anterior. En cambio, la <xref:System.Collections.Hashtable.Add%2A> método no modifica los elementos existentes.  
  
 No puede ser una clave `null`, pero puede ser un valor. Para distinguir entre `null` que se devuelve porque no se encuentra la clave especificada y `null` que se devuelve porque el valor de la clave especificada es `null`, use la <xref:System.Collections.Hashtable.Contains%2A> método o la <xref:System.Collections.Hashtable.ContainsKey%2A> método para determinar si la clave existe en la lista.  
  
 La recuperación del valor de esta propiedad es una operación o (1); establecer la propiedad también es una operación o (1).  
  
 El lenguaje C# utiliza la palabra clave para definir los indizadores en lugar de implementar la <xref:System.Collections.IList.Item%2A> propiedad. Visual Basic implementa <xref:System.Collections.Hashtable.Item%2A> como propiedad predeterminada, lo que proporciona la misma funcionalidad de indización.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La propiedad está establecida y <see cref="T:System.Collections.Hashtable" /> es de solo lectura.  
  
 O bien  
  
 La propiedad está establecida, <paramref name="key" /> no existe en la colección y el objeto <see cref="T:System.Collections.Hashtable" /> tiene un tamaño fijo.</exception>
        <altmember cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="KeyEquals">
      <MemberSignature Language="C#" Value="protected virtual bool KeyEquals (object item, object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool KeyEquals(object item, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function KeyEquals (item As Object, key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool KeyEquals(System::Object ^ item, System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Object" /> que se va a comparar con <c>key</c>.</param>
        <param name="key">Clave de <see cref="T:System.Collections.Hashtable" /> que se va a comparar con <c>item</c>.</param>
        <summary>Compara un <see cref="T:System.Object" /> específico con una clave concreta en <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="item" /> y <paramref name="key" /> son iguales; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se creó la tabla hash con un valor concreto <xref:System.Collections.IComparer> implementación, este método utiliza ese comparador; es decir, <xref:System.Collections.IComparer.Compare%2A> (`item`, `key`). De lo contrario, usa `item.Equals(key)`.  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="key" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Collections.IComparer.Compare(System.Object,System.Object)" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un <see cref="T:System.Collections.ICollection" /> que contiene las claves de <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> que contiene las claves de <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El orden de las claves de la <xref:System.Collections.ICollection> no está especificado, pero es el mismo orden que los valores asociados en la <xref:System.Collections.ICollection> devuelto por la <xref:System.Collections.Hashtable.Values%2A> método.  
  
 El valor devuelto <xref:System.Collections.ICollection> no es una copia estática; en su lugar, el <xref:System.Collections.ICollection> hace referencia a las claves de la versión original <xref:System.Collections.Hashtable>. Por consiguiente, los cambios a la <xref:System.Collections.Hashtable> continuarán reflejarse en el <xref:System.Collections.ICollection>.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Hashtable.Values" />
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">Origen del evento de deserialización.</param>
        <summary>Implementa la interfaz <see cref="T:System.Runtime.Serialization.ISerializable" /> y genera el evento de deserialización cuando esta ha finalizado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una O (`n`) operación, donde `n` es <xref:System.Collections.Hashtable.Count%2A>.  
  
 Dado que serializar y deserializar un enumerador para una <xref:System.Collections.Hashtable> puede hacer que los elementos que se van a ordenar de nuevo se convierten en, no es posible continuar la enumeración sin llamar a la <xref:System.Collections.IEnumerator.Reset%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">El objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> asociado a la <see cref="T:System.Collections.Hashtable" /> actual no es válido.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clave del elemento que se va a quitar.</param>
        <summary>Quita el elemento con la clave especificada de <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Collections.Hashtable> no contiene un elemento con la clave especificada, el <xref:System.Collections.Hashtable> permanece sin cambios. No se inicia ninguna excepción.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo quitar elementos de la <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.Hashtable" /> es de solo lectura.  
  
 O bien  
  
 <see cref="T:System.Collections.Hashtable" /> tiene un tamaño fijo.</exception>
        <altmember cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.Hashtable Synchronized (System.Collections.Hashtable table);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Hashtable Synchronized(class System.Collections.Hashtable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (table As Hashtable) As Hashtable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Hashtable ^ Synchronized(System::Collections::Hashtable ^ table);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Collections.Hashtable" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Collections.Hashtable" /> que se va a sincronizar.</param>
        <summary>Devuelve un contenedor sincronizado (seguro para subprocesos) para el objeto <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>Contenedor sincronizado (seguro para subprocesos) para el objeto <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.Hashtable.Synchronized%2A> método es seguro para varios lectores y escritores de subprocesos. Además, el contenedor sincronizado garantiza que hay solo un escritor de escritura a la vez.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
 En el ejemplo de código siguiente se muestra cómo bloquear la colección utilizando el <xref:System.Collections.Hashtable.SyncRoot%2A> durante toda la enumeración:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo sincronizar un <xref:System.Collections.Hashtable>, determinar si un <xref:System.Collections.Hashtable> se sincronizan y usar un sincronizada <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="table" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.Hashtable.IsSynchronized" />
        <altmember cref="P:System.Collections.Hashtable.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>Objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para crear una versión sincronizada de la <xref:System.Collections.Hashtable>, use el <xref:System.Collections.Hashtable.Synchronized%2A> método. Sin embargo, las clases derivadas pueden proporcionar su propia versión sincronizada de la <xref:System.Collections.Hashtable> mediante el <xref:System.Collections.Hashtable.SyncRoot%2A> propiedad. El código de sincronización debe realizar las operaciones en el <xref:System.Collections.Hashtable.SyncRoot%2A> de la <xref:System.Collections.Hashtable>y no directamente en el <xref:System.Collections.Hashtable> . De este modo, se garantiza el funcionamiento correcto de las colecciones derivadas de otros objetos. En concreto, mantiene la sincronización correcta con otros subprocesos que podrían modificar al mismo tiempo la <xref:System.Collections.Hashtable> objeto.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
 En el ejemplo de código siguiente se muestra cómo bloquear la colección utilizando el <xref:System.Collections.Hashtable.SyncRoot%2A> durante toda la enumeración:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Hashtable.IsSynchronized" />
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> que se puede utilizar para recorrer en iteración la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 La instrucción `foreach` del lenguaje C# (`for each` en Visual Basic) oculta la complejidad de los enumeradores.  Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. <xref:System.Collections.IEnumerator.Reset%2A> también devuelve el enumerador a esta posición. En esta posición, al llamar a <xref:System.Collections.IEnumerator.Current%2A> produce una excepción. Por lo tanto, debe llamar a <xref:System.Collections.IEnumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A> o a <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.IEnumerator.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`. Mientras el enumerador permanezca en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, si se llama <xref:System.Collections.IEnumerator.Current%2A> produce una excepción. Para volver a establecer el valor de <xref:System.Collections.IEnumerator.Current%2A> en el primer elemento de la colección, se puede llamar primero a <xref:System.Collections.IEnumerator.Reset%2A> y después a <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumerador es válido mientras la colección no cambie. Si se realizan cambios en la colección, como agregar, modificar, o eliminar elementos, el enumerador se puede invalidar y la siguiente llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> produce una <xref:System.InvalidOperationException>. Si la colección se modifica entre <xref:System.Collections.IEnumerator.MoveNext%2A> y <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> devuelve el elemento que está establecido, aunque el enumerador ya haya quedado invalidado.  
  
 La enumeración en una colección no es un procedimiento seguro para subprocesos ya que el enumerador carece de acceso exclusivo. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Values" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una interfaz <see cref="T:System.Collections.ICollection" /> que contiene los valores de la interfaz <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> que contiene los valores de <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El orden de los valores de la <xref:System.Collections.ICollection> no está especificado, pero es el mismo orden que las claves asociadas en la <xref:System.Collections.ICollection> devuelto por la <xref:System.Collections.Hashtable.Keys%2A> método.  
  
 El valor devuelto <xref:System.Collections.ICollection> no es una copia estática; en su lugar, el <xref:System.Collections.ICollection> hace referencia a los valores de la versión original <xref:System.Collections.Hashtable>. Por consiguiente, los cambios a la <xref:System.Collections.Hashtable> continuarán reflejarse en el <xref:System.Collections.ICollection>.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Hashtable.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>