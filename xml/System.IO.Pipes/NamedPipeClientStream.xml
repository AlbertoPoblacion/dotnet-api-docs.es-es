<Type Name="NamedPipeClientStream" FullName="System.IO.Pipes.NamedPipeClientStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="145ed8417b729beaf7802c52d9b3f51577c3b254" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30419889" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class NamedPipeClientStream : System.IO.Pipes.PipeStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NamedPipeClientStream extends System.IO.Pipes.PipeStream" />
  <TypeSignature Language="DocId" Value="T:System.IO.Pipes.NamedPipeClientStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NamedPipeClientStream&#xA;Inherits PipeStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NamedPipeClientStream sealed : System::IO::Pipes::PipeStream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Pipes</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Pipes.PipeStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Expone un <see cref="T:System.IO.Stream" /> alrededor de una canalización con nombre, que admite operaciones de lectura y escritura sincrónica y asincrónica.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Canalizaciones con nombre permiten canalizaciones unidireccionales o bidireccionales para la comunicación entre un servidor de canalización y uno o más clientes de canalización. Canalizaciones con nombre se pueden utilizar para la comunicación entre procesos localmente o a través de una red. Una única canalización con nombre puede compartirse entre varios <xref:System.IO.Pipes.NamedPipeClientStream> objetos.  
  
 Cualquier proceso puede actuar como un servidor de canalización con nombre o cliente o ambos.  
  
> [!NOTE]
>  Para [!INCLUDE[winxppro](~/includes/winxppro-md.md)] y [!INCLUDE[win2kserver](~/includes/win2kserver-md.md)], un máximo de 10 canalizaciones puede conectarse simultáneamente a través de la red.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra una manera de enviar una cadena de un proceso primario a un proceso secundario en el mismo equipo con canalizaciones con nombre. Este ejemplo se crea un <xref:System.IO.Pipes.NamedPipeServerStream> objeto en un proceso primario. El <xref:System.IO.Pipes.NamedPipeServerStream> objeto tiene una <xref:System.IO.Pipes.PipeDirection> valo <xref:System.IO.Pipes.PipeDirection.Out>. El servidor, a continuación, espera un <xref:System.IO.Pipes.NamedPipeClientStream> objeto en un proceso secundario para conectarse a ella. En este ejemplo, ambos procesos se encuentran en el mismo equipo y la <xref:System.IO.Pipes.NamedPipeClientStream> objeto tiene una <xref:System.IO.Pipes.PipeDirection> valo <xref:System.IO.Pipes.PipeDirection.In>. El proceso primario envía a continuación una cadena proporcionada por usuario al proceso secundario. La cadena se muestra en la consola.  
  
 En este ejemplo es para el proceso de cliente, que se conecta al proceso del servidor. Para el ejemplo de código completo, incluido el código para el cliente de la canalización y el servidor, consulte [Cómo: uso de canalizaciones con nombre para la comunicación de red entre procesos](~/docs/standard/io/how-to-use-named-pipes-for-network-interprocess-communication.md).  
  
 [!code-csharp[System.IO.Pipes.NamedPipeClientStream_Sample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeClientStream_Sample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeClientStream_Sample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeClientStream_Sample1/vb/program.vb#01)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Pipes.NamedPipeClientStream" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeClientStream (string pipeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeClientStream.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeClientStream(System::String ^ pipeName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pipeName">Nombre de la canalización.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> con el nombre de canalización especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor utiliza los siguientes valores predeterminados:  
  
-   Nombre de servidor predeterminado ".".  
  
-   Valor predeterminado es <xref:System.IO.Pipes.PipeDirection> valo <xref:System.IO.Pipes.PipeDirection.InOut>.  
  
-   Valor predeterminado es <xref:System.IO.Pipes.PipeOptions> valo <xref:System.IO.Pipes.PipeOptions.None>.  
  
-   Valor predeterminado es <xref:System.Security.Principal.TokenImpersonationLevel> valo <xref:System.Security.Principal.TokenImpersonationLevel.None>.  
  
-   Valor predeterminado es <xref:System.IO.HandleInheritability> valo <xref:System.IO.HandleInheritability.None>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> es una cadena de longitud cero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> se establece en "anónimo".</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeClientStream (string serverName, string pipeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string serverName, string pipeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeClientStream.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (serverName As String, pipeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeClientStream(System::String ^ serverName, System::String ^ pipeName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serverName" Type="System.String" />
        <Parameter Name="pipeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="serverName">Nombre del equipo remoto al que se va a conectar; o bien, "." para especificar el equipo local.</param>
        <param name="pipeName">Nombre de la canalización.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> con los nombres de canalización y servidor especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor utiliza los siguientes valores predeterminados:  
  
-   Valor predeterminado es <xref:System.IO.Pipes.PipeDirection> valo <xref:System.IO.Pipes.PipeDirection.InOut>.  
  
-   Valor predeterminado es <xref:System.IO.Pipes.PipeOptions> valo <xref:System.IO.Pipes.PipeOptions.None>.  
  
-   Valor predeterminado es <xref:System.Security.Principal.TokenImpersonationLevel> valo <xref:System.Security.Principal.TokenImpersonationLevel.None>.  
  
-   Valor predeterminado es <xref:System.IO.HandleInheritability> valo <xref:System.IO.HandleInheritability.None>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="pipeName" /> o <paramref name="serverName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> o <paramref name="serverName" /> es una cadena de longitud cero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> se establece en "anónimo".</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeClientStream (string serverName, string pipeName, System.IO.Pipes.PipeDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string serverName, string pipeName, valuetype System.IO.Pipes.PipeDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeClientStream.#ctor(System.String,System.String,System.IO.Pipes.PipeDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (serverName As String, pipeName As String, direction As PipeDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeClientStream(System::String ^ serverName, System::String ^ pipeName, System::IO::Pipes::PipeDirection direction);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serverName" Type="System.String" />
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
      </Parameters>
      <Docs>
        <param name="serverName">Nombre del equipo remoto al que se va a conectar; o bien, "." para especificar el equipo local.</param>
        <param name="pipeName">Nombre de la canalización.</param>
        <param name="direction">Uno de los valores de enumeración que determina la dirección de la canalización.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> con los nombres de canalización y servidor especificados y la dirección de canalización especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor utiliza los siguientes valores predeterminados:  
  
-   Valor predeterminado es <xref:System.IO.Pipes.PipeOptions> valo <xref:System.IO.Pipes.PipeOptions.None>.  
  
-   Valor predeterminado es <xref:System.Security.Principal.TokenImpersonationLevel> valo <xref:System.Security.Principal.TokenImpersonationLevel.None>.  
  
-   Valor predeterminado es <xref:System.IO.HandleInheritability> valo <xref:System.IO.HandleInheritability.None>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un método para enviar una cadena de un proceso primario a un proceso secundario mediante canalizaciones con nombre. Este ejemplo se crea un <xref:System.IO.Pipes.NamedPipeClientStream> objeto en un proceso secundario, que, a continuación, se conecta a una canalización en el equipo local. En el ejemplo de servidor puede verse en la <xref:System.IO.Pipes.NamedPipeServerStream> clase. Este ejemplo forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.Pipes.NamedPipeServerStream> y <xref:System.IO.Pipes.NamedPipeClientStream> clases.  
  
 [!code-csharp[System.IO.Pipes.NamedPipeClientStream_Sample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeClientStream_Sample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeClientStream_Sample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeClientStream_Sample1/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="pipeName" /> o <paramref name="serverName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> o <paramref name="serverName" /> es una cadena de longitud cero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> se establece en "anónimo".  
  
 O bien  
  
 <paramref name="direction" /> no es un valor <see cref="T:System.IO.Pipes.PipeDirection" /> válido.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeClientStream (System.IO.Pipes.PipeDirection direction, bool isAsync, bool isConnected, Microsoft.Win32.SafeHandles.SafePipeHandle safePipeHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, bool isAsync, bool isConnected, class Microsoft.Win32.SafeHandles.SafePipeHandle safePipeHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeClientStream.#ctor(System.IO.Pipes.PipeDirection,System.Boolean,System.Boolean,Microsoft.Win32.SafeHandles.SafePipeHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeClientStream(System::IO::Pipes::PipeDirection direction, bool isAsync, bool isConnected, Microsoft::Win32::SafeHandles::SafePipeHandle ^ safePipeHandle);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="isAsync" Type="System.Boolean" />
        <Parameter Name="isConnected" Type="System.Boolean" />
        <Parameter Name="safePipeHandle" Type="Microsoft.Win32.SafeHandles.SafePipeHandle" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de enumeración que determina la dirección de la canalización.</param>
        <param name="isAsync">
          Es <see langword="true" /> para indicar que se abrió el identificador de forma asincrónica; en caso contrario, es <see langword="false" />.</param>
        <param name="isConnected">
          Es <see langword="true" /> para indicar que la canalización está conectada; de lo contrario, es <see langword="false" />.</param>
        <param name="safePipeHandle">Controlador seguro para la canalización que este objeto <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> encapsulará.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> para el identificador de canalización especificado con la dirección de canalización especificada.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="safePipeHandle" /> no es un controlador válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="safePipeHandle" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="direction" /> no es un valor <see cref="T:System.IO.Pipes.PipeDirection" /> válido.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeClientStream (string serverName, string pipeName, System.IO.Pipes.PipeDirection direction, System.IO.Pipes.PipeOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string serverName, string pipeName, valuetype System.IO.Pipes.PipeDirection direction, valuetype System.IO.Pipes.PipeOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeClientStream.#ctor(System.String,System.String,System.IO.Pipes.PipeDirection,System.IO.Pipes.PipeOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (serverName As String, pipeName As String, direction As PipeDirection, options As PipeOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeClientStream(System::String ^ serverName, System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, System::IO::Pipes::PipeOptions options);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serverName" Type="System.String" />
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
      </Parameters>
      <Docs>
        <param name="serverName">Nombre del equipo remoto al que se va a conectar; o bien, "." para especificar el equipo local.</param>
        <param name="pipeName">Nombre de la canalización.</param>
        <param name="direction">Uno de los valores de enumeración que determina la dirección de la canalización.</param>
        <param name="options">Uno de los valores de enumeración que determina cómo abrir o crear la canalización.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> con los nombres de canalización y servidor especificados, y la dirección y opciones de canalización especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor utiliza los siguientes valores predeterminados:  
  
-   Valor predeterminado es <xref:System.Security.Principal.TokenImpersonationLevel> valo <xref:System.Security.Principal.TokenImpersonationLevel.None>.  
  
-   Valor predeterminado es <xref:System.IO.HandleInheritability> valo <xref:System.IO.HandleInheritability.None>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="pipeName" /> o <paramref name="serverName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> o <paramref name="serverName" /> es una cadena de longitud cero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> se establece en "anónimo".  
  
 O bien  
  
 <paramref name="direction" /> no es un valor <see cref="T:System.IO.Pipes.PipeDirection" /> válido.  
  
 O bien  
  
 <paramref name="options" /> no es un valor <see cref="T:System.IO.Pipes.PipeOptions" /> válido.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeClientStream (string serverName, string pipeName, System.IO.Pipes.PipeDirection direction, System.IO.Pipes.PipeOptions options, System.Security.Principal.TokenImpersonationLevel impersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string serverName, string pipeName, valuetype System.IO.Pipes.PipeDirection direction, valuetype System.IO.Pipes.PipeOptions options, valuetype System.Security.Principal.TokenImpersonationLevel impersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeClientStream.#ctor(System.String,System.String,System.IO.Pipes.PipeDirection,System.IO.Pipes.PipeOptions,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (serverName As String, pipeName As String, direction As PipeDirection, options As PipeOptions, impersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeClientStream(System::String ^ serverName, System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, System::IO::Pipes::PipeOptions options, System::Security::Principal::TokenImpersonationLevel impersonationLevel);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serverName" Type="System.String" />
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
        <Parameter Name="impersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="serverName">Nombre del equipo remoto al que se va a conectar; o bien, "." para especificar el equipo local.</param>
        <param name="pipeName">Nombre de la canalización.</param>
        <param name="direction">Uno de los valores de enumeración que determina la dirección de la canalización.</param>
        <param name="options">Uno de los valores de enumeración que determina cómo abrir o crear la canalización.</param>
        <param name="impersonationLevel">Uno de los valores de enumeración que determina el nivel de suplantación de seguridad.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> con los nombres de canalización y servidor especificados, y las características dirección de canalización, opciones de canalización y nivel de suplantación de seguridad especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor utiliza el valor predeterminado es <xref:System.IO.HandleInheritability> valo <xref:System.IO.HandleInheritability.None>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="pipeName" /> o <paramref name="serverName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> o <paramref name="serverName" /> es una cadena de longitud cero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> se establece en "anónimo".  
  
 O bien  
  
 <paramref name="direction" /> no es un valor <see cref="T:System.IO.Pipes.PipeDirection" /> válido.  
  
 O bien  
  
 <paramref name="options" /> no es un valor <see cref="T:System.IO.Pipes.PipeOptions" /> válido.  
  
 O bien  
  
 <paramref name="impersonationLevel" /> no es un valor <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> válido.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeClientStream (string serverName, string pipeName, System.IO.Pipes.PipeAccessRights desiredAccessRights, System.IO.Pipes.PipeOptions options, System.Security.Principal.TokenImpersonationLevel impersonationLevel, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string serverName, string pipeName, valuetype System.IO.Pipes.PipeAccessRights desiredAccessRights, valuetype System.IO.Pipes.PipeOptions options, valuetype System.Security.Principal.TokenImpersonationLevel impersonationLevel, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeClientStream.#ctor(System.String,System.String,System.IO.Pipes.PipeAccessRights,System.IO.Pipes.PipeOptions,System.Security.Principal.TokenImpersonationLevel,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (serverName As String, pipeName As String, desiredAccessRights As PipeAccessRights, options As PipeOptions, impersonationLevel As TokenImpersonationLevel, inheritability As HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeClientStream(System::String ^ serverName, System::String ^ pipeName, System::IO::Pipes::PipeAccessRights desiredAccessRights, System::IO::Pipes::PipeOptions options, System::Security::Principal::TokenImpersonationLevel impersonationLevel, System::IO::HandleInheritability inheritability);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serverName" Type="System.String" />
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="desiredAccessRights" Type="System.IO.Pipes.PipeAccessRights" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
        <Parameter Name="impersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="serverName">Nombre del equipo remoto al que se va a conectar; o bien, "." para especificar el equipo local.</param>
        <param name="pipeName">Nombre de la canalización.</param>
        <param name="desiredAccessRights">Uno de los valores de enumeración que especifica los derechos de acceso deseados de la canalización.</param>
        <param name="options">Uno de los valores de enumeración que determina cómo abrir o crear la canalización.</param>
        <param name="impersonationLevel">Uno de los valores de enumeración que determina el nivel de suplantación de seguridad.</param>
        <param name="inheritability">Uno de los valores de enumeración que determina si los procesos secundarios van a poder heredar el identificador subyacente.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> con los nombres de canalización y servidor especificados, y las características opciones de canalización, nivel de suplantación de seguridad y modo de herencia especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La dirección de canalización para este constructor viene determinada por la `desiredAccessRights` parámetro. Si el `desiredAccessRights` valor es <xref:System.IO.Pipes.PipeAccessRights.ReadData>, será la dirección de canalización <xref:System.IO.Pipes.PipeDirection.In>. Si el valor de `desiredAccessRights` es <xref:System.IO.Pipes.PipeAccessRights.WriteData>, será la dirección de canalización <xref:System.IO.Pipes.PipeDirection.Out>. Si el valor de `desiredAccessRights` incluye tanto <xref:System.IO.Pipes.PipeAccessRights.ReadData> y <xref:System.IO.Pipes.PipeAccessRights.WriteData>, será la dirección de canalización <xref:System.IO.Pipes.PipeDirection.InOut>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="pipeName" /> o <paramref name="serverName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> o <paramref name="serverName" /> es una cadena de longitud cero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> se establece en "anónimo".  
  
 O bien  
  
 <paramref name="options" /> no es un valor <see cref="T:System.IO.Pipes.PipeOptions" /> válido.  
  
 O bien  
  
 <paramref name="impersonationLevel" /> no es un valor <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> válido.  
  
 O bien  
  
 <paramref name="inheritability" /> no es un valor <see cref="T:System.IO.HandleInheritability" /> válido.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeClientStream (string serverName, string pipeName, System.IO.Pipes.PipeDirection direction, System.IO.Pipes.PipeOptions options, System.Security.Principal.TokenImpersonationLevel impersonationLevel, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string serverName, string pipeName, valuetype System.IO.Pipes.PipeDirection direction, valuetype System.IO.Pipes.PipeOptions options, valuetype System.Security.Principal.TokenImpersonationLevel impersonationLevel, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeClientStream.#ctor(System.String,System.String,System.IO.Pipes.PipeDirection,System.IO.Pipes.PipeOptions,System.Security.Principal.TokenImpersonationLevel,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (serverName As String, pipeName As String, direction As PipeDirection, options As PipeOptions, impersonationLevel As TokenImpersonationLevel, inheritability As HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeClientStream(System::String ^ serverName, System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, System::IO::Pipes::PipeOptions options, System::Security::Principal::TokenImpersonationLevel impersonationLevel, System::IO::HandleInheritability inheritability);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serverName" Type="System.String" />
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
        <Parameter Name="impersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="serverName">Nombre del equipo remoto al que se va a conectar; o bien, "." para especificar el equipo local.</param>
        <param name="pipeName">Nombre de la canalización.</param>
        <param name="direction">Uno de los valores de enumeración que determina la dirección de la canalización.</param>
        <param name="options">Uno de los valores de enumeración que determina cómo abrir o crear la canalización.</param>
        <param name="impersonationLevel">Uno de los valores de enumeración que determina el nivel de suplantación de seguridad.</param>
        <param name="inheritability">Uno de los valores de enumeración que determina si los procesos secundarios van a poder heredar el identificador subyacente.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> con los nombres de canalización y servidor especificados, y las características dirección de canalización, opciones de canalización, nivel de suplantación de seguridad y modo de herencia especificadas.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="pipeName" /> o <paramref name="serverName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> o <paramref name="serverName" /> es una cadena de longitud cero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> se establece en "anónimo".  
  
 O bien  
  
 <paramref name="direction" /> no es un valor <see cref="T:System.IO.Pipes.PipeDirection" /> válido.  
  
 O bien  
  
 <paramref name="options" /> no es un valor <see cref="T:System.IO.Pipes.PipeOptions" /> válido.  
  
 O bien  
  
 <paramref name="impersonationLevel" /> no es un valor <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> válido.  
  
 O bien  
  
 <paramref name="inheritability" /> no es un valor <see cref="T:System.IO.HandleInheritability" /> válido.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="CheckPipePropertyOperations">
      <MemberSignature Language="C#" Value="protected internal override void CheckPipePropertyOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void CheckPipePropertyOperations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeClientStream.CheckPipePropertyOperations" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub CheckPipePropertyOperations ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void CheckPipePropertyOperations();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Conecta con un servidor en espera.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeClientStream.Connect" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Conecta a un servidor de espera con un valor de tiempo de espera infinito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método llama a la <xref:System.IO.Pipes.NamedPipeClientStream.Connect%28System.Int32%29> método con un valor de tiempo de espera infinito.  
  
 Este método espera una instancia de canalización esté disponible. <xref:System.IO.Pipes.NamedPipeClientStream.Connect%2A> podría devolver antes <xref:System.IO.Pipes.NamedPipeServerStream.WaitForConnection%2A> se llama desde el <xref:System.IO.Pipes.NamedPipeServerStream> objeto, pero <xref:System.IO.Pipes.NamedPipeServerStream.WaitForConnection%2A> no devolverá hasta <xref:System.IO.Pipes.NamedPipeClientStream.Connect%2A> ha devuelto.  
  
 Los datos escritos en la canalización después un <xref:System.IO.Pipes.NamedPipeClientStream> ha conectado el objeto, pero antes de que el servidor haya llamado <xref:System.IO.Pipes.NamedPipeServerStream.WaitForConnection%2A>, estará disponible para el servidor tras la llamada a <xref:System.IO.Pipes.NamedPipeServerStream.WaitForConnection%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un método para enviar una cadena de un proceso primario a un proceso secundario mediante canalizaciones con nombre. Este ejemplo se crea un <xref:System.IO.Pipes.NamedPipeClientStream> objeto en un proceso secundario, que, a continuación, se conecta a una canalización en el equipo local. En el ejemplo de servidor puede verse en la <xref:System.IO.Pipes.NamedPipeServerStream> clase. Este ejemplo forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.Pipes.NamedPipeServerStream> y <xref:System.IO.Pipes.NamedPipeClientStream> clases.  
  
 [!code-csharp[System.IO.Pipes.NamedPipeClientStream_Sample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeClientStream_Sample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeClientStream_Sample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeClientStream_Sample1/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El cliente ya está conectado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeClientStream.Connect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(int timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">El número de milisegundos a la espera de que el servidor responda antes de que se supere el tiempo de espera de la conexión.</param>
        <summary>Conecta con un servidor de espera dentro del período de tiempo de espera especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método espera una instancia de canalización esté disponible. <xref:System.IO.Pipes.NamedPipeClientStream.Connect%2A> podría devolver antes <xref:System.IO.Pipes.NamedPipeServerStream.WaitForConnection%2A> se llama desde el <xref:System.IO.Pipes.NamedPipeServerStream>, pero <xref:System.IO.Pipes.NamedPipeServerStream.WaitForConnection%2A> no devolverá hasta <xref:System.IO.Pipes.NamedPipeClientStream.Connect%2A> ha devuelto. Establece el `timeout` parámetro <xref:System.Threading.Timeout.Infinite> para especificar un valor de tiempo de espera infinito.  
  
 Los datos escritos en la canalización después un <xref:System.IO.Pipes.NamedPipeClientStream> ha conectado el objeto, pero antes de que el servidor haya llamado <xref:System.IO.Pipes.NamedPipeServerStream.WaitForConnection%2A>, estará disponible para el servidor tras la llamada a <xref:System.IO.Pipes.NamedPipeServerStream.WaitForConnection%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">No se ha podido conectar al servidor en el tiempo de espera especificado por el período <paramref name="timeout" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> es menor que 0 y no se establece en <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <exception cref="T:System.InvalidOperationException">El cliente ya está conectado.</exception>
        <exception cref="T:System.IO.IOException">El servidor se conecta a otro cliente y el tiempo de espera ha expirado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tarea que representa la operación de conexión asincrónica.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeClientStream.ConnectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Conecta de forma asincrónica a un servidor de espera con un período de tiempo de espera infinito.</summary>
        <returns>Tarea que representa la operación de conexión asincrónica.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeClientStream.ConnectAsync(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (timeout As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(int timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">El número de milisegundos a la espera de que el servidor responda antes de que se supere el tiempo de espera de la conexión.</param>
        <summary>Conecta de forma asincrónica a un servidor de espera dentro del período de tiempo de espera especificado.</summary>
        <returns>Tarea que representa la operación de conexión asincrónica.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeClientStream.ConnectAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token para supervisar solicitudes de cancelación. El valor predeterminado es <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Conecta de forma asincrónica a un servidor de espera y supervisa las solicitudes de cancelación.</summary>
        <returns>Tarea que representa la operación de conexión asincrónica.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (int timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(int32 timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeClientStream.ConnectAsync(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(int timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeout">El número de milisegundos a la espera de que el servidor responda antes de que se supere el tiempo de espera de la conexión.</param>
        <param name="cancellationToken">Token para supervisar solicitudes de cancelación. El valor predeterminado es <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Conecta de forma asincrónica a un servidor de espera dentro del período de tiempo de espera especificado y supervisa las solicitudes de cancelación.</summary>
        <returns>Tarea que representa la operación de conexión asincrónica.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~NamedPipeClientStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeClientStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!NamedPipeClientStream ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera recursos no administrados y realiza otras operaciones de limpieza antes de que la recolección de elementos no utilizados reclame la instancia de <see cref="T:System.IO.Pipes.NamedPipeClientStream" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NumberOfServerInstances">
      <MemberSignature Language="C#" Value="public int NumberOfServerInstances { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NumberOfServerInstances" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.NamedPipeClientStream.NumberOfServerInstances" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NumberOfServerInstances As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NumberOfServerInstances { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número máximo de instancias de servidor que comparten el mismo nombre de canalización.</summary>
        <value>El número máximo de instancias de servidor que comparten el mismo nombre de canalización.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el número de instancias del servidor para la <xref:System.IO.Pipes.NamedPipeServerStream> objeto que actual <xref:System.IO.Pipes.NamedPipeClientStream> tiene un identificador de objeto o está conectado a. Si la actual <xref:System.IO.Pipes.NamedPipeClientStream> objeto no se ha conectado a un servidor de canalización con nombre o, si aún no se ha establecido el identificador de canalización actual, esta propiedad produce un <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un método para enviar una cadena de un proceso primario a un proceso secundario mediante canalizaciones con nombre. En este ejemplo, un <xref:System.IO.Pipes.NamedPipeClientStream> objeto se crea en un proceso secundario, que, a continuación, se conecta a una canalización en el equipo local. En el ejemplo de servidor puede verse en la <xref:System.IO.Pipes.NamedPipeServerStream> clase. Este ejemplo forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.Pipes.NamedPipeServerStream> y <xref:System.IO.Pipes.NamedPipeClientStream> clases.  
  
 [!code-csharp[System.IO.Pipes.NamedPipeClientStream_Sample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeClientStream_Sample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeClientStream_Sample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeClientStream_Sample1/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La canalización no se estableció.  
  
 O bien  
  
 El objeto <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> actual no se ha conectado todavía a un objeto <see cref="T:System.IO.Pipes.NamedPipeServerStream" />.</exception>
        <exception cref="T:System.IO.IOException">La canalización se ha roto o se ha producido un error de E/S.</exception>
        <exception cref="T:System.ObjectDisposedException">El controlador de la canalización subyacente está cerrado.</exception>
      </Docs>
    </Member>
  </Members>
</Type>