<Type Name="PipeSecurity" FullName="System.IO.Pipes.PipeSecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="404ad7ec6e9638e0f1a6b3f1c68249e5095307c0" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52237198" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PipeSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PipeSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.IO.Pipes.PipeSecurity" />
  <TypeSignature Language="VB.NET" Value="Public Class PipeSecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class PipeSecurity : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type PipeSecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa el control de acceso y la seguridad de auditoría de una canalización.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.IO.Pipes.PipeSecurity> clase especifica los derechos de acceso para una canalización y cómo se auditan los intentos de acceso.  Esta clase representa los derechos de acceso y auditoría como un conjunto de reglas. Cada regla de acceso se representa mediante un <xref:System.IO.Pipes.PipeAccessRule> objeto, mientras que cada regla de auditoría se representa mediante un <xref:System.IO.Pipes.PipeAuditRule> objeto.  
  
 La <xref:System.IO.Pipes.PipeSecurity> clase es una abstracción del sistema de seguridad de archivos de Microsoft Windows subyacente. En este sistema, cada canalización tiene una lista de control de acceso discrecional (DACL), que controla el acceso a la canalización y una lista de control de acceso del sistema (SACL), que especifica los intentos de control de acceso se auditan.  El <xref:System.IO.Pipes.PipeAccessRule> y <xref:System.IO.Pipes.PipeAuditRule> clases son abstracciones de las entradas de control de acceso (ACE) que comprenden las DACL y las SACL.  
  
 La <xref:System.IO.Pipes.PipeSecurity> clase oculta muchos de los detalles de las DACL y las SACL; que no tiene que preocuparse sobre pedidos de ACE o DACL null.  
  
 Use la <xref:System.IO.Pipes.PipeSecurity> clase para recuperar, agregar o cambiar las reglas de acceso que representan la lista DACL y SACL de una canalización.  
  
 Para conservar el acceso nuevo o modificado o las reglas a una canalización de auditoría, utilice el <xref:System.IO.Pipes.PipeStream.SetAccessControl%2A> método. Para recuperar las reglas de acceso o de auditoría de un archivo existente, utilice el método <xref:System.IO.Pipes.PipeStream.GetAccessControl%2A>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PipeSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PipeSecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Pipes.PipeSecurity" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un valor vacío <xref:System.IO.Pipes.PipeSecurity> objeto que no se basa en una canalización existente. A continuación, puede rellenar el objeto con información de control de acceso y aplicarlo a una canalización.  
  
 Puede agregar acceso o las reglas de auditoría del <xref:System.IO.Pipes.PipeSecurity> objeto utilizando el <xref:System.IO.Pipes.PipeSecurity.AddAccessRule%2A> método. Puede quitar el acceso o uso de las reglas de auditoría del <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> método.  
  
 Para conservar el acceso nuevo o modificado o las reglas a una canalización de auditoría, utilice el <xref:System.IO.Pipes.PipeStream.SetAccessControl%2A> método. Para recuperar las reglas de acceso o de auditoría de un archivo existente, utilice el método <xref:System.IO.Pipes.PipeStream.GetAccessControl%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeSecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.IO.Pipes.PipeSecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el valor de <see cref="T:System.Type" /> del objeto asegurable que está asociado con el objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</summary>
        <value>El tipo del objeto asegurable que está asociado con el objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de la <xref:System.Security.AccessControl.ObjectSecurity> clase invalidación el <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> propiedad y devuelva el tipo que se utilizan para representar los derechos de acceso. Cuando se trabaja con matrices o colecciones que contienen varios tipos de objetos de seguridad, use esta propiedad para determinar el tipo de enumeración correctos para utilizar con cada objeto de seguridad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="abstract member AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule&#xA;override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="pipeSecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">Identidad a la que se aplica la regla de acceso. Debe ser un objeto que permita su conversión al tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</param>
        <param name="accessMask">La máscara de acceso de esta regla. La máscara de acceso es una colección de 32 bits anónimos, cuyo significado está definido por cada uno de sus integrantes.</param>
        <param name="isInherited">Es <see langword="true" /> si esta regla se hereda de un contenedor primario; de lo contrario, es false.</param>
        <param name="inheritanceFlags">Uno de los valores de <see cref="T:System.Security.AccessControl.InheritanceFlags" /> que especifica las propiedades de herencia de la regla de acceso.</param>
        <param name="propagationFlags">Uno de los valores de <see cref="T:System.Security.AccessControl.PropagationFlags" /> que especifica si se propagan automáticamente las reglas de acceso heredadas. Los indicadores de propagación se omiten si <paramref name="inheritanceFlags" /> está establecido en <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
        <param name="type">Especifica el tipo de control de acceso válido.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.AccessControl.AccessRule" /> con los valores especificados.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.AccessRule" /> que crea este método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La manera recomendada para crear reglas de control de acceso es utilizar los constructores de la <xref:System.IO.Pipes.PipeAccessRule> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="type" /> especifican un valor no válido.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="identityReference" /> es <see langword="null" />.  
  
O bien 
 <paramref name="accessMask" /> es cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> no es de tipo <see cref="T:System.Security.Principal.SecurityIdentifier" /> ni pertenece a un tipo, como <see cref="T:System.Security.Principal.NTAccount" />, que pueda convertirse al tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeSecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.IO.Pipes.PipeSecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el valor de <see cref="T:System.Type" /> del objeto que está asociado con las reglas de acceso del objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</summary>
        <value>El tipo del objeto que está asociado con las reglas de acceso del objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de la <xref:System.Security.AccessControl.ObjectSecurity> clase invalidación el <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> propiedad y devuelva el tipo que se utilizan para representar los derechos de acceso. Cuando se trabaja con matrices o colecciones que contienen varios tipos de objetos de seguridad, use esta propiedad para determinar el tipo de enumeración correctos para utilizar con cada objeto de seguridad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.AddAccessRule(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As PipeAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAccessRule : System.IO.Pipes.PipeAccessRule -&gt; unit" Usage="pipeSecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">La regla de acceso que se va a agregar.</param>
        <summary>Agrega una regla de acceso a la lista de control de acceso discrecional (DACL) que está asociada con el objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Pipes.PipeSecurity.AddAccessRule%2A> método agrega una nueva regla a la lista de reglas que un <xref:System.IO.Pipes.PipeSecurity> contiene el objeto. Si ya existe una lista de control de acceso (ACL) para la regla especificada, el <xref:System.IO.Pipes.PipeSecurity.AddAccessRule%2A> método todavía agregará la regla con una excepción: un <xref:System.IO.Pipes.PipeAccessRule> objeto que se crea utilizando el <xref:System.Security.AccessControl.AccessControlType.Deny> valor reemplaza a un objeto que se crea utilizando el <xref:System.Security.AccessControl.AccessControlType.Allow> valor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.AddAuditRule(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As PipeAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAuditRule : System.IO.Pipes.PipeAuditRule -&gt; unit" Usage="pipeSecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">La regla de auditoría que se va a agregar.</param>
        <summary>Agrega una regla de auditoría a la lista de control de acceso del sistema (SACL) que está asociada con el objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Pipes.PipeSecurity.AddAuditRule%2A> método agrega una nueva regla de auditoría a la lista de reglas que un <xref:System.IO.Pipes.PipeSecurity> contiene el objeto.  
  
 Si ya existe una regla de auditoría para la regla especificada, el <xref:System.IO.Pipes.PipeSecurity.AddAuditRule%2A> método todavía agregará la regla.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override sealed System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="abstract member AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule&#xA;override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="pipeSecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">Identidad a la que se aplica la regla de acceso. Debe ser un objeto que permita su conversión al tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</param>
        <param name="accessMask">La máscara de acceso de esta regla. La máscara de acceso es una colección de 32 bits anónimos, cuyo significado está definido por cada uno de sus integrantes.</param>
        <param name="isInherited">
          <see langword="true" /> si esta regla se hereda de un contenedor primario; de lo contrario, es false.</param>
        <param name="inheritanceFlags">Uno de los valores de <see cref="T:System.Security.AccessControl.InheritanceFlags" /> que especifica las propiedades de herencia de la regla de acceso.</param>
        <param name="propagationFlags">Uno de los valores de <see cref="T:System.Security.AccessControl.PropagationFlags" /> que especifica si se propagan automáticamente las reglas de acceso heredadas. Los indicadores de propagación se omiten si <paramref name="inheritanceFlags" /> está establecido en <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
        <param name="flags">Uno de los valores de <see cref="T:System.Security.AccessControl.AuditFlags" /> que especifica el tipo de control de acceso válido.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.AccessControl.AuditRule" /> con los valores especificados.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.AuditRule" /> que crea este método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La manera recomendada para crear las reglas de auditoría es utilizar los constructores de la <xref:System.IO.Pipes.PipeAuditRule> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Las propiedades <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="flags" /> especifican un valor no válido.</exception>
        <exception cref="T:System.ArgumentNullException">La propiedad <paramref name="identityReference" /> es <see langword="null" />.  
  
O bien 
La propiedad <paramref name="accessMask" /> es cero.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <paramref name="identityReference" /> no es de tipo <see cref="T:System.Security.Principal.SecurityIdentifier" /> ni de un tipo, como <see cref="T:System.Security.Principal.NTAccount" />, que se pueda convertir al tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeSecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.IO.Pipes.PipeSecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Type" /> asociado con las reglas de auditoría del objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</summary>
        <value>El tipo del objeto que está asociado con las reglas de auditoría del objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de la <xref:System.Security.AccessControl.ObjectSecurity> clase invalidación el <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> propiedad y devuelva el tipo que se utilizan para representar los derechos de acceso. Cuando se trabaja con matrices o colecciones que contienen varios tipos de objetos de seguridad, use esta propiedad para determinar el tipo de enumeración correctos para utilizar con cada objeto de seguridad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Persist">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Guarda las secciones especificadas del descriptor de seguridad asociado al objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual en una ubicación de almacenamiento permanente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Persist">
      <MemberSignature Language="C#" Value="protected internal void Persist (System.Runtime.InteropServices.SafeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Persist(class System.Runtime.InteropServices.SafeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.Persist(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Persist (handle As SafeHandle)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Persist(System::Runtime::InteropServices::SafeHandle ^ handle);" />
      <MemberSignature Language="F#" Value="member this.Persist : System.Runtime.InteropServices.SafeHandle -&gt; unit" Usage="pipeSecurity.Persist handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">El identificador del objeto asegurable con el que está asociado el objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</param>
        <summary>Guarda las secciones especificadas del descriptor de seguridad asociado al objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual en una ubicación de almacenamiento permanente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Persist">
      <MemberSignature Language="C#" Value="protected internal void Persist (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Persist(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.Persist(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Persist (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Persist(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.Persist : string -&gt; unit" Usage="pipeSecurity.Persist name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del objeto asegurable con el que está asociado el objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</param>
        <summary>Guarda las secciones especificadas del descriptor de seguridad asociado al objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual en una ubicación de almacenamiento permanente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAccessRule(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As PipeAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRule : System.IO.Pipes.PipeAccessRule -&gt; bool" Usage="pipeSecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">La regla de acceso que se va a quitar.</param>
        <summary>Quita una regla de acceso de la lista de control de acceso discrecional (DACL) que está asociada con el objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</summary>
        <returns>
          <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> método quita todos los coincidentes <xref:System.Security.AccessControl.AccessControlType.Deny> reglas de acceso o todas las coincidencias con <xref:System.Security.AccessControl.AccessControlType.Allow> las reglas de acceso desde la actual <xref:System.IO.Pipes.PipeSecurity> objeto. Por ejemplo, puede usar este método para quitar todos los <xref:System.Security.AccessControl.AccessControlType.Deny> reglas de acceso para un usuario pasando un <xref:System.IO.Pipes.PipeAccessRule> objeto creado mediante el <xref:System.Security.AccessControl.AccessControlType.Deny> valor, el <xref:System.IO.Pipes.PipeAccessRights.Read> valor y una cuenta de usuario. El <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> método quita las reglas de denegación que especifican el <xref:System.IO.Pipes.PipeAccessRights.Read> valor o el <xref:System.IO.Pipes.PipeAccessRights.Write> valor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAccessRuleSpecific(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As PipeAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRuleSpecific : System.IO.Pipes.PipeAccessRule -&gt; unit" Usage="pipeSecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">La regla de acceso que se va a quitar.</param>
        <summary>Quita la regla de acceso especificada de la lista de control de acceso discrecional (DACL) que está asociada con el objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> método quita todos los coincidentes <xref:System.Security.AccessControl.AccessControlType.Deny> reglas de acceso o todas las coincidencias con <xref:System.Security.AccessControl.AccessControlType.Allow> las reglas de acceso desde la actual <xref:System.IO.Pipes.PipeSecurity> objeto. Por ejemplo, puede usar este método para quitar todos los <xref:System.Security.AccessControl.AccessControlType.Deny> reglas de acceso para un usuario pasando un <xref:System.IO.Pipes.PipeAccessRule> objeto creado mediante el <xref:System.Security.AccessControl.AccessControlType.Deny> valor, el <xref:System.IO.Pipes.PipeAccessRights.Read> valor y una cuenta de usuario. El <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> método quita las reglas de denegación que especifican el <xref:System.IO.Pipes.PipeAccessRights.Read> valor o el <xref:System.IO.Pipes.PipeAccessRights.Write> valor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAuditRule(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As PipeAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRule : System.IO.Pipes.PipeAuditRule -&gt; bool" Usage="pipeSecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">La regla de auditoría que se va a quitar.</param>
        <summary>Quita una regla de auditoría de la lista de control de acceso del sistema (SACL) que está asociada con el objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</summary>
        <returns>
          <see langword="true" /> si se ha quitado la regla de auditoría; en caso contrario, <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRule%2A> método quita todos los coincidentes <xref:System.Security.AccessControl.AccessControlType.Deny> las reglas de auditoría o todas las coincidencias con <xref:System.Security.AccessControl.AccessControlType.Allow> reglas desde la actual auditoría <xref:System.IO.Pipes.PipeSecurity> objeto.  Por ejemplo, puede usar este método para quitar todos los <xref:System.Security.AccessControl.AccessControlType.Deny> reglas de auditoría para un usuario pasando un <xref:System.Security.AccessControl.FileSystemAuditRule> objeto creado mediante el <xref:System.Security.AccessControl.AccessControlType.Deny> valor, el <xref:System.Security.AccessControl.AuditFlags.Failure> valor y una cuenta de usuario.  Al hacerlo, el <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRule%2A> método quita las reglas de denegación que especifican el <xref:System.Security.AccessControl.AuditFlags.Failure> valor o el <xref:System.Security.AccessControl.AuditFlags.Success> valor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAuditRuleAll(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As PipeAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleAll : System.IO.Pipes.PipeAuditRule -&gt; unit" Usage="pipeSecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">La regla de auditoría que se va a quitar.</param>
        <summary>Quita todas las reglas de auditoría que tienen el mismo identificador de seguridad que la regla de auditoría especificada de la lista de control de acceso del sistema (SACL) que está asociada con el objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRuleAll%2A> método quita todas las reglas de auditoría para el usuario especificado.  Omite todos los valores de la <xref:System.IO.Pipes.PipeAuditRule> objeto excepto la cuenta de usuario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAuditRuleSpecific(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As PipeAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleSpecific : System.IO.Pipes.PipeAuditRule -&gt; unit" Usage="pipeSecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">La regla de auditoría que se va a quitar.</param>
        <summary>Quita la regla de auditoría especificada de la lista de control de acceso del sistema (SACL) que está asociada con el objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRuleSpecific%2A> método quita la coincidencia especificada <xref:System.Security.AccessControl.AccessControlType.Deny> la coincidencia especificado o regla de auditoría <xref:System.Security.AccessControl.AccessControlType.Allow> regla de auditoría desde la actual <xref:System.IO.Pipes.PipeSecurity> objeto.  Por ejemplo, puede usar este método para quitar un especificado <xref:System.Security.AccessControl.AccessControlType.Deny> regla de auditoría para un usuario pasando un <xref:System.Security.AccessControl.FileSystemAuditRule> objeto creado mediante el <xref:System.Security.AccessControl.AccessControlType.Deny> valor, el <xref:System.Security.AccessControl.AuditFlags.Failure> valor y una cuenta de usuario.  Al hacerlo, el <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRuleSpecific%2A> método quita solo una regla de denegación que especifica el <xref:System.Security.AccessControl.AuditFlags.Failure> valor.  No quita las reglas de denegación que especifican el <xref:System.Security.AccessControl.AuditFlags.Success> valor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.ResetAccessRule(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As PipeAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.ResetAccessRule : System.IO.Pipes.PipeAccessRule -&gt; unit" Usage="pipeSecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">La regla de acceso que se va a agregar.</param>
        <summary>Quita todas las reglas de acceso de la lista de control de acceso discrecional (DACL) que está asociada con el objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual y, a continuación, agrega la regla de acceso especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Pipes.PipeSecurity.ResetAccessRule%2A> método agrega la regla de lista (ACL) del control de acceso especificada o sobrescribe cualquier regla de ACL idéntica que coinciden con el `rule` parámetro.  Por ejemplo, si la `rule` parámetro especifica un <xref:System.IO.Pipes.PipeAccessRights.Read> valor y el <xref:System.IO.Pipes.PipeSecurity.ResetAccessRule%2A> método busca una regla ACL idéntica que especifica el <xref:System.IO.Pipes.PipeAccessRights.Read> valor, la regla idéntica se sobrescribirá.  Si el <xref:System.IO.Pipes.PipeSecurity.ResetAccessRule%2A> método busca una regla ACL idéntica que especifica el <xref:System.IO.Pipes.PipeAccessRights.Write> valor, la regla idéntica también se sobrescribirá.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.SetAccessRule(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As PipeAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAccessRule : System.IO.Pipes.PipeAccessRule -&gt; unit" Usage="pipeSecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Regla que se va a establecer.</param>
        <summary>Establece una regla de acceso de la lista de control de acceso discrecional (DACL) que está asociada con el objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Pipes.PipeSecurity.SetAccessRule%2A> método agrega la regla de lista (ACL) del control de acceso especificada o sobrescribe cualquier regla de ACL idéntica que coinciden con el <xref:System.IO.Pipes.PipeAccessRights> valor de la `rule` parámetro.  Por ejemplo, si la `rule` parámetro especifica un <xref:System.IO.Pipes.PipeAccessRights.Read> valor y el <xref:System.IO.Pipes.PipeSecurity.SetAccessRule%2A> método busca una regla ACL idéntica que especifica el <xref:System.IO.Pipes.PipeAccessRights.Read> valor, la regla idéntica se sobrescribirá.  Si el <xref:System.IO.Pipes.PipeSecurity.SetAccessRule%2A> método busca una regla ACL idéntica que especifica el <xref:System.IO.Pipes.PipeAccessRights.Write> valor, la regla idéntica no se sobrescribirá.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.SetAuditRule(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As PipeAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAuditRule : System.IO.Pipes.PipeAuditRule -&gt; unit" Usage="pipeSecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Regla que se va a establecer.</param>
        <summary>Establece una regla de auditoría en la lista de control de acceso del sistema (SACL) que está asociada con el objeto <see cref="T:System.IO.Pipes.PipeSecurity" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Pipes.PipeSecurity.SetAuditRule%2A> método agrega la regla de auditoría especificada o sobrescribe cualquier regla de auditoría idéntica que coinciden con el <xref:System.IO.Pipes.PipeAccessRights> valor de la `rule` parámetro.  Por ejemplo, si la `rule` parámetro especifica un <xref:System.IO.Pipes.PipeAccessRights.Read> valor y el <xref:System.IO.Pipes.PipeSecurity.SetAuditRule%2A> método busca una regla de auditoría idéntica que especifica el <xref:System.IO.Pipes.PipeAccessRights.Read> valor, la regla idéntica se sobrescribirá.  Si el <xref:System.IO.Pipes.PipeSecurity.SetAuditRule%2A> método busca una regla de auditoría idéntica que especifica el <xref:System.IO.Pipes.PipeAccessRights.Write> valor, la regla idéntica no se sobrescribirá.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>