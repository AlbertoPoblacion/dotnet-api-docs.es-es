<Type Name="GraphicsPath" FullName="System.Drawing.Drawing2D.GraphicsPath">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="010b867d0c50e186006fea90cdbc67fefd8cfd61" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30410679" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class GraphicsPath : MarshalByRefObject, ICloneable, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit GraphicsPath extends System.MarshalByRefObject implements class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Drawing.Drawing2D.GraphicsPath" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class GraphicsPath&#xA;Inherits MarshalByRefObject&#xA;Implements ICloneable, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class GraphicsPath sealed : MarshalByRefObject, ICloneable, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Drawing</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa una serie de líneas y curvas conectadas. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplicaciones usan las rutas de acceso para dibujar los contornos de formas, rellenar los interiores de formas y crear áreas de recorte. El motor de gráficos mantiene las coordenadas de formas geométricas en una ruta de acceso en el espacio de coordenadas universales.  
  
 Una ruta de acceso puede estar formada por cualquier número de figuras (subtrazados). Cada figura está formada por una secuencia de varias líneas y curvas o una forma geométrica primitiva. El punto inicial de una figura es el primer punto en la secuencia de líneas y curvas conectadas. El punto final es el último punto en la secuencia. Los puntos inicial y finales de una forma geométrica primitiva se definen mediante la especificación primitiva.  
  
 Una figura que consta de una secuencia de varias líneas y curvas conectadas (cuyos puntos inicial y final pueden ser coincidentes) es una figura abierta, a menos que se cierre explícitamente. Una figura se puede cerrar explícitamente, mediante el uso de la <xref:System.Drawing.Drawing2D.GraphicsPath.CloseFigure%2A> método, que cierra la figura actual mediante la conexión de una línea desde el punto final en el punto de partida. Una figura que consta de una forma geométrica primitiva es una figura cerrada.  
  
 Para los fines de relleno y el recorte (por ejemplo, si una ruta de acceso se representa mediante <xref:System.Drawing.Graphics.FillPath%2A>), abra todas las cifras se cierran agregando una línea desde el primer punto en el último punto.  
  
 Una nueva figura se inicia implícitamente cuando se crea una ruta de acceso o cuando se cierra una figura. Una nueva figura explícitamente cuando se crea el <xref:System.Drawing.Drawing2D.GraphicsPath.StartFigure%2A> se llama al método.  
  
 Cuando una forma geométrica primitiva se agrega a una ruta de acceso, agrega una figura que contiene la forma geométrica y también implícitamente inicia una nueva figura. Por lo tanto, siempre hay una figura actual en una ruta de acceso. Cuando se agregan líneas y curvas conectadas a una ruta de acceso, se agrega una línea implícita, según sea necesario para conectar el punto final de la figura actual en el punto de partida de las nuevas líneas y curvas para formar una secuencia de varias líneas y curvas.  
  
 Una figura tiene una dirección que describe cómo se realiza el seguimiento de los segmentos de línea y curva entre el punto inicial y el punto final. La dirección se define en el orden en que las líneas y curvas conectadas se agregan a una figura o se define mediante la forma geométrica primitiva. La dirección se utiliza para determinar los interiores de ruta de acceso para el recorte y relleno.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> con una enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> de <see langword="Alternate" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> con <see cref="P:System.Drawing.Drawing2D.GraphicsPath.FillMode" /> como valor de la propiedad <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="fillMode">Enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina cómo se rellena el interior de <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> con la enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> especificada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Point[] pts, byte[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Point[] pts, unsigned int8[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Point[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pts As Point(), types As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::Point&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
        <Parameter Name="types" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="pts">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que define las coordenadas de los puntos que componen este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Matriz de elementos de la enumeración <see cref="T:System.Drawing.Drawing2D.PathPointType" /> que especifica el tipo de cada punto correspondiente de la matriz <c>pts</c>.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> con las matrices<see cref="T:System.Drawing.Drawing2D.PathPointType" /> y <see cref="T:System.Drawing.Point" /> que se hayan especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.PointF[] pts, byte[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.PointF[] pts, unsigned int8[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.PointF[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pts As PointF(), types As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::PointF&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
        <Parameter Name="types" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="pts">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que define las coordenadas de los puntos que componen este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Matriz de elementos de la enumeración <see cref="T:System.Drawing.Drawing2D.PathPointType" /> que especifica el tipo de cada punto correspondiente de la matriz <c>pts</c>.</param>
        <summary>Inicializa una nueva instancia de la matriz <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> con las matrices <see cref="T:System.Drawing.Drawing2D.PathPointType" /> y <see cref="T:System.Drawing.PointF" /> especificadas.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Point[] pts, byte[] types, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Point[] pts, unsigned int8[] types, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Point[],System.Byte[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::Point&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
        <Parameter Name="types" Type="System.Byte[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pts">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que define las coordenadas de los puntos que componen este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Matriz de elementos de la enumeración <see cref="T:System.Drawing.Drawing2D.PathPointType" /> que especifica el tipo de cada punto correspondiente de la matriz <c>pts</c>.</param>
        <param name="fillMode">Enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> que especifica cómo se rellena el interior de las formas en este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> con las matrices <see cref="T:System.Drawing.Drawing2D.PathPointType" /> y <see cref="T:System.Drawing.Point" /> especificadas y con el elemento de enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.PointF[] pts, byte[] types, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.PointF[] pts, unsigned int8[] types, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.PointF[],System.Byte[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::PointF&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
        <Parameter Name="types" Type="System.Byte[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pts">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que define las coordenadas de los puntos que componen este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Matriz de elementos de la enumeración <see cref="T:System.Drawing.Drawing2D.PathPointType" /> que especifica el tipo de cada punto correspondiente de la matriz <c>pts</c>.</param>
        <param name="fillMode">Enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> que especifica cómo se rellena el interior de las formas en este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <summary>Inicializa una nueva instancia de la matriz <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> con las matrices <see cref="T:System.Drawing.Drawing2D.PathPointType" /> y <see cref="T:System.Drawing.PointF" /> especificadas y con el elemento de enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> especificada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddArc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega un arco elíptico a la figura actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (rect As Rectangle, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> que representa los límites rectangulares de la elipse cuyo arco se toma.</param>
        <param name="startAngle">Ángulo inicial del arco, medido en grados en el sentido de las agujas del reloj desde el eje X.</param>
        <param name="sweepAngle">Ángulo existente entre <c>startAngle</c> y el final del arco.</param>
        <summary>Agrega un arco elíptico a la figura actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay líneas o curvas en la ilustración anteriores, se agrega una línea para conectar el extremo del segmento anterior al principio del arco.  
  
 El arco se realiza un seguimiento a lo largo del perímetro de la elipse limitada por el rectángulo especificado. El punto inicial del arco se determina mediante la medición hacia la derecha desde el eje x de la elipse (en el ángulo 0 grados) en el número de grados en el ángulo inicial. De igual forma se encuentra el punto de conexión mediante la medición hacia la derecha desde el punto inicial en el número de grados en el ángulo de barrido. Si el ángulo de barrido es mayor que 360 grados o menor que-360 grados, el arco se trazará exactamente 360 o -360 grados, respectivamente.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea un rectángulo, desde el que se define el arco.  
  
-   Crea una ruta de acceso, `myPath`.  
  
-   Define un arco elíptico de 180 grados que oscila desde 0 a 180 grados y se anexa a una ruta de acceso.  
  
-   Dibuja la ruta de acceso a la pantalla.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#1)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (rect As RectangleF, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(System::Drawing::RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> que representa los límites rectangulares de la elipse cuyo arco se toma.</param>
        <param name="startAngle">Ángulo inicial del arco, medido en grados en el sentido de las agujas del reloj desde el eje X.</param>
        <param name="sweepAngle">Ángulo existente entre <c>startAngle</c> y el final del arco.</param>
        <summary>Agrega un arco elíptico a la figura actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay líneas o curvas en la ilustración anteriores, se agrega una línea para conectar el extremo del segmento anterior al principio del arco.  
  
 El arco se realiza un seguimiento a lo largo del perímetro de la elipse limitada por el rectángulo especificado. El punto inicial del arco se determina mediante la medición hacia la derecha desde el eje x de la elipse (en el ángulo 0 grados) en el número de grados en el ángulo inicial. De igual forma se encuentra el punto de conexión mediante la medición hacia la derecha desde el punto inicial en el número de grados en el ángulo de barrido. Si el ángulo de barrido es mayor que 360 grados o menor que-360 grados, el arco se trazará exactamente 360 o -360 grados, respectivamente.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(int32 x, int32 y, int32 width, int32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (x As Integer, y As Integer, width As Integer, height As Integer, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada x del ángulo superior izquierdo del área rectangular que define la elipse desde la que se dibuja el arco.</param>
        <param name="y">Coordenada y del ángulo superior izquierdo del área rectangular que define la elipse desde la que se dibuja el arco.</param>
        <param name="width">Ancho del área rectangular que define la elipse desde la que se dibuja el arco.</param>
        <param name="height">Alto del área rectangular que define la elipse desde la que se dibuja el arco.</param>
        <param name="startAngle">Ángulo inicial del arco, medido en grados en el sentido de las agujas del reloj desde el eje X.</param>
        <param name="sweepAngle">Ángulo existente entre <c>startAngle</c> y el final del arco.</param>
        <summary>Agrega un arco elíptico a la figura actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay líneas o curvas en la ilustración anteriores, se agrega una línea para conectar el extremo del segmento anterior al principio del arco.  
  
 El arco se realiza un seguimiento a lo largo del perímetro de la elipse limitada por el rectángulo especificado. El punto inicial del arco se determina mediante la medición hacia la derecha desde el eje x de la elipse (en el ángulo 0 grados) en el número de grados en el ángulo inicial. De igual forma se encuentra el punto de conexión mediante la medición hacia la derecha desde el punto inicial en el número de grados en el ángulo de barrido. Si el ángulo de barrido es mayor que 360 grados o menor que-360 grados, el arco se trazará exactamente 360 o -360 grados, respectivamente.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (x As Single, y As Single, width As Single, height As Single, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada x del ángulo superior izquierdo del área rectangular que define la elipse desde la que se dibuja el arco.</param>
        <param name="y">Coordenada y del ángulo superior izquierdo del área rectangular que define la elipse desde la que se dibuja el arco.</param>
        <param name="width">Ancho del área rectangular que define la elipse desde la que se dibuja el arco.</param>
        <param name="height">Alto del área rectangular que define la elipse desde la que se dibuja el arco.</param>
        <param name="startAngle">Ángulo inicial del arco, medido en grados en el sentido de las agujas del reloj desde el eje X.</param>
        <param name="sweepAngle">Ángulo existente entre <c>startAngle</c> y el final del arco.</param>
        <summary>Agrega un arco elíptico a la figura actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay líneas o curvas en la ilustración anteriores, se agrega una línea para conectar el extremo del segmento anterior al principio del arco.  
  
 El arco se realiza un seguimiento a lo largo del perímetro de la elipse limitada por el rectángulo especificado. El punto inicial del arco se determina mediante la medición hacia la derecha desde el eje x de la elipse (en el ángulo 0 grados) en el número de grados en el ángulo inicial. De igual forma se encuentra el punto de conexión mediante la medición hacia la derecha desde el punto inicial en el número de grados en el ángulo de barrido. Si el ángulo de barrido es mayor que 360 grados o menor que-360 grados, el arco se trazará exactamente 360 o -360 grados, respectivamente.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBezier">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega una curva Bézier cúbica a la figura actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (System.Drawing.Point pt1, System.Drawing.Point pt2, System.Drawing.Point pt3, System.Drawing.Point pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2, valuetype System.Drawing.Point pt3, valuetype System.Drawing.Point pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Drawing.Point,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (pt1 As Point, pt2 As Point, pt3 As Point, pt4 As Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(System::Drawing::Point pt1, System::Drawing::Point pt2, System::Drawing::Point pt3, System::Drawing::Point pt4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
        <Parameter Name="pt3" Type="System.Drawing.Point" />
        <Parameter Name="pt4" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt1">
          <see cref="T:System.Drawing.Point" /> que representa el punto inicial de la curva.</param>
        <param name="pt2">
          <see cref="T:System.Drawing.Point" /> que representa el primer punto de control de la curva.</param>
        <param name="pt3">
          <see cref="T:System.Drawing.Point" /> que representa el segundo punto de control de la curva.</param>
        <param name="pt4">
          <see cref="T:System.Drawing.Point" /> que representa el extremo de la curva.</param>
        <summary>Agrega una curva Bézier cúbica a la figura actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La curva cúbica se construye desde el primer punto hasta el cuarto punto mediante el segundo y tercer puntos como puntos de control.  
  
 Si hay una línea anterior o un segmento de curva en la ilustración, se agrega una línea para conectar el extremo del segmento anterior con el punto inicial de la curva cúbica.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (System.Drawing.PointF pt1, System.Drawing.PointF pt2, System.Drawing.PointF pt3, System.Drawing.PointF pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2, valuetype System.Drawing.PointF pt3, valuetype System.Drawing.PointF pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (pt1 As PointF, pt2 As PointF, pt3 As PointF, pt4 As PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(System::Drawing::PointF pt1, System::Drawing::PointF pt2, System::Drawing::PointF pt3, System::Drawing::PointF pt4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
        <Parameter Name="pt3" Type="System.Drawing.PointF" />
        <Parameter Name="pt4" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pt1">
          <see cref="T:System.Drawing.PointF" /> que representa el punto inicial de la curva.</param>
        <param name="pt2">
          <see cref="T:System.Drawing.PointF" /> que representa el primer punto de control de la curva.</param>
        <param name="pt3">
          <see cref="T:System.Drawing.PointF" /> que representa el segundo punto de control de la curva.</param>
        <param name="pt4">
          <see cref="T:System.Drawing.PointF" /> que representa el extremo de la curva.</param>
        <summary>Agrega una curva Bézier cúbica a la figura actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La curva cúbica se construye desde el primer punto hasta el cuarto punto mediante el segundo y tercer puntos como puntos de control.  
  
 Si hay una línea anterior o un segmento de curva en la ilustración, se agrega una línea para conectar el extremo del segmento anterior con el punto inicial de la curva cúbica.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(int32 x1, int32 y1, int32 x2, int32 y2, int32 x3, int32 y3, int32 x4, int32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, x3 As Integer, y3 As Integer, x4 As Integer, y4 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
        <Parameter Name="x3" Type="System.Int32" />
        <Parameter Name="y3" Type="System.Int32" />
        <Parameter Name="x4" Type="System.Int32" />
        <Parameter Name="y4" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x1">Coordenada x del punto inicial de la curva.</param>
        <param name="y1">Coordenada y del punto inicial de la curva.</param>
        <param name="x2">Coordenada x del primer punto de control para la curva.</param>
        <param name="y2">Coordenada y del primer punto de control para la curva.</param>
        <param name="x3">Coordenada x del segundo punto de control para la curva.</param>
        <param name="y3">Coordenada y del segundo punto de control para la curva.</param>
        <param name="x4">Coordenada x del extremo de la curva.</param>
        <param name="y4">Coordenada y del extremo de la curva.</param>
        <summary>Agrega una curva Bézier cúbica a la figura actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La curva cúbica se construye desde el primer punto hasta el cuarto punto mediante el segundo y tercer puntos como puntos de control.  
  
 Si hay una línea anterior o un segmento de curva en la ilustración, se agrega una línea para conectar el extremo del segmento anterior con el punto inicial de la curva cúbica.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una ruta de acceso.  
  
-   Agrega una curva Bézier cúbica definida por los puntos (50, 50), (70, 0), (100, 120) y (150, 50) para la ruta de acceso.  
  
-   Cierra la curva.  
  
-   Dibuja la ruta de acceso a la pantalla.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#2)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(float32 x1, float32 y1, float32 x2, float32 y2, float32 x3, float32 y3, float32 x4, float32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (x1 As Single, y1 As Single, x2 As Single, y2 As Single, x3 As Single, y3 As Single, x4 As Single, y4 As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
        <Parameter Name="x3" Type="System.Single" />
        <Parameter Name="y3" Type="System.Single" />
        <Parameter Name="x4" Type="System.Single" />
        <Parameter Name="y4" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x1">Coordenada x del punto inicial de la curva.</param>
        <param name="y1">Coordenada y del punto inicial de la curva.</param>
        <param name="x2">Coordenada x del primer punto de control para la curva.</param>
        <param name="y2">Coordenada y del primer punto de control para la curva.</param>
        <param name="x3">Coordenada x del segundo punto de control para la curva.</param>
        <param name="y3">Coordenada y del segundo punto de control para la curva.</param>
        <param name="x4">Coordenada x del extremo de la curva.</param>
        <param name="y4">Coordenada y del extremo de la curva.</param>
        <summary>Agrega una curva Bézier cúbica a la figura actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La curva cúbica se construye desde el primer punto hasta el cuarto punto mediante el segundo y tercer puntos como puntos de control.  
  
 Si hay una línea anterior o un segmento de curva en la ilustración, se agrega una línea para conectar el extremo del segmento anterior con el punto inicial de la curva cúbica.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBeziers">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega una secuencia de curvas Bézier cúbicas conectadas a la figura actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBeziers">
      <MemberSignature Language="C#" Value="public void AddBeziers (params System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeziers(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBeziers(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeziers (ParamArray points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeziers(... cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que representa los puntos que definen la curva.</param>
        <summary>Agrega una secuencia de curvas Bézier cúbicas conectadas a la figura actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `points` parámetro especifica una matriz de puntos de conexión y puntos de control de las curvas conectadas. La primera curva se construye desde el primer punto hasta el cuarto punto en el `points` matriz mediante el segundo y tercer puntos como puntos de control. Además del extremo de la curva anterior, cada curva sucesiva en la secuencia necesita exactamente tres puntos más: los dos puntos siguientes de la secuencia son puntos de control y el tercero es el extremo de la curva agregada.  
  
 Si no hay líneas o curvas en la ilustración anteriores, se agrega una línea para conectar el extremo del segmento anterior con el punto inicial de la primera curva cúbica de la secuencia.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una matriz de siete puntos (que representan dos curvas de Bézier conectadas).  
  
-   Crea una ruta de acceso y agrega la serie de puntos de curva de Bézier a la ruta de acceso.  
  
-   Dibuja la ruta de acceso a la pantalla.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#3)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBeziers">
      <MemberSignature Language="C#" Value="public void AddBeziers (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeziers(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBeziers(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeziers (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeziers(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que representa los puntos que definen la curva.</param>
        <summary>Agrega una secuencia de curvas Bézier cúbicas conectadas a la figura actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `points` parámetro especifica una matriz de puntos de conexión y puntos de control de las curvas conectadas. La primera curva se construye desde el primer punto hasta el cuarto punto en el `points` matriz mediante el segundo y tercer puntos como puntos de control. Además del extremo de la curva anterior, cada curva sucesiva en la secuencia necesita exactamente tres puntos más: los dos puntos siguientes de la secuencia son puntos de control y el tercero es el extremo de la curva agregada.  
  
 Si no hay líneas o curvas en la ilustración anteriores, se agrega una línea para conectar el extremo del segmento anterior con el punto inicial de la primera curva cúbica de la secuencia.  
  
   
  
## Examples  
 Para una ejemplo, vea:  
  
 <xref:System.Drawing.Drawing2D.GraphicsPath.AddBeziers%28System.Drawing.Point%5B%5D%29>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddClosedCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega una curva cerrada a este trazado. Se utiliza una curva spline cardinal porque la curva recorre todos los puntos de la matriz.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que representa los puntos que definen la curva.</param>
        <summary>Agrega una curva cerrada a este trazado. Se utiliza una curva spline cardinal porque la curva recorre todos los puntos de la matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El usuario debe mantener los puntos originales si son necesarias. Los puntos originales se convierten en puntos de control de Bézier cúbicos internamente, por lo tanto, no hay ningún mecanismo para devolver los puntos originales. Si los puntos primero y el último punto en el `points` matriz no son el mismo punto, la curva se cierra conectando dichos dos puntos. Este método, no se puede establecer el valor de tensión y el valor predeterminado es un valor equivalente a 0,5.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que representa los puntos que definen la curva.</param>
        <summary>Agrega una curva cerrada a este trazado. Se utiliza una curva spline cardinal porque la curva recorre todos los puntos de la matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El usuario debe mantener los puntos originales si son necesarias. Los puntos originales se convierten en puntos de control de Bézier cúbicos internamente, por lo tanto, no hay ningún mecanismo para devolver los puntos originales. Si los puntos primero y el último punto en el `points` matriz no son el mismo punto, la curva se cierra conectando dichos dos puntos. Este método, no se puede establecer el valor de tensión y el valor predeterminado es un valor equivalente a 0,5.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As Point(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que representa los puntos que definen la curva.</param>
        <param name="tension">Valor de 0 a 1 que especifica la inclinación de la curva entre puntos, donde 0 es la curva más cerrada (esquina más apuntada) y 1 es la curva más abierta.</param>
        <summary>Agrega una curva cerrada a este trazado. Se utiliza una curva spline cardinal porque la curva recorre todos los puntos de la matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El usuario debe mantener los puntos originales si son necesarias. Los puntos originales se convierten en puntos de control de Bézier cúbicos internamente, por lo tanto, no hay ningún mecanismo para devolver los puntos originales. Si los puntos primero y el último punto en el `points` matriz no son el mismo punto, la curva se cierra conectando dichos dos puntos.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una matriz de seis puntos (que representan una curva spline cardinal).  
  
-   Crea una ruta de acceso y agrega las curvas spline cardinal cerrada en la ruta de acceso (cerrado desde el punto de conexión en el punto de partida).  
  
-   Dibuja la ruta de acceso a la pantalla.  
  
 Tenga en cuenta que se usa una tensión de 0,5.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As PointF(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que representa los puntos que definen la curva.</param>
        <param name="tension">Valor de 0 a 1 que especifica la inclinación de la curva entre puntos, donde 0 es la curva más cerrada (esquina más apuntada) y 1 es la curva más abierta.</param>
        <summary>Agrega una curva cerrada a este trazado. Se utiliza una curva spline cardinal porque la curva recorre todos los puntos de la matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El usuario debe mantener los puntos originales si son necesarias. Los puntos originales se convierten en puntos de control de Bézier cúbicos internamente, por lo tanto, no hay ningún mecanismo para devolver los puntos originales. Si los puntos primero y el último punto en el `points` matriz no son el mismo punto, la curva se cierra conectando dichos dos puntos.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega una curva spline a la figura actual. Se utiliza una curva spline cardinal porque la curva recorre todos los puntos de la matriz.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que representa los puntos que definen la curva.</param>
        <summary>Agrega una curva spline a la figura actual. Se utiliza una curva spline cardinal porque la curva recorre todos los puntos de la matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El usuario debe mantener los puntos originales si son necesarias. Los puntos originales se convierten en puntos de control de Bézier cúbicos internamente, por lo tanto, no hay ningún mecanismo para devolver los puntos originales.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que representa los puntos que definen la curva.</param>
        <summary>Agrega una curva spline a la figura actual. Se utiliza una curva spline cardinal porque la curva recorre todos los puntos de la matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El usuario debe mantener los puntos originales si son necesarias. Los puntos originales se convierten en puntos de control de Bézier cúbicos internamente, por lo tanto, no hay ningún mecanismo para devolver los puntos originales.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que representa los puntos que definen la curva.</param>
        <param name="tension">Valor que especifica la inclinación de la curva entre puntos de control. Los valores mayores que 1 producen resultados impredecibles.</param>
        <summary>Agrega una curva spline a la figura actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El usuario debe mantener los puntos originales si son necesarias. Los puntos originales se convierten en puntos de control de Bézier cúbicos internamente, por lo tanto, no hay ningún mecanismo para devolver los puntos originales.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que representa los puntos que definen la curva.</param>
        <param name="tension">Valor que especifica la inclinación de la curva entre puntos de control. Los valores mayores que 1 producen resultados impredecibles.</param>
        <summary>Agrega una curva spline a la figura actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El usuario debe mantener los puntos originales si son necesarias. Los puntos originales se convierten en puntos de control de Bézier cúbicos internamente, por lo tanto, no hay ningún mecanismo para devolver los puntos originales.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point(), offset As Integer, numberOfSegments As Integer, tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que representa los puntos que definen la curva.</param>
        <param name="offset">Índice del elemento de la matriz <c>points</c> que se usa como primer punto de la curva.</param>
        <param name="numberOfSegments">Valor que especifica la inclinación de la curva entre puntos de control. Los valores mayores que 1 producen resultados impredecibles.</param>
        <param name="tension">Valor que especifica la inclinación de la curva entre puntos de control. Los valores mayores que 1 producen resultados impredecibles.</param>
        <summary>Agrega una curva spline a la figura actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El usuario debe mantener los puntos originales si son necesarias. Los puntos originales se convierten en puntos de control de Bézier cúbicos internamente, por lo tanto, no hay ningún mecanismo para devolver los puntos originales.  
  
 La curva comienza en el punto de la matriz especificada por el `offset` parámetro e incluye el número de puntos (segmentos) especificados por `numberOfSegments`.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una matriz de cuatro puntos (que representan una curva spline cardinal).  
  
-   Crea una ruta de acceso y con la matriz de puntos, agrega la curva a la ruta de acceso.  
  
-   Dibuja la ruta de acceso a la pantalla.  
  
 Tenga en cuenta que aunque la matriz tiene cuatro puntos, hay sólo tres segmentos, que es el número especificado en el tercer argumento de la llamada a <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%2A>.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#5)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF(), offset As Integer, numberOfSegments As Integer, tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que representa los puntos que definen la curva.</param>
        <param name="offset">Índice del elemento de la matriz <c>points</c> que se usa como primer punto de la curva.</param>
        <param name="numberOfSegments">Número de segmentos usados para dibujar la curva. Un segmento es, en realidad, una línea que conecta dos puntos.</param>
        <param name="tension">Valor que especifica la inclinación de la curva entre puntos de control. Los valores mayores que 1 producen resultados impredecibles.</param>
        <summary>Agrega una curva spline a la figura actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El usuario debe mantener los puntos originales si son necesarias. Los puntos originales se convierten en puntos de control de Bézier cúbicos internamente, por lo tanto, no hay ningún mecanismo para devolver los puntos originales.  
  
 La curva comienza en el punto de la matriz especificada por `offset`e incluye el número de puntos (segmentos) especificados por `numberOfSegments`.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddEllipse">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega una elipse al trazado actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(System::Drawing::Rectangle rect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> que representa el rectángulo delimitador que define la elipse.</param>
        <summary>Agrega una elipse al trazado actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
 Crea un rectángulo delimitador que define la elipse.  
  
 Crea una ruta de acceso y agrega los puntos suspensivos a la ruta de acceso.  
  
 Dibuja la ruta de acceso a la pantalla.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#6)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(System::Drawing::RectangleF rect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> que representa el rectángulo delimitador que define la elipse.</param>
        <summary>Agrega una elipse al trazado actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(int x, int y, int width, int height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada X de la esquina superior izquierda del rectángulo delimitador que define la elipse.</param>
        <param name="y">Coordenada Y de la esquina superior izquierda del rectángulo delimitador que define la elipse.</param>
        <param name="width">Ancho del rectángulo delimitador que define la elipse.</param>
        <param name="height">Alto del rectángulo delimitador que define la elipse.</param>
        <summary>Agrega una elipse al trazado actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (x As Single, y As Single, width As Single, height As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(float x, float y, float width, float height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada X de la esquina superior izquierda del rectángulo delimitador que define la elipse.</param>
        <param name="y">Coordenada y de la esquina superior izquierda del rectángulo delimitador que define la elipse.</param>
        <param name="width">Ancho del rectángulo delimitador que define la elipse.</param>
        <param name="height">Alto del rectángulo delimitador que define la elipse.</param>
        <summary>Agrega una elipse al trazado actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddLine">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Anexa un segmento de línea a este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (System.Drawing.Point pt1, System.Drawing.Point pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (pt1 As Point, pt2 As Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(System::Drawing::Point pt1, System::Drawing::Point pt2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt1">
          <see cref="T:System.Drawing.Point" /> que representa el punto inicial de la línea.</param>
        <param name="pt2">
          <see cref="T:System.Drawing.Point" /> que representa el extremo de la línea.</param>
        <summary>Anexa un segmento de línea a este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método agrega el segmento de línea definido por los puntos especificados al final de este <xref:System.Drawing.Drawing2D.GraphicsPath>. Si no hay líneas o curvas en anteriores el <xref:System.Drawing.Drawing2D.GraphicsPath>, se dibujará un segmento de línea para conectar el último punto en la ruta de acceso hasta el primer punto en el nuevo segmento de línea.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (System.Drawing.PointF pt1, System.Drawing.PointF pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (pt1 As PointF, pt2 As PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(System::Drawing::PointF pt1, System::Drawing::PointF pt2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pt1">
          <see cref="T:System.Drawing.PointF" /> que representa el punto inicial de la línea.</param>
        <param name="pt2">
          <see cref="T:System.Drawing.PointF" /> que representa el extremo de la línea.</param>
        <summary>Anexa un segmento de línea a este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método agrega el segmento de línea definido por los puntos especificados al final de este <xref:System.Drawing.Drawing2D.GraphicsPath>. Si no hay líneas o curvas en anteriores el <xref:System.Drawing.Drawing2D.GraphicsPath>, se dibujará un segmento de línea para conectar el último punto en la ruta de acceso hasta el primer punto en el nuevo segmento de línea.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(int32 x1, int32 y1, int32 x2, int32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(int x1, int y1, int x2, int y2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x1">Coordenada x del punto inicial de la línea.</param>
        <param name="y1">Coordenada y del punto inicial de la línea.</param>
        <param name="x2">Coordenada x del extremo de la línea.</param>
        <param name="y2">Coordenada y del extremo de la línea.</param>
        <summary>Agrega un segmento de línea a la figura actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método agrega el segmento de línea definido por los puntos especificados al final de la figura actual. Si no hay líneas o curvas en anteriores el <xref:System.Drawing.Drawing2D.GraphicsPath>, se dibujará un segmento de línea para conectar el último punto en la ruta de acceso hasta el primer punto en el nuevo segmento de línea.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código crea un trazado, agrega tres líneas que forman un triángulo y, a continuación, dibuja la ruta de acceso a la pantalla.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#7)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(float32 x1, float32 y1, float32 x2, float32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (x1 As Single, y1 As Single, x2 As Single, y2 As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(float x1, float y1, float x2, float y2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x1">Coordenada x del punto inicial de la línea.</param>
        <param name="y1">Coordenada y del punto inicial de la línea.</param>
        <param name="x2">Coordenada x del extremo de la línea.</param>
        <param name="y2">Coordenada y del extremo de la línea.</param>
        <summary>Anexa un segmento de línea a este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método agrega el segmento de línea definido por los puntos especificados al final de este <xref:System.Drawing.Drawing2D.GraphicsPath>. Si no hay líneas o curvas en anteriores el <xref:System.Drawing.Drawing2D.GraphicsPath>, se dibujará un segmento de línea para conectar el último punto en la ruta de acceso hasta el primer punto en el nuevo segmento de línea.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddLines">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Anexa una serie de segmentos de línea conectados al final de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddLines">
      <MemberSignature Language="C#" Value="public void AddLines (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLines(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLines(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLines (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLines(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que representa los puntos que definen los segmentos de línea que se van a agregar.</param>
        <summary>Anexa una serie de segmentos de línea conectados al final de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay líneas o curvas en la ilustración anteriores, se agrega una línea para conectar el extremo del segmento anterior con el punto inicial de la línea. El `points` parámetro especifica una matriz de puntos de conexión. Los dos primeros especifican la primera línea. Cada punto adicional especifica el extremo de un segmento de línea cuyo punto inicial es el punto de conexión de la línea anterior.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una matriz de cuatro puntos que describe un triángulo.  
  
-   Crea una ruta de acceso y agrega la matriz de líneas.  
  
-   Dibuja la ruta de acceso a la pantalla.  
  
 Observe que cada línea después del primer punto utiliza el punto anterior como punto inicial y el nuevo punto como punto de conexión.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#8)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#8)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLines">
      <MemberSignature Language="C#" Value="public void AddLines (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLines(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLines(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLines (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLines(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que representa los puntos que definen los segmentos de línea que se van a agregar.</param>
        <summary>Anexa una serie de segmentos de línea conectados al final de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay líneas o curvas en la ilustración anteriores, se agrega una línea para conectar el extremo del segmento anterior con el punto inicial de la línea. El `points` parámetro especifica una matriz de puntos de conexión. Los dos primeros especifican la primera línea. Cada punto adicional especifica el extremo de un segmento de línea cuyo punto inicial es el punto de conexión de la línea anterior.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddLines%28System.Drawing.Point%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPath">
      <MemberSignature Language="C#" Value="public void AddPath (System.Drawing.Drawing2D.GraphicsPath addingPath, bool connect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPath(class System.Drawing.Drawing2D.GraphicsPath addingPath, bool connect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPath(System.Drawing.Drawing2D.GraphicsPath,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPath (addingPath As GraphicsPath, connect As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPath(System::Drawing::Drawing2D::GraphicsPath ^ addingPath, bool connect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addingPath" Type="System.Drawing.Drawing2D.GraphicsPath" />
        <Parameter Name="connect" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="addingPath">
          <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> que se va a agregar.</param>
        <param name="connect">Valor booleano que especifica si la primera figura del trazado agregado forma parte de la última figura de este trazado. El valor <see langword="true" /> especifica que, si es posible, la primera figura del trazado agregado forma parte de la última figura de este trazado. El valor <see langword="false" /> especifica que la primera figura del trazado agregado no forma parte de la última figura de este trazado.</param>
        <summary>Anexa el trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> especificado a este trazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea dos trazados, un triángulo derecha en posición vertical y el otro un triángulo flechas de lado.  
  
-   Agrega la segunda ruta de acceso a la primera.  
  
-   Dibuja la ruta de acceso resultante en la pantalla.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#9)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#9)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddPie">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega el contorno de una forma circular a este trazado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (rect As Rectangle, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> que representa el rectángulo delimitador que define la elipse cuya forma circular se dibuja.</param>
        <param name="startAngle">Ángulo de inicio de la sección circular, medido en grados en el sentido de las agujas del reloj desde el eje X.</param>
        <param name="sweepAngle">Ángulo existente entre <c>startAngle</c> y el final de la sección circular, medido en grados en el sentido de las agujas del reloj desde <c>startAngle</c>.</param>
        <summary>Agrega el contorno de una forma circular a este trazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La forma de gráfico circular se define por un contorno parcial de una elipse y dos líneas radiales que forman una intersección los extremos del contorno parcial. El contorno parcial comienza en `startAngle` (medido hacia la derecha desde el eje x) y termina en `startAngle`  +  `sweepAngle`.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddPie%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(int32 x, int32 y, int32 width, int32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (x As Integer, y As Integer, width As Integer, height As Integer, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada x del ángulo superior izquierdo del rectángulo delimitador que define la elipse desde la que se dibuja la forma circular.</param>
        <param name="y">Coordenada y del ángulo superior izquierdo del rectángulo delimitador que define la elipse desde la que se dibuja la forma circular.</param>
        <param name="width">Ancho del rectángulo limitador que define la elipse de la que se dibuja la forma circular.</param>
        <param name="height">Alto del rectángulo limitador que define la elipse de la que se dibuja la forma circular.</param>
        <param name="startAngle">Ángulo de inicio de la sección circular, medido en grados en el sentido de las agujas del reloj desde el eje X.</param>
        <param name="sweepAngle">Ángulo existente entre <c>startAngle</c> y el final de la sección circular, medido en grados en el sentido de las agujas del reloj desde <c>startAngle</c>.</param>
        <summary>Agrega el contorno de una forma circular a este trazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La forma de gráfico circular se define por un contorno parcial de una elipse y dos líneas radiales que forman una intersección los extremos del contorno parcial. El contorno parcial comienza en `startAngle` (medido hacia la derecha desde el eje x) y termina en `startAngle`  +  `sweepAngle`.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código crea un trazado gráfico, agrega la forma circular y, a continuación, dibuja la ruta de acceso a la pantalla.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#10)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#10)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (x As Single, y As Single, width As Single, height As Single, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada x del ángulo superior izquierdo del rectángulo delimitador que define la elipse desde la que se dibuja la forma circular.</param>
        <param name="y">Coordenada y del ángulo superior izquierdo del rectángulo delimitador que define la elipse desde la que se dibuja la forma circular.</param>
        <param name="width">Ancho del rectángulo limitador que define la elipse de la que se dibuja la forma circular.</param>
        <param name="height">Alto del rectángulo limitador que define la elipse de la que se dibuja la forma circular.</param>
        <param name="startAngle">Ángulo de inicio de la sección circular, medido en grados en el sentido de las agujas del reloj desde el eje X.</param>
        <param name="sweepAngle">Ángulo existente entre <c>startAngle</c> y el final de la sección circular, medido en grados en el sentido de las agujas del reloj desde <c>startAngle</c>.</param>
        <summary>Agrega el contorno de una forma circular a este trazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La forma de gráfico circular se define por un contorno parcial de una elipse y dos líneas radiales que forman una intersección los extremos del contorno parcial. El contorno parcial comienza en `startAngle` (medido hacia la derecha desde el eje x) y termina en `startAngle`  +  `sweepAngle`.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddPie%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddPolygon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega un polígono a este trazado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddPolygon">
      <MemberSignature Language="C#" Value="public void AddPolygon (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPolygon(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPolygon(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPolygon (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPolygon(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que define el polígono que se va a agregar.</param>
        <summary>Agrega un polígono a este trazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los puntos en el `points` matriz especificar los vértices de un polígono. Si el primer punto de la matriz no es el mismo que el último punto, los dos puntos se conectan para cerrar el polígono.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una matriz de puntos que define un polígono.  
  
-   Crea una ruta de acceso y el polígono se agrega a la ruta de acceso.  
  
-   Dibuja la ruta de acceso a la pantalla.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#11)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#11)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPolygon">
      <MemberSignature Language="C#" Value="public void AddPolygon (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPolygon(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPolygon(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPolygon (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPolygon(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que define el polígono que se va a agregar.</param>
        <summary>Agrega un polígono a este trazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los puntos en el `points` matriz especificar los vértices de un polígono. Si el primer punto de la matriz no es el mismo que el último punto, los dos puntos se conectan para cerrar el polígono.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddPolygon%28System.Drawing.Point%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRectangle">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega un rectángulo a este trazado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRectangle">
      <MemberSignature Language="C#" Value="public void AddRectangle (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangle(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangle(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangle (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangle(System::Drawing::Rectangle rect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> que representa el rectángulo que se va a agregar.</param>
        <summary>Agrega un rectángulo a este trazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una ruta de acceso.  
  
-   Crea un rectángulo y agrega el rectángulo a la ruta de acceso.  
  
-   Dibuja la ruta de acceso a la pantalla.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#12)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#12)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRectangle">
      <MemberSignature Language="C#" Value="public void AddRectangle (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangle(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangle(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangle (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangle(System::Drawing::RectangleF rect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> que representa el rectángulo que se va a agregar.</param>
        <summary>Agrega un rectángulo a este trazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddRectangle%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRectangles">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega una serie de rectángulos a este trazado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRectangles">
      <MemberSignature Language="C#" Value="public void AddRectangles (System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangles(valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangles(System.Drawing.Rectangle[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangles (rects As Rectangle())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangles(cli::array &lt;System::Drawing::Rectangle&gt; ^ rects);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="rects">Matriz de estructuras <see cref="T:System.Drawing.Rectangle" /> que representa los rectángulos que se van a agregar.</param>
        <summary>Agrega una serie de rectángulos a este trazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una ruta de acceso.  
  
-   Crea una matriz de rectángulos y los rectángulos se agrega a la ruta de acceso.  
  
-   Dibuja la ruta de acceso a la pantalla.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#13)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#13)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRectangles">
      <MemberSignature Language="C#" Value="public void AddRectangles (System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangles(valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangles(System.Drawing.RectangleF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangles (rects As RectangleF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangles(cli::array &lt;System::Drawing::RectangleF&gt; ^ rects);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="rects">Matriz de estructuras <see cref="T:System.Drawing.RectangleF" /> que representa los rectángulos que se van a agregar.</param>
        <summary>Agrega una serie de rectángulos a este trazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddRectangles%28System.Drawing.Rectangle%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddString">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega una cadena de texto a este trazado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.Point origin, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.Point origin, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.Point,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, origin As Point, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::Point origin, System::Drawing::StringFormat ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="origin" Type="System.Drawing.Point" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> que se va a agregar.</param>
        <param name="family">
          <see cref="T:System.Drawing.FontFamily" /> que representa el nombre de la fuente con la que se dibuja la prueba.</param>
        <param name="style">Enumeración <see cref="T:System.Drawing.FontStyle" /> que representa la información de estilo sobre el texto (negrita, cursiva, etc.). Se debe convertir en un entero (vea el ejemplo de código más adelante en esta sección).</param>
        <param name="emSize">Alto del cuadrado Em que delimita el carácter.</param>
        <param name="origin">
          <see cref="T:System.Drawing.Point" /> que representa el punto donde comienza el texto.</param>
        <param name="format">
          <see cref="T:System.Drawing.StringFormat" /> que especifica información sobre el formato de texto, como el interlineado y la alineación.</param>
        <summary>Agrega una cadena de texto a este trazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una ruta de acceso.  
  
-   Configura los argumentos de cadena y fuente.  
  
-   Agrega la cadena a la ruta de acceso.  
  
-   Dibuja la cadena en la pantalla.  
  
 Hay dos aspectos importantes a señalar. En primer lugar, tenga en cuenta que el `fontStyle` argumento se convierte como un entero. El <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%2A> método lo requiere, por lo que ese dos o más <xref:System.Drawing.FontStyle> miembros se pueden combinar para crear el estilo de fuente deseado (en este caso, <xref:System.Drawing.FontStyle.Italic> y <xref:System.Drawing.FontStyle.Underline>). En segundo lugar, tenga en cuenta que la <xref:System.Drawing.Graphics.FillPath%2A> método se utiliza en lugar del <xref:System.Drawing.Graphics.DrawPath%2A> método. Si <xref:System.Drawing.Graphics.FillPath%2A> se utiliza, se representa texto sólido, mientras que si <xref:System.Drawing.Graphics.DrawPath%2A> es usa, el texto será un estilo de esquema.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#14)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#14)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.PointF origin, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.PointF origin, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, origin As PointF, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::PointF origin, System::Drawing::StringFormat ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="origin" Type="System.Drawing.PointF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> que se va a agregar.</param>
        <param name="family">
          <see cref="T:System.Drawing.FontFamily" /> que representa el nombre de la fuente con la que se dibuja la prueba.</param>
        <param name="style">Enumeración <see cref="T:System.Drawing.FontStyle" /> que representa la información de estilo sobre el texto (negrita, cursiva, etc.). Se debe convertir en un entero (vea el ejemplo de código más adelante en esta sección).</param>
        <param name="emSize">Alto del cuadrado Em que delimita el carácter.</param>
        <param name="origin">
          <see cref="T:System.Drawing.PointF" /> que representa el punto donde comienza el texto.</param>
        <param name="format">
          <see cref="T:System.Drawing.StringFormat" /> que especifica información sobre el formato de texto, como el interlineado y la alineación.</param>
        <summary>Agrega una cadena de texto a este trazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.Rectangle layoutRect, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.Rectangle layoutRect, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.Rectangle,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, layoutRect As Rectangle, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::Rectangle layoutRect, System::Drawing::StringFormat ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="layoutRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> que se va a agregar.</param>
        <param name="family">
          <see cref="T:System.Drawing.FontFamily" /> que representa el nombre de la fuente con la que se dibuja la prueba.</param>
        <param name="style">Enumeración <see cref="T:System.Drawing.FontStyle" /> que representa la información de estilo sobre el texto (negrita, cursiva, etc.). Se debe convertir en un entero (vea el ejemplo de código más adelante en esta sección).</param>
        <param name="emSize">Alto del cuadrado Em que delimita el carácter.</param>
        <param name="layoutRect">
          <see cref="T:System.Drawing.Rectangle" /> que representa el rectángulo que delimita el texto.</param>
        <param name="format">
          <see cref="T:System.Drawing.StringFormat" /> que especifica información sobre el formato de texto, como el interlineado y la alineación.</param>
        <summary>Agrega una cadena de texto a este trazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.RectangleF layoutRect, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.RectangleF layoutRect, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, layoutRect As RectangleF, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::RectangleF layoutRect, System::Drawing::StringFormat ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="layoutRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> que se va a agregar.</param>
        <param name="family">
          <see cref="T:System.Drawing.FontFamily" /> que representa el nombre de la fuente con la que se dibuja la prueba.</param>
        <param name="style">Enumeración <see cref="T:System.Drawing.FontStyle" /> que representa la información de estilo sobre el texto (negrita, cursiva, etc.). Se debe convertir en un entero (vea el ejemplo de código más adelante en esta sección).</param>
        <param name="emSize">Alto del cuadrado Em que delimita el carácter.</param>
        <param name="layoutRect">
          <see cref="T:System.Drawing.RectangleF" /> que representa el rectángulo que delimita el texto.</param>
        <param name="format">
          <see cref="T:System.Drawing.StringFormat" /> que especifica información sobre el formato de texto, como el interlineado y la alineación.</param>
        <summary>Agrega una cadena de texto a este trazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearMarkers">
      <MemberSignature Language="C#" Value="public void ClearMarkers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearMarkers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.ClearMarkers" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearMarkers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearMarkers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra todos los marcadores de este trazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Drawing.Drawing2D.GraphicsPath.SetMarkers%2A> método para crear un marcador en la ubicación actual en un <xref:System.Drawing.Drawing2D.GraphicsPath>. Use la <xref:System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker%2A> método para recorrer en iteración los marcadores existentes en una ruta de acceso.  
  
 Los marcadores se utilizan para separar grupos de subtrazados. Entre dos marcadores puede haber uno o varios subtrazados.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una ruta de acceso.  
  
-   Agrega varios objetos a la ruta de acceso.  
  
-   Agrega marcadores a la ruta de acceso.  
  
-   Borra todos los marcadores de la ruta de acceso.  
  
-   Dibuja la ruta de acceso a la pantalla.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#15)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#15)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia exacta de este trazado.</summary>
        <returns>
          <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> que crea este método, convertido en objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una ruta de acceso.  
  
-   Agrega varias figuras a la ruta de acceso.  
  
-   Dibuja la ruta de acceso a la pantalla.  
  
-   Clona una copia de dicha ruta de acceso.  
  
-   Dibuja la nueva ruta de acceso a la pantalla.  
  
 Tenga en cuenta que la llamada la <xref:System.Drawing.Drawing2D.GraphicsPath.Clone%2A> método debe convertirse en un <xref:System.Drawing.Drawing2D.GraphicsPath>.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#16)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#16)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseAllFigures">
      <MemberSignature Language="C#" Value="public void CloseAllFigures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseAllFigures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.CloseAllFigures" />
      <MemberSignature Language="VB.NET" Value="Public Sub CloseAllFigures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseAllFigures();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra todas las figuras abiertas de este trazado e inicia una nueva figura. Cierra cada figura abierta conectando una línea desde su extremo hasta su punto inicial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una ruta de acceso.  
  
-   Agrega varias figuras abiertas a la ruta de acceso.  
  
-   Cierra todas las figuras en la ruta de acceso.  
  
-   Dibuja la ruta de acceso a la pantalla.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#17)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#17)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseFigure">
      <MemberSignature Language="C#" Value="public void CloseFigure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseFigure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.CloseFigure" />
      <MemberSignature Language="VB.NET" Value="Public Sub CloseFigure ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseFigure();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra la figura actual e inicia una nueva figura. Si la figura actual contiene una secuencia de líneas y curvas interconectadas, este método cierra el bucle conectando una línea desde el extremo hasta el punto inicial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código crea un triángulo al crear una nueva ruta de acceso, a partir de una figura, agregar dos líneas de intersección en la figura y, a continuación, cerrando la figura para formar un triángulo. A continuación, se dibuja la ruta de acceso a la pantalla.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#18)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#18)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos utilizados por este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al llamar a <xref:System.Drawing.Drawing2D.GraphicsPath.Dispose%2A> permite que los recursos utilizados por este <xref:System.Drawing.Drawing2D.GraphicsPath> se reasignen para otros fines.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.FillMode FillMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.FillMode FillMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.FillMode" />
      <MemberSignature Language="VB.NET" Value="Public Property FillMode As FillMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::FillMode FillMode { System::Drawing::Drawing2D::FillMode get(); void set(System::Drawing::Drawing2D::FillMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.FillMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina cómo se rellena el interior de las formas en este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <value>Enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> que especifica cómo se rellena el interior de las formas en este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~GraphicsPath ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!GraphicsPath ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que un objeto intente liberar recursos y realizar otras operaciones de limpieza antes de que sea reclamado por la recolección de elementos no utilizados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flatten">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte cada una de las curvas de este trazado en una secuencia de segmentos conectados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flatten ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convierte cada una de las curvas de este trazado en una secuencia de segmentos conectados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.Flatten%28System.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">
          <see cref="T:System.Drawing.Drawing2D.Matrix" /> mediante la cual se va a transformar este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> antes de aplanarlo.</param>
        <summary>Aplica la transformación especificada y, a continuación, convierte cada curva de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> en una secuencia de segmentos de línea conectados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.Flatten%28System.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten (System.Drawing.Drawing2D.Matrix matrix, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten(class System.Drawing.Drawing2D.Matrix matrix, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten(System.Drawing.Drawing2D.Matrix,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten(System::Drawing::Drawing2D::Matrix ^ matrix, float flatness);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="matrix">
          <see cref="T:System.Drawing.Drawing2D.Matrix" /> mediante la cual se va a transformar este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> antes de aplanarlo.</param>
        <param name="flatness">Especifica el error máximo permitido entre la curva y su aproximación aplanada. El valor predeterminado es 0,25. Si se reduce el valor del aplanamiento aumentará el número de segmentos de línea en la aproximación.</param>
        <summary>Convierte cada curva de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> en una secuencia de segmentos de línea conectados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea un trazado gráfico y una matriz de traslación.  
  
-   Agrega una curva a la ruta de acceso con cuatro puntos.  
  
-   Dibuja la ruta de acceso (curva) en la pantalla, con un lápiz de color negro.  
  
-   Se desplaza a la curva hacia abajo 10 píxeles y se reduce.  
  
-   Dibuja la curva en la pantalla con un lápiz rojo.  
  
 Tenga en cuenta que la curva de color rojo se reducen las líneas que conectan los puntos.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#19)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#19)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBounds">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un rectángulo que delimita este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBounds () As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un rectángulo que delimita este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>
          <see cref="T:System.Drawing.RectangleF" /> que representa un rectángulo que delimita este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tamaño del rectángulo delimitador devuelto se ve afectado por el tipo de límite en ángulo lápiz, extremos y ancho del lápiz y, por tanto, crea un "ajuste flexible" a la ruta de acceso enlazado. La fórmula aproximada es: el rectángulo delimitador inicial se aumenta en el ancho del lápiz y este resultado se multiplica por el límite del ángulo, además de un margen adicional para los extremos.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una ruta de acceso de gráficos.  
  
-   Agrega una elipse (círculo) a él y lo muestra en la pantalla.  
  
-   Recupera el rectángulo delimitador para el círculo con una llamada a <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds%2A> y dibuja el rectángulo en la pantalla.  
  
-   Crea una segunda ruta de acceso de gráficos.  
  
-   Agrega un círculo y ensancha la ruta de acceso a un ancho de 10.  
  
-   Dibuja la ruta de acceso a la pantalla.  
  
-   Recupera el rectángulo delimitador para el segundo círculo.  
  
-   Dibuja el rectángulo delimitador en la pantalla.  
  
-   Muestra el tamaño del rectángulo en un cuadro de diálogo.  
  
 Tenga en cuenta que el rectángulo delimitador de la derecha es más grande (a la cuenta para el ancho de la línea adicional).  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#20)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#20)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">
          <see cref="T:System.Drawing.Drawing2D.Matrix" /> que especifica la transformación que se va a aplicar a este trazado antes de que se calcule el rectángulo delimitador. Este trazado no se transforma de manera permanente, se usa sólo durante el proceso de cálculo del rectángulo delimitador.</param>
        <summary>Devuelve un rectángulo que delimita este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se transforma por la matriz <see cref="T:System.Drawing.Drawing2D.Matrix" /> especificada.</summary>
        <returns>
          <see cref="T:System.Drawing.RectangleF" /> que representa un rectángulo que delimita este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tamaño del rectángulo delimitador devuelto se ve afectado por el tipo de límite en ángulo lápiz, extremos y ancho del lápiz y, por tanto, crea un "ajuste flexible" a la ruta de acceso enlazado. La fórmula aproximada es: el rectángulo delimitador inicial se aumenta en el ancho del lápiz y este resultado se multiplica por el límite del ángulo, además de un margen adicional para los extremos.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds (System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds(class System.Drawing.Drawing2D.Matrix matrix, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds(System.Drawing.Drawing2D.Matrix,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds(System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="matrix">
          <see cref="T:System.Drawing.Drawing2D.Matrix" /> que especifica la transformación que se va a aplicar a este trazado antes de que se calcule el rectángulo delimitador. Este trazado no se transforma de manera permanente, se usa sólo durante el proceso de cálculo del rectángulo delimitador.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> con el que se va a dibujar el trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <summary>Devuelve un rectángulo que delimita este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando el actual trazado se transforma por la matriz <see cref="T:System.Drawing.Drawing2D.Matrix" /> especificada y se dibuja con el <see cref="T:System.Drawing.Pen" /> indicado.</summary>
        <returns>
          <see cref="T:System.Drawing.RectangleF" /> que representa un rectángulo que delimita este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tamaño del rectángulo delimitador devuelto se ve afectado por el tipo de límite en ángulo lápiz, extremos y ancho del lápiz y, por tanto, crea un "ajuste flexible" a la ruta de acceso enlazado. La fórmula aproximada es: el rectángulo delimitador inicial se aumenta en el ancho del lápiz y este resultado se multiplica por el límite del ángulo, además de un margen adicional para los extremos.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastPoint">
      <MemberSignature Language="C#" Value="public System.Drawing.PointF GetLastPoint ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.PointF GetLastPoint() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetLastPoint" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastPoint () As PointF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::PointF GetLastPoint();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el último punto de la matriz <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Un <see cref="T:System.Drawing.PointF" /> que representa el último punto de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código crea una ruta de acceso, agrega una línea a la ruta de acceso y, a continuación, obtiene el último punto en la ruta de acceso.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#21)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#21)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOutlineVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.Point point, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.Point point, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.Point,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::Point point, System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="point">
          <see cref="T:System.Drawing.Point" /> que especifica la ubicación que se va a comprobar.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> que se va a probar.</param>
        <summary>Indica si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> especificado.</summary>
        <returns>Este método devuelve <see langword="true" /> si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> indicado; en caso contrario, devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método comprueba si el esquema de una ruta de acceso dada se representa visible en el punto especificado.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.PointF point, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.PointF point, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.PointF,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::PointF point, System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="point">
          <see cref="T:System.Drawing.PointF" /> que especifica la ubicación que se va a comprobar.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> que se va a probar.</param>
        <summary>Indica si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> especificado.</summary>
        <returns>Este método devuelve <see langword="true" /> si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> indicado; en caso contrario, devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método comprueba si el esquema de una ruta de acceso dada se representa visible en el punto especificado.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.Point pt, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.Point pt, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.Point,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::Point pt, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">
          <see cref="T:System.Drawing.Point" /> que especifica la ubicación que se va a comprobar.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> que se va a probar.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> cuya visibilidad se va a comprobar.</param>
        <summary>Indica si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> especificado y el <see cref="T:System.Drawing.Graphics" /> indicado.</summary>
        <returns>Este método devuelve <see langword="true" /> si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> indicado; en caso contrario, devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método comprueba si el esquema de una ruta de acceso dada se representa visible en el punto especificado. Las coordenadas del punto de va a probar se proporcionan en coordenadas universales. La matriz de transformación de `graphics` se aplica temporalmente antes de las pruebas para la visibilidad.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.PointF pt, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.PointF pt, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.PointF,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::PointF pt, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.PointF" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">
          <see cref="T:System.Drawing.PointF" /> que especifica la ubicación que se va a comprobar.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> que se va a probar.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> cuya visibilidad se va a comprobar.</param>
        <summary>Indica si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> especificado y el <see cref="T:System.Drawing.Graphics" /> indicado.</summary>
        <returns>Este método devuelve <see langword="true" /> si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> indicado; en caso contrario, devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método comprueba si el esquema de una ruta de acceso dada se representa visible en el punto especificado. Las coordenadas del punto de va a probar se proporcionan en coordenadas universales. La matriz de transformación de `graphics` se aplica temporalmente antes de las pruebas para la visibilidad.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (int x, int y, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(int32 x, int32 y, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Int32,System.Int32,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(int x, int y, System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada X del punto que se va a probar.</param>
        <param name="y">Coordenada Y del punto que se va a probar.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> que se va a probar.</param>
        <summary>Indica si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> especificado.</summary>
        <returns>Este método devuelve <see langword="true" /> si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> indicado; en caso contrario, devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método comprueba si el esquema de una ruta de acceso dada se representa visible en el punto especificado.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (float x, float y, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(float32 x, float32 y, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Single,System.Single,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(float x, float y, System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada X del punto que se va a probar.</param>
        <param name="y">Coordenada Y del punto que se va a probar.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> que se va a probar.</param>
        <summary>Indica si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> especificado.</summary>
        <returns>Este método devuelve <see langword="true" /> si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> indicado; en caso contrario, devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método comprueba si el esquema de una ruta de acceso dada se representa visible en el punto especificado.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (int x, int y, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(int32 x, int32 y, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Int32,System.Int32,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(int x, int y, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada X del punto que se va a probar.</param>
        <param name="y">Coordenada Y del punto que se va a probar.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> que se va a probar.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> cuya visibilidad se va a comprobar.</param>
        <summary>Indica si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> especificado y el <see cref="T:System.Drawing.Graphics" /> indicado.</summary>
        <returns>Este método devuelve <see langword="true" /> si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> indicado; en caso contrario, devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método comprueba si el esquema de una ruta de acceso dada se representa visible en el punto especificado. Las coordenadas del punto de va a probar se proporcionan en coordenadas universales. La matriz de transformación de `graphics` se aplica temporalmente antes de las pruebas para la visibilidad.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> eventos. El código realiza las siguientes acciones:  
  
-   Crea una ruta de acceso.  
  
-   Agrega un rectángulo a la ruta de acceso.  
  
-   Crea un lápiz ancho y se amplía la ruta de acceso con ese lápiz (para convertirlo en el ejemplo más claro),  
  
-   Prueba en un punto (100, 50) para ver si se encuentra dentro (bajo) de uno de los bordes del rectángulo mediante una llamada a <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%2A>.  
  
 El resultado se muestra en el cuadro de mensaje (en este caso, true). En otras palabras, el borde se representa en ese punto.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#22)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#22)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (float x, float y, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(float32 x, float32 y, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Single,System.Single,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(float x, float y, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada X del punto que se va a probar.</param>
        <param name="y">Coordenada Y del punto que se va a probar.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> que se va a probar.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> cuya visibilidad se va a comprobar.</param>
        <summary>Indica si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> especificado y el <see cref="T:System.Drawing.Graphics" /> indicado.</summary>
        <returns>Este método devuelve <see langword="true" /> si el punto especificado está dentro del contorno de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> cuando se dibuja con el <see cref="T:System.Drawing.Pen" /> indicado; en caso contrario, devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método comprueba si el esquema de una ruta de acceso dada se representa visible en el punto especificado. Las coordenadas del punto de va a probar se proporcionan en coordenadas universales. La matriz de transformación de la `graphics` parámetro temporalmente se aplica antes de las pruebas para la visibilidad.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si el punto especificado está dentro de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">
          <see cref="T:System.Drawing.Point" /> que representa el punto que se va a comprobar.</param>
        <summary>Indica si el punto especificado está dentro de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Este método devuelve <see langword="true" /> si el punto especificado está dentro de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; de lo contrario, devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta `GraphicsPath.IsVisible Method (Int32, Int32, Graphics)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (point As PointF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="point">
          <see cref="T:System.Drawing.PointF" /> que representa el punto que se va a comprobar.</param>
        <summary>Indica si el punto especificado está dentro de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Este método devuelve <see langword="true" /> si el punto especificado está dentro de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; de lo contrario, devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point pt, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point pt, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.Point,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point pt, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">
          <see cref="T:System.Drawing.Point" /> que representa el punto que se va a comprobar.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> cuya visibilidad se va a comprobar.</param>
        <summary>Indica si el punto especificado está dentro de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Este método devuelve <see langword="true" /> si el punto especificado está dentro de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; de lo contrario, devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las coordenadas del punto de va a probar se proporcionan en coordenadas universales. La matriz de transformación de la `graphics` parámetro temporalmente se aplica antes de las pruebas para la visibilidad.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta `GraphicsPath.IsVisible Method (Int32, Int32, Graphics)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF pt, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF pt, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.PointF,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF pt, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.PointF" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">
          <see cref="T:System.Drawing.PointF" /> que representa el punto que se va a comprobar.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> cuya visibilidad se va a comprobar.</param>
        <summary>Indica si el punto especificado está dentro de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Este método devuelve <see langword="true" /> si el punto especificado está contenido dentro de este objeto; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las coordenadas del punto de va a probar se proporcionan en coordenadas universales. La matriz de transformación de la `graphics` parámetro temporalmente se aplica antes de las pruebas para la visibilidad.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada X del punto que se va a probar.</param>
        <param name="y">Coordenada Y del punto que se va a probar.</param>
        <summary>Indica si el punto especificado está dentro de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Este método devuelve <see langword="true" /> si el punto especificado está dentro de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; de lo contrario, devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada X del punto que se va a probar.</param>
        <param name="y">Coordenada Y del punto que se va a probar.</param>
        <summary>Indica si el punto especificado está dentro de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Este método devuelve <see langword="true" /> si el punto especificado está dentro de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; de lo contrario, devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Int32,System.Int32,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada X del punto que se va a probar.</param>
        <param name="y">Coordenada Y del punto que se va a probar.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> cuya visibilidad se va a comprobar.</param>
        <summary>Indica si el punto especificado está dentro de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />, utilizando el <see cref="T:System.Drawing.Graphics" /> indicado.</summary>
        <returns>Este método devuelve <see langword="true" /> si el punto especificado está dentro de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; de lo contrario, devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las coordenadas del punto de va a probar se proporcionan en coordenadas universales. La matriz de transformación de `graphics` se aplica temporalmente antes de las pruebas para la visibilidad.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una ruta de acceso y agrega una elipse a la ruta de acceso.  
  
-   Comprueba si el punto especificado está dentro de la ruta de acceso.  
  
-   Muestra el resultado en un cuadro de diálogo.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#23)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#23)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Single,System.Single,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada X del punto que se va a probar.</param>
        <param name="y">Coordenada Y del punto que se va a probar.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> cuya visibilidad se va a comprobar.</param>
        <summary>Indica si el punto especificado está dentro de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> en la región de recorte visible del <see cref="T:System.Drawing.Graphics" /> indicado.</summary>
        <returns>Este método devuelve <see langword="true" /> si el punto especificado está dentro de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; de lo contrario, devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las coordenadas del punto de va a probar se proporcionan en coordenadas universales. La matriz de transformación de la `graphics` parámetro temporalmente se aplica antes de las pruebas para la visibilidad.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathData">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.PathData PathData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Drawing2D.PathData PathData" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathData As PathData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::PathData ^ PathData { System::Drawing::Drawing2D::PathData ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.PathData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los datos <see cref="T:System.Drawing.Drawing2D.PathData" /> que encapsulan matrices de puntos (<paramref name="points" />) y tipos (<paramref name="types" />) para este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <value>
          <see cref="T:System.Drawing.Drawing2D.PathData" /> que encapsulan matrices de puntos y tipos para este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathPoints">
      <MemberSignature Language="C#" Value="public System.Drawing.PointF[] PathPoints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.PointF[] PathPoints" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathPoints As PointF()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Drawing::PointF&gt; ^ PathPoints { cli::array &lt;System::Drawing::PointF&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los puntos del trazado.</summary>
        <value>Una matriz de objetos <see cref="T:System.Drawing.PointF" /> que representan el trazado.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathTypes">
      <MemberSignature Language="C#" Value="public byte[] PathTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] PathTypes" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathTypes As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ PathTypes { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los tipos de los puntos correspondientes de la matriz <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" />.</summary>
        <value>Matriz de bytes que especifica los tipos de los puntos correspondientes del trazado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz de bytes devuelto por la <xref:System.Drawing.Drawing2D.GraphicsPath.PathTypes%2A> propiedad especifica los tipos de punto y los marcadores de los puntos de datos en una ruta de acceso. Para cada punto, bits del 0 al 2 indican el tipo de un punto y bits 3 al 7 contienen un conjunto de marcas que especifican los atributos de un punto. La siguiente tabla muestra los valores posibles y sus significados.  
  
|Valor|Significado|  
|-----------|-------------|  
|0|Indica que el punto es el inicio de una figura.|  
|1|Indica que el punto es uno de los dos extremos de una línea.|  
|3|Indica que el punto es un punto de control o extremo de una curva spline de Bézier cúbica.|  
|0x7|Enmascara todos los bits excepto los tres bits de orden inferior, que indican el tipo de punto.|  
|0x20|Especifica que el punto es un marcador.|  
|0x80|Especifica que el punto es el último punto en una subruta cerrado (figura).|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointCount">
      <MemberSignature Language="C#" Value="public int PointCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PointCount" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PointCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PointCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PointCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de elementos de la matriz <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> o de la matriz <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" />.</summary>
        <value>Un entero que especifica el número de elementos de la matriz <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" />o de la matriz <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vacía las matrices <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> y <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> y establece <see cref="T:System.Drawing.Drawing2D.FillMode" /> en <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una ruta de acceso.  
  
-   Se le agrega a varios elementos primitivos.  
  
-   Dibuja la matriz de puntos de la ruta de acceso a la pantalla.  
  
-   Restablece la ruta de acceso a un estado vacío.  
  
-   Vuelve a adquirir la matriz de puntos (si existe).  
  
-   Dibuja la matriz en la pantalla.  
  
 Tenga en cuenta que no encuentra ninguna matriz después de la llamada de restablecimiento.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#24)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#24)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Invierte el orden de los puntos en la matriz de <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> de este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una ruta de acceso y agrega a varios elementos primitivos a la ruta de acceso.  
  
-   Dibuja la matriz de puntos de la ruta de acceso a la pantalla.  
  
-   Dibuja la matriz de puntos en orden invertido en la pantalla.  
  
 Tenga en cuenta que el segundo listado de puntos está en orden inverso de la primera.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#25)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#25)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#25)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMarkers">
      <MemberSignature Language="C#" Value="public void SetMarkers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMarkers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.SetMarkers" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMarkers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMarkers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establece un marcador en este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea un marcador en la ruta de acceso que puede usarse para separar dos secciones de la ruta de acceso. A continuación, puede usar el <xref:System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker%2A> métodos para recorrer en iteración los marcadores en la ruta de acceso.  
  
 Los marcadores se utilizan para separar grupos de subtrazados. Entre dos marcadores en la ruta de acceso puede ser uno o varios subtrazados.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código crea una ruta de acceso y agrega a varios elementos primitivos separado por marcadores de la ruta de acceso y dibuja la ruta de acceso a la pantalla.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#26)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#26)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartFigure">
      <MemberSignature Language="C#" Value="public void StartFigure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartFigure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.StartFigure" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartFigure ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartFigure();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia una nueva figura sin cerrar la actual. Todos los puntos siguientes agregados al trazado se incorporan a esta nueva figura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El usuario debe mantener los puntos originales si son necesarias. Los puntos originales se convierten en puntos de control de Bézier cúbicos internamente, por lo tanto, no hay ningún mecanismo para devolver los puntos originales.  
  
 Este método inicia una subruta de acceso nuevo en la ruta de acceso. Subtrazados permiten dividir un trazado en secciones y usar la <xref:System.Drawing.Drawing2D.GraphicsPathIterator> clase para recorrer en iteración los subtrazados.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una ruta de acceso.  
  
-   Agrega dos conjuntos de figuras. El primer conjunto de figuras combina a cuatro elementos primitivos en dos figuras. El segundo conjunto de figuras combina a los mismos cuatro elementos primitivos (salvo que se calcula el desplazamiento en el eje y) en tres cifras.  
  
-   Dibuja todas las figuras en la pantalla.  
  
 Observe la diferencia en el aspecto entre los dos conjuntos de figuras.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#27)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#27)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public void Transform (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transform(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Transform(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transform(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">
          <see cref="T:System.Drawing.Drawing2D.Matrix" /> que representa la transformación que se va a aplicar.</param>
        <summary>Aplica una matriz de transformación a este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La transformación puede escalar, traducir, girar o sesgar la <xref:System.Drawing.Drawing2D.GraphicsPath>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una ruta de acceso y agrega una elipse a la ruta de acceso.  
  
-   Dibuja la ruta de acceso a la pantalla.  
  
-   Crea una matriz de transformación para convertir la ruta de acceso de 100 unidades en la dirección del eje x.  
  
-   Dibuja el trazado transformado en la pantalla.  
  
 Observe que la elipse original se dibuja en negro y la elipse transformada se dibuja en rojo.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#28)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#28)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Warp">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aplica una transformación de alabeo, definida por un rectángulo y un paralelogramo, a este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Warp (destPoints As PointF(), srcRect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="destPoints">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que definen un paralelogramo en el que se transforma el rectángulo definido por <c>srcRect</c>. La matriz puede contener tres elementos o cuatro. Si la matriz contiene tres elementos, el ángulo inferior derecho del paralelogramo viene definido por los tres primeros puntos.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> que representa el rectángulo que se transforma en el paralelogramo definido por <c>destPoints</c>.</param>
        <summary>Aplica una transformación de alabeo, definida por un rectángulo y un paralelogramo, a este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="destPoints">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que definen un paralelogramo en el que se transforma el rectángulo definido por <c>srcRect</c>. La matriz puede contener tres elementos o cuatro. Si la matriz contiene tres elementos, el ángulo inferior derecho del paralelogramo viene definido por los tres primeros puntos.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> que representa el rectángulo que se transforma en el paralelogramo definido por <c>destPoints</c>.</param>
        <param name="matrix">
          <see cref="T:System.Drawing.Drawing2D.Matrix" /> que especifica la transformación geométrica que se va a aplicar al trazado.</param>
        <summary>Aplica una transformación de alabeo, definida por un rectángulo y un paralelogramo, a este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.WarpMode warpMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.WarpMode warpMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.WarpMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::WarpMode warpMode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="warpMode" Type="System.Drawing.Drawing2D.WarpMode" />
      </Parameters>
      <Docs>
        <param name="destPoints">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que define un paralelogramo en el que se transforma el rectángulo definido por <c>srcRect</c>. La matriz puede contener tres elementos o cuatro. Si la matriz contiene tres elementos, el ángulo inferior derecho del paralelogramo viene definido por los tres primeros puntos.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> que representa el rectángulo que se transforma en el paralelogramo definido por <c>destPoints</c>.</param>
        <param name="matrix">
          <see cref="T:System.Drawing.Drawing2D.Matrix" /> que especifica la transformación geométrica que se va a aplicar al trazado.</param>
        <param name="warpMode">Enumeración <see cref="T:System.Drawing.Drawing2D.WarpMode" /> que especifica si esta operación de alabeo usa el modo en perspectiva o bilineal.</param>
        <summary>Aplica una transformación de alabeo, definida por un rectángulo y un paralelogramo, a este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.WarpMode warpMode, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.WarpMode warpMode, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.WarpMode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::WarpMode warpMode, float flatness);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="warpMode" Type="System.Drawing.Drawing2D.WarpMode" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="destPoints">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que definen un paralelogramo en el que se transforma el rectángulo definido por <c>srcRect</c>. La matriz puede contener tres elementos o cuatro. Si la matriz contiene tres elementos, el ángulo inferior derecho del paralelogramo viene definido por los tres primeros puntos.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> que representa el rectángulo que se transforma en el paralelogramo definido por <c>destPoints</c>.</param>
        <param name="matrix">
          <see cref="T:System.Drawing.Drawing2D.Matrix" /> que especifica la transformación geométrica que se va a aplicar al trazado.</param>
        <param name="warpMode">Enumeración <see cref="T:System.Drawing.Drawing2D.WarpMode" /> que especifica si esta operación de alabeo usa el modo en perspectiva o bilineal.</param>
        <param name="flatness">Valor de 0 a 1 que especifica cómo es de plano el trazado resultante. Para obtener más información, vea los métodos <see cref="M:System.Drawing.Drawing2D.GraphicsPath.Flatten" />.</param>
        <summary>Aplica una transformación de alabeo, definida por un rectángulo y un paralelogramo, a este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una ruta de acceso y agrega un rectángulo a la ruta de acceso.  
  
-   Dibuja el rectángulo en la pantalla en negro.  
  
-   Distorsiona la ruta de acceso con una deformación de perspectiva.  
  
-   Dibuja el rectángulo alabeado (ruta de acceso) en la pantalla en rojo.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#29)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#29)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#29)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Widen">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reemplaza este trazado con curvas que rodean el área que está rellena cuando ese trazado se dibuja con el lápiz especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> que especifica el ancho entre el contorno original del trazado y el nuevo contorno que este método crea.</param>
        <summary>Agrega un contorno adicional al trazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea un contorno alrededor de las líneas originales en este <xref:System.Drawing.Drawing2D.GraphicsPath>, con una distancia entre las líneas existentes y el nuevo contorno es igual a la que el ancho de la <xref:System.Drawing.Pen> usada en la llamada a <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>. Si desea rellenar el espacio entre las líneas debe utilizar el <xref:System.Drawing.Graphics.FillPath%2A> en lugar de tener la <xref:System.Drawing.Graphics.DrawPath%2A>.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%28System.Drawing.Pen%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen, System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen,System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> que especifica el ancho entre el contorno original del trazado y el nuevo contorno que este método crea.</param>
        <param name="matrix">
          <see cref="T:System.Drawing.Drawing2D.Matrix" /> que especifica la transformación que se va a aplicar al trazado antes de ensancharlo.</param>
        <summary>Agrega un contorno adicional al trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea un contorno alrededor de las líneas originales en este <xref:System.Drawing.Drawing2D.GraphicsPath>, con una distancia entre las líneas existentes y el nuevo contorno es igual a la que el ancho de la <xref:System.Drawing.Pen> usada en la llamada a <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>. Si desea rellenar el espacio entre las líneas debe utilizar el <xref:System.Drawing.Graphics.FillPath%2A> en lugar de tener la <xref:System.Drawing.Graphics.DrawPath%2A>.  
  
   
  
## Examples  
 Para obtener un ejemplo, consulta <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%28System.Drawing.Pen%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen, System.Drawing.Drawing2D.Matrix matrix, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.Matrix matrix, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen,System.Drawing.Drawing2D.Matrix,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::Matrix ^ matrix, float flatness);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> que especifica el ancho entre el contorno original del trazado y el nuevo contorno que este método crea.</param>
        <param name="matrix">
          <see cref="T:System.Drawing.Drawing2D.Matrix" /> que especifica la transformación que se va a aplicar al trazado antes de ensancharlo.</param>
        <param name="flatness">Valor que especifica cómo son de planas las curvas.</param>
        <summary>Reemplaza este trazado <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> con curvas que rodean el área rellena cuando se dibuja este trazado con el lápiz especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea un contorno alrededor de las líneas originales en este <xref:System.Drawing.Drawing2D.GraphicsPath>, con una distancia entre las líneas existentes y el nuevo contorno es igual a la que el ancho de la <xref:System.Drawing.Pen> usada en la llamada a <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>. Si desea rellenar el espacio entre las líneas debe utilizar el <xref:System.Drawing.Graphics.FillPath%2A> en lugar de tener la <xref:System.Drawing.Graphics.DrawPath%2A>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, un <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. El código realiza las siguientes acciones:  
  
-   Crea una ruta de acceso y agrega dos elipses a la ruta de acceso.  
  
-   Dibuja la ruta de acceso en negro.  
  
-   Se amplía la ruta de acceso.  
  
-   Dibuja la ruta de acceso en rojo.  
  
 Tenga en cuenta que utiliza la segunda representación <xref:System.Drawing.Graphics.FillPath%2A> en lugar de <xref:System.Drawing.Graphics.DrawPath%2A>, por lo que la figura representada tiene el contorno relleno.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#30)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#30)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>