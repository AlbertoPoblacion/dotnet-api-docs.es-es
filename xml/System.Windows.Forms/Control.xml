<Type Name="Control" FullName="System.Windows.Forms.Control">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b5d014fc3de2b603802c4f93c3c1ceee760c755b" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39907649" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Control : System.ComponentModel.Component, IDisposable, System.ComponentModel.ISynchronizeInvoke, System.Windows.Forms.IBindableComponent, System.Windows.Forms.IDropTarget, System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Control extends System.ComponentModel.Component implements class System.ComponentModel.IComponent, class System.ComponentModel.ISynchronizeInvoke, class System.IDisposable, class System.Windows.Forms.IBindableComponent, class System.Windows.Forms.IDropTarget, class System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Inherits Component&#xA;Implements IBindableComponent, IDisposable, IDropTarget, ISynchronizeInvoke, IWin32Window" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : System::ComponentModel::Component, IDisposable, System::ComponentModel::ISynchronizeInvoke, System::Windows::Forms::IBindableComponent, System::Windows::Forms::IDropTarget, System::Windows::Forms::IWin32Window" />
  <TypeSignature Language="F#" Value="type Control = class&#xA;    inherit Component&#xA;    interface IDropTarget&#xA;    interface ISynchronizeInvoke&#xA;    interface IWin32Window&#xA;    interface IComponent&#xA;    interface IDisposable&#xA;    interface IBindableComponent" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISynchronizeInvoke</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IBindableComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IDropTarget</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IWin32Window</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Define la clase base para los controles, que son componentes con una representación visual.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para crear su propia clase de control, herede de la <xref:System.Windows.Forms.UserControl>, <xref:System.Windows.Forms.Control> clases, o desde las otras formas de Windows siempre y cuando los controles. Para obtener más información sobre la creación de controles personalizados, vea [Developing Custom Controls de Windows Forms con .NET Framework](~/docs/framework/winforms/controls/developing-custom-windows-forms-controls.md).  
  
 La <xref:System.Windows.Forms.Control> clase implementa la funcionalidad básica requerida por las clases que muestran información al usuario. Controla la entrada del usuario a través del teclado y dispositivos señaladores. Controla el enrutamiento de mensajes y seguridad. Define los límites de un control (posición y tamaño), aunque no implementa la pintura. Proporciona un identificador de ventana (`hWnd`).  
  
 Controles de formularios Windows Forms usan las propiedades de ambiente para que los controles secundarios pueden aparecer como en su entorno circundante. Un *propiedad de ambiente* es una propiedad de control que, si no establece, se recupera desde el control primario. Si el control no tiene un <xref:System.Windows.Forms.Control.Parent%2A>y la propiedad no está establecida, el control intenta determinar el valor de la propiedad de ambiente a través de la <xref:System.Windows.Forms.Control.Site%2A> propiedad. Si el control no está ubicado, si el sitio no es compatible con las propiedades de ambiente, o si la propiedad no está establecida en el <xref:System.Windows.Forms.AmbientProperties>, el control utiliza sus propios valores predeterminados. Normalmente, una propiedad de ambiente representa una característica de un control, como <xref:System.Windows.Forms.Control.BackColor%2A>, que se comunica con un control secundario. Por ejemplo, un <xref:System.Windows.Forms.Button> tendrá el mismo <xref:System.Windows.Forms.Control.BackColor%2A> como su elemento primario <xref:System.Windows.Forms.Form> de forma predeterminada. Las propiedades de ambiente proporcionadas por el <xref:System.Windows.Forms.Control> clase incluyen: <xref:System.Windows.Forms.Control.Cursor%2A>, <xref:System.Windows.Forms.Control.Font%2A>, <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.ForeColor%2A>, y <xref:System.Windows.Forms.Control.RightToLeft%2A>.  
  
> [!NOTE]
>  Para que la aplicación de Windows Forms admiten estilos visuales, asegúrese de establecer el <xref:System.Windows.Forms.FlatStyle> propiedad `System` e incluir un manifiesto con el archivo ejecutable. Un manifiesto es un archivo XML que se incluye como un recurso en el ejecutable de aplicación o como un archivo independiente que se encuentra en el mismo directorio que el archivo ejecutable. Para obtener un ejemplo de manifiesto, vea la sección ejemplo de la <xref:System.Windows.Forms.FlatStyle> enumeración. Para obtener más información sobre cómo usar los estilos visuales, vea [estilos visuales](http://msdn.microsoft.com/library/windows/desktop/bb773187.aspx).  
  
 Windows Forms tiene compatibilidad integrada para accesibilidad y proporciona información acerca de la aplicación que le permite trabajar con aplicaciones cliente de accesibilidad, como utilidades para aumentar y revisar la pantalla, la voz de las utilidades de entrada, en la pantalla teclados, dispositivos de entrada alternativos y utilidades de mejora del teclado. A veces desea proporcionar información adicional a las aplicaciones cliente de accesibilidad. Hay dos maneras de proporcionar esta información adicional. Puede establecer el <xref:System.Windows.Forms.Control.AccessibleName%2A>, <xref:System.Windows.Forms.Control.AccessibleDescription%2A>, <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A>, y <xref:System.Windows.Forms.Control.AccessibleRole%2A> los valores de propiedad que se notificará a las aplicaciones cliente de accesibilidad. Este método se utiliza normalmente para proporcionar información de accesibilidad limitado de controles existentes. Como alternativa, puede escribir su propia clase que deriva de la <xref:System.Windows.Forms.AccessibleObject> o <xref:System.Windows.Forms.Control.ControlAccessibleObject> clases, proporcionar tanta información de accesibilidad según sea necesario.  
  
> [!NOTE]
>  Para mantener un rendimiento óptimo, no establezca el tamaño de un control en su constructor. El método preferido es invalidar el <xref:System.Windows.Forms.Control.DefaultSize%2A> propiedad.  
  
> [!NOTE]
>  ¿Agregar enlaces de datos para un <xref:System.Windows.Forms.Control> en su constructor. Si lo hace, se producirán errores en la generación de código y puede provocar un comportamiento no deseado.  
  
 La mayoría de los controles en el <xref:System.Windows.Forms> espacio de nombres use el control común de Windows subyacente como base para compilar en. Para obtener más información acerca de los controles comunes de Windows, consulte [referencia de Control General](http://msdn.microsoft.com/library/windows/desktop/bb775497.aspx).  
  
 Para identificar los controles de Windows Forms desde un proceso independiente, use un estándar `SendMessage` llamada para pasar el mensaje WM_GETCONTROLNAME. WM_GETCONTROLNAME es independiente del idioma y la jerarquía de Windows. Para obtener más información, vea el tema "Recomienda soluciones para Windows Forms" en[automatización de Windows Forms](http://msdn.microsoft.com/library/ms996405.aspx).  
  
 Use el <xref:System.Windows.Forms.Control.InvokeRequired%2A> propiedad para sincronizar el acceso al control desde varios subprocesos. Para obtener más información acerca de los controles de Windows Forms multiproceso, vea [Cómo: realizar llamadas de subprocesos a controles de formularios Windows Forms](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md)  
  
 ]]></format>
    </remarks>
    <threadsafe>Solo los miembros siguientes son seguros para subprocesos: <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />, <see cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />, <see cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />, <see cref="P:System.Windows.Forms.Control.InvokeRequired" />, y <see cref="M:System.Windows.Forms.Control.CreateGraphics" /> si ya se ha creado el identificador del control. Una llamada a <see cref="M:System.Windows.Forms.Control.CreateGraphics" /> antes de que se ha creado el identificador del control en un subproceso en segundo plano puede provocar no válidas entre las llamadas de subprocesos.</threadsafe>
    <altmember cref="T:System.Windows.Forms.Form" />
    <altmember cref="T:System.Windows.Forms.ScrollableControl" />
    <altmember cref="T:System.Windows.Forms.ContainerControl" />
    <altmember cref="T:System.ComponentModel.Component" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Forms.Control" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Forms.Control" /> con los valores predeterminados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Forms.Control> clase es la clase base para todos los controles utilizados en una aplicación de Windows Forms. Puesto que esta clase no se utiliza normalmente para crear una instancia de la clase, este constructor no se suele llamar directamente, pero en su lugar, se llama a una clase derivada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : string -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Texto que muestra el control.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Forms.Control" /> con un texto específico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Forms.Control> clase es la clase base para todos los controles utilizados en una aplicación de Windows Forms. Puesto que esta clase no se utiliza normalmente para crear una instancia de la clase, este constructor no se suele llamar directamente, pero en su lugar, se llama a una clase derivada.  
  
 Esta versión de la <xref:System.Windows.Forms.Control.%23ctor%2A> constructor establece inicial <xref:System.Windows.Forms.Control.Text%2A> valor de propiedad para el `text` el valor del parámetro.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parent As Control, text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::Windows::Forms::Control ^ parent, System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : System.Windows.Forms.Control * string -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (parent, text)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="parent">
          <see cref="T:System.Windows.Forms.Control" /> que es el elemento primario del control.</param>
        <param name="text">Texto que muestra el control.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Forms.Control" /> como control secundario, con un texto específico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Forms.Control> clase es la clase base para todos los controles utilizados en una aplicación de Windows Forms. Puesto que esta clase no se utiliza normalmente para crear una instancia de la clase, este constructor no se suele llamar directamente, pero en su lugar, se llama a una clase derivada.  
  
 Esta versión de la <xref:System.Windows.Forms.Control.%23ctor%2A> constructor establece inicial <xref:System.Windows.Forms.Control.Text%2A> valor de propiedad para el `text` el valor del parámetro. El constructor también agrega el control para el control primario <xref:System.Windows.Forms.Control.ControlCollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, left As Integer, top As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::String ^ text, int left, int top, int width, int height);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : string * int * int * int * int -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (text, left, top, width, height)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">Texto que muestra el control.</param>
        <param name="left">Posición <see cref="P:System.Drawing.Point.X" /> del control, en píxeles, desde el borde izquierdo del contenedor del control. El valor se asigna a la propiedad <see cref="P:System.Windows.Forms.Control.Left" />.</param>
        <param name="top">Posición <see cref="P:System.Drawing.Point.Y" /> del control, en píxeles, desde el borde superior del contenedor del control. El valor se asigna a la propiedad <see cref="P:System.Windows.Forms.Control.Top" />.</param>
        <param name="width">Ancho del control, en píxeles. El valor se asigna a la propiedad <see cref="P:System.Windows.Forms.Control.Width" />.</param>
        <param name="height">Alto del control, en píxeles. El valor se asigna a la propiedad <see cref="P:System.Windows.Forms.Control.Height" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Forms.Control" /> con un texto, tamaño y ubicación específicos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Forms.Control> clase es la clase base para todos los controles utilizados en una aplicación de Windows Forms. Puesto que esta clase no se utiliza normalmente para crear una instancia de la clase, este constructor no se suele llamar directamente, pero en su lugar, se llama a una clase derivada.  
  
 Esta versión de la <xref:System.Windows.Forms.Control.%23ctor%2A> constructor establece inicial <xref:System.Windows.Forms.Control.Text%2A> valor de propiedad para el `text` el valor del parámetro. Inicial <xref:System.Windows.Forms.Control.Size%2A> y <xref:System.Windows.Forms.Control.Location%2A> del control están determinados por la `left`, `top`, `width` y `height` los valores de parámetro.  
  
> [!NOTE]
>  Para mantener un rendimiento óptimo, no establezca el tamaño de un control en su constructor. El método preferido es invalidar el <xref:System.Windows.Forms.Control.DefaultSize%2A> propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parent As Control, text As String, left As Integer, top As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::Windows::Forms::Control ^ parent, System::String ^ text, int left, int top, int width, int height);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : System.Windows.Forms.Control * string * int * int * int * int -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (parent, text, left, top, width, height)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parent">
          <see cref="T:System.Windows.Forms.Control" /> que es el elemento primario del control.</param>
        <param name="text">Texto que muestra el control.</param>
        <param name="left">Posición <see cref="P:System.Drawing.Point.X" /> del control, en píxeles, desde el borde izquierdo del contenedor del control. El valor se asigna a la propiedad <see cref="P:System.Windows.Forms.Control.Left" />.</param>
        <param name="top">Posición <see cref="P:System.Drawing.Point.Y" /> del control, en píxeles, desde el borde superior del contenedor del control. El valor se asigna a la propiedad <see cref="P:System.Windows.Forms.Control.Top" />.</param>
        <param name="width">Ancho del control, en píxeles. El valor se asigna a la propiedad <see cref="P:System.Windows.Forms.Control.Width" />.</param>
        <param name="height">Alto del control, en píxeles. El valor se asigna a la propiedad <see cref="P:System.Windows.Forms.Control.Height" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Forms.Control" /> como control secundario, con un texto, tamaño y ubicación específicos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Forms.Control> clase es la clase base para todos los controles utilizados en una aplicación de Windows Forms. Puesto que esta clase no se utiliza normalmente para crear una instancia de la clase, este constructor no se suele llamar directamente, pero en su lugar, se llama a una clase derivada.  
  
 Esta versión de la <xref:System.Windows.Forms.Control.%23ctor%2A> constructor establece inicial <xref:System.Windows.Forms.Control.Text%2A> valor de propiedad para el `text` el valor del parámetro. El constructor también agrega el control para el control primario <xref:System.Windows.Forms.Control.ControlCollection>. Inicial <xref:System.Windows.Forms.Control.Size%2A> y <xref:System.Windows.Forms.Control.Location%2A> del control están determinados por la `left`, `top`, `width` y `height` los valores de parámetro.  
  
> [!NOTE]
>  Para mantener un rendimiento óptimo, no establezca el tamaño de un control en su constructor. El método preferido es invalidar el <xref:System.Windows.Forms.Control.DefaultSize%2A> propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AccessibilityNotifyClients">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Notifica los objetos <see cref="T:System.Windows.Forms.AccessibleEvents" /> a las aplicaciones cliente de accesibilidad.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected internal void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, childID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int childID);" />
      <MemberSignature Language="F#" Value="member this.AccessibilityNotifyClients : System.Windows.Forms.AccessibleEvents * int -&gt; unit" Usage="control.AccessibilityNotifyClients (accEvent, childID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" />
        <Parameter Name="childID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="accEvent">
          <see cref="T:System.Windows.Forms.AccessibleEvents" /> del que se va a notificar a las aplicaciones cliente de accesibilidad.</param>
        <param name="childID">
          <see cref="T:System.Windows.Forms.Control" /> secundario al que se notificará el evento accesible.</param>
        <summary>Notifica a las aplicaciones cliente de accesibilidad los objetos <see cref="T:System.Windows.Forms.AccessibleEvents" /> especificados del control secundario especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe llamar a la <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A?displayProperty=nameWithType> método para cada <xref:System.Windows.Forms.AccessibleEvents> son las aplicaciones cliente de accesibilidad para recibir una notificación de. El <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A> normalmente se llama al método cuando una propiedad se establece o desde un controlador de eventos. Por ejemplo, podría llamar a la <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A> método y pase un <xref:System.Windows.Forms.AccessibleEvents> valor de `Hide` desde dentro del controlador de eventos para el <xref:System.Windows.Forms.Control.VisibleChanged?displayProperty=nameWithType> eventos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la creación de un gráfico de accesibilidad para controlar, mediante el <xref:System.Windows.Forms.AccessibleObject> y <xref:System.Windows.Forms.Control.ControlAccessibleObject> clases para exponer información accesible. El control traza dos curvas junto con una leyenda. El `ChartControlAccessibleObject` (clase), que se deriva de `ControlAccessibleObject`, se usa en el <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> método para proporcionar información personalizada accesible para el control chart. Dado que la leyenda del gráfico no es un real <xref:System.Windows.Forms.Control> -control basado en, pero en su lugar se dibuja mediante el control chart, lo hace no ninguna información accesible. Por este motivo, el `ChartControlAccessibleObject` clase invalida el <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> método para devolver el `CurveLegendAccessibleObject` que representa la información accesible de cada parte de la leyenda. Cuando una aplicación accesible para usa este control, el control puede proporcionar la información de acceso necesaria.  
  
 Este fragmento de código se muestra cómo llamar el <xref:System.Windows.Forms.Control.AccessibilityNotifyClients%2A> método. Consulte la <xref:System.Windows.Forms.AccessibleObject> información general de clases para el ejemplo de código completo.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#5)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#5)]
 [!code-vb[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleEvents" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
      </Docs>
    </Member>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 objectID, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, objectID As Integer, childID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberSignature Language="F#" Value="member this.AccessibilityNotifyClients : System.Windows.Forms.AccessibleEvents * int * int -&gt; unit" Usage="control.AccessibilityNotifyClients (accEvent, objectID, childID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" />
        <Parameter Name="objectID" Type="System.Int32" />
        <Parameter Name="childID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="accEvent">
          <see cref="T:System.Windows.Forms.AccessibleEvents" /> del que se va a notificar a las aplicaciones cliente de accesibilidad.</param>
        <param name="objectID">Identificador de <see cref="T:System.Windows.Forms.AccessibleObject" />.</param>
        <param name="childID">
          <see cref="T:System.Windows.Forms.Control" /> secundario al que se notificará el evento accesible.</param>
        <summary>Notifica a las aplicaciones cliente de accesibilidad los objetos <see cref="T:System.Windows.Forms.AccessibleEvents" /> especificados del control secundario especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityObject">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleObject AccessibilityObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.AccessibleObject AccessibilityObject" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibilityObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessibilityObject As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleObject ^ AccessibilityObject { System::Windows::Forms::AccessibleObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessibilityObject : System.Windows.Forms.AccessibleObject" Usage="System.Windows.Forms.Control.AccessibilityObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene <see cref="T:System.Windows.Forms.AccessibleObject" /> asignado al control.</summary>
        <value>
          <see cref="T:System.Windows.Forms.AccessibleObject" /> asignado al control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar la instancia devuelta por este método, reemplace el <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> método.  
  
 Si no hay ningún <xref:System.Windows.Forms.AccessibleObject> asignado al control en la actualidad, se crea una nueva instancia de uno.  
  
> [!NOTE]
>  Para obtener o establecer el <xref:System.Windows.Forms.Control.AccessibilityObject%2A> propiedad, debe agregar una referencia a la `Accessibility` ensamblado instalado con el[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
 Para obtener más información sobre los objetos accesibles, vea [Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
        <altmember cref="T:System.Windows.Forms.Control.ControlAccessibleObject" />
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleDefaultActionDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDefaultActionDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDefaultActionDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleDefaultActionDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleDefaultActionDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleDefaultActionDescription : string with get, set" Usage="System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la descripción de la acción predeterminada del control que usan las aplicaciones cliente de accesibilidad.</summary>
        <value>Descripción de la acción predeterminada del control que usan las aplicaciones cliente de accesibilidad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un objeto <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A> propiedad describe el método del objeto principal de manipulación de punto de vista del usuario. Esta propiedad debe ser un verbo o una frase corta.  
  
> [!NOTE]
>  No todos los objetos tienen acciones predeterminadas y algunos pueden tener una acción predeterminada que está relacionado con su <xref:System.Windows.Forms.AccessibleObject.Value%2A?displayProperty=nameWithType> propiedad, como se muestra en los ejemplos siguientes:  
  
-   Una casilla activada tiene una acción predeterminada de "Desactivar" y un valor de "Activado".  
  
-   Una casilla desactivada tiene una acción predeterminada "Check" y un valor de "Desactivado".  
  
-   Un botón con la etiqueta "Imprimir" tiene una acción predeterminada "Press", sin ningún valor.  
  
-   Una etiqueta o un control de cuadro de texto que muestra "Printer" no tiene ninguna acción predeterminada, pero tendría un valor de "Impresora".  
  
 Para obtener más información acerca de las propiedades de los objetos accesibles, vea [contenido de propiedades descriptivas](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleDescription : string with get, set" Usage="System.Windows.Forms.Control.AccessibleDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la descripción del control que las aplicaciones cliente de accesibilidad utilizan.</summary>
        <value>Descripción del control que las aplicaciones cliente de accesibilidad utilizan. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un objeto <xref:System.Windows.Forms.Control.AccessibleDescription%2A> propiedad proporciona una descripción textual acerca de la apariencia de un objeto. La descripción se utiliza principalmente para proporcionar más contexto para los usuarios ciegos o con deficiencia visual, pero también se puede usar para búsqueda de contexto u otras aplicaciones.  
  
 El <xref:System.Windows.Forms.Control.AccessibleDescription%2A> propiedad es necesaria si la descripción no es obvia, o si es redundante en función del objeto <xref:System.Windows.Forms.Control.AccessibleName%2A>, <xref:System.Windows.Forms.Control.AccessibleRole%2A>, <xref:System.Windows.Forms.AccessibleObject.State%2A>, y <xref:System.Windows.Forms.AccessibleObject.Value%2A> propiedades. Por ejemplo, un botón "Aceptar" no necesita información adicional, pero un botón que muestra una imagen de un cactus. El <xref:System.Windows.Forms.Control.AccessibleName%2A>, y <xref:System.Windows.Forms.Control.AccessibleRole%2A> (y quizás <xref:System.Windows.Forms.AccessibleObject.Help%2A>) las propiedades del botón de cactus podrían describir su finalidad, pero la <xref:System.Windows.Forms.Control.AccessibleDescription%2A> propiedad transmitiría información menos tangible, como "Botón que muestra una imagen de un cactus."  
  
 Para obtener más información acerca de las propiedades de los objetos accesibles, vea [contenido de propiedades descriptivas](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea una instancia de un <xref:System.Windows.Forms.CheckBox> clase derivada, `MyCheckBox`, le asigna un <xref:System.Drawing.Image> a su <xref:System.Windows.Forms.ButtonBase.Image%2A> propiedad y los conjuntos de la <xref:System.Windows.Forms.Control.AccessibleName%2A> y <xref:System.Windows.Forms.Control.AccessibleDescription%2A> propiedades, porque el <xref:System.Windows.Forms.Control.Text%2A> propiedad es `null`. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> denominado `MyForm`.  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleName">
      <MemberSignature Language="C#" Value="public string AccessibleName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleName" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleName : string with get, set" Usage="System.Windows.Forms.Control.AccessibleName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del control que las aplicaciones cliente de accesibilidad utilizan.</summary>
        <value>Nombre del control que las aplicaciones cliente de accesibilidad utilizan. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.AccessibleName%2A> propiedad es una etiqueta que describe brevemente e identifica el objeto dentro de su contenedor, como el texto de un <xref:System.Windows.Forms.Button>, el nombre de un <xref:System.Windows.Forms.MenuItem>, o una etiqueta que se muestra junto a un <xref:System.Windows.Forms.TextBox> control.  
  
 Para obtener más información acerca de las propiedades de los objetos accesibles, vea el "[contenido de propiedades descriptivas](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea una instancia de un <xref:System.Windows.Forms.CheckBox> clase derivada, `MyCheckBox`, le asigna un <xref:System.Drawing.Image> a su <xref:System.Windows.Forms.ButtonBase.Image%2A> propiedad y los conjuntos de la <xref:System.Windows.Forms.Control.AccessibleName%2A> y <xref:System.Windows.Forms.Control.AccessibleDescription%2A> propiedades desde el <xref:System.Windows.Forms.Control.Text%2A> propiedad es `null`. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> denominado `MyForm`.  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleRole">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleRole AccessibleRole { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AccessibleRole AccessibleRole" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleRole" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleRole As AccessibleRole" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleRole AccessibleRole { System::Windows::Forms::AccessibleRole get(); void set(System::Windows::Forms::AccessibleRole value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleRole : System.Windows.Forms.AccessibleRole with get, set" Usage="System.Windows.Forms.Control.AccessibleRole" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleRole</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el rol accesible del control.</summary>
        <value>Uno de los valores de <see cref="T:System.Windows.Forms.AccessibleRole" />. El valor predeterminado es <see langword="Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propiedad <xref:System.Windows.Forms.Control.AccessibleRole%2A> describe qué tipo de elemento de la interfaz de usuario es un objeto. Si no se puede determinar la función del control, la propiedad <xref:System.Windows.Forms.Control.AccessibleRole%2A> se establece en `Default`.  
  
 Para obtener más información acerca de las propiedades de los objetos accesibles, vea [contenido de propiedades descriptivas](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El valor asignado no es uno de los valores de <see cref="T:System.Windows.Forms.AccessibleRole" />.</exception>
        <altmember cref="T:System.Windows.Forms.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public virtual bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.Forms.Control.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el control puede aceptar los datos que el usuario arrastra al mismo.</summary>
        <value>
          <see langword="true" /> si están permitidas las operaciones de arrastrar y colocar en el control; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Habilita de ejemplo de código siguiente se quita al usuario arrastrar una imagen o un archivo de imagen del formulario y se muestra en el punto. El <xref:System.Windows.Forms.Control.OnPaint%2A> se invalida el método para volver a dibujar la imagen cada vez que se pinta el formulario; en caso contrario, la imagen sólo se conserva hasta la siguiente operación de dibujo. El <xref:System.Windows.Forms.Control.DragEnter> método de control de eventos determina el tipo de datos que se arrastran al formulario y proporciona la información apropiada. El <xref:System.Windows.Forms.Control.DragDrop> método de control de eventos muestra la imagen en el formulario, si un <xref:System.Drawing.Image> pueden crearse a partir de los datos. Dado que el <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> y <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> los valores son las coordenadas de pantalla, el ejemplo se usa el <xref:System.Windows.Forms.Control.PointToClient%2A> método convertirlos a coordenadas de cliente.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para el acceso sin restricciones de Portapapeles establecer esta propiedad en <see langword="true" />. Enumeración asociada: el <see langword="AllClipboard" /> valor de <see cref="T:System.Security.Permissions.UIPermissionClipboard" /></permission>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.AllowDrop" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.AllowDrop" /> propiedad para extender la implementación base. En caso contrario, debe proporcionar toda la implementación. No es necesario reemplazar ambos el <see langword="get" /> y <see langword="set" /> descriptores de acceso de la <see cref="P:System.Windows.Forms.Control.AllowDrop" /> propiedad; se puede reemplazar sólo uno, si es necesario.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.DragEventArgs" />
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
        <altmember cref="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      </Docs>
    </Member>
    <Member MemberName="Anchor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AnchorStyles Anchor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AnchorStyles Anchor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Anchor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Anchor As AnchorStyles" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AnchorStyles Anchor { System::Windows::Forms::AnchorStyles get(); void set(System::Windows::Forms::AnchorStyles value); };" />
      <MemberSignature Language="F#" Value="member this.Anchor : System.Windows.Forms.AnchorStyles with get, set" Usage="System.Windows.Forms.Control.Anchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AnchorStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece los bordes del contenedor al que está enlazado un control y determina cómo se cambia el tamaño de un control con su elemento primario.</summary>
        <value>Combinación bit a bit de los valores de <see cref="T:System.Windows.Forms.AnchorStyles" />. Los valores predeterminados son <see langword="Top" /> y <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Windows.Forms.Control.Anchor%2A> propiedad para definir cómo se cambia automáticamente el tamaño de un control cuando se cambia el tamaño de su control primario. Delimitación de un control a su control principal, se garantiza que los bordes delimitados permanecen en la misma posición relativa a los bordes del control primario cuando se cambia el tamaño del control primario.  
  
 Puede anclar un control para uno o más bordes de su contenedor. Por ejemplo, si tiene un <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.Button> cuyo <xref:System.Windows.Forms.Control.Anchor%2A> el valor de propiedad se establece en `Top` y `Bottom`, el <xref:System.Windows.Forms.Button> se ajusta para mantener la distancia con respecto a los bordes superior e inferior de la <xref:System.Windows.Forms.Form>como el <xref:System.Windows.Forms.Control.Height%2A> de la <xref:System.Windows.Forms.Form> aumenta.  
  
> [!NOTE]
>  El <xref:System.Windows.Forms.Control.Anchor%2A> y <xref:System.Windows.Forms.Control.Dock%2A> propiedades son mutuamente excluyentes. Solo una puede establecerse en un momento, y el último conjunto tiene prioridad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se agrega un <xref:System.Windows.Forms.Button> a un formulario y se establecen algunas de sus propiedades comunes. En el ejemplo se ancla el botón a la esquina inferior derecha del formulario, por lo que mantiene su posición relativa, como el tamaño del formulario. A continuación establece el <xref:System.Windows.Forms.Control.BackgroundImage%2A> y cambia el tamaño del botón en el mismo tamaño que el <xref:System.Drawing.Image>. En el ejemplo, a continuación, Establece el <xref:System.Windows.Forms.Control.TabStop%2A> a `true` y establece el <xref:System.Windows.Forms.Control.TabIndex%2A> propiedad. Por último, agrega un controlador de eventos para controlar la <xref:System.Windows.Forms.Control.Click> eventos del botón. En este ejemplo requiere que haya un <xref:System.Windows.Forms.ImageList> denominado `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.Anchor" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.Anchor" /> propiedad para extender la implementación base. En caso contrario, debe proporcionar toda la implementación. No es necesario reemplazar ambos el <see langword="get" /> y <see langword="set" /> descriptores de acceso de la <see cref="P:System.Windows.Forms.Control.Anchor" /> propiedad; se puede reemplazar sólo uno, si es necesario.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.AnchorStyles" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="AutoScrollOffset">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Point AutoScrollOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point AutoScrollOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoScrollOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoScrollOffset As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Point AutoScrollOffset { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScrollOffset : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Control.AutoScrollOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Point), "0, 0")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece a dónde se desplaza este control en <see cref="M:System.Windows.Forms.ScrollableControl.ScrollControlIntoView(System.Windows.Forms.Control)" />.</summary>
        <value>
          <see cref="T:System.Drawing.Point" /> que especifica la ubicación de desplazamiento. El valor predeterminado es la esquina superior izquierda del control.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public virtual bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.Control.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta propiedad no es relevante para esta clase.</summary>
        <value>
          <see langword="true" /> si está habilitado; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoSizeChanged : EventHandler " Usage="member this.AutoSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Este evento no es relevante para esta clase.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.Control.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(-501)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el color de fondo del control.</summary>
        <value>Objeto <see cref="T:System.Drawing.Color" /> que representa el color de fondo del control. El valor predeterminado es el valor de la propiedad <see cref="P:System.Windows.Forms.Control.DefaultBackColor" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.BackColor%2A> propiedad no admite colores transparentes a menos que el `SupportsTransparentBackColor` valor <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> está establecido en `true`.  
  
 El <xref:System.Windows.Forms.Control.BackColor%2A> es una propiedad de ambiente. Una propiedad de ambiente es una propiedad de control que, si no establece, se recupera desde el control primario. Por ejemplo, un <xref:System.Windows.Forms.Button> tendrá el mismo <xref:System.Windows.Forms.Control.BackColor%2A> como su elemento primario <xref:System.Windows.Forms.Form> de forma predeterminada. Para obtener más información acerca de las propiedades de ambiente, vea la <xref:System.Windows.Forms.AmbientProperties> clase o el <xref:System.Windows.Forms.Control> información general de clases.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Windows.Forms.Control.BackColor%2A> y <xref:System.Windows.Forms.Control.ForeColor%2A> de los controles a los colores del sistema de forma predeterminada. El código de forma recursiva llama a sí mismo si el control tiene todos los controles secundarios. Este ejemplo de código requiere que haya un <xref:System.Windows.Forms.Form> con control de al menos un elemento secundario; sin embargo, un contenedor secundario controlar, como un <xref:System.Windows.Forms.Panel> o <xref:System.Windows.Forms.GroupBox>, con su propio elemento secundario controles mejor demostraría la recursividad.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.BackColor" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.BackColor" /> propiedad para extender la implementación base. En caso contrario, debe proporcionar toda la implementación. No es necesario reemplazar ambos el <see langword="get" /> y <see langword="set" /> descriptores de acceso de la <see cref="P:System.Windows.Forms.Control.BackColor" /> propiedad; se puede reemplazar sólo uno, si es necesario.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.AmbientProperties" />
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="BackColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackColorChanged;" />
      <MemberSignature Language="F#" Value="member this.BackColorChanged : EventHandler " Usage="member this.BackColorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.BackColor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.BackColor%2A> propiedad se modifica mediante programación o interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente es un controlador de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre *PropertyName* `Changed` que se genera cuando correspondiente *PropertyName* cambia el valor (* PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> que contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.Control.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la imagen de fondo que se muestra en el control.</summary>
        <value>
          <see cref="T:System.Drawing.Image" /> que representa la imagen que se va a mostrar en el fondo del control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Use el <xref:System.Windows.Forms.Control.BackgroundImage%2A> propiedad que se va a colocar una imagen gráfica en un control.  
  
> [!NOTE]
>  Controles de formularios Windows Forms no admiten las imágenes con colores translúcidos o transparentes como imágenes de fondo.  
>   
>  Esta propiedad no se admite en los controles secundarios cuya <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> propiedad es `true`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se agrega un <xref:System.Windows.Forms.Button> a un formulario y se establecen algunas de sus propiedades comunes. En el ejemplo se ancla el botón a la esquina inferior derecha del formulario, por lo que mantiene su posición relativa, como el tamaño del formulario. A continuación establece el <xref:System.Windows.Forms.Control.BackgroundImage%2A> y cambia el tamaño del botón en el mismo tamaño que el <xref:System.Drawing.Image>. En el ejemplo, a continuación, Establece el <xref:System.Windows.Forms.Control.TabStop%2A> a `true` y establece el <xref:System.Windows.Forms.Control.TabIndex%2A> propiedad. Por último, agrega un controlador de eventos para controlar la <xref:System.Windows.Forms.Control.Click> eventos del botón. En este ejemplo requiere que haya un <xref:System.Windows.Forms.ImageList> denominado `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> propiedad para extender la implementación base. En caso contrario, debe proporcionar toda la implementación. No es necesario reemplazar ambos el <see langword="get" /> y <see langword="set" /> descriptores de acceso de la <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> propiedad; se puede reemplazar sólo uno, si es necesario.</para>
        </block>
        <altmember cref="T:System.Drawing.Image" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.BackgroundImage" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.BackgroundImage%2A> propiedad se modifica mediante programación o interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente es un controlador de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre *PropertyName* `Changed` que se genera cuando correspondiente *PropertyName* cambia el valor (* PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> que contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Image" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.Control.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el diseño de imagen de fondo como se define en la enumeración <see cref="T:System.Windows.Forms.ImageLayout" />.</summary>
        <value>Uno de los valores de <see cref="T:System.Windows.Forms.ImageLayout" /> (<see cref="F:System.Windows.Forms.ImageLayout.Center" />, <see cref="F:System.Windows.Forms.ImageLayout.None" />, <see cref="F:System.Windows.Forms.ImageLayout.Stretch" />, <see cref="F:System.Windows.Forms.ImageLayout.Tile" /> o <see cref="F:System.Windows.Forms.ImageLayout.Zoom" />). El valor predeterminado es <see cref="F:System.Windows.Forms.ImageLayout.Tile" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> propiedad para especificar la posición y el comportamiento de una imagen colocada en un control. <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> solo tiene efecto si la <xref:System.Windows.Forms.Control.BackgroundImage%2A> se establece la propiedad.  
  
 Puede aumentar el rendimiento para las imágenes grandes si establece <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> a algo distinto <xref:System.Windows.Forms.ImageLayout.Tile>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El valor de enumeración especificado no existe.</exception>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia la propiedad <see cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> cambia la propiedad mediante programación o mediante la interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#9)]
 [!code-vb[System.Windows.Forms.EventExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ejecuta un delegado de forma asincrónica en el subproceso donde se creó el identificador subyacente del control.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate -&gt; IAsyncResult" Usage="control.BeginInvoke method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Delegado de un método que no toma parámetros.</param>
        <summary>Ejecuta el delegado especificado de forma asincrónica en el subproceso donde se creó el identificador subyacente del control.</summary>
        <returns>Una <see cref="T:System.IAsyncResult" /> que representa el resultado de la operación <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama al delegado de forma asincrónica, y este método vuelve inmediatamente. Puede llamar a este método desde cualquier subproceso, incluso el subproceso que posee el identificador del control. Si el identificador del control no existe aún, este método buscará la cadena del control primario hasta que encuentra un control o formulario que tiene un identificador de ventana. Si no se encuentra ningún identificador adecuado, <xref:System.Windows.Forms.Control.BeginInvoke%2A> generará una excepción. Las excepciones dentro del método delegado se consideran no interceptadas y se enviarán al controlador de excepciones sin capturar de la aplicación.  
  
 Puede llamar a <xref:System.Windows.Forms.Control.EndInvoke%2A> para recuperar el valor devuelto del delegado, si es necesario, aunque esto no es necesario. <xref:System.Windows.Forms.Control.EndInvoke%2A> se bloqueará hasta que se puede recuperar el valor devuelto.  
  
> [!NOTE]
>  Mayoría de los métodos en un control sólo puede llamar desde el subproceso donde se creó el control. Además el <xref:System.Windows.Forms.Control.InvokeRequired%2A> propiedad, hay cuatro métodos en un control que son seguros para subprocesos: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, y <xref:System.Windows.Forms.Control.CreateGraphics%2A> si ya se ha creado el identificador del control. Una llamada a <xref:System.Windows.Forms.Control.CreateGraphics%2A> antes de que se ha creado el identificador del control en un subproceso en segundo plano puede provocar no válidas entre las llamadas de subprocesos. Para todas las demás llamadas de método, debe usar uno de los métodos de invocación para calcular las referencias de la llamada al subproceso del control. Los métodos de invocación siempre invocan sus devoluciones de llamada en el subproceso del control.  
  
> [!NOTE]
>  Es posible que se produce una excepción si el subproceso que se va a procesar el mensaje ya no está activo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra un uso de la <xref:System.Windows.Forms.Control.BeginInvoke%2A> método.  
  
 [!code-cpp[Control_BeginInvoke#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#2)]
 [!code-csharp[Control_BeginInvoke#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#2)]
 [!code-vb[Control_BeginInvoke#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se puede encontrar ningún identificador de ventana adecuado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para que el llamador inmediato llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.CreateGraphics" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member BeginInvoke : Delegate * obj[] -&gt; IAsyncResult&#xA;override this.BeginInvoke : Delegate * obj[] -&gt; IAsyncResult" Usage="control.BeginInvoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegado de un método que obtiene los parámetros del mismo número y tipo que los incluidos en el parámetro <c>args</c>.</param>
        <param name="args">Matriz de objetos cuyos valores se pasan como argumentos al método especificado. Puede ser <see langword="null" /> si no se necesita ningún argumento.</param>
        <summary>Ejecuta el delegado especificado de forma asincrónica con los argumentos especificados en el subproceso donde se creó el identificador subyacente del control.</summary>
        <returns>Una <see cref="T:System.IAsyncResult" /> que representa el resultado de la operación <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama al delegado de forma asincrónica, y este método vuelve inmediatamente. Puede llamar a este método desde cualquier subproceso, incluso el subproceso que posee el identificador del control. Si el identificador del control no existe aún, este método buscará la cadena del control primario hasta que encuentra un control o formulario que tiene un identificador de ventana. Si no se encuentra ningún identificador adecuado, <xref:System.Windows.Forms.Control.BeginInvoke%2A> generará una excepción. Las excepciones dentro del método delegado se consideran no interceptadas y se enviarán al controlador de excepciones sin capturar de la aplicación.  
  
 Puede llamar a <xref:System.Windows.Forms.Control.EndInvoke%2A> para recuperar el valor devuelto del delegado, si es necesario, aunque esto no es necesario. <xref:System.Windows.Forms.Control.EndInvoke%2A> se bloqueará hasta que se puede recuperar el valor devuelto.  
  
> [!NOTE]
>  Mayoría de los métodos en un control sólo puede llamar desde el subproceso donde se creó el control. Además el <xref:System.Windows.Forms.Control.InvokeRequired%2A> propiedad, hay cuatro métodos en un control que son seguros para subprocesos: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, y <xref:System.Windows.Forms.Control.CreateGraphics%2A> si ya se ha creado el identificador del control. Una llamada a <xref:System.Windows.Forms.Control.CreateGraphics%2A> antes de que se ha creado el identificador del control en un subproceso en segundo plano puede provocar no válidas entre las llamadas de subprocesos. Para todas las demás llamadas de método, debe usar uno de los métodos de invocación para calcular las referencias de la llamada al subproceso del control. Los métodos de invocación siempre invocan sus devoluciones de llamada en el subproceso del control.  
  
> [!NOTE]
>  Es posible que se produce una excepción si el subproceso que se va a procesar el mensaje ya no está activo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra un uso de la <xref:System.Windows.Forms.Control.BeginInvoke%2A> método.  
  
 [!code-cpp[Control_BeginInvoke#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#1)]
 [!code-csharp[Control_BeginInvoke#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#1)]
 [!code-vb[Control_BeginInvoke#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se puede encontrar ningún identificador de ventana adecuado.</exception>
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.CreateGraphics" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="BindingContext">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.BindingContext BindingContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingContext BindingContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BindingContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BindingContext As BindingContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::BindingContext ^ BindingContext { System::Windows::Forms::BindingContext ^ get(); void set(System::Windows::Forms::BindingContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingContext : System.Windows.Forms.BindingContext with get, set" Usage="System.Windows.Forms.Control.BindingContext" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IBindableComponent.BindingContext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la plantilla <see cref="T:System.Windows.Forms.BindingContext" /> para el control.</summary>
        <value>
          <see cref="T:System.Windows.Forms.BindingContext" /> del control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingContext> de un <xref:System.Windows.Forms.Control> se usa para devolver un único <xref:System.Windows.Forms.BindingManagerBase> para todos los controles enlazados a datos que contiene el <xref:System.Windows.Forms.Control>. El <xref:System.Windows.Forms.BindingManagerBase> mantiene todos los controles que están enlazados al mismo origen de datos sincronizado. Por ejemplo, si se establece la <xref:System.Windows.Forms.BindingManagerBase.Position%2A> propiedad de la <xref:System.Windows.Forms.BindingManagerBase> especifica el elemento en la lista subyacente que seleccione todos los controles enlazados a datos.  
  
 Para obtener más información acerca de cómo crear un nuevo <xref:System.Windows.Forms.BindingContext> y asignarlo a la <xref:System.Windows.Forms.Control.BindingContext%2A> propiedad, vea el <xref:System.Windows.Forms.BindingContext.%23ctor%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente crea cuatro <xref:System.Windows.Forms.Binding> objetos que se va a enlazar controles de cinco, un <xref:System.Windows.Forms.DateTimePicker> y cuatro <xref:System.Windows.Forms.TextBox> controles a varios orígenes de datos. El <xref:System.Windows.Forms.BindingContext> , a continuación, se utiliza para obtener el <xref:System.Windows.Forms.BindingManagerBase> para cada origen de datos.  
  
 [!code-cpp[Classic BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.BindingContext" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.BindingContext" /> propiedad para extender la implementación base. En caso contrario, debe proporcionar toda la implementación. No es necesario reemplazar ambos el <see langword="get" /> y <see langword="set" /> descriptores de acceso de la <see cref="P:System.Windows.Forms.Control.BindingContext" /> propiedad; se puede reemplazar sólo uno, si es necesario.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="BindingContextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BindingContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BindingContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BindingContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BindingContextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BindingContextChanged;" />
      <MemberSignature Language="F#" Value="member this.BindingContextChanged : EventHandler " Usage="member this.BindingContextChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="T:System.Windows.Forms.BindingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para agregar un nuevo <xref:System.Windows.Forms.BindingContext> a la <xref:System.Windows.Forms.Control> a través de la <xref:System.Windows.Forms.Control.BindingContext%2A> propiedad, vea el <xref:System.Windows.Forms.BindingContext.%23ctor%2A> constructor.  
  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.BindingContext%2A> se cambia la propiedad se modifica mediante programación o interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se agrega un <xref:System.EventHandler> delegar en el <xref:System.Windows.Forms.Control.BindingContextChanged> eventos de un <xref:System.Windows.Forms.TextBox> control.  
  
 [!code-cpp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CS/source.cs#1)]
 [!code-vb[Classic Control.BindingContextChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingContext" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
        <altmember cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Bottom">
      <MemberSignature Language="C#" Value="public int Bottom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Bottom" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bottom" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Bottom As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Bottom { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Bottom : int" Usage="System.Windows.Forms.Control.Bottom" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la distancia, en píxeles, que existe entre el borde inferior del control y el borde superior del área cliente de su contenedor.</summary>
        <value>
          <see cref="T:System.Int32" /> que representa la distancia, en píxeles, que existe entre el borde inferior del control y el borde superior del área cliente de su contenedor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta propiedad es igual a la suma de los <xref:System.Windows.Forms.Control.Top%2A> valor de propiedad y el <xref:System.Windows.Forms.Control.Height%2A> valor de propiedad.  
  
 El <xref:System.Windows.Forms.Control.Bottom%2A> propiedad es una propiedad de solo lectura. Puede manipular el valor de esta propiedad si cambia el valor de la <xref:System.Windows.Forms.Control.Top%2A> o <xref:System.Windows.Forms.Control.Height%2A> propiedades o llamar a la <xref:System.Windows.Forms.Control.SetBounds%2A>, <xref:System.Windows.Forms.Control.SetBoundsCore%2A>, <xref:System.Windows.Forms.Control.UpdateBounds%2A>, o <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> métodos.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.Bottom%2A> propiedad para definir el límite inferior de un <xref:System.Windows.Forms.TextBox> control en relación con el área cliente del contenedor.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Top" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
      </Docs>
    </Member>
    <Member MemberName="Bounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle Bounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle Bounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bounds" />
      <MemberSignature Language="VB.NET" Value="Public Property Bounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle Bounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberSignature Language="F#" Value="member this.Bounds : System.Drawing.Rectangle with get, set" Usage="System.Windows.Forms.Control.Bounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño y la ubicación del control incluyendo sus elementos no cliente, en píxeles, con respecto al control primario.</summary>
        <value>
          <see cref="T:System.Drawing.Rectangle" /> en píxeles con respecto al control primario que representa el tamaño y la ubicación del control, incluyendo sus elementos no cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los límites del control incluyen los elementos no cliente, como los bordes, las barras de título, los menús y barras de desplazamiento. El <xref:System.Windows.Forms.Control.SetBoundsCore%2A> método se llama para establecer el <xref:System.Windows.Forms.Control.Bounds%2A> propiedad. El <xref:System.Windows.Forms.Control.Bounds%2A> propiedad no siempre se cambia a través de su `set` método por lo que se debe reemplazar el <xref:System.Windows.Forms.Control.SetBoundsCore%2A> método para asegurarse de que el código se ejecuta cuando el <xref:System.Windows.Forms.Control.Bounds%2A> se establece la propiedad.  
  
   
  
## Examples  
 El ejemplo de código siguiente crea tres <xref:System.Windows.Forms.Button> controles de formularios y establece su tamaño y la ubicación mediante el uso de las diversas propiedades relacionadas con la ubicación y tamaño. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> que tiene un ancho y alto de al menos 300 píxeles.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Top" />
        <altmember cref="P:System.Windows.Forms.Control.Left" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
      </Docs>
    </Member>
    <Member MemberName="BringToFront">
      <MemberSignature Language="C#" Value="public void BringToFront ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringToFront() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BringToFront" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringToFront ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringToFront();" />
      <MemberSignature Language="F#" Value="member this.BringToFront : unit -&gt; unit" Usage="control.BringToFront " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Coloca el control al principio del orden Z.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El control se mueve al frente del orden z. Si el control es un elemento secundario de otro control, el control secundario se mueve al frente del orden z. <xref:System.Windows.Forms.Control.BringToFront%2A> hace realiza un control de un control de nivel superior y no provoca la <xref:System.Windows.Forms.Control.Paint> eventos.  
  
   
  
## Examples  
 El siguiente ejemplo de código que garantiza una <xref:System.Windows.Forms.Label> está visible mediante una llamada a su <xref:System.Windows.Forms.Control.BringToFront%2A> método. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.Panel> denominado `panel1`y un <xref:System.Windows.Forms.Label> denominado `label1`.  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SendToBack" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
      </Docs>
    </Member>
    <Member MemberName="CanEnableIme">
      <MemberSignature Language="C#" Value="protected virtual bool CanEnableIme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnableIme" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanEnableIme" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property CanEnableIme As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanEnableIme { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanEnableIme : bool" Usage="System.Windows.Forms.Control.CanEnableIme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la propiedad <see cref="P:System.Windows.Forms.Control.ImeMode" /> puede establecerse en un valor activo para habilitar la compatibilidad con el IME.</summary>
        <value>
          <see langword="true" /> en todos los casos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas pueden invalidar esta propiedad para devolver `false` si no se admite el IME.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFocus">
      <MemberSignature Language="C#" Value="public bool CanFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanFocus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFocus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFocus : bool" Usage="System.Windows.Forms.Control.CanFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el control puede recibir el foco.</summary>
        <value>Es <see langword="true" /> si el control puede recibir el foco; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En el orden de un control recibir el foco de entrada, el control debe tener un identificador asignado a él y el <xref:System.Windows.Forms.Control.Visible%2A> y <xref:System.Windows.Forms.Control.Enabled%2A> propiedades deben establecerse ambas como `true` para el control y todos sus controles principales tanto el control deben ser un formulario o la elemento primario exterior del control debe ser un formulario.  
  
   
  
## Examples  
 El ejemplo de código siguiente establece el foco en especificado <xref:System.Windows.Forms.Control>, si puede recibir el foco.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
      </Docs>
    </Member>
    <Member MemberName="CanRaiseEvents">
      <MemberSignature Language="C#" Value="protected override bool CanRaiseEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRaiseEvents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanRaiseEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CanRaiseEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanRaiseEvents { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRaiseEvents : bool" Usage="System.Windows.Forms.Control.CanRaiseEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina si se pueden producir eventos en el control.</summary>
        <value>
          <see langword="true" /> si el control está hospedado como un control ActiveX cuyos eventos no están inmovilizados; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este control se hospeda como un control ActiveX, esta propiedad devolverá `false` si el control ActiveX tiene sus eventos bloqueados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSelect">
      <MemberSignature Language="C#" Value="public bool CanSelect { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSelect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanSelect" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanSelect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanSelect { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSelect : bool" Usage="System.Windows.Forms.Control.CanSelect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el control se puede seleccionar.</summary>
        <value>Es <see langword="true" /> si el control se puede seleccionar; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve `true` si el `Selectable` valor <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> está establecido en `true`, está contenido en otro control, el propio control está habilitado y visible y todos sus controles principales son visibles y están habilitados.  
  
 Los controles de Windows Forms en la lista siguiente no se pueden seleccionables y devolverá un valor de `false` para el <xref:System.Windows.Forms.Control.CanSelect%2A> propiedad. Controles derivados de estos controles también no son seleccionables.  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel> (cuando no hay ningún vínculo en el control)  
  
   
  
## Examples  
 En el ejemplo de código siguiente se selecciona especificado <xref:System.Windows.Forms.Control>, si puede seleccionarse.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
 [!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
 [!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public bool Capture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Capture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Capture" />
      <MemberSignature Language="VB.NET" Value="Public Property Capture As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Capture { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Capture : bool with get, set" Usage="System.Windows.Forms.Control.Capture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el control ha capturado el mouse.</summary>
        <value>
          <see langword="true" /> si el control ha capturado el mouse; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un control ha capturado el mouse, recibe la entrada del mouse si el cursor se encuentra dentro de sus bordes. Normalmente, el mouse solo se captura durante las operaciones de arrastre.  
  
 Ventana de primer plano puede capturar el mouse. Cuando una ventana en segundo plano intenta hacerlo, la ventana recibe los mensajes solo para los eventos del mouse que se producen cuando el cursor del mouse está dentro de la parte visible de la ventana. Además, incluso si la ventana de primer plano ha capturado el mouse, el usuario puede hacer clic en otra ventana, llevándola a primer plano.  
  
 Cuando se captura el mouse, teclas de método abreviado no funcionará.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Windows.Forms.Control.Capture%2A> propiedad. Para ejecutar este ejemplo pegue el siguiente código en un formulario que contenga un <xref:System.Windows.Forms.Label> denominado label1 y dos <xref:System.Windows.Forms.ListBox> controles denominados listbox1 y listbox2. Asegúrese del formulario y los controles <xref:System.Windows.Forms.Control.MouseDown> evento está asociado con el método en este ejemplo.  
  
 [!code-cpp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlCapture#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas establecer este valor de propiedad. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CausesValidation">
      <MemberSignature Language="C#" Value="public bool CausesValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CausesValidation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CausesValidation" />
      <MemberSignature Language="VB.NET" Value="Public Property CausesValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CausesValidation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CausesValidation : bool with get, set" Usage="System.Windows.Forms.Control.CausesValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el control hace que se realice una validación de todos los controles que requieren validación cuando reciben el foco.</summary>
        <value>Es <see langword="true" /> si el control hace que se validen los controles que requieren validación cuando reciben el foco; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Forms.Control.CausesValidation%2A> propiedad está establecida en `false`, <xref:System.Windows.Forms.Control.Validating> y <xref:System.Windows.Forms.Control.Validated> se suprimen eventos.  
  
 El <xref:System.Windows.Forms.Control.CausesValidation%2A> normalmente se establece el valor de propiedad en `false` para controles como un botón de ayuda.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se utiliza la clase derivada <xref:System.Windows.Forms.TextBox> y valida una dirección de correo electrónico que el usuario escribe. Si la dirección de correo electrónico no está en el formato estándar (que contiene "@" and "."), se produce un error en la validación, un <xref:System.Windows.Forms.ErrorProvider> icono se muestra y se cancela el evento. Uno de los botones en el formulario tiene su <xref:System.Windows.Forms.Control.CausesValidation%2A> propiedad establecida en `false`. Al hacer clic en o establecer el foco en este botón no activa la validación. Este ejemplo requiere que un <xref:System.Windows.Forms.TextBox>, un <xref:System.Windows.Forms.ErrorProvider> control y un <xref:System.Windows.Forms.Button> se han creado en un formulario.  
  
 [!code-cpp[Control.Validating#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#2)]
 [!code-csharp[Control.Validating#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#2)]
 [!code-vb[Control.Validating#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="CausesValidationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CausesValidationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CausesValidationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CausesValidationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CausesValidationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CausesValidationChanged;" />
      <MemberSignature Language="F#" Value="member this.CausesValidationChanged : EventHandler " Usage="member this.CausesValidationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.CausesValidation" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.CausesValidation%2A> propiedad se modifica mediante programación o interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
      </Docs>
    </Member>
    <Member MemberName="ChangeUICues">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.UICuesEventHandler ChangeUICues;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.UICuesEventHandler ChangeUICues" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ChangeUICues" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ChangeUICues As UICuesEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::UICuesEventHandler ^ ChangeUICues;" />
      <MemberSignature Language="F#" Value="member this.ChangeUICues : System.Windows.Forms.UICuesEventHandler " Usage="member this.ChangeUICues : System.Windows.Forms.UICuesEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.UICuesEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambian las guías de la interfaz de usuario para el foco o el teclado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.ChangeUICues> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.ChangeUICues> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#67](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#67)]
 [!code-vb[System.Windows.Forms.EventExamples#67](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="CheckForIllegalCrossThreadCalls">
      <MemberSignature Language="C#" Value="public static bool CheckForIllegalCrossThreadCalls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckForIllegalCrossThreadCalls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckForIllegalCrossThreadCalls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckForIllegalCrossThreadCalls : bool with get, set" Usage="System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se detectarán las llamadas en el subproceso equivocado que tiene acceso a la propiedad <see cref="P:System.Windows.Forms.Control.Handle" /> de un control cuando se está depurando una aplicación.</summary>
        <value>
          <see langword="true" /> si se detectan las llamadas en el subproceso equivocado; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un subproceso distinto del subproceso de creación de un control intenta tener acceso a uno de los métodos o propiedades de ese control, suelen producirse resultados imprevisibles. Una actividad de subproceso no válido común es una llamada en el subproceso equivocado que tiene acceso al control <xref:System.Windows.Forms.Control.Handle%2A> propiedad. Establecer <xref:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls%2A> a `true` para buscar y diagnosticar más fácilmente esta actividad de subproceso durante la depuración.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se hace clic en el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.Click> evento pasa una <xref:System.EventArgs> a su controlador de eventos, por lo tanto, sólo indica que se ha producido un clic. Si necesita información más específica de mouse (botón, número de clics, rotación de la rueda o ubicación), use el <xref:System.Windows.Forms.Control.MouseClick> eventos. Sin embargo, el <xref:System.Windows.Forms.Control.MouseClick> evento no se genera si se debe hacer clic en acción distinto del mouse, como presionar la tecla ENTRAR.  
  
 Un doble clic viene determinada por la configuración del mouse del sistema operativo del usuario. El usuario puede establecer el tiempo entre los clics de un botón del mouse que debe considerarse como un doble clic y no como dos clics. El <xref:System.Windows.Forms.Control.Click> evento se desencadena cada vez que se hace doble clic en un control. Por ejemplo, si tiene controladores de eventos para el <xref:System.Windows.Forms.Control.Click> y <xref:System.Windows.Forms.Control.DoubleClick> eventos de un <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Control.Click> y <xref:System.Windows.Forms.Control.DoubleClick> se generan eventos cuando se hace doble clic en el formulario y se llama a ambos métodos. Si se hace doble clic en un control y que el control no admite la <xref:System.Windows.Forms.Control.DoubleClick> eventos, el <xref:System.Windows.Forms.Control.Click> evento podría generarse dos veces.  
  
 Debe establecer el `StandardClick` valor <xref:System.Windows.Forms.ControlStyles> a `true` para que se genere este evento.  
  
> [!NOTE]
>  Los siguientes eventos no se generan para el <xref:System.Windows.Forms.TabControl> a menos que haya al menos una de las clases <xref:System.Windows.Forms.TabPage> en el <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> colección: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> y <xref:System.Windows.Forms.Control.MouseMove>. Si hay al menos un <xref:System.Windows.Forms.TabPage> en la colección, y el usuario interactúa con el encabezado del control de ficha (donde el <xref:System.Windows.Forms.TabPage> aparecen nombres), el <xref:System.Windows.Forms.TabControl> provoca el evento adecuado. Sin embargo, si la interacción del usuario está dentro del área de cliente de la página de ficha, el <xref:System.Windows.Forms.TabPage> provoca el evento adecuado.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra la <xref:System.Windows.Forms.Control.Click> eventos en un controlador de eventos.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Heredar de un control de Windows Forms estándar y cambiar el <see langword="StandardClick" /> o <see langword="StandardDoubleClick" /> valores de <see cref="T:System.Windows.Forms.ControlStyles" /> a <see langword="true" /> puede provocar un comportamiento inesperado o no tienen ningún efecto en absoluto si el control no admite el <see cref="E:System.Windows.Forms.Control.Click" /> o <see cref="E:System.Windows.Forms.Control.DoubleClick" />eventos.  En la tabla siguiente se enumera los controles de formularios Windows Forms y qué evento (<see cref="E:System.Windows.Forms.Control.Click" /> o <see cref="E:System.Windows.Forms.Control.DoubleClick" />) se produce en respuesta a la acción del mouse especificada.  <list type="table"><listheader><term> Control </term><description> deja el clic del Mouse </description><description> haga doble clic en el primario del Mouse </description><description> clic del Mouse a la derecha </description><description> secundario del Mouse haga doble clic en </description><description> Clic del Mouse en el medio </description><description> central del Mouse haga doble clic en </description><description> XButton1 del Mouse Click </description><description> XButton1 del Mouse haga doble clic en </description><description> XButton2 Haga clic en el mouse </description><description> XButton2 del Mouse haga doble clic en </description></listheader><item><term><see cref="T:System.Windows.Forms.MonthCalendar" />, <see cref="T:System.Windows.Forms.DateTimePicker" />, <see cref="T:System.Windows.Forms.HScrollBar" />, <see cref="T:System.Windows.Forms.VScrollBar" /></term><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description></item><item><term><see cref="T:System.Windows.Forms.Button" />, <see cref="T:System.Windows.Forms.CheckBox" />, <see cref="T:System.Windows.Forms.RichTextBox" />, <see cref="T:System.Windows.Forms.RadioButton" /></term><description> Haga clic en </description><description> , haga clic en </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description></item><item><term><see cref="T:System.Windows.Forms.ListBox" />, <see cref="T:System.Windows.Forms.CheckedListBox" />, <see cref="T:System.Windows.Forms.ComboBox" /></term><description> Haga clic en </description><description> Click, DoubleClick </description><description> ninguno </description><description> ninguno </description><description> ninguno  </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno  </description></item><item><term><see cref="T:System.Windows.Forms.TextBox" />, <see cref="T:System.Windows.Forms.DomainUpDown" />, <see cref="T:System.Windows.Forms.NumericUpDown" /></term><description> Haga clic en </description><description>  Haga clic en DoubleClick </description><description> ninguno </description><description> ninguno</description><description> none  </description><description> none  </description><description> none  </description><description> none  </description><description> none  </description><description> none  </description></item><item><term> * <see cref="T:System.Windows.Forms.TreeView" />,  \* <see cref="T:System.Windows.Forms.ListView" /></term><description> Click  </description><description> Click, DoubleClick  </description><description> Click  </description><description> Click, DoubleClick  </description><description> none  </description><description> none  </description><description> none  </description><description> none  </description><description> none  </description><description> none  </description></item><item><term><see cref="T:System.Windows.Forms.ProgressBar" />,  <see cref="T:System.Windows.Forms.TrackBar" /></term><description> Click  </description><description> Click, Click  </description><description> Click  </description><description> Click, Click  </description><description> Click  </description><description> Click, Click  </description><description> Click  </description><description> Click, Click  </description><description> Click  </description><description> Click, Click  </description></item><item><term><see cref="T:System.Windows.Forms.Form" />,  <see cref="T:System.Windows.Forms.DataGrid" />,  <see cref="T:System.Windows.Forms.Label" />,  <see cref="T:System.Windows.Forms.LinkLabel" />,  <see cref="T:System.Windows.Forms.Panel" />,  <see cref="T:System.Windows.Forms.GroupBox" />,  <see cref="T:System.Windows.Forms.PictureBox" />,  <see cref="T:System.Windows.Forms.Splitter" />,  <see cref="T:System.Windows.Forms.StatusBar" />,  <see cref="T:System.Windows.Forms.ToolBar" />,  <see cref="T:System.Windows.Forms.TabPage" />,  ** <see cref="T:System.Windows.Forms.TabControl" /></term><description> Click  </description><description> Click, DoubleClick  </description><description> Click  </description><description> Click, DoubleClick  </description><description> Click  </description><description> Click, DoubleClick  </description><description> Click  </description><description> Click, DoubleClick  </description><description> Click  </description><description> Click, DoubleClick  </description></item></list>  \* The mouse pointer must be over a child object (<see cref="T:System.Windows.Forms.TreeNode" /> or <see cref="T:System.Windows.Forms.ListViewItem" />).  ** The <see cref="T:System.Windows.Forms.TabControl" /> must have at least one <see cref="T:System.Windows.Forms.TabPage" /> in its <see cref="P:System.Windows.Forms.TabControl.TabPages" /> collection.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ClientRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.Control.ClientRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el rectángulo que representa el área cliente del control.</summary>
        <value>
          <see cref="T:System.Drawing.Rectangle" /> que representa el área cliente del control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El área cliente de un control es los límites del control, menos los elementos no cliente, como los bordes, las barras de título, los menús y barras de desplazamiento.  
  
 Dado que las coordenadas de cliente son relativas a la esquina superior izquierda del área cliente del control, las coordenadas de la esquina superior izquierda del rectángulo devuelto por esta propiedad son (0,0). Puede utilizar esta propiedad para obtener el tamaño y las coordenadas del área cliente del control para realizar tareas como dibujar en la superficie del control.  
  
 Para obtener más información sobre el dibujo de controles, vea [representar un Control de Windows Forms](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se habilita el desplazamiento automático para un formulario, cambia el tamaño del formulario y garantiza que un botón permanece visible después de que se cambia el tamaño del formulario. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.Button> denominado `button2` en él.  
  
 [!code-cpp[Windows.Forms.Control Member5#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#2)]
 [!code-csharp[Windows.Forms.Control Member5#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#2)]
 [!code-vb[Windows.Forms.Control Member5#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
        <altmember cref="T:System.Windows.Forms.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size ClientSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.ClientSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.ClientSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el alto y el ancho del área cliente del control.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> que representa las dimensiones del área cliente del control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El área cliente de un control es los límites del control, menos los elementos no cliente, como los bordes, las barras de título, los menús y barras de desplazamiento. El <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> método se llama para establecer el <xref:System.Windows.Forms.Control.ClientSize%2A> propiedad. El <xref:System.Windows.Forms.Control.ClientSize%2A> propiedad no siempre se cambia a través de su `set` método por lo que se debe reemplazar el <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> método para asegurarse de que el código se ejecuta cuando el <xref:System.Windows.Forms.Control.ClientSize%2A> se establece la propiedad.  
  
 El <xref:System.Drawing.Size.Width%2A?displayProperty=nameWithType> y <xref:System.Drawing.Size.Height%2A?displayProperty=nameWithType> propiedades representan el ancho y alto del área cliente del control. Puede utilizar esta propiedad para obtener el tamaño del área cliente del control para realizar tareas como dibujar en la superficie del control.  
  
 Para obtener más información sobre el dibujo de controles, vea [representar un Control de Windows Forms](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).  
  
> [!NOTE]
>  No se puede enlazar la configuración de la aplicación para esta propiedad. Para obtener más información sobre la configuración de la aplicación, consulte [Application Settings Overview](~/docs/framework/winforms/advanced/application-settings-overview.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se cambia el tamaño del control especificado para que el control alojará el texto con formato. El texto con formato es el <xref:System.Windows.Forms.Control.Text%2A> asignado de propiedad con el control del <xref:System.Windows.Forms.Control.Font%2A> aplicado al texto. El `AutoSizeControl` método en este ejemplo también tiene un `textPadding` parámetro que representa el relleno que se aplican a todos los bordes del control. Para que el relleno parecen iguales, se alinea el texto con el <xref:System.Drawing.ContentAlignment.MiddleCenter?displayProperty=nameWithType> valor, si el control lo permite.  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="T:System.Windows.Forms.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ClientSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ClientSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ClientSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ClientSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ClientSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ClientSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.ClientSizeChanged : EventHandler " Usage="member this.ClientSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.ClientSize" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.ClientSizeChanged> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.ClientSizeChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#12)]
 [!code-vb[System.Windows.Forms.EventExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Control.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Description("ControlCompanyNameDescr")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de la compañía o del creador de la aplicación que contiene el control.</summary>
        <value>Nombre de la compañía o del creador de la aplicación que contiene el control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.CompanyName%2A> propiedad es una propiedad de solo lectura. Para cambiar el valor de esta propiedad, establezca el <xref:System.Reflection.AssemblyCompanyAttribute.Company%2A> valor de propiedad de la <xref:System.Reflection.AssemblyCompanyAttribute>. La siguiente línea de conjuntos de código de C# del <xref:System.Windows.Forms.Control.CompanyName%2A> propiedad.  
  
```csharp  
[assembly: AssemblyCompany("Microsoft")]  
```  
  
> [!NOTE]
>  Se recomienda encarecidamente proporcionar el nombre de la compañía, nombre de producto y versión del producto para la aplicación.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra información acerca de la aplicación en un <xref:System.Windows.Forms.Label> contenidos en un <xref:System.Windows.Forms.Form>. Este ejemplo requiere que el <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> y <xref:System.Windows.Forms.Control.ProductVersion%2A> se han establecido.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyCompanyAttribute.Company" />
        <altmember cref="P:System.Diagnostics.FileVersionInfo.CompanyName" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Forms.Control ctl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Windows.Forms.Control ctl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Contains(System.Windows.Forms.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (ctl As Control) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Windows::Forms::Control ^ ctl);" />
      <MemberSignature Language="F#" Value="member this.Contains : System.Windows.Forms.Control -&gt; bool" Usage="control.Contains ctl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="ctl">
          <see cref="T:System.Windows.Forms.Control" /> que se va a evaluar.</param>
        <summary>Obtiene un valor que indica si el control especificado es un control secundario del control.</summary>
        <returns>
          <see langword="true" /> si el control especificado es un control secundario del control; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código que garantiza una <xref:System.Windows.Forms.Label> está visible mediante una llamada a su <xref:System.Windows.Forms.Control.BringToFront%2A> método. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.Panel> denominado `panel1`y un <xref:System.Windows.Forms.Label> denominado `label1`.  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ControlCollection.Contains(System.Windows.Forms.Control)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="ContainsFocus">
      <MemberSignature Language="C#" Value="public bool ContainsFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContainsFocus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainsFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ContainsFocus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsFocus : bool" Usage="System.Windows.Forms.Control.ContainsFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el control, o uno de sus controles secundarios, tiene el foco de entrada en la actualidad.</summary>
        <value>
          <see langword="true" /> si el control o uno de sus controles secundarios tiene el foco de entrada en la actualidad; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede utilizar esta propiedad para determinar si un control o cualquiera de los controles contenidos en la misma tiene el foco de entrada. Para determinar si el control tiene foco, independientemente de si alguno de sus controles secundarios tiene el foco, utilice el <xref:System.Windows.Forms.Control.Focused%2A> propiedad. Para dar el foco de entrada de un control, utilice el <xref:System.Windows.Forms.Control.Focus%2A> o <xref:System.Windows.Forms.Control.Select%2A> métodos.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenu ^ ContextMenu { System::Windows::Forms::ContextMenu ^ get(); void set(System::Windows::Forms::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Forms.ContextMenu with get, set" Usage="System.Windows.Forms.Control.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el menú contextual asociado al control.</summary>
        <value>
          <see cref="T:System.Windows.Forms.ContextMenu" /> que representa el menú contextual asociado al control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use los menús contextuales para ofrecer a los usuarios opciones de menú específicas del contexto cuando haga doble clic en el control.  
  
   
  
## Examples  
 El siguiente código de ejemplo se muestra el <xref:System.Windows.Forms.ContextMenu> asignado a un <xref:System.Windows.Forms.TreeView> cuando se hace clic y libera el botón secundario del mouse. Este código requiere que haya un <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.TreeView> en él. También es necesario que el <xref:System.Windows.Forms.TreeView> tiene un <xref:System.Windows.Forms.ContextMenu> asignado a su <xref:System.Windows.Forms.Control.ContextMenu%2A> propiedad.  
  
 [!code-cpp[Windows.Forms.Control Properties2#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#5)]
 [!code-csharp[Windows.Forms.Control Properties2#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#5)]
 [!code-vb[Windows.Forms.Control Properties2#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.ContextMenu" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.ContextMenu" /> propiedad para extender la implementación base. En caso contrario, debe proporcionar toda la implementación. No es necesario reemplazar ambos el <see langword="get" /> y <see langword="set" /> descriptores de acceso de la <see cref="P:System.Windows.Forms.Control.ContextMenu" /> propiedad; se puede reemplazar sólo uno, si es necesario.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContextMenuChanged;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuChanged : EventHandler " Usage="member this.ContextMenuChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.ContextMenu" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.ContextMenu%2A> propiedad se modifica mediante programación o interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra un mensaje cuando se produce un cambio en el menú contextual.  
  
 [!code-cpp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CPP/control_contextmenu_creategraphics.cpp#2)]
 [!code-csharp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CS/control_contextmenu_creategraphics.cs#2)]
 [!code-vb[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/VB/control_contextmenu_creategraphics.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenu" />
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStrip">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenuStrip ContextMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenuStrip ContextMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenuStrip As ContextMenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenuStrip ^ ContextMenuStrip { System::Windows::Forms::ContextMenuStrip ^ get(); void set(System::Windows::Forms::ContextMenuStrip ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenuStrip : System.Windows.Forms.ContextMenuStrip with get, set" Usage="System.Windows.Forms.Control.ContextMenuStrip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el <see cref="T:System.Windows.Forms.ContextMenuStrip" /> asociado a este control.</summary>
        <value>El <see cref="T:System.Windows.Forms.ContextMenuStrip" /> para este control o <see langword="null" /> si no hay ningún <see cref="T:System.Windows.Forms.ContextMenuStrip" />. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un <xref:System.Windows.Forms.ContextMenu> también está asignado al control, el <xref:System.Windows.Forms.ContextMenu> tiene prioridad sobre la <xref:System.Windows.Forms.ContextMenuStrip>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo agregar tres <xref:System.Windows.Forms.ToolStripMenuItem> objetos a un <xref:System.Windows.Forms.ContextMenuStrip>. Además se muestra cómo establecer el <xref:System.Windows.Forms.Control.ContextMenuStrip%2A> propiedad del formulario.  
  
 [!code-csharp[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStripChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuStripChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuStripChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuStripChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuStripChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContextMenuStripChanged;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuStripChanged : EventHandler " Usage="member this.ContextMenuStripChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.ContextMenuStrip" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.ContextMenuStripChanged> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.ContextMenuStripChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#14)]
 [!code-vb[System.Windows.Forms.EventExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ControlAdded">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlAdded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ControlAdded As ControlEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ControlEventHandler ^ ControlAdded;" />
      <MemberSignature Language="F#" Value="member this.ControlAdded : System.Windows.Forms.ControlEventHandler " Usage="member this.ControlAdded : System.Windows.Forms.ControlEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se agrega un nuevo control a <see cref="T:System.Windows.Forms.Control.ControlCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.Control.ControlAdded> para agregar un control a un formulario y muestra el nombre del control se ha agregado en un <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ControlRemoved">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlRemoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ControlRemoved As ControlEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ControlEventHandler ^ ControlRemoved;" />
      <MemberSignature Language="F#" Value="member this.ControlRemoved : System.Windows.Forms.ControlEventHandler " Usage="member this.ControlRemoved : System.Windows.Forms.ControlEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se quita un control de <see cref="T:System.Windows.Forms.Control.ControlCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.Control.ControlRemoved> para quitar un control de un formulario y muestra el nombre del control eliminado en un <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control/ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Controls" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Controls As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control::ControlCollection ^ Controls { System::Windows::Forms::Control::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Windows.Forms.Control.ControlCollection" Usage="System.Windows.Forms.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección de controles que contiene el control.</summary>
        <value>
          <see cref="T:System.Windows.Forms.Control.ControlCollection" /> que representa la colección de controles incluidos en el control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Forms.Control> puede actuar como primario de una colección de controles. Por ejemplo, cuando se agregan varios controles a un <xref:System.Windows.Forms.Form>, cada uno de los controles es un miembro de la <xref:System.Windows.Forms.Control.ControlCollection> asignado a la <xref:System.Windows.Forms.Control.Controls%2A> propiedad del formulario, que se deriva el <xref:System.Windows.Forms.Control> clase.  
  
 Puede manipular los controles en el <xref:System.Windows.Forms.Control.ControlCollection> asignado a la <xref:System.Windows.Forms.Control.Controls%2A> propiedad mediante el uso de los métodos disponibles en la <xref:System.Windows.Forms.Control.ControlCollection> clase.  
  
 Al agregar varios controles a un control principal, se recomienda que llame el <xref:System.Windows.Forms.Control.SuspendLayout%2A> método antes de inicializar los controles que se va a agregar. Después de agregar los controles al control primario, llame a la <xref:System.Windows.Forms.Control.ResumeLayout%2A> método. Si lo hace, aumentará el rendimiento de aplicaciones con muchos controles.  
  
 Use el <xref:System.Windows.Forms.Control.Controls%2A> propiedad para recorrer en iteración todos los controles de un formulario, incluidos los controles anidados. Use el <xref:System.Windows.Forms.Control.GetNextControl%2A> método para recuperar el control secundario anterior o siguiente en el orden de tabulación. Use el <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> propiedad va a obtener o establecer el control activo de un control contenedor.  
  
   
  
## Examples  
 El código siguiente en el ejemplo se quita un <xref:System.Windows.Forms.Control> desde el <xref:System.Windows.Forms.Control.ControlCollection> de la clase derivada <xref:System.Windows.Forms.Panel> si es un miembro de la colección. El ejemplo requiere que se haya creado un <xref:System.Windows.Forms.Panel>, un <xref:System.Windows.Forms.Button>y al menos un <xref:System.Windows.Forms.RadioButton> control en un <xref:System.Windows.Forms.Form>. El <xref:System.Windows.Forms.RadioButton> controles se agregan a la <xref:System.Windows.Forms.Panel> control y el <xref:System.Windows.Forms.Panel> control agregado al <xref:System.Windows.Forms.Form>. Cuando se hace clic en el botón, el botón de radio denominado `removeButton` se quita de la <xref:System.Windows.Forms.Control.ControlCollection>.  
  
 [!code-cpp[ControlCollection#4](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlCollection/CPP/controlcollection.cpp#4)]
 [!code-csharp[ControlCollection#4](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlCollection/CS/controlcollection.cs#4)]
 [!code-vb[ControlCollection#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlCollection/VB/controlcollection.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControlsInstance" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
      </Docs>
    </Member>
    <Member MemberName="CreateAccessibilityInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject CreateAccessibilityInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject CreateAccessibilityInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAccessibilityInstance () As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ CreateAccessibilityInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject" Usage="control.CreateAccessibilityInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuevo objeto de accesibilidad para el control.</summary>
        <returns>Nuevo <see cref="T:System.Windows.Forms.AccessibleObject" /> del control.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se llama de forma explícita al método <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>, se llamará a este método al hacer referencia a la propiedad <xref:System.Windows.Forms.Control.AccessibilityObject%2A>.  
  
> [!NOTE]
>  Para obtener o establecer el <xref:System.Windows.Forms.Control.AccessibilityObject%2A> propiedad, debe agregar una referencia a la `Accessibility` ensamblado instalado con el [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la creación de un gráfico de accesibilidad para controlar, mediante el <xref:System.Windows.Forms.AccessibleObject> y <xref:System.Windows.Forms.Control.ControlAccessibleObject> clases para exponer información accesible. El control traza dos curvas junto con una leyenda. El `ChartControlAccessibleObject` (clase), que se deriva de `ControlAccessibleObject`, se usa en el <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> método para proporcionar información personalizada accesible para el control chart. Dado que la leyenda del gráfico no es un real <xref:System.Windows.Forms.Control> -control basado en, pero en su lugar se dibuja mediante el control chart, lo hace no ninguna información accesible. Por este motivo, el `ChartControlAccessibleObject` clase invalida el <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> método para devolver el `CurveLegendAccessibleObject` que representa la información accesible de cada parte de la leyenda. Cuando una aplicación accesible para usa este control, el control puede proporcionar la información de acceso necesaria.  
  
 Este fragmento de código se muestra cómo reemplazar el <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> método. Consulte la <xref:System.Windows.Forms.AccessibleObject> información general de clases para el ejemplo de código completo.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#2)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#2)]
 [!code-vb[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" /> en una clase derivada, no llame a la clase base <see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" /> método.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.Control.ControlAccessibleObject" />
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="CreateControl">
      <MemberSignature Language="C#" Value="public void CreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControl" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateControl();" />
      <MemberSignature Language="F#" Value="member this.CreateControl : unit -&gt; unit" Usage="control.CreateControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fuerza la creación del control visible, incluidos el identificador y los controles secundarios visibles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.CreateControl%2A> método obliga a un identificador que se crearán para el control y sus controles secundarios. Este método se utiliza cuando se necesita un identificador inmediatamente para la manipulación del control o sus elementos secundarios; basta con llamar el constructor de un control no crea el <xref:System.Windows.Forms.Control.Handle%2A>.  
  
 <xref:System.Windows.Forms.Control.CreateControl%2A> no crea un identificador de control si el control <xref:System.Windows.Forms.Control.Visible%2A> propiedad es `false`. Puede llamar a la <xref:System.Windows.Forms.Control.CreateHandle%2A> método o acceso a la <xref:System.Windows.Forms.Control.Handle%2A> propiedad para crear el control para controlar independientemente la visibilidad del control, pero en este caso, no hay ninguna ventana que se creen los controladores para los elementos secundarios del control.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControlsInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateControlsInstance () As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::Control::ControlCollection ^ CreateControlsInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateControlsInstance : unit -&gt; System.Windows.Forms.Control.ControlCollection&#xA;override this.CreateControlsInstance : unit -&gt; System.Windows.Forms.Control.ControlCollection" Usage="control.CreateControlsInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una nueva instancia de la colección de controles para el control.</summary>
        <returns>Nueva instancia de <see cref="T:System.Windows.Forms.Control.ControlCollection" /> que se le asigna al control.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>La versión de la clase base de este método no debe llamarse mediante una clase derivada.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public bool Created { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Created" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Created" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Created As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Created { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Created : bool" Usage="System.Windows.Forms.Control.Created" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se ha creado el control.</summary>
        <value>Es <see langword="true" /> si se ha creado el control; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.Created%2A> propiedad devuelve `true` si el <xref:System.Windows.Forms.Control> se creó correctamente, aunque es posible que el identificador del control no se han creado o volver a crear todavía.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.OnCreateControl" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="CreateGraphics">
      <MemberSignature Language="C#" Value="public System.Drawing.Graphics CreateGraphics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Graphics CreateGraphics() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateGraphics" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateGraphics () As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Graphics ^ CreateGraphics();" />
      <MemberSignature Language="F#" Value="member this.CreateGraphics : unit -&gt; System.Drawing.Graphics" Usage="control.CreateGraphics " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea el <see cref="T:System.Drawing.Graphics" /> para el control.</summary>
        <returns>
          <see cref="T:System.Drawing.Graphics" /> del control.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Drawing.Graphics> objeto que se recupera mediante el <xref:System.Windows.Forms.Control.CreateGraphics%2A> método no normalmente deben retenerse una vez procesado el mensaje actual de Windows, ya que nada se pinta con ese objeto se borrarán con el siguiente mensaje WM_PAINT. Por lo tanto no se puede almacenar en caché el <xref:System.Drawing.Graphics> objeto para su reutilización, excepto para usar métodos no visual, como <xref:System.Drawing.Graphics.MeasureString%2A?displayProperty=nameWithType>. En su lugar, debe llamar a <xref:System.Windows.Forms.Control.CreateGraphics%2A> cada vez que se va a usar el <xref:System.Drawing.Graphics> objeto y, a continuación, llame a <xref:System.Drawing.Graphics.Dispose%2A> cuando haya terminado de utilizarlo. Para obtener más información acerca de los mensajes de Windows, consulte <xref:System.Windows.Forms.Control.WndProc%2A>.  
  
 Por diseño, <xref:System.Windows.Forms.Control.CreateGraphics%2A> establece la propiedad en el subproceso de llamada y se produce un error si se llama en otros subprocesos.  
  
> [!NOTE]
>  Además el <xref:System.Windows.Forms.Control.InvokeRequired%2A> propiedad, hay cuatro métodos en un control que son seguros para subprocesos: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, y <xref:System.Windows.Forms.Control.CreateGraphics%2A> si ya se ha creado el identificador del control. Una llamada a <xref:System.Windows.Forms.Control.CreateGraphics%2A> antes de que se ha creado el identificador del control en un subproceso en segundo plano puede provocar no válidas entre las llamadas de subprocesos. Para todas las demás llamadas de método, debe usar uno de los métodos de invocación para calcular las referencias de la llamada al subproceso del control.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se cambia el tamaño del control especificado para que el control alojará el texto con formato. El texto con formato es el <xref:System.Windows.Forms.Control.Text%2A> asignado de propiedad con el control del <xref:System.Windows.Forms.Control.Font%2A> aplicado al texto. El `AutoSizeControl` método en este ejemplo también tiene un `textPadding` parámetro que representa el relleno que se aplican a todos los bordes del control. Para que el relleno parecen iguales, se alinea el texto con el `MiddleCenter` valor <xref:System.Drawing.ContentAlignment?displayProperty=nameWithType> si el control lo admite.  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para las ventanas secundarias seguras llamar a este método. Enumeración asociada: <see langword="SafeSubWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="T:System.Drawing.Graphics" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected virtual void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CreateHandle();" />
      <MemberSignature Language="F#" Value="abstract member CreateHandle : unit -&gt; unit&#xA;override this.CreateHandle : unit -&gt; unit" Usage="control.CreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un identificador para el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente no se debería llamar el <xref:System.Windows.Forms.Control.CreateHandle%2A> método directamente. El método preferido es llamar a la <xref:System.Windows.Forms.Control.CreateControl%2A> método, que fuerza un identificador que se crearán para el control y sus controles secundarios cuando se crea el control.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El objeto está eliminado.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas para la herencia de clases para llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.CreateHandle" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.CreateHandle" /> método para asegurarse de que se crea el identificador.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.Control.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los parámetros de creación necesarios cuando se crea el identificador del control.</summary>
        <value>
          <see cref="T:System.Windows.Forms.CreateParams" /> que contiene los parámetros de creación necesarios cuando se crea el identificador del control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.CreateParams%2A> propiedad no se debe invalidar y utiliza para ajustar las propiedades del control derivado. Propiedades, como el <xref:System.Windows.Forms.CreateParams.Caption%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.CreateParams.Width%2A?displayProperty=nameWithType>, y <xref:System.Windows.Forms.CreateParams.Height%2A?displayProperty=nameWithType> debe establecer las propiedades correspondientes en el control como <xref:System.Windows.Forms.Control.Text%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Control.Width%2A?displayProperty=nameWithType> y <xref:System.Windows.Forms.Control.Height%2A?displayProperty=nameWithType>. El <xref:System.Windows.Forms.CreateParams> sólo debe extenderse cuando se está ajustando una clase de control estándar de Windows o para establecer estilos no proporcionados por el espacio de nombres de Windows Forms. Para obtener más información acerca de cómo crear parámetros de control, vea el `CreateWindow` y `CreateWindowEx` funciones y la [CREATESTRUCT](http://msdn.microsoft.com/library/windows/desktop/ms632603.aspx)documentación de la estructura.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se amplía el <xref:System.Windows.Forms.Control.CreateParams%2A> propiedad de un <xref:System.Windows.Forms.Button> clase derivada. El <xref:System.Windows.Forms.CreateParams.Style%2A?displayProperty=nameWithType> propiedad ha cambiado, lo que hace que el botón para mostrar un <xref:System.Drawing.Icon> en lugar de un <xref:System.Drawing.Image>. En este ejemplo requiere que tenga una clase que hereda de la <xref:System.Windows.Forms.Button> clase.  
  
 [!code-cpp[CreateParams#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CreateParams/CPP/createparams.cpp#3)]
 [!code-csharp[CreateParams#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CreateParams/CS/createparams.cs#3)]
 [!code-vb[CreateParams#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CreateParams/VB/createparams.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para que el llamador inmediato llamar a código no administrado al obtener el valor de propiedad. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.CreateParams" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.CreateParams" /> propiedad para extender la implementación base. En caso contrario, debe proporcionar toda la implementación.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Cursor ^ Cursor { System::Windows::Forms::Cursor ^ get(); void set(System::Windows::Forms::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Forms.Cursor with get, set" Usage="System.Windows.Forms.Control.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el cursor que se muestra cuando el puntero del mouse se sitúa sobre el control.</summary>
        <value>Un <see cref="T:System.Windows.Forms.Cursor" /> que representa el cursor que se va a mostrar cuando el puntero del mouse se sitúe sobre el control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asignar un <xref:System.Windows.Forms.Cursor> a la <xref:System.Windows.Forms.Control.Cursor%2A> propiedad del control para cambiar el cursor que se muestra cuando el puntero del mouse está encima del control. Para cambiar temporalmente el cursor del mouse para todos los controles en el conjunto de aplicaciones el <xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType> propiedad. Normalmente, establecería el <xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType> propiedad a un cursor de espera al rellenar un <xref:System.Windows.Forms.ComboBox> o guardar o cargar un archivo.  
  
 El <xref:System.Windows.Forms.Control.Cursor%2A> es una propiedad de ambiente. Una propiedad de ambiente es una propiedad de control que, si no establece, se recupera desde el control primario. Por ejemplo, un <xref:System.Windows.Forms.Button> tendrá el mismo <xref:System.Windows.Forms.Control.BackColor%2A> como su elemento primario <xref:System.Windows.Forms.Form> de forma predeterminada. Para obtener más información acerca de las propiedades de ambiente, vea la <xref:System.Windows.Forms.AmbientProperties> clase o el <xref:System.Windows.Forms.Control> información general de clases.  
  
   
  
## Examples  
 El siguiente código de ejemplo se llena un <xref:System.Windows.Forms.ComboBox> con unidades lógicas disponibles del usuario. El ejemplo también establece el cuadro combinado <xref:System.Windows.Forms.Cursor> propiedad por lo que el <xref:System.Windows.Forms.Cursors.Hand%2A?displayProperty=nameWithType> cursor se muestra cuando el puntero del mouse está sobre el botón de lista desplegable. Este código requiere que haya un <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.ComboBox> en él.  
  
 [!code-cpp[Windows.Forms.Control Properties2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para las ventanas secundarias seguras establecer este valor de propiedad. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.Cursor" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.Cursor" /> propiedad para extender la implementación base. En caso contrario, debe proporcionar toda la implementación. No es necesario reemplazar ambos el <see langword="get" /> y <see langword="set" /> métodos de la <see cref="P:System.Windows.Forms.Control.Cursor" /> propiedad; se puede reemplazar sólo uno, si es necesario.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.Cursor" />
        <altmember cref="T:System.Windows.Forms.Cursors" />
      </Docs>
    </Member>
    <Member MemberName="CursorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CursorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CursorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CursorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CursorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CursorChanged;" />
      <MemberSignature Language="F#" Value="member this.CursorChanged : EventHandler " Usage="member this.CursorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.Cursor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.Cursor%2A> propiedad se modifica mediante programación o interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo cambiar el cursor del mouse mediante el <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType> propiedad, el <xref:System.Windows.Forms.Cursor> (clase) y el <xref:System.Windows.Forms.Cursors> clase. El ejemplo crea un formulario que contenga un <xref:System.Windows.Forms.ComboBox> (control), un <xref:System.Windows.Forms.Panel> control y un <xref:System.Windows.Forms.ListView> control. El <xref:System.Windows.Forms.ComboBox> contiene todos los cursores proporcionados por el <xref:System.Windows.Forms.Cursors> clase. Cuando el usuario selecciona un cursor del mouse en el <xref:System.Windows.Forms.ComboBox>, <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType> propiedad está establecida en el cursor seleccionado, que actualiza el cursor para el <xref:System.Windows.Forms.Panel>. El <xref:System.Windows.Forms.ListView> se actualiza cada vez que el <xref:System.Windows.Forms.Control.CursorChanged?displayProperty=nameWithType> se produce el evento.  
  
 [!code-cpp[System.Windows.Forms.Cursors#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CPP/cursorexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursors#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CS/cursorexample.cs#1)]
 [!code-vb[System.Windows.Forms.Cursors#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursors/VB/cursorexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
        <altmember cref="T:System.Windows.Forms.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="DataBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ControlBindingsCollection DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ControlBindingsCollection DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DataBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataBindings As ControlBindingsCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ControlBindingsCollection ^ DataBindings { System::Windows::Forms::ControlBindingsCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataBindings : System.Windows.Forms.ControlBindingsCollection" Usage="System.Windows.Forms.Control.DataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IBindableComponent.DataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlBindingsCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los enlaces de datos del control.</summary>
        <value>
          <see cref="T:System.Windows.Forms.ControlBindingsCollection" /> que contiene los objetos <see cref="T:System.Windows.Forms.Binding" /> del control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Windows.Forms.Control.DataBindings%2A> propiedad para tener acceso a la <xref:System.Windows.Forms.ControlBindingsCollection>. Agregando <xref:System.Windows.Forms.Binding> objetos a la colección, puede enlazar cualquier propiedad de un control a la propiedad de un objeto.  
  
   
  
## Examples  
 El ejemplo de código siguiente agrega <xref:System.Windows.Forms.Binding> objetos a la <xref:System.Windows.Forms.ControlBindingsCollection> de cinco controles: cuatro <xref:System.Windows.Forms.TextBox> controles y un <xref:System.Windows.Forms.DateTimePicker> control. Se obtiene acceso a <xref:System.Windows.Forms.ControlBindingsCollection> mediante la propiedad <xref:System.Windows.Forms.Control.DataBindings%2A> de la clase <xref:System.Windows.Forms.Control>.  
  
 [!code-cpp[Classic Control.DataBindings Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.DataBindings Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CS/source.cs#1)]
 [!code-vb[Classic Control.DataBindings Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.DataBindings Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingContext" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBackColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultBackColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Color DefaultBackColor { System::Drawing::Color get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBackColor : System.Drawing.Color" Usage="System.Windows.Forms.Control.DefaultBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el color de fondo predeterminado del control.</summary>
        <value>
          <see cref="T:System.Drawing.Color" /> de fondo predeterminado del control. El valor predeterminado es <see cref="P:System.Drawing.SystemColors.Control" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este es el valor predeterminado <xref:System.Windows.Forms.Control.BackColor%2A> valor de propiedad de un control genérico de nivel superior. Las clases derivadas pueden tener distintos valores predeterminados.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A>, y <xref:System.Windows.Forms.Control.DefaultForeColor%2A> miembros. Para ejecutar el ejemplo, pegue el código siguiente en un formulario que contenga un <xref:System.Windows.Forms.ListBox> denominado ListBox1. Llame a la `Populate_ListBox` método en el constructor del formulario o <xref:System.Windows.Forms.Form.Load> el método de control de eventos.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
        <altmember cref="T:System.Drawing.Color" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="DefaultCursor">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Cursor DefaultCursor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor DefaultCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultCursor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Cursor ^ DefaultCursor { System::Windows::Forms::Cursor ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCursor : System.Windows.Forms.Cursor" Usage="System.Windows.Forms.Control.DefaultCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el cursor predeterminado para el control.</summary>
        <value>Un objeto de tipo <see cref="T:System.Windows.Forms.Cursor" /> que representa el cursor predeterminado actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalidar <xref:System.Windows.Forms.Control.DefaultCursor%2A> para configurar un cursor predeterminado para el control. Esto es más eficaz que establecer el cursor en el constructor del control y proporciona compatibilidad automática para ciertas funciones de diseñador relacionadas con el cursor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultFont">
      <MemberSignature Language="C#" Value="public static System.Drawing.Font DefaultFont { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Drawing.Font DefaultFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultFont" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Font ^ DefaultFont { System::Drawing::Font ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultFont : System.Drawing.Font" Usage="System.Windows.Forms.Control.DefaultFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la fuente predeterminada del control.</summary>
        <value>
          <see cref="T:System.Drawing.Font" /> predeterminado del control. El valor devuelto variará en función de la configuración de referencia cultural local del sistema operativo del usuario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabla siguiente describe el valor devuelto por <xref:System.Windows.Forms.Control.DefaultFont%2A> según el sistema operativo y la referencia cultural local.  
  
|Sistema / y o la referencia cultural|Tipo de letra|  
|----------------------------|----------|  
|Windows NT 4 x, la versión en japonés|MS UI: gótica, 9 puntos.|  
|Windows árabe|Tahoma de 8 puntos.|  
|Otro sistema operativo o la referencia cultural|Fuente lógica de MS Shell Dlg, normalmente Microsoft Sans Serif de 8 puntos.|  
  
 MS Shell Dlg se asigna a una fuente establecida en el registro del sistema.  
  
 Si no están instaladas las fuentes anteriores, la fuente predeterminada es Tahoma, 8 puntos. Si no está instalado Tahoma de 8 puntos, <xref:System.Windows.Forms.Control.DefaultFont%2A> devuelve el valor de la <xref:System.Drawing.FontFamily.GenericSansSerif%2A> propiedad  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A>, y <xref:System.Windows.Forms.Control.DefaultForeColor%2A> miembros. Para ejecutar el ejemplo, pegue el código siguiente en un formulario que contenga un <xref:System.Windows.Forms.ListBox> denominado ListBox1. Llame a la `Populate_ListBox` método en el constructor del formulario o <xref:System.Windows.Forms.Form.Load> el método de control de eventos.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La fuente predeterminada o las fuentes alternativas regionales no están instaladas en el equipo cliente.</exception>
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="DefaultForeColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultForeColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Color DefaultForeColor { System::Drawing::Color get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultForeColor : System.Drawing.Color" Usage="System.Windows.Forms.Control.DefaultForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el color de primer plano predeterminado del control.</summary>
        <value>
          <see cref="T:System.Drawing.Color" /> predeterminado de primer plano del control. El valor predeterminado es <see cref="P:System.Drawing.SystemColors.ControlText" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este es el valor predeterminado <xref:System.Windows.Forms.Control.ForeColor%2A> valor de propiedad de un control principal. Las clases derivadas pueden tener distintos valores predeterminados.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A>, y <xref:System.Windows.Forms.Control.DefaultForeColor%2A> miembros. Para ejecutar el ejemplo, pegue el código siguiente en un formulario que contenga un <xref:System.Windows.Forms.ListBox> denominado ListBox1. Llame a la `Populate_ListBox` método en el constructor del formulario o <xref:System.Windows.Forms.Form.Load> el método de control de eventos.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ForeColor" />
        <altmember cref="T:System.Drawing.Color" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode DefaultImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultImeMode : System.Windows.Forms.ImeMode" Usage="System.Windows.Forms.Control.DefaultImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el modo de Editor de métodos de entrada (IME) predeterminado admitido por el control.</summary>
        <value>Uno de los valores de <see cref="T:System.Windows.Forms.ImeMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Editor de métodos de entrada (IME) es un programa que permite a los usuarios escribir caracteres y símbolos, como los caracteres Kanji del japonés, complejos mediante un teclado estándar.  
  
 Como se implementa en el <xref:System.Windows.Forms.Control> clase, esta propiedad siempre devuelve el <xref:System.Windows.Forms.ImeMode.Inherit?displayProperty=nameWithType> valor. El <xref:System.Windows.Forms.ImeMode.Inherit> valor especifica que se hereda el modo IME del control principal.  
  
   
  
## Examples  
 El siguiente código de ejemplo invalida el <xref:System.Windows.Forms.Control.DefaultImeMode%2A> propiedad que se va a desactivar el Editor de métodos de entrada.  
  
 [!code-cpp[Windows.Forms.Control Properties2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#4)]
 [!code-csharp[Windows.Forms.Control Properties2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#4)]
 [!code-vb[Windows.Forms.Control Properties2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.DefaultImeMode" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.DefaultImeMode" /> propiedad para extender la implementación base. En caso contrario, debe proporcionar toda la implementación.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMargin">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultMargin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMargin" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMargin As Padding" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Padding DefaultMargin { System::Windows::Forms::Padding get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMargin : System.Windows.Forms.Padding" Usage="System.Windows.Forms.Control.DefaultMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el espacio, en píxeles, que se especifica de manera predeterminada entre los controles.</summary>
        <value>
          <see cref="T:System.Windows.Forms.Padding" /> que representa el espacio predeterminado entre los controles.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMaximumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMaximumSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultMaximumSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultMaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la longitud y el alto, en píxeles, que se especifica como el tamaño máximo predeterminado de un control.</summary>
        <value>
          <see cref="M:System.Drawing.Point.#ctor(System.Drawing.Size)" /> que representa el tamaño del control.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMinimumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMinimumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMinimumSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultMinimumSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMinimumSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultMinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la longitud y el alto, en píxeles, que se especifica como el tamaño mínimo predeterminado de un control.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> que representa el tamaño del control.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPadding">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultPadding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultPadding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultPadding" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultPadding As Padding" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Padding DefaultPadding { System::Windows::Forms::Padding get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPadding : System.Windows.Forms.Padding" Usage="System.Windows.Forms.Control.DefaultPadding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el espaciado interno, en píxeles, del contenido de un control.</summary>
        <value>
          <see cref="T:System.Windows.Forms.Padding" /> que representa el espaciado interno del contenido de un control.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño predeterminado del control.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> predeterminado del control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.DefaultSize%2A> propiedad representa el <xref:System.Drawing.Size> del control cuando se crea inicialmente. Puede ajustar el tamaño del control estableciendo su <xref:System.Windows.Forms.Control.Size%2A> valor de propiedad.  
  
> [!NOTE]
>  Para mantener un rendimiento óptimo, no establezca la <xref:System.Drawing.Size> de un control en su constructor. El método preferido es invalidar el <xref:System.Windows.Forms.Control.DefaultSize%2A> propiedad.  
  
> [!NOTE]
>  En los sistemas Windows Server 2003, el tamaño de un <xref:System.Windows.Forms.Form> está restringido por el ancho de píxel máximo y el alto del monitor.  
  
   
  
## Examples  
 El siguiente código de ejemplo invalida el <xref:System.Windows.Forms.Control.DefaultSize%2A> propiedad y hace que el tamaño predeterminado de los píxeles del formulario 500 cuadrados.  
  
 [!code-cpp[Windows.Forms.Control Properties2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.DefaultSize" /> propiedad en una clase derivada, es preferible devolver un <see cref="T:System.Drawing.Size" /> con las dimensiones deseadas en lugar de reemplazar toda la implementación.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="T:System.Drawing.Size" />
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected virtual void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member DefWndProc :  -&gt; unit&#xA;override this.DefWndProc :  -&gt; unit" Usage="control.DefWndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">
          <see cref="T:System.Windows.Forms.Message" /> de Windows que se va a procesar.</param>
        <summary>Envía el mensaje especificado al procedimiento de ventana predeterminado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de cómo procesar mensajes de Windows, consulte el [función WindowProc](http://go.microsoft.com/fwlink/?LinkId=181565).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para que el llamador inmediato llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="DestroyHandle">
      <MemberSignature Language="C#" Value="protected virtual void DestroyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DestroyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DestroyHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DestroyHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DestroyHandle();" />
      <MemberSignature Language="F#" Value="abstract member DestroyHandle : unit -&gt; unit&#xA;override this.DestroyHandle : unit -&gt; unit" Usage="control.DestroyHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Destruye el identificador asociado a este control.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para que el llamador inmediato llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.DestroyHandle" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.DestroyHandle" /> método para asegurarse de que se destruye el identificador.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="DeviceDpi">
      <MemberSignature Language="C#" Value="public int DeviceDpi { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DeviceDpi" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DeviceDpi" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeviceDpi As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DeviceDpi { int get(); };" />
      <MemberSignature Language="F#" Value="member this.DeviceDpi : int" Usage="System.Windows.Forms.Control.DeviceDpi" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el valor de PPP de la pantalla donde se muestra actualmente el control.</summary>
        <value>El valor de PPP de la pantalla.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayRectangle">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Rectangle DisplayRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DisplayRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DisplayRectangle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DisplayRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Rectangle DisplayRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.Control.DisplayRectangle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.Layout.IArrangedElement.DisplayRectangle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el rectángulo que representa el área de presentación del control.</summary>
        <value>
          <see cref="T:System.Drawing.Rectangle" /> que representa el área de visualización del control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.DisplayRectangle%2A> propiedad devuelve el rectángulo cliente del área de presentación del control. Para la clase base control, esto es igual al rectángulo cliente. Sin embargo, los controles heredados es posible que desee cambiar esto si difiere de su área cliente de su área de presentación. El rectángulo de presentación es el más pequeño <xref:System.Drawing.Rectangle> que rodea un control y se utiliza para diseñar controles.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.DisplayRectangle" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.DisplayRectangle" /> propiedad para extender la implementación base. Como alternativa, debe proporcionar toda la implementación.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="control.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usan <see cref="T:System.Windows.Forms.Control" /> y sus controles secundarios, además de liberar los recursos administrados de forma opcional.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama por el público `Dispose()` método y el <xref:System.Object.Finalize%2A> método.`Dispose()` invoca el protegido `Dispose(Boolean)` método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` con `disposing` establecido en `false`.  
  
 Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.Windows.Forms.Control> hace referencia. Este método invoca al método `Dispose()` de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> puede llamarse varias veces por otros objetos. Cuando se reemplaza <see langword="Dispose(Boolean)" /> tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />. Para obtener más información sobre cómo implementar <see langword="Dispose(Boolean)" />, consulte [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  Para obtener más información acerca de <see langword="Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [reemplazar el método Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Disposing">
      <MemberSignature Language="C#" Value="public bool Disposing { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Disposing" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Disposing" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Disposing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Disposing { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Disposing : bool" Usage="System.Windows.Forms.Control.Disposing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la clase base <see cref="T:System.Windows.Forms.Control" /> está en el proceso de eliminación.</summary>
        <value>Es <see langword="true" /> si la clase base <see cref="T:System.Windows.Forms.Control" /> está en el proceso de eliminación; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando esta propiedad devuelve `true`, la base de <xref:System.Windows.Forms.Control> clase está en proceso de eliminación. Después de eliminar el control, ya no pueden hacer referencia como un control de Windows válido. Aunque se elimine la instancia de un control de, todavía se mantiene en memoria hasta que se quita de la memoria a través de la recolección de elementos. Cuando se elimina un control, no puede llamar a su <xref:System.Windows.Forms.Control.RecreateHandle%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
        <altmember cref="T:System.GC" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="Dock">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.DockStyle Dock { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DockStyle Dock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Dock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Dock As DockStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::DockStyle Dock { System::Windows::Forms::DockStyle get(); void set(System::Windows::Forms::DockStyle value); };" />
      <MemberSignature Language="F#" Value="member this.Dock : System.Windows.Forms.DockStyle with get, set" Usage="System.Windows.Forms.Control.Dock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DockStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece que los bordes del control se acoplarán a su control primario y determina cómo se cambia el tamaño de un control con su elemento primario.</summary>
        <value>Uno de los valores de <see cref="T:System.Windows.Forms.DockStyle" />. El valor predeterminado es <see cref="F:System.Windows.Forms.DockStyle.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Windows.Forms.Control.Dock%2A> propiedad para definir cómo se cambia automáticamente el tamaño de un control cuando se cambia el tamaño de su control primario. Por ejemplo, si se establece <xref:System.Windows.Forms.Control.Dock%2A> a <xref:System.Windows.Forms.DockStyle.Left?displayProperty=nameWithType> hace que el control para alinearse con los bordes izquierdos de su control primario y cambia de tamaño cuando se cambia el tamaño del control primario. Los controles se acoplan en su orden Z, que es el diseño visual de los controles en un formulario a lo largo del eje z del formulario (profundidad).  
  
 Un control se puede acoplar a uno de los bordes de su contenedor primario o se puede acoplar a todos los bordes y rellene el contenedor primario.  
  
 Establecer el <xref:System.Windows.Forms.Control.Margin%2A> propiedad en un control acoplado no tiene ningún efecto en la distancia del control de los bordes de su contenedor.  
  
> [!NOTE]
>  El <xref:System.Windows.Forms.Control.Anchor%2A> y <xref:System.Windows.Forms.Control.Dock%2A> propiedades son mutuamente excluyentes. Solo una puede establecerse en un momento, y el último conjunto tiene prioridad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Windows.Forms.GroupBox> y se establecen algunas de sus propiedades comunes. El ejemplo se crea un <xref:System.Windows.Forms.TextBox> y establece su <xref:System.Windows.Forms.Control.Location%2A> dentro del cuadro de grupo. A continuación, Establece la <xref:System.Windows.Forms.Control.Text%2A> propiedad del cuadro de grupo y lo acopla el grupo de cuadro a la parte superior del formulario. Por último, deshabilita el cuadro de grupo estableciendo el <xref:System.Windows.Forms.Control.Enabled%2A> propiedad `false`, lo que hace que todos los controles contenidos en el cuadro de grupo va a deshabilitar.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El valor asignado no es uno de los valores de <see cref="T:System.Windows.Forms.DockStyle" />.</exception>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.Dock" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.Dock" /> propiedad para extender la implementación base. En caso contrario, debe proporcionar toda la implementación. No es necesario reemplazar ambos el <see langword="get" /> y <see langword="set" /> métodos de la <see cref="P:System.Windows.Forms.Control.Dock" /> propiedad; se puede reemplazar sólo uno, si es necesario.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.DockStyle" />
        <altmember cref="P:System.Windows.Forms.Control.Anchor" />
        <altmember cref="T:System.Windows.Forms.ScrollableControl.DockPaddingEdges" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="DockChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DockChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DockChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DockChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DockChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DockChanged;" />
      <MemberSignature Language="F#" Value="member this.DockChanged : EventHandler " Usage="member this.DockChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.Dock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.Dock%2A> propiedad se modifica mediante programación o interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente es un controlador de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre *PropertyName* `Changed` que se genera cuando correspondiente *PropertyName* cambia el valor (* PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> que contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="T:System.Windows.Forms.DockStyle" />
      </Docs>
    </Member>
    <Member MemberName="DoDragDrop">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DragDropEffects DoDragDrop (object data, System.Windows.Forms.DragDropEffects allowedEffects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DragDropEffects DoDragDrop(object data, valuetype System.Windows.Forms.DragDropEffects allowedEffects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      <MemberSignature Language="VB.NET" Value="Public Function DoDragDrop (data As Object, allowedEffects As DragDropEffects) As DragDropEffects" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DragDropEffects DoDragDrop(System::Object ^ data, System::Windows::Forms::DragDropEffects allowedEffects);" />
      <MemberSignature Language="F#" Value="member this.DoDragDrop : obj * System.Windows.Forms.DragDropEffects -&gt; System.Windows.Forms.DragDropEffects" Usage="control.DoDragDrop (data, allowedEffects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragDropEffects</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="allowedEffects" Type="System.Windows.Forms.DragDropEffects" />
      </Parameters>
      <Docs>
        <param name="data">Datos que se van a arrastrar.</param>
        <param name="allowedEffects">Uno de los valores de <see cref="T:System.Windows.Forms.DragDropEffects" />.</param>
        <summary>Inicia una operación de arrastrar y colocar.</summary>
        <returns>Valor de la enumeración <see cref="T:System.Windows.Forms.DragDropEffects" /> que representa el efecto final obtenido durante la operación de arrastrar y colocar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `allowedEffects` parámetro determina qué pueden realizar operaciones de arrastre. Si la operación de arrastrar debe interoperar con aplicaciones en otro proceso, datos deben ser una clase base administrada (<xref:System.String>, <xref:System.Drawing.Bitmap>, o <xref:System.Drawing.Imaging.Metafile>), o un objeto que implementa <xref:System.Runtime.Serialization.ISerializable> o <xref:System.Windows.Forms.IDataObject>.  
  
 A continuación, se describe cómo y cuándo se generan eventos relacionados con operaciones de arrastrar y colocar.  
  
 El <xref:System.Windows.Forms.Control.DoDragDrop%2A> método determina el control en la ubicación actual del cursor. A continuación, comprueba si el control es un destino de colocación válido.  
  
 Si el control es un destino válido, el <xref:System.Windows.Forms.Control.GiveFeedback> se provoca el evento con el efecto de arrastrar y colocar especificado. Para obtener una lista de efectos de arrastrar y colocar, vea la enumeración <xref:System.Windows.Forms.DragDropEffects>.  
  
 Se realiza el seguimiento de la posición del cursor del mouse, del estado del teclado y del estado de los botones del mouse.  
  
-   Si el usuario desplaza el mouse fuera de una ventana, se genera el evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Si el mouse entra en otro control, se genera el evento <xref:System.Windows.Forms.Control.DragEnter> para ese control.  
  
-   Si se mueve el mouse dentro del mismo control, se genera el evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Si hay un cambio en el estado del botón teclado o mouse, el <xref:System.Windows.Forms.Control.QueryContinueDrag> se provoca el evento y determina si debe continuar la operación de arrastrar, colocar los datos, o cancelar la operación en función del valor de la <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> propiedad del evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Continue`, <xref:System.Windows.Forms.Control.DragOver> evento se provoca para continuar con la operación y el <xref:System.Windows.Forms.Control.GiveFeedback> evento se genera con el nuevo efecto, por lo que se puede establecer la información visual apropiada. Para obtener una lista de efectos de colocar válidos, vea la enumeración <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  El <xref:System.Windows.Forms.Control.DragOver> y <xref:System.Windows.Forms.Control.GiveFeedback> eventos están emparejados de forma que cuando el mouse se desplace por el destino de colocación, el usuario reciba la información más actualizada sobre la posición del mouse.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Drop`, el valor del efecto de colocar se devuelve al origen, para que la aplicación de origen pueda realizar la operación apropiada en los datos de origen; por ejemplo, cortar los datos si la operación es un movimiento.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Cancel`, el <xref:System.Windows.Forms.Control.DragLeave> provoca el evento.  
  
> [!NOTE]
>  El <xref:System.Windows.Forms.Control.DoDragDrop%2A> detecta todas las excepciones de método y vuelve a iniciar solo la siguiente seguridad o las excepciones críticas:  
  
-   SecurityException  
  
-   NullReferenceException  
  
-   StackOverflowException  
  
-   OutOfMemoryException  
  
-   ThreadAbortException  
  
-   ExecutionEngineException  
  
-   IndexOutOfRangeException  
  
-   AccessViolationException  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra una operación de arrastrar y colocar entre dos <xref:System.Windows.Forms.ListBox> controles. El ejemplo llama a la <xref:System.Windows.Forms.Control.DoDragDrop%2A> método cuando se inicia la acción de arrastrar. La acción de arrastrar se inicia si se ha movido el mouse más de <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> desde la ubicación del mouse durante el <xref:System.Windows.Forms.Control.MouseDown> eventos. El <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> método se utiliza para determinar el índice del elemento que se va a arrastrar durante el `MouseDown` eventos.  
  
 El ejemplo también muestra cómo utilizar cursores personalizados para la operación de arrastrar y colocar. El ejemplo requiere que dos archivos de cursor `3dwarro.cur` y `3dwno.cur`, existe en el directorio de aplicación para la operación de arrastre personalizado y no colocar cursores, respectivamente. Los cursores personalizados que se usará si el `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> está activada. Los cursores personalizados se establecen el <xref:System.Windows.Forms.Control.GiveFeedback> controlador de eventos.  
  
 El estado del teclado se evalúa en el <xref:System.Windows.Forms.Control.DragOver> controlador de eventos para el derecho `ListBox`, para determinar cuál será la operación de arrastre según el estado de las teclas MAYÚS, CTRL, ALT o CTRL + ALT. La ubicación en la `ListBox` donde se produciría la operación de colocar también se determina durante el `DragOver` eventos. Si los datos que se va a quitar no están un `String`, el <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> está establecido en `None` en <xref:System.Windows.Forms.DragDropEffects>. Por último, se muestra el estado de la operación de colocar en el `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 Los datos que se va a quitar de la derecha `ListBox` viene determinada en el <xref:System.Windows.Forms.Control.DragDrop> controlador de eventos y el `String` valor se agrega en el lugar adecuado en el `ListBox`. Si la operación de arrastre sobrepasa los límites del formulario y, después, se cancela la operación de arrastrar y colocar en el <xref:System.Windows.Forms.Control.QueryContinueDrag> controlador de eventos.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#1)]  
  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Windows.Forms.DragDropEffects> enumeración para especificar cómo se deben transferir los datos entre los controles implicados en una operación de arrastrar y colocar. Este ejemplo requiere que el formulario incluye un <xref:System.Windows.Forms.RichTextBox> control y un <xref:System.Windows.Forms.ListBox> control y que el <xref:System.Windows.Forms.ListBox> control se rellena con una lista de nombres de archivo válidos. Cuando el usuario arrastra un nombre de archivo en el <xref:System.Windows.Forms.RichTextBox> (control), el control <xref:System.Windows.Forms.Control.DragEnter> provoca el evento. En el controlador de eventos, el <xref:System.Windows.Forms.DragEventArgs.Effect%2A> propiedad de la <xref:System.Windows.Forms.DragEventArgs> se inicializa en <xref:System.Windows.Forms.DragDropEffects> para indicar que se deben copiar los datos al que hace referencia la ruta de acceso a la <xref:System.Windows.Forms.RichTextBox> control.  
  
 [!code-cpp[RichTextDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextDragDrop/CS/form1.cs#1)]
 [!code-vb[RichTextDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextDragDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AllowDrop" />
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
      </Docs>
    </Member>
    <Member MemberName="DoubleBuffered">
      <MemberSignature Language="C#" Value="protected virtual bool DoubleBuffered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DoubleBuffered" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DoubleBuffered" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property DoubleBuffered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool DoubleBuffered { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DoubleBuffered : bool with get, set" Usage="System.Windows.Forms.Control.DoubleBuffered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si este control debe volver a dibujar su superficie mediante un búfer secundario para reducir o evitar el parpadeo.</summary>
        <value>
          <see langword="true" /> si la superficie del control debe dibujarse utilizando el búfer doble; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gráficos almacenados en búfer pueden reducir o eliminar el parpadeo que se produce al volver a dibujar progresiva de partes de una superficie mostrada. Gráficos almacenados en búfer requieren que los datos de gráficos actualizados se escriben primero en un búfer. Los datos en el búfer de gráficos, a continuación, se escriben rápidamente en memoria de la superficie mostrada. El modificador relativamente rápido de la memoria de gráficos mostrados suele reduce el parpadeo que puede producirse en caso contrario.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.DoubleBuffered%2A> no es una propiedad enlazable.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.BufferedGraphics" />
        <altmember cref="T:System.Drawing.BufferedGraphicsContext" />
        <altmember cref="T:System.Drawing.BufferedGraphicsManager" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer" />
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event EventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DoubleClick;" />
      <MemberSignature Language="F#" Value="member this.DoubleClick : EventHandler " Usage="member this.DoubleClick : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se hace doble clic en el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un doble clic viene determinada por la configuración del mouse del sistema operativo del usuario. El usuario puede establecer el tiempo entre los clics de un botón del mouse que debe considerarse como un doble clic y no como dos clics. El <xref:System.Windows.Forms.Control.Click> evento se desencadena cada vez que se hace doble clic en un control. Por ejemplo, si tiene controladores de eventos para el <xref:System.Windows.Forms.Control.Click> y <xref:System.Windows.Forms.Control.DoubleClick> eventos de un <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Control.Click> y <xref:System.Windows.Forms.Control.DoubleClick> se generan eventos cuando se hace doble clic en el formulario y se llama a ambos métodos. Si se hace doble clic en un control y que el control no admite la <xref:System.Windows.Forms.Control.DoubleClick> eventos, el <xref:System.Windows.Forms.Control.Click> evento podría generarse dos veces.  
  
 Debe establecer el `StandardDoubleClick` y `StandardClick` valores de <xref:System.Windows.Forms.ControlStyles> a `true` para que se genere este evento. Ya se pueden establecer estos valores en `true` si se hereda de existente controles Windows Forms.  
  
> [!NOTE]
>  Los siguientes eventos no se generan para el <xref:System.Windows.Forms.TabControl> a menos que haya al menos una de las clases <xref:System.Windows.Forms.TabPage> en el <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> colección: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> y <xref:System.Windows.Forms.Control.MouseMove>. Si hay al menos un <xref:System.Windows.Forms.TabPage> en la colección, y el usuario interactúa con el encabezado del control de ficha (donde el <xref:System.Windows.Forms.TabPage> aparecen nombres), el <xref:System.Windows.Forms.TabControl> provoca el evento adecuado. Sin embargo, si la interacción del usuario está dentro del área de cliente de la página de ficha, el <xref:System.Windows.Forms.TabPage> provoca el evento adecuado.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.DoubleClick> eventos de un <xref:System.Windows.Forms.ListBox> para cargar los archivos de texto que aparece en el <xref:System.Windows.Forms.ListBox> en un <xref:System.Windows.Forms.TextBox> control.  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Heredar de un control de Windows Forms estándar y cambiar el <see langword="StandardClick" /> o <see langword="StandardDoubleClick" /> valores de <see cref="T:System.Windows.Forms.ControlStyles" /> a <see langword="true" /> puede provocar un comportamiento inesperado o no tienen ningún efecto en absoluto si el control no admite el <see cref="E:System.Windows.Forms.Control.Click" /> o <see cref="E:System.Windows.Forms.Control.DoubleClick" />eventos.  En la tabla siguiente se enumera los controles de formularios Windows Forms y qué evento (<see cref="E:System.Windows.Forms.Control.Click" /> o <see cref="E:System.Windows.Forms.Control.DoubleClick" />) se produce en respuesta a la acción del mouse especificada.  <list type="table"><listheader><term> Control </term><description> deja el clic del Mouse </description><description> haga doble clic en el primario del Mouse </description><description> clic del Mouse a la derecha </description><description> secundario del Mouse haga doble clic en </description><description> Clic del Mouse en el medio </description><description> central del Mouse haga doble clic en </description><description> XButton1 del Mouse Click </description><description> XButton1 del Mouse haga doble clic en </description><description> XButton2 Haga clic en el mouse </description><description> XButton2 del Mouse haga doble clic en </description></listheader><item><term><see cref="T:System.Windows.Forms.MonthCalendar" />, <see cref="T:System.Windows.Forms.DateTimePicker" />, <see cref="T:System.Windows.Forms.RichTextBox" />, <see cref="T:System.Windows.Forms.HScrollBar" />, <see cref="T:System.Windows.Forms.VScrollBar" /></term><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description>ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description></item><item><term><see cref="T:System.Windows.Forms.Button" />, <see cref="T:System.Windows.Forms.CheckBox" />, <see cref="T:System.Windows.Forms.RadioButton" /></term><description> Haga clic en </description><description> , haga clic en </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description></item><item><term><see cref="T:System.Windows.Forms.ListBox" />, <see cref="T:System.Windows.Forms.CheckedListBox" />, <see cref="T:System.Windows.Forms.ComboBox" /></term><description> Haga clic en </description><description> Click, DoubleClick </description><description> ninguno </description><description> ninguno </description><description> ninguno  </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno </description><description> ninguno  </description></item><item><term><see cref="T:System.Windows.Forms.TextBox" />, <see cref="T:System.Windows.Forms.DomainUpDown" />, <see cref="T:System.Windows.Forms.NumericUpDown" /></term><description> Haga clic en </description><description>  Haga clic en DoubleClick </description><description> ninguno </description><description> ninguno</description><description> none  </description><description> none  </description><description> none  </description><description> none  </description><description> none  </description><description> none  </description></item><item><term> * <see cref="T:System.Windows.Forms.TreeView" />,  \* <see cref="T:System.Windows.Forms.ListView" /></term><description> Click  </description><description> Click, DoubleClick  </description><description> Click  </description><description> Click, DoubleClick  </description><description> none  </description><description> none  </description><description> none  </description><description> none  </description><description> none  </description><description> none  </description></item><item><term><see cref="T:System.Windows.Forms.ProgressBar" />,  <see cref="T:System.Windows.Forms.TrackBar" /></term><description> Click  </description><description> Click, Click  </description><description> Click  </description><description> Click, Click  </description><description> Click  </description><description> Click, Click  </description><description> Click  </description><description> Click, Click  </description><description> Click  </description><description> Click, Click  </description></item><item><term><see cref="T:System.Windows.Forms.Form" />,  <see cref="T:System.Windows.Forms.DataGrid" />,  <see cref="T:System.Windows.Forms.Label" />,  <see cref="T:System.Windows.Forms.LinkLabel" />,  <see cref="T:System.Windows.Forms.Panel" />,  <see cref="T:System.Windows.Forms.GroupBox" />,  <see cref="T:System.Windows.Forms.PictureBox" />,  <see cref="T:System.Windows.Forms.Splitter" />,  <see cref="T:System.Windows.Forms.StatusBar" />,  <see cref="T:System.Windows.Forms.ToolBar" />,  <see cref="T:System.Windows.Forms.TabPage" />,  ** <see cref="T:System.Windows.Forms.TabControl" /></term><description> Click  </description><description> Click, DoubleClick  </description><description> Click  </description><description> Click, DoubleClick  </description><description> Click  </description><description> Click, DoubleClick  </description><description> Click  </description><description> Click, DoubleClick  </description><description> Click  </description><description> Click, DoubleClick  </description></item></list>  \* The mouse pointer must be over a child object (<see cref="T:System.Windows.Forms.TreeNode" /> or <see cref="T:System.Windows.Forms.ListViewItem" />).  ** The <see cref="T:System.Windows.Forms.TabControl" /> must have at least one <see cref="T:System.Windows.Forms.TabPage" /> in its <see cref="P:System.Windows.Forms.TabControl.TabPages" /> collection.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardClick" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardDoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="DpiChangedAfterParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedAfterParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedAfterParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedAfterParent" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChangedAfterParent As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DpiChangedAfterParent;" />
      <MemberSignature Language="F#" Value="member this.DpiChangedAfterParent : EventHandler " Usage="member this.DpiChangedAfterParent : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce al cambiar la configuración de PPP para un control mediante programación antes de cambiar el valor de PPP de su control o formulario principal.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedBeforeParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedBeforeParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedBeforeParent" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChangedBeforeParent As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DpiChangedBeforeParent;" />
      <MemberSignature Language="F#" Value="member this.DpiChangedBeforeParent : EventHandler " Usage="member this.DpiChangedBeforeParent : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce al cambiar la configuración de PPP para un control mediante programación antes de tener lugar un evento de cambio de PPP para su control o formulario principal.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragDrop;" />
      <MemberSignature Language="F#" Value="member this.DragDrop : System.Windows.Forms.DragEventHandler " Usage="member this.DragDrop : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se completa una operación de arrastrar y colocar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.DragEventArgs.X%2A> y <xref:System.Windows.Forms.DragEventArgs.Y%2A> propiedades de la <xref:System.Windows.Forms.DragEventArgs> están en coordenadas de pantalla, no las coordenadas de cliente. La siguiente línea de código de Visual C# convierte las propiedades en un cliente <xref:System.Drawing.Point>.  
  
```  
Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
```  
  
> [!NOTE]
>  En versiones anteriores a [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], si coloca un <xref:System.Windows.Forms.UserControl> con <xref:System.Windows.Forms.Control.DragEnter> y <xref:System.Windows.Forms.Control.DragDrop> eventos en un formulario de Windows y arrastrar y colocar algo en el <xref:System.Windows.Forms.UserControl> en tiempo de diseño, el `DropDrop` y `DropEnter` son eventos se genera. Sin embargo, cuando cierre y vuelva a abrir la solución, el <xref:System.Windows.Forms.Control.DragEnter> y <xref:System.Windows.Forms.Control.DragDrop> eventos no se vuelve a generar.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Este fragmento de código muestra cómo utilizar el <xref:System.Windows.Forms.Control.DragDrop> eventos. Consulte la <xref:System.Windows.Forms.Control.DoDragDrop%2A> método para el ejemplo de código completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#5)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#5)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
        <altmember cref="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
        <altmember cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.Forms.DragEventHandler " Usage="member this.DragEnter : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se arrastra un objeto dentro de los límites del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.DragEnter> evento se produce cuando el usuario arrastra primero el cursor del mouse sobre el control durante una operación de arrastrar y colocar.  
  
> [!NOTE]
>  En versiones anteriores a [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], si coloca un <xref:System.Windows.Forms.UserControl> con <xref:System.Windows.Forms.Control.DragEnter> y <xref:System.Windows.Forms.Control.DragDrop> eventos en un formulario de Windows y arrastrar y colocar algo en el <xref:System.Windows.Forms.UserControl> en tiempo de diseño, el `DropDrop` y `DropEnter` son eventos se genera. Sin embargo, cuando cierre y vuelva a abrir la solución, el <xref:System.Windows.Forms.Control.DragEnter> y <xref:System.Windows.Forms.Control.DragDrop> eventos no se vuelve a generar.  
  
 A continuación, se describe cómo y cuándo se generan eventos relacionados con operaciones de arrastrar y colocar.  
  
 El <xref:System.Windows.Forms.Control.DoDragDrop%2A> método determina el control en la ubicación actual del cursor. A continuación, comprueba si el control es un destino de colocación válido.  
  
 Si el control es un destino válido, el <xref:System.Windows.Forms.Control.GiveFeedback> se provoca el evento con el efecto de arrastrar y colocar especificado. Para obtener una lista de efectos de arrastrar y colocar, vea la enumeración <xref:System.Windows.Forms.DragDropEffects>.  
  
 Se realiza el seguimiento de la posición del cursor del mouse, del estado del teclado y del estado de los botones del mouse.  
  
-   Si el usuario desplaza el mouse fuera de una ventana, se genera el evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Si el mouse entra en otro control, se genera el evento <xref:System.Windows.Forms.Control.DragEnter> para ese control.  
  
-   Si se mueve el mouse dentro del mismo control, se genera el evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Si hay un cambio en el estado del botón teclado o mouse, el <xref:System.Windows.Forms.Control.QueryContinueDrag> se provoca el evento y determina si debe continuar la operación de arrastrar, colocar los datos, o cancelar la operación en función del valor de la <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> propiedad del evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Continue`, <xref:System.Windows.Forms.Control.DragOver> evento se provoca para continuar con la operación y el <xref:System.Windows.Forms.Control.GiveFeedback> evento se genera con el nuevo efecto, por lo que se puede establecer la información visual apropiada. Para obtener una lista de efectos de colocar válidos, vea la enumeración <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  El <xref:System.Windows.Forms.Control.DragOver> y <xref:System.Windows.Forms.Control.GiveFeedback> eventos están emparejados de forma que cuando el mouse se desplace por el destino de colocación, el usuario reciba la información más actualizada sobre la posición del mouse.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Drop`, el valor del efecto de colocar se devuelve al origen, para que la aplicación de origen pueda realizar la operación apropiada en los datos de origen; por ejemplo, cortar los datos si la operación es un movimiento.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Cancel`, el <xref:System.Windows.Forms.Control.DragLeave> provoca el evento.  
  
    > [!NOTE]
    >  El <xref:System.Windows.Forms.DragEventArgs.X%2A> y <xref:System.Windows.Forms.DragEventArgs.Y%2A> propiedades de la <xref:System.Windows.Forms.DragEventArgs> están en coordenadas de pantalla, no las coordenadas de cliente. La siguiente línea de código de Visual C# convierte las propiedades en un cliente <xref:System.Drawing.Point>.  
  
    ```  
    Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
    ```  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra una operación de arrastrar y colocar entre dos <xref:System.Windows.Forms.ListBox> controles. El ejemplo llama a la <xref:System.Windows.Forms.Control.DoDragDrop%2A> método cuando se inicia la acción de arrastrar. La acción de arrastrar se inicia si se ha movido el mouse más de <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> desde la ubicación del mouse durante el <xref:System.Windows.Forms.Control.MouseDown> eventos. El <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> método se utiliza para determinar el índice del elemento que se va a arrastrar durante el `MouseDown` eventos.  
  
 El ejemplo también muestra cómo utilizar cursores personalizados para la operación de arrastrar y colocar. El ejemplo requiere que dos archivos de cursor `3dwarro.cur` y `3dwno.cur`, existe en el directorio de aplicación para la operación de arrastre personalizado y no colocar cursores, respectivamente. Los cursores personalizados que se usará si el `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> está activada. Los cursores personalizados se establecen el <xref:System.Windows.Forms.Control.GiveFeedback> controlador de eventos.  
  
 El estado del teclado se evalúa en el <xref:System.Windows.Forms.Control.DragOver> controlador de eventos para el derecho `ListBox`, para determinar cuál será la operación de arrastre según el estado de las teclas MAYÚS, CTRL, ALT o CTRL + ALT. La ubicación en la `ListBox` donde se produciría la operación de colocar también se determina durante el `DragOver` eventos. Si los datos que se va a quitar no están un `String`, el <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> está establecido en `None` en <xref:System.Windows.Forms.DragDropEffects>. Por último, se muestra el estado de la operación de colocar en el `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 Los datos que se va a quitar de la derecha `ListBox` viene determinada en el <xref:System.Windows.Forms.Control.DragDrop> controlador de eventos y el `String` valor se agrega en el lugar adecuado en el `ListBox`. Si la operación de arrastre sobrepasa los límites del formulario y, después, se cancela la operación de arrastrar y colocar en el <xref:System.Windows.Forms.Control.QueryContinueDrag> controlador de eventos.  
  
 Este fragmento de código muestra cómo utilizar el <xref:System.Windows.Forms.Control.DragEnter> eventos. Consulte la <xref:System.Windows.Forms.Control.DoDragDrop%2A> método para el ejemplo de código completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : EventHandler " Usage="member this.DragLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se arrastra un objeto fuera de los límites del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.DragLeave> evento se produce cuando el usuario arrastra el cursor fuera del control o el usuario cancela la operación de arrastrar y colocar actual.  
  
 A continuación, se describe cómo y cuándo se generan eventos relacionados con operaciones de arrastrar y colocar.  
  
 El <xref:System.Windows.Forms.Control.DoDragDrop%2A> método determina el control en la ubicación actual del cursor. A continuación, comprueba si el control es un destino de colocación válido.  
  
 Si el control es un destino válido, el <xref:System.Windows.Forms.Control.GiveFeedback> se provoca el evento con el efecto de arrastrar y colocar especificado. Para obtener una lista de efectos de arrastrar y colocar, vea la enumeración <xref:System.Windows.Forms.DragDropEffects>.  
  
 Se realiza el seguimiento de la posición del cursor del mouse, del estado del teclado y del estado de los botones del mouse.  
  
-   Si el usuario desplaza el mouse fuera de una ventana, se genera el evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Si el mouse entra en otro control, se genera el evento <xref:System.Windows.Forms.Control.DragEnter> para ese control.  
  
-   Si se mueve el mouse dentro del mismo control, se genera el evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Si hay un cambio en el estado del botón teclado o mouse, el <xref:System.Windows.Forms.Control.QueryContinueDrag> se provoca el evento y determina si debe continuar la operación de arrastrar, colocar los datos, o cancelar la operación en función del valor de la <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> propiedad del evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Continue`, <xref:System.Windows.Forms.Control.DragOver> evento se provoca para continuar con la operación y el <xref:System.Windows.Forms.Control.GiveFeedback> evento se genera con el nuevo efecto, por lo que se puede establecer la información visual apropiada. Para obtener una lista de efectos de colocar válidos, vea la enumeración <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  El <xref:System.Windows.Forms.Control.DragOver> y <xref:System.Windows.Forms.Control.GiveFeedback> eventos están emparejados de forma que cuando el mouse se desplace por el destino de colocación, el usuario reciba la información más actualizada sobre la posición del mouse.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Drop`, el valor del efecto de colocar se devuelve al origen, para que la aplicación de origen pueda realizar la operación apropiada en los datos de origen; por ejemplo, cortar los datos si la operación es un movimiento.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Cancel`, el <xref:System.Windows.Forms.Control.DragLeave> provoca el evento.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra una operación de arrastrar y colocar entre dos <xref:System.Windows.Forms.ListBox> controles. El ejemplo llama a la <xref:System.Windows.Forms.Control.DoDragDrop%2A> método cuando se inicia la acción de arrastrar. La acción de arrastrar se inicia si se ha movido el mouse más de <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> desde la ubicación del mouse durante el <xref:System.Windows.Forms.Control.MouseDown> eventos. El <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> método se utiliza para determinar el índice del elemento que se va a arrastrar durante el `MouseDown` eventos.  
  
 El ejemplo también muestra cómo utilizar cursores personalizados para la operación de arrastrar y colocar. El ejemplo requiere que dos archivos de cursor `3dwarro.cur` y `3dwno.cur`, existe en el directorio de aplicación para la operación de arrastre personalizado y no colocar cursores, respectivamente. Los cursores personalizados que se usará si el `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> está activada. Los cursores personalizados se establecen el <xref:System.Windows.Forms.Control.GiveFeedback> controlador de eventos.  
  
 El estado del teclado se evalúa en el <xref:System.Windows.Forms.Control.DragOver> controlador de eventos para el derecho `ListBox`, para determinar cuál será la operación de arrastre según el estado de las teclas MAYÚS, CTRL, ALT o CTRL + ALT. La ubicación en la `ListBox` donde se produciría la operación de colocar también se determina durante el `DragOver` eventos. Si los datos que se va a quitar no están un `String`, el <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> está establecido en `None` en <xref:System.Windows.Forms.DragDropEffects>. Por último, se muestra el estado de la operación de colocar en el `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 Los datos que se va a quitar de la derecha `ListBox` viene determinada en el <xref:System.Windows.Forms.Control.DragDrop> controlador de eventos y el `String` valor se agrega en el lugar adecuado en el `ListBox`. Si la operación de arrastre sobrepasa los límites del formulario y, después, se cancela la operación de arrastrar y colocar en el <xref:System.Windows.Forms.Control.QueryContinueDrag> controlador de eventos.  
  
 Este fragmento de código muestra cómo utilizar el <xref:System.Windows.Forms.Control.DragLeave> eventos. Consulte la <xref:System.Windows.Forms.Control.DoDragDrop%2A> método para el ejemplo de código completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#8)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.DragEventHandler " Usage="member this.DragOver : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se arrastra un objeto sobre los límites del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.DragOver> evento se produce cuando el cursor del mouse se mueve dentro de los límites del control durante una operación de arrastrar y colocar.  
  
 A continuación, se describe cómo y cuándo se generan eventos relacionados con operaciones de arrastrar y colocar.  
  
 El <xref:System.Windows.Forms.Control.DoDragDrop%2A> método determina el control en la ubicación actual del cursor. A continuación, comprueba si el control es un destino de colocación válido.  
  
 Si el control es un destino válido, el <xref:System.Windows.Forms.Control.GiveFeedback> se provoca el evento con el efecto de arrastrar y colocar especificado. Para obtener una lista de efectos de arrastrar y colocar, vea la enumeración <xref:System.Windows.Forms.DragDropEffects>.  
  
 Se realiza el seguimiento de la posición del cursor del mouse, del estado del teclado y del estado de los botones del mouse.  
  
-   Si el usuario desplaza el mouse fuera de una ventana, se genera el evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Si el mouse entra en otro control, se genera el evento <xref:System.Windows.Forms.Control.DragEnter> para ese control.  
  
-   Si se mueve el mouse dentro del mismo control, se genera el evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Si hay un cambio en el estado del botón teclado o mouse, el <xref:System.Windows.Forms.Control.QueryContinueDrag> se provoca el evento y determina si debe continuar la operación de arrastrar, colocar los datos, o cancelar la operación en función del valor de la <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> propiedad del evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> valor es `Continue`, <xref:System.Windows.Forms.Control.DragOver> evento se provoca para continuar con la operación y el <xref:System.Windows.Forms.Control.GiveFeedback> evento se genera con el nuevo efecto, por lo que se puede establecer la información visual apropiada. Para obtener una lista de efectos de colocar válidos, vea la enumeración <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  El <xref:System.Windows.Forms.Control.DragOver> y <xref:System.Windows.Forms.Control.GiveFeedback> eventos están emparejados de forma que cuando el mouse se desplace por el destino de colocación, el usuario reciba la información más actualizada sobre la posición del mouse.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Drop`, el valor del efecto de colocar se devuelve al origen, para que la aplicación de origen pueda realizar la operación apropiada en los datos de origen; por ejemplo, cortar los datos si la operación es un movimiento.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Cancel`, el <xref:System.Windows.Forms.Control.DragLeave> provoca el evento.  
  
    > [!NOTE]
    >  El <xref:System.Windows.Forms.DragEventArgs.X%2A> y <xref:System.Windows.Forms.DragEventArgs.Y%2A> propiedades de la <xref:System.Windows.Forms.DragEventArgs> están en coordenadas de pantalla, no las coordenadas de cliente. La siguiente línea de código de C# convierte las propiedades en un cliente <xref:System.Drawing.Point>:  
    >   
    >  Punto clientPoint = targetControl.PointToClient (nuevo punto (de. X, de. Y));  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra una operación de arrastrar y colocar entre dos <xref:System.Windows.Forms.ListBox> controles. El ejemplo llama a la <xref:System.Windows.Forms.Control.DoDragDrop%2A> método cuando se inicia la acción de arrastrar. La acción de arrastrar se inicia si se ha movido el mouse más de <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> desde la ubicación del mouse durante el <xref:System.Windows.Forms.Control.MouseDown> eventos. El <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> método se utiliza para determinar el índice del elemento que se va a arrastrar durante el `MouseDown` eventos.  
  
 El ejemplo también muestra cómo utilizar cursores personalizados para la operación de arrastrar y colocar. El ejemplo requiere que dos archivos de cursor `3dwarro.cur` y `3dwno.cur`, existe en el directorio de aplicación para la operación de arrastre personalizado y no colocar cursores, respectivamente. Los cursores personalizados que se usará si el `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> está activada. Los cursores personalizados se establecen el <xref:System.Windows.Forms.Control.GiveFeedback> controlador de eventos.  
  
 El estado del teclado se evalúa en el <xref:System.Windows.Forms.Control.DragOver> controlador de eventos para el derecho `ListBox`, para determinar cuál será la operación de arrastre según el estado de las teclas MAYÚS, CTRL, ALT o CTRL + ALT. La ubicación en la `ListBox` donde se produciría la operación de colocar también se determina durante el `DragOver` eventos. Si los datos que se va a quitar no están un `String`, el <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> está establecido en `None` en <xref:System.Windows.Forms.DragDropEffects>. Por último, se muestra el estado de la operación de colocar en el `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 Los datos que se va a quitar de la derecha `ListBox` viene determinada en el <xref:System.Windows.Forms.Control.DragDrop> controlador de eventos y el `String` valor se agrega en el lugar adecuado en el `ListBox`. Si la operación de arrastre sobrepasa los límites del formulario y, después, se cancela la operación de arrastrar y colocar en el <xref:System.Windows.Forms.Control.QueryContinueDrag> controlador de eventos.  
  
 Este fragmento de código muestra cómo utilizar el <xref:System.Windows.Forms.Control.DragOver> eventos. Consulte la <xref:System.Windows.Forms.Control.DoDragDrop%2A> método para el ejemplo de código completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#4)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#4)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawToBitmap(System::Drawing::Bitmap ^ bitmap, System::Drawing::Rectangle targetBounds);" />
      <MemberSignature Language="F#" Value="member this.DrawToBitmap : System.Drawing.Bitmap * System.Drawing.Rectangle -&gt; unit" Usage="control.DrawToBitmap (bitmap, targetBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="bitmap">Mapa de bits que se va a dibujar.</param>
        <param name="targetBounds">Los límites dentro de los cuales se representa el control.</param>
        <summary>Permite la representación del mapa de bits especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.DrawToBitmap%2A> método no se admite para los controles ActiveX. Puede invalidar el <xref:System.Windows.Forms.Control.OnPrint%2A> eventos y proporcionar la lógica de impresión personalizada si es necesario.  
  
 El <xref:System.Windows.Forms.Control.DrawToBitmap%2A> método tiene las siguientes limitaciones:  
  
-   Un <xref:System.ArgumentException> que podría producirse para mapas de bits grandes. El tamaño máximo permitido varía según el equipo.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> no admite la `Ink` controles para el sistema operativo de Windows XP Tablet PC Edition 2005.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> dibujar un elemento secundario no <xref:System.Windows.Forms.TextBox> si el <xref:System.Windows.Forms.Control.Visible%2A> propiedad de la <xref:System.Windows.Forms.TextBox> está establecido en `false`.  
  
-   Los controles dentro de contenedores se procesan en orden inverso.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> no es totalmente funcional para el <xref:System.Windows.Forms.RichTextBox>; sólo se dibuja el borde de un mapa de bits.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.Control.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(-514)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el control puede responder a la interacción del usuario.</summary>
        <value>Es <see langword="true" /> si el control puede responder a la interacción del usuario; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con el <xref:System.Windows.Forms.Control.Enabled%2A> propiedad, puede habilitar o deshabilitar controles en tiempo de ejecución. Por ejemplo, puede deshabilitar los controles que no se aplican al estado actual de la aplicación. También puede deshabilitar un control para restringir su uso. Por ejemplo, un botón puede deshabilitarse para evitar que el usuario haga clic en él. Si un control está deshabilitado, no puede seleccionarse.  
  
> [!IMPORTANT]
>  Establecer el <xref:System.Windows.Forms.Control.Enabled%2A> propiedad `false` no deshabilita el cuadro de control de la aplicación o evitar que la ventana de la aplicación recibe el foco.  
  
 Cuando un control contenedor tiene su propiedad enabled establecido en `false`, se deshabilitan todos sus controles independientes, también. Por ejemplo, si el usuario hace clic en cualquiera de los controles contenidos en deshabilitado <xref:System.Windows.Forms.GroupBox> control, se genera ningún evento.  
  
> [!NOTE]
>  Cuando se deshabilita un control desplazable, también se deshabilitan las barras de desplazamiento. Por ejemplo, un cuadro de texto multilínea deshabilitado no puede desplazarse para mostrar todas las líneas de texto.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Windows.Forms.GroupBox> y se establecen algunas de sus propiedades comunes. El ejemplo se crea un <xref:System.Windows.Forms.TextBox> y establece su <xref:System.Windows.Forms.Control.Location%2A> dentro del cuadro de grupo. A continuación, Establece la <xref:System.Windows.Forms.Control.Text%2A> propiedad del cuadro de grupo y lo acopla el grupo de cuadro a la parte superior del formulario. Por último, deshabilita el cuadro de grupo estableciendo el <xref:System.Windows.Forms.Control.Enabled%2A> propiedad `false`, lo que hace que todos los controles contenidos en el cuadro de grupo va a deshabilitar.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ScrollableControl" />
      </Docs>
    </Member>
    <Member MemberName="EnabledChanged">
      <MemberSignature Language="C#" Value="public event EventHandler EnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.EnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EnabledChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ EnabledChanged;" />
      <MemberSignature Language="F#" Value="member this.EnabledChanged : EventHandler " Usage="member this.EnabledChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.Enabled" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.Enabled%2A> propiedad se modifica mediante programación o interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente utiliza dos <xref:System.Windows.Forms.RadioButton> controles para mostrar el <xref:System.Windows.Forms.Control.EnabledChanged> eventos. Al hacer clic en un botón cambia el valor de la <xref:System.Windows.Forms.Control.Enabled%2A> propiedad del botón en `false` y muestra un <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-csharp[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="EndInvoke">
      <MemberSignature Language="C#" Value="public object EndInvoke (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object EndInvoke(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndInvoke (asyncResult As IAsyncResult) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ EndInvoke(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndInvoke : IAsyncResult -&gt; obj&#xA;override this.EndInvoke : IAsyncResult -&gt; obj" Usage="control.EndInvoke asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> que representa una operación asincrónica de invocación específica; se devuelve al llamar a <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />.</param>
        <summary>Recupera el valor devuelto por la operación asincrónica representada por la interfaz <see cref="T:System.IAsyncResult" /> que se pasa.</summary>
        <returns>
          <see cref="T:System.Object" /> generado por la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se ha completado la operación asincrónica, esta función se bloqueará hasta que el resultado está disponible.  
  
> [!NOTE]
>  Además el <xref:System.Windows.Forms.Control.InvokeRequired%2A> propiedad, hay cuatro métodos en un control que son seguros para subprocesos: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, y <xref:System.Windows.Forms.Control.CreateGraphics%2A> si ya se ha creado el identificador del control. Una llamada a <xref:System.Windows.Forms.Control.CreateGraphics%2A> antes de que se ha creado el identificador del control en un subproceso en segundo plano puede provocar no válidas entre las llamadas de subprocesos. Para todas las demás llamadas de método, debe usar uno de los métodos de invocación para calcular las referencias de la llamada al subproceso del control.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El objeto <paramref name="asyncResult" /> no se creó en una llamada anterior al método <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" /> desde el mismo control.</exception>
        <altmember cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public event EventHandler Enter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Enter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Enter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Enter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Enter;" />
      <MemberSignature Language="F#" Value="member this.Enter : EventHandler " Usage="member this.Enter : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se entra en el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al cambiar el foco mediante el teclado (ficha, MAYÚS+TAB etc.), mediante una llamada a la <xref:System.Windows.Forms.Control.Select%2A> o <xref:System.Windows.Forms.Control.SelectNextControl%2A> métodos, o estableciendo la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> propiedad al formulario actual, se producen eventos de foco en el orden siguiente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Al cambiar el foco mediante el mouse o mediante una llamada a la <xref:System.Windows.Forms.Control.Focus%2A> método, se producen eventos de foco en el orden siguiente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Si el <xref:System.Windows.Forms.Control.CausesValidation%2A> propiedad está establecida en `false`, <xref:System.Windows.Forms.Control.Validating> y <xref:System.Windows.Forms.Control.Validated> se suprimen eventos.  
  
> [!NOTE]
>  El <xref:System.Windows.Forms.Control.Enter> y <xref:System.Windows.Forms.Control.Leave> eventos se han suprimido por el <xref:System.Windows.Forms.Form> clase. Los eventos equivalentes en el <xref:System.Windows.Forms.Form> clase son el <xref:System.Windows.Forms.Form.Activated> y <xref:System.Windows.Forms.Form.Deactivate> eventos. El <xref:System.Windows.Forms.Control.Enter> y <xref:System.Windows.Forms.Control.Leave> eventos son jerárquicos y se realizará en cascada arriba y abajo de la cadena primaria hasta que se alcance el control adecuado. Por ejemplo, suponga que tiene un <xref:System.Windows.Forms.Form> con dos <xref:System.Windows.Forms.GroupBox> controles y cada <xref:System.Windows.Forms.GroupBox> control tiene uno <xref:System.Windows.Forms.TextBox> control. Cuando se mueve el símbolo de intercalación de una <xref:System.Windows.Forms.TextBox> a otro, el <xref:System.Windows.Forms.Control.Leave> evento se desencadena para el <xref:System.Windows.Forms.TextBox> y <xref:System.Windows.Forms.GroupBox>y el <xref:System.Windows.Forms.Control.Enter> evento se desencadena para los demás <xref:System.Windows.Forms.GroupBox> y <xref:System.Windows.Forms.TextBox>.  
  
> [!CAUTION]
>  No intente establecer el foco desde el <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> controladores de eventos. Si lo hace, puede provocar la aplicación o el sistema operativo deja de responder. Para obtener más información, consulte el `WM_KILLFOCUS` tema en la sección "Referencia de la entrada de teclado" y la sección "Mensaje interbloqueos" de la[acerca de los mensajes y las colas de mensajes](http://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx)tema.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.Enter> eventos para cambiar los colores de primer plano y fondo un <xref:System.Windows.Forms.TextBox> bajo ciertas condiciones.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="FindForm">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form FindForm ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Form FindForm() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FindForm" />
      <MemberSignature Language="VB.NET" Value="Public Function FindForm () As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Form ^ FindForm();" />
      <MemberSignature Language="F#" Value="member this.FindForm : unit -&gt; System.Windows.Forms.Form" Usage="control.FindForm " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera el formulario en el que se encuentra el control.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.Form" /> en el que se encuentra el control.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El control <xref:System.Windows.Forms.Control.Parent%2A> valor de propiedad no puede ser el mismo que el <xref:System.Windows.Forms.Form> devuelto por <xref:System.Windows.Forms.Control.FindForm%2A> método. Por ejemplo, si un <xref:System.Windows.Forms.RadioButton> control está dentro de un <xref:System.Windows.Forms.GroupBox> control y el <xref:System.Windows.Forms.GroupBox> se encuentra en un <xref:System.Windows.Forms.Form>, el <xref:System.Windows.Forms.RadioButton> del control <xref:System.Windows.Forms.Control.Parent%2A> es el <xref:System.Windows.Forms.GroupBox> y el <xref:System.Windows.Forms.GroupBox> control <xref:System.Windows.Forms.Control.Parent%2A>es el <xref:System.Windows.Forms.Form>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se busca el formulario que contiene el botón especificado.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.GetTopLevel" />
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; bool" Usage="control.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establece el foco de entrada en el control.</summary>
        <returns>Es <see langword="true" /> si la solicitud del foco de entrada se realizó correctamente; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.Focus%2A> devuelve del método `true` si el control recibió correctamente el foco de entrada. El control puede tener el foco de entrada mientras no se están mostrando las indicaciones visuales de tener el foco. Este comportamiento se observa principalmente por los controles no seleccionable que se enumeran a continuación, o los controles derivados de ellos.  
  
 Un control pueden seleccionarse y recibir el foco de entrada si se cumple lo siguiente: el `Selectable` valor <xref:System.Windows.Forms.ControlStyles> está establecido en `true`, que está contenida en otro control y todos sus controles principales son visibles y están habilitados.  
  
 Los controles de Windows Forms en la lista siguiente no son seleccionables. Controles derivados de estos controles también no son seleccionables.  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel> (cuando no hay ningún vínculo en el control)  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Focus%2A> es un método de bajo nivel pensado principalmente para los autores de controles personalizados. En su lugar, deben usar los programadores de aplicaciones el <xref:System.Windows.Forms.Control.Select%2A> método o la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> propiedad para los controles secundarios, o el <xref:System.Windows.Forms.Form.Activate%2A> método para formularios.  
  
   
  
## Examples  
 El ejemplo de código siguiente establece el foco en especificado <xref:System.Windows.Forms.Control>, si puede recibir el foco.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="P:System.Windows.Forms.Control.ContainsFocus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public virtual bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Focused" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Focused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Focused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Focused : bool" Usage="System.Windows.Forms.Control.Focused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el control tiene el foco de entrada.</summary>
        <value>
          <see langword="true" /> si el control tiene foco; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente código de ejemplo se deshabilita un <xref:System.Windows.Forms.MenuItem> si un <xref:System.Windows.Forms.TextBox> no tiene el foco. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.TextBox> denominado `textBox1` y dos <xref:System.Windows.Forms.MenuItem> objetos denominados `menuItemEdit` y `menuItemEditInsertCustomerInfo`.  
  
 [!code-cpp[Windows.FOrms.Control Members2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#4)]
 [!code-csharp[Windows.FOrms.Control Members2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#4)]
 [!code-vb[Windows.FOrms.Control Members2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.Focused" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.Focused" /> propiedad para extender la implementación base. En caso contrario, debe proporcionar toda la implementación.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
        <altmember cref="P:System.Windows.Forms.Control.ContainsFocus" />
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Font : System.Drawing.Font with get, set" Usage="System.Windows.Forms.Control.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(-512)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la fuente del texto que muestra el control.</summary>
        <value>
          <see cref="T:System.Drawing.Font" /> que se va a aplicar al texto que muestra el control. El valor predeterminado es el valor de la propiedad <see cref="P:System.Windows.Forms.Control.DefaultFont" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.Font%2A> es una propiedad de ambiente. Una propiedad de ambiente es una propiedad de control que, si no establece, se recupera desde el control primario. Por ejemplo, un <xref:System.Windows.Forms.Button> tendrá el mismo <xref:System.Windows.Forms.Control.BackColor%2A> como su elemento primario <xref:System.Windows.Forms.Form> de forma predeterminada. Para obtener más información acerca de las propiedades de ambiente, vea la <xref:System.Windows.Forms.AmbientProperties> clase o el <xref:System.Windows.Forms.Control> información general de clases.  
  
 Dado que el <xref:System.Drawing.Font> es inmutable (es decir, que no se puede ajustar en cualquiera de sus propiedades), solo se puede asignar el <xref:System.Windows.Forms.Control.Font%2A> propiedad un nuevo <xref:System.Drawing.Font>. Sin embargo, puede basar la nueva fuente en la fuente existente.  
  
 [Visual Basic, C#]  
  
 El siguiente es un ejemplo de cómo ajustar la fuente existente para convertirla en negrita:  
  
```csharp  
myControl.Font = new Font(myControl.Font,   
    myControl.Font.Style | FontStyle.Bold);  
```  
  
```vb  
MyControl.Font = New Font(MyControl.Font, _   
    MyControl.Font.Style Or FontStyle.Bold)  
```  
  
   
  
## Examples  
 El siguiente código de ejemplo se muestra un <xref:System.Windows.Forms.FontDialog> para el usuario y los cambios del <xref:System.Drawing.Font> de un <xref:System.Windows.Forms.DateTimePicker> control. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> con <xref:System.Windows.Forms.Button> y un <xref:System.Windows.Forms.DateTimePicker> en él.  
  
 [!code-cpp[Control_Font#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Font/CPP/control_font.cpp#1)]
 [!code-csharp[Control_Font#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Font/CS/control_font.cs#1)]
 [!code-vb[Control_Font#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Font/VB/control_font.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.Font" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.Font" /> propiedad para extender la implementación base. En caso contrario, debe proporcionar toda la implementación. No es necesario reemplazar ambos el <see langword="get" /> y <see langword="set" /> descriptores de acceso de la <see cref="P:System.Windows.Forms.Control.Font" /> propiedad; se puede reemplazar sólo uno, si es necesario.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="FontChanged">
      <MemberSignature Language="C#" Value="public event EventHandler FontChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler FontChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.FontChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FontChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ FontChanged;" />
      <MemberSignature Language="F#" Value="member this.FontChanged : EventHandler " Usage="member this.FontChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.Font" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.Font%2A> se cambia la propiedad mediante programación o a través de la interacción.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Windows.Forms.Control.FontChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="FontHeight">
      <MemberSignature Language="C#" Value="protected int FontHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FontHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.FontHeight" />
      <MemberSignature Language="VB.NET" Value="Protected Property FontHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int FontHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.FontHeight : int with get, set" Usage="System.Windows.Forms.Control.FontHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el alto de la fuente del control.</summary>
        <value>Alto de <see cref="T:System.Drawing.Font" /> del control, en píxeles.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  El <xref:System.Windows.Forms.Control.FontHeight%2A> propiedad no debe establecerse en cualquier valor distinto del control <xref:System.Drawing.Font.Height%2A?displayProperty=nameWithType> valor, o -1. Establecer <xref:System.Windows.Forms.Control.FontHeight%2A> en -1 tiene el efecto de borrar el valor de alto almacenado en caché y el valor se vuelve a calcular la próxima vez que se hace referencia a la propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Font.Height" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.Control.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(-513)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el color de primer plano del control.</summary>
        <value>
          <see cref="T:System.Drawing.Color" /> de primer plano del control. El valor predeterminado es el valor de la propiedad <see cref="P:System.Windows.Forms.Control.DefaultForeColor" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.ForeColor%2A> es una propiedad de ambiente. Una propiedad de ambiente es una propiedad de control que, si no establece, se recupera desde el control primario. Por ejemplo, un <xref:System.Windows.Forms.Button> tendrá el mismo <xref:System.Windows.Forms.Control.BackColor%2A> como su elemento primario <xref:System.Windows.Forms.Form> de forma predeterminada. Para obtener más información acerca de las propiedades de ambiente, vea la <xref:System.Windows.Forms.AmbientProperties> clase o el <xref:System.Windows.Forms.Control> información general de clases.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Windows.Forms.Control.BackColor%2A> y <xref:System.Windows.Forms.Control.ForeColor%2A> de los controles a los colores del sistema de forma predeterminada. El código de forma recursiva llama a sí mismo si el control tiene todos los controles secundarios. Este ejemplo de código requiere que haya un <xref:System.Windows.Forms.Form> con control de al menos un elemento secundario; sin embargo, un contenedor secundario controlar, como un <xref:System.Windows.Forms.Panel> o <xref:System.Windows.Forms.GroupBox>, con su propio elemento secundario controles mejor demostraría la recursividad.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.ForeColor" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.ForeColor" /> propiedad para extender la implementación base. En caso contrario, debe proporcionar toda la implementación. No es necesario reemplazar ambos el <see langword="get" /> y <see langword="set" /> descriptores de acceso de la <see cref="P:System.Windows.Forms.Control.ForeColor" /> propiedad; se puede reemplazar sólo uno, si es necesario.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="ForeColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ForeColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ForeColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ForeColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ForeColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ForeColorChanged;" />
      <MemberSignature Language="F#" Value="member this.ForeColorChanged : EventHandler " Usage="member this.ForeColorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.ForeColor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.ForeColor%2A> se cambia la propiedad mediante programación o a través de la interacción.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente es un controlador de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre *PropertyName* `Changed` que se genera cuando correspondiente *PropertyName* cambia el valor (* PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> que contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ForeColor" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="FromChildHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromChildHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromChildHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromChildHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromChildHandle (handle As IntPtr) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::Control ^ FromChildHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="static member FromChildHandle : nativeint -&gt; System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.FromChildHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Identificador de ventana (<see langword="HWND" />) que se va a buscar.</param>
        <summary>Recupera el control que contiene el identificador especificado.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.Control" /> que representa al control asociado al identificador especificado; devuelve <see langword="null" /> si no se encuentra un control con el identificador especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método busca la cadena principal del identificador de ventana hasta que encuentra un identificador que está asociado a un control. Este método es más confiable que la <xref:System.Windows.Forms.Control.FromHandle%2A> método, porque devuelve correctamente los controles que tienen más de un identificador.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As IntPtr) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::Control ^ FromHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="static member FromHandle : nativeint -&gt; System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.FromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Identificador de ventana (<see langword="HWND" />) que se va a buscar.</param>
        <summary>Devuelve el control actualmente asociado al identificador especificado.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.Control" /> que representa al control asociado al identificador especificado; devuelve <see langword="null" /> si no se encuentra un control con el identificador especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Windows.Forms.Control.FromChildHandle%2A> si necesita devolver controles que tienen más de un identificador de método.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetAccessibilityObjectById">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject GetAccessibilityObjectById (int objectId);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject GetAccessibilityObjectById(int32 objectId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAccessibilityObjectById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetAccessibilityObjectById (objectId As Integer) As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ GetAccessibilityObjectById(int objectId);" />
      <MemberSignature Language="F#" Value="abstract member GetAccessibilityObjectById : int -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.GetAccessibilityObjectById : int -&gt; System.Windows.Forms.AccessibleObject" Usage="control.GetAccessibilityObjectById objectId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="objectId">
          <see langword="Int32" /> que identifica el <see cref="T:System.Windows.Forms.AccessibleObject" /> que se va a recuperar.</param>
        <summary>Recupera el <see cref="T:System.Windows.Forms.AccessibleObject" /> especificado.</summary>
        <returns>Objeto <see cref="T:System.Windows.Forms.AccessibleObject" /> especificado.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="GetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.AutoSizeMode GetAutoSizeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.AutoSizeMode GetAutoSizeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAutoSizeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetAutoSizeMode () As AutoSizeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::AutoSizeMode GetAutoSizeMode();" />
      <MemberSignature Language="F#" Value="member this.GetAutoSizeMode : unit -&gt; System.Windows.Forms.AutoSizeMode" Usage="control.GetAutoSizeMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera un valor que indica cómo se comportará un control cuando su propiedad <see cref="P:System.Windows.Forms.Control.AutoSize" /> esté habilitada.</summary>
        <returns>Uno de los valores de <see cref="T:System.Windows.Forms.AutoSizeMode" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChildAtPoint">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera el control secundario en una ubicación especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildAtPoint (pt As Point) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetChildAtPoint(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="member this.GetChildAtPoint : System.Drawing.Point -&gt; System.Windows.Forms.Control" Usage="control.GetChildAtPoint pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">
          <see cref="T:System.Drawing.Point" /> que contiene las coordenadas donde se desea buscar un control. Las coordenadas se expresan con relación a la esquina superior izquierda del área cliente del control.</param>
        <summary>Recupera el control secundario ubicado en las coordenadas especificadas.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.Control" /> que representa al control ubicado en el punto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay ningún control secundario en el punto especificado, el <xref:System.Windows.Forms.Control.GetChildAtPoint%2A> devuelve del método `null`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para que todas las ventanas llamar a este método si el control devuelto no es un elemento secundario del control. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt, System.Windows.Forms.GetChildAtPointSkip skipValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt, valuetype System.Windows.Forms.GetChildAtPointSkip skipValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point,System.Windows.Forms.GetChildAtPointSkip)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildAtPoint (pt As Point, skipValue As GetChildAtPointSkip) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetChildAtPoint(System::Drawing::Point pt, System::Windows::Forms::GetChildAtPointSkip skipValue);" />
      <MemberSignature Language="F#" Value="member this.GetChildAtPoint : System.Drawing.Point * System.Windows.Forms.GetChildAtPointSkip -&gt; System.Windows.Forms.Control" Usage="control.GetChildAtPoint (pt, skipValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="skipValue" Type="System.Windows.Forms.GetChildAtPointSkip" />
      </Parameters>
      <Docs>
        <param name="pt">
          <see cref="T:System.Drawing.Point" /> que contiene las coordenadas donde se desea buscar un control. Las coordenadas se expresan con relación a la esquina superior izquierda del área cliente del control.</param>
        <param name="skipValue">Uno de los valores de <see cref="T:System.Windows.Forms.GetChildAtPointSkip" />, que determina si se omitirán determinados tipos de controles secundarios.</param>
        <summary>Recupera el control secundario que se encuentra en las coordenadas especificadas, especificando si se omitirán determinados tipos de controles secundarios.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.Control" /> secundario que se encuentra en las coordenadas especificadas.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainerControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IContainerControl GetContainerControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.IContainerControl GetContainerControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetContainerControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContainerControl () As IContainerControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::IContainerControl ^ GetContainerControl();" />
      <MemberSignature Language="F#" Value="member this.GetContainerControl : unit -&gt; System.Windows.Forms.IContainerControl" Usage="control.GetContainerControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IContainerControl</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el siguiente <see cref="T:System.Windows.Forms.ContainerControl" /> (en sentido ascendente) de la cadena de controles primarios del control.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.IContainerControl" /> que representa el elemento primario de <see cref="T:System.Windows.Forms.Control" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="T:System.Windows.Forms.IContainerControl" />
      </Docs>
    </Member>
    <Member MemberName="GetNextControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetNextControl (System.Windows.Forms.Control ctl, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetNextControl(class System.Windows.Forms.Control ctl, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetNextControl(System.Windows.Forms.Control,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextControl (ctl As Control, forward As Boolean) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetNextControl(System::Windows::Forms::Control ^ ctl, bool forward);" />
      <MemberSignature Language="F#" Value="member this.GetNextControl : System.Windows.Forms.Control * bool -&gt; System.Windows.Forms.Control" Usage="control.GetNextControl (ctl, forward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">
          <see cref="T:System.Windows.Forms.Control" /> donde va a comenzar la búsqueda.</param>
        <param name="forward">Es <see langword="true" /> para buscar hacia delante en el orden de tabulación; es <see langword="false" /> para buscar hacia atrás.</param>
        <summary>Recupera el siguiente control, hacia delante o hacia atrás, en el orden de tabulación de controles secundarios.</summary>
        <returns>Siguiente <see cref="T:System.Windows.Forms.Control" /> en el orden de tabulación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.GetNextControl%2A> método depende del orden de tabulación. Para recorrer en iteración todos los controles de un formulario, incluidos los controles anidados, utilice el <xref:System.Windows.Forms.Control.Controls%2A> propiedad. Para obtener o establecer el control activo de un control contenedor, utilice el <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="GetPreferredSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size GetPreferredSize (System.Drawing.Size proposedSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.Size GetPreferredSize(valuetype System.Drawing.Size proposedSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreferredSize (proposedSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Drawing::Size GetPreferredSize(System::Drawing::Size proposedSize);" />
      <MemberSignature Language="F#" Value="abstract member GetPreferredSize : System.Drawing.Size -&gt; System.Drawing.Size&#xA;override this.GetPreferredSize : System.Drawing.Size -&gt; System.Drawing.Size" Usage="control.GetPreferredSize proposedSize" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.Layout.IArrangedElement.GetPreferredSize(System.Drawing.Size)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proposedSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="proposedSize">Área de tamaño personalizado de un control.</param>
        <summary>Recupera el tamaño de un área rectangular en la que se puede encajar un control.</summary>
        <returns>Un par ordenado de tipo <see cref="T:System.Drawing.Size" /> que representa el ancho y el alto de un rectángulo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento de <xref:System.Windows.Forms.Control.GetPreferredSize%2A> difiere según el control. El <xref:System.Windows.Forms.Control.LayoutEngine%2A> podría ser no se puede asignar el tamaño devuelto al control. Puede devolver un tamaño mayor que las restricciones indicadas en la `proposedSize` parámetro, pero `proposedSize` debe disminuir a medida que disminuye la restricción. Por ejemplo, `GetPreferredSize(new Size(100, 0))` no debe ser mayor que `GetPreferredSize(new Size(200, 0))`. La excepción es un `proposedSize` 0 o `Size.Empty`, que se definen como sin restricciones.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetScaledBounds (bounds As Rectangle, factor As SizeF, specified As BoundsSpecified) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Rectangle GetScaledBounds(System::Drawing::Rectangle bounds, System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member GetScaledBounds : System.Drawing.Rectangle * System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; System.Drawing.Rectangle&#xA;override this.GetScaledBounds : System.Drawing.Rectangle * System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; System.Drawing.Rectangle" Usage="control.GetScaledBounds (bounds, factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="bounds">
          <see cref="T:System.Drawing.Rectangle" /> que especifica el área para la que se deben recuperar los límites de pantalla.</param>
        <param name="factor">El alto y el ancho de los límites del control.</param>
        <param name="specified">Uno de los valores de <see cref="T:System.Windows.Forms.BoundsSpecified" /> que especifica los límites del control que se usarán al definir su tamaño y posición.</param>
        <summary>Recupera los límites dentro de los cuales se escala el control.</summary>
        <returns>
          <see cref="T:System.Drawing.Rectangle" /> que representa los límites dentro de los cuales se escala el control.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de un método auxiliar que llama a <xref:System.Windows.Forms.Control.ScaleControl%2A> para recuperar los límites dentro del cual se escala el control. Puede invalidar este método para reutilizar el <xref:System.Windows.Forms.Control.ScaleControl%2A> escalado lógica, pero debe proporcionar sus propios límites. La implementación predeterminada devuelve límites escalados que tienen en cuenta la `specified` los límites indicados, si el control es de nivel superior, si el control se ha corregido ancho o tamaño automático y cualquier elemento gráfico podría tener el control.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.Scale(System.Single)" />
        <altmember cref="P:System.Windows.Forms.Control.ScaleChildren" />
      </Docs>
    </Member>
    <Member MemberName="GetStyle">
      <MemberSignature Language="C#" Value="protected bool GetStyle (System.Windows.Forms.ControlStyles flag);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetStyle(valuetype System.Windows.Forms.ControlStyles flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetStyle (flag As ControlStyles) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool GetStyle(System::Windows::Forms::ControlStyles flag);" />
      <MemberSignature Language="F#" Value="member this.GetStyle : System.Windows.Forms.ControlStyles -&gt; bool" Usage="control.GetStyle flag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
      </Parameters>
      <Docs>
        <param name="flag">Bit <see cref="T:System.Windows.Forms.ControlStyles" /> a partir del que se va a devolver el valor.</param>
        <summary>Recupera el valor del bit de estilo de control especificado para el control.</summary>
        <returns>Es <see langword="true" /> si el bit de estilo de control especificado se establece en <see langword="true" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Marcas de bit de estilo de control se usan para categorizar el comportamiento compatible. Un control puede habilitar un estilo mediante una llamada a la <xref:System.Windows.Forms.Control.SetStyle%2A> método y pasando adecuado <xref:System.Windows.Forms.ControlStyles> bits y el valor booleano para establecer el bit. Para determinar el valor asignado a un determinado <xref:System.Windows.Forms.ControlStyles> de bits, utilice el <xref:System.Windows.Forms.Control.GetStyle%2A> método y pase el <xref:System.Windows.Forms.ControlStyles> miembro para evaluar.  
  
   
  
## Examples  
 El ejemplo de código siguiente devuelve el valor del estilo relacionado doble búfer bits para un <xref:System.Windows.Forms.Form>. Este ejemplo devuelve `true` solo si todos los bits de estilo se establece en `true`.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#4)]
 [!code-csharp[Windows.Forms.ControlMembers6#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#4)]
 [!code-vb[Windows.Forms.ControlMembers6#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="GetTopLevel">
      <MemberSignature Language="C#" Value="protected bool GetTopLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetTopLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetTopLevel" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetTopLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool GetTopLevel();" />
      <MemberSignature Language="F#" Value="member this.GetTopLevel : unit -&gt; bool" Usage="control.GetTopLevel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina si el control es de nivel superior.</summary>
        <returns>
          <see langword="true" /> si el control es de nivel superior; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce durante una operación de arrastre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.GiveFeedback> evento se desencadena cuando se inicia una operación de arrastrar y colocar. Con el <xref:System.Windows.Forms.Control.GiveFeedback> eventos, el origen de un evento de arrastre puede modificar la apariencia del puntero del mouse con el fin de proporcionar información visual al usuario durante una operación de arrastrar y colocar.  
  
 A continuación, se describe cómo y cuándo se generan eventos relacionados con operaciones de arrastrar y colocar.  
  
 El <xref:System.Windows.Forms.Control.DoDragDrop%2A> método determina el control en la ubicación actual del cursor. A continuación, comprueba si el control es un destino de colocación válido.  
  
 Si el control es un destino válido, el <xref:System.Windows.Forms.Control.GiveFeedback> se provoca el evento con el efecto de arrastrar y colocar especificado. Para obtener una lista de efectos de arrastrar y colocar, vea la enumeración <xref:System.Windows.Forms.DragDropEffects>.  
  
 Se realiza el seguimiento de la posición del cursor del mouse, del estado del teclado y del estado de los botones del mouse.  
  
-   Si el usuario desplaza el mouse fuera de una ventana, se genera el evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Si el mouse entra en otro control, se genera el evento <xref:System.Windows.Forms.Control.DragEnter> para ese control.  
  
-   Si se mueve el mouse dentro del mismo control, se genera el evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Si hay un cambio en el estado del botón teclado o mouse, el <xref:System.Windows.Forms.Control.QueryContinueDrag> se provoca el evento y determina si debe continuar la operación de arrastrar, colocar los datos, o cancelar la operación en función del valor de la <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> propiedad del evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Continue`, <xref:System.Windows.Forms.Control.DragOver> evento se provoca para continuar con la operación y el <xref:System.Windows.Forms.Control.GiveFeedback> evento se genera con el nuevo efecto, por lo que se puede establecer la información visual apropiada. Para obtener una lista de efectos de colocar válidos, vea la enumeración <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  El <xref:System.Windows.Forms.Control.DragOver> y <xref:System.Windows.Forms.Control.GiveFeedback> eventos están emparejados de forma que cuando el mouse se desplace por el destino de colocación, el usuario reciba la información más actualizada sobre la posición del mouse.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Drop`, el valor del efecto de colocar se devuelve al origen, para que la aplicación de origen pueda realizar la operación apropiada en los datos de origen; por ejemplo, cortar los datos si la operación es un movimiento.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Cancel`, el <xref:System.Windows.Forms.Control.DragLeave> provoca el evento.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra una operación de arrastrar y colocar entre dos <xref:System.Windows.Forms.ListBox> controles. El ejemplo llama a la <xref:System.Windows.Forms.Control.DoDragDrop%2A> método cuando se inicia la acción de arrastrar. La acción de arrastrar se inicia si se ha movido el mouse más de <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> desde la ubicación del mouse durante el <xref:System.Windows.Forms.Control.MouseDown> eventos. El <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> método se utiliza para determinar el índice del elemento que se va a arrastrar durante el `MouseDown` eventos.  
  
 El ejemplo también muestra cómo utilizar cursores personalizados para la operación de arrastrar y colocar. El ejemplo requiere que dos archivos de cursor `3dwarro.cur` y `3dwno.cur`, existe en el directorio de aplicación para la operación de arrastre personalizado y no colocar cursores, respectivamente. Los cursores personalizados que se usará si el `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> está activada. Los cursores personalizados se establecen el <xref:System.Windows.Forms.Control.GiveFeedback> controlador de eventos.  
  
 El estado del teclado se evalúa en el <xref:System.Windows.Forms.Control.DragOver> controlador de eventos para el derecho `ListBox`, para determinar cuál será la operación de arrastre según el estado de las teclas MAYÚS, CTRL, ALT o CTRL + ALT. La ubicación en la `ListBox` donde se produciría la operación de colocar también se determina durante el `DragOver` eventos. Si los datos que se va a quitar no están un `String`, el <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> está establecido en `None` en <xref:System.Windows.Forms.DragDropEffects>. Por último, se muestra el estado de la operación de colocar en el `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 Los datos que se va a quitar de la derecha `ListBox` viene determinada en el <xref:System.Windows.Forms.Control.DragDrop> controlador de eventos y el `String` valor se agrega en el lugar adecuado en el `ListBox`. Si la operación de arrastre sobrepasa los límites del formulario y, después, se cancela la operación de arrastrar y colocar en el <xref:System.Windows.Forms.Control.QueryContinueDrag> controlador de eventos.  
  
 Este fragmento de código muestra cómo utilizar el <xref:System.Windows.Forms.Control.GiveFeedback> eventos. Consulte la <xref:System.Windows.Forms.Control.DoDragDrop%2A> método para el ejemplo de código completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event EventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : EventHandler " Usage="member this.GotFocus : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el control recibe el foco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al cambiar el foco mediante el teclado (ficha, MAYÚS+TAB etc.), mediante una llamada a la <xref:System.Windows.Forms.Control.Select%2A> o <xref:System.Windows.Forms.Control.SelectNextControl%2A> métodos, o estableciendo la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> propiedad al formulario actual, se producen eventos de foco en el orden siguiente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Al cambiar el foco mediante el mouse o mediante una llamada a la <xref:System.Windows.Forms.Control.Focus%2A> método, se producen eventos de foco en el orden siguiente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Si el <xref:System.Windows.Forms.Control.CausesValidation%2A> propiedad está establecida en `false`, <xref:System.Windows.Forms.Control.Validating> y <xref:System.Windows.Forms.Control.Validated> se suprimen eventos.  
  
 **Tenga en cuenta** el <xref:System.Windows.Forms.Control.GotFocus> y <xref:System.Windows.Forms.Control.LostFocus> son eventos de foco de bajo nivel que están vinculados a los mensajes de WM_KILLFOCUS y WM_SETFOCUS Windows. Normalmente, el <xref:System.Windows.Forms.Control.GotFocus> y <xref:System.Windows.Forms.Control.LostFocus> eventos solo se usan al actualizar <xref:System.Windows.Forms.UICues> o al escribir controles personalizados. En su lugar el <xref:System.Windows.Forms.Control.Enter> y <xref:System.Windows.Forms.Control.Leave> eventos deben utilizarse para todos los controles, excepto el <xref:System.Windows.Forms.Form> clase, que usa el <xref:System.Windows.Forms.Form.Activated> y <xref:System.Windows.Forms.Form.Deactivate> eventos. Para obtener más información sobre la <xref:System.Windows.Forms.Control.GotFocus> y <xref:System.Windows.Forms.Control.LostFocus> los eventos, vea el [WM_SETFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646283\(v=vs.85\).aspx)y[WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) temas.  
  
> [!CAUTION]
>  No intente establecer el foco desde el <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> controladores de eventos. Si lo hace, puede provocar la aplicación o el sistema operativo deja de responder. Para obtener más información, consulte el [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) tema.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.GotFocus> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.GotFocus> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#47](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#47)]
 [!code-vb[System.Windows.Forms.EventExamples#47](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#47)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Forms.Control.Handle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IWin32Window.Handle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(-515)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador de ventana al que está enlazado el control.</summary>
        <value>
          <see cref="T:System.IntPtr" /> que contiene el identificador de ventana (<see langword="HWND" />) del control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de la <xref:System.Windows.Forms.Control.Handle%2A> propiedad es un Windows `HWND`. Si aún no se ha creado el identificador, que hacen referencia a esta propiedad se fuerza la creación de identificador.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Windows.Forms.ControlPaint.DrawFocusRectangle%2A?displayProperty=nameWithType> y <xref:System.Windows.Forms.Control.Handle%2A> propiedad. Para ejecutar el ejemplo, pegue el código siguiente en un formulario. Agregue dos botones denominados `Button1` y `Button2` al formulario y asegúrese de que todos los eventos están conectados a sus controladores de eventos.  
  
 [!code-cpp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HandleCreated">
      <MemberSignature Language="C#" Value="public event EventHandler HandleCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleCreated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HandleCreated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HandleCreated;" />
      <MemberSignature Language="F#" Value="member this.HandleCreated : EventHandler " Usage="member this.HandleCreated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se crea un identificador para el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se crea un identificador cuando el <xref:System.Windows.Forms.Control> se muestra por primera vez. Por ejemplo, si un <xref:System.Windows.Forms.Control> se crea que tiene <xref:System.Windows.Forms.Control.Visible%2A> establecido en `false`, el <xref:System.Windows.Forms.Control.HandleCreated> no se producirá el evento hasta <xref:System.Windows.Forms.Control.Visible%2A> está establecido en `true`.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.HandleCreated> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.HandleCreated> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#37](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#37)]
 [!code-vb[System.Windows.Forms.EventExamples#37](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HandleDestroyed">
      <MemberSignature Language="C#" Value="public event EventHandler HandleDestroyed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleDestroyed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleDestroyed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HandleDestroyed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HandleDestroyed;" />
      <MemberSignature Language="F#" Value="member this.HandleDestroyed : EventHandler " Usage="member this.HandleDestroyed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el identificador del control está en proceso de eliminación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durante la <xref:System.Windows.Forms.Control.HandleDestroyed> eventos, el control sigue siendo un control de Windows válido y el <xref:System.Windows.Forms.Control.Handle%2A> puede crearse mediante una llamada a la <xref:System.Windows.Forms.Control.RecreateHandle%2A> método.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.HandleDestroyed> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.HandleDestroyed> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#38](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#38)]
 [!code-vb[System.Windows.Forms.EventExamples#38](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#38)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HasChildren">
      <MemberSignature Language="C#" Value="public bool HasChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.HasChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChildren : bool" Usage="System.Windows.Forms.Control.HasChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el control contiene uno o más controles secundarios.</summary>
        <value>
          <see langword="true" /> si el control contiene uno o más controles secundarios; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Forms.Control.Controls%2A> colección tiene un <xref:System.Windows.Forms.Layout.ArrangedElementCollection.Count%2A> mayor que cero, el <xref:System.Windows.Forms.Control.HasChildren%2A> propiedad devolverá `true`. Obtener acceso a la <xref:System.Windows.Forms.Control.HasChildren%2A> propiedad no fuerza la creación de un <xref:System.Windows.Forms.Control.ControlCollection> si el control no tiene elementos secundarios, por lo que hace referencia a esta propiedad puede proporcionar una mejora del rendimiento al recorrer un árbol de controles.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Windows.Forms.Control.BackColor%2A> y <xref:System.Windows.Forms.Control.ForeColor%2A> de los controles a los colores del sistema de forma predeterminada. El código de forma recursiva llama a sí mismo si el control tiene todos los controles secundarios. Este ejemplo de código requiere que haya un <xref:System.Windows.Forms.Form> con control de al menos un elemento secundario; sin embargo, un contenedor secundario controlar, como un <xref:System.Windows.Forms.Panel> o <xref:System.Windows.Forms.GroupBox>, con su propio elemento secundario controles mejor demostraría la recursividad.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Layout.ArrangedElementCollection.Count" />
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public int Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Height { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Height : int with get, set" Usage="System.Windows.Forms.Control.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el alto del control.</summary>
        <value>Alto del control, en píxeles.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los cambios realizados en el <xref:System.Windows.Forms.Control.Height%2A> y <xref:System.Windows.Forms.Control.Top%2A> causa de los valores de propiedad el <xref:System.Windows.Forms.Control.Bottom%2A> valor de propiedad del control que se va a cambiar.  
  
> [!NOTE]
>  El alto mínimo del control derivado <xref:System.Windows.Forms.Splitter> es de un píxel. El alto predeterminado para el <xref:System.Windows.Forms.Splitter> control es tres píxeles. Si se establece el alto de la <xref:System.Windows.Forms.Splitter> el control a un valor menor que uno restablecerá el valor de propiedad en el alto predeterminado.  
  
   
  
## Examples  
 El ejemplo de código siguiente crea tres <xref:System.Windows.Forms.Button> controles de formularios y establece su tamaño y la ubicación mediante el uso de las diversas propiedades relacionadas con la ubicación y tamaño. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> que tiene un ancho y alto de al menos 300 píxeles.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
        <altmember cref="P:System.Drawing.Size.Height" />
      </Docs>
    </Member>
    <Member MemberName="HelpRequested">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HelpEventHandler HelpRequested;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HelpEventHandler HelpRequested" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HelpRequested" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HelpRequested As HelpEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HelpEventHandler ^ HelpRequested;" />
      <MemberSignature Language="F#" Value="member this.HelpRequested : System.Windows.Forms.HelpEventHandler " Usage="member this.HelpRequested : System.Windows.Forms.HelpEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario solicita ayuda para un control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.HelpRequested> evento normalmente se produce cuando el usuario presiona la tecla F1 se hace clic en un botón de ayuda contextual asociado o la tecla.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo tratar el <xref:System.Windows.Forms.Control.HelpRequested> eventos para mostrar el contenido de ayuda personalizado en un formulario que contiene cuatro campos de dirección. El <xref:System.Windows.Forms.Control.HelpRequested> se provoca el evento presionando la tecla F1 con el foco en un campo de dirección o el mediante el botón de ayuda contextual y haga clic en el cursor de ayuda sobre un campo de dirección. El <xref:System.Windows.Forms.HelpEventArgs.Handled%2A> propiedad está establecida en true para indicar que el `HelpRequested` controla el evento. El ejemplo también se muestra cómo almacenar el texto de ayuda en la <xref:System.Windows.Forms.Control.Tag%2A?displayProperty=nameWithType> propiedad.  
  
 [!code-cpp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CPP/helpevent.cpp#1)]
 [!code-csharp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CS/helpevent.cs#1)]
 [!code-vb[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/VB/helpevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
        <altmember cref="T:System.Windows.Forms.HelpProvider" />
        <altmember cref="T:System.Windows.Forms.Help" />
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="control.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oculta el control al usuario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ocultar el control es equivalente a establecer el <xref:System.Windows.Forms.Control.Visible%2A> propiedad `false`. Después de la <xref:System.Windows.Forms.Control.Hide%2A> se invoca el <xref:System.Windows.Forms.Control.Visible%2A> propiedad devuelve un valor de `false` hasta que el <xref:System.Windows.Forms.Control.Show%2A> se llama al método.  
  
   
  
## Examples  
 El siguiente ejemplo de código oculta un botón si se presiona la tecla CTRL cuando se hace clic en el botón. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Button> denominado `button1` en un <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Show" />
      </Docs>
    </Member>
    <Member MemberName="ImeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ImeMode ImeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ImeMode ImeMode { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ImeMode : System.Windows.Forms.ImeMode with get, set" Usage="System.Windows.Forms.Control.ImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el modo de Editor de métodos de entrada (IME) del control.</summary>
        <value>Uno de los valores de <see cref="T:System.Windows.Forms.ImeMode" />. El valor predeterminado es <see cref="F:System.Windows.Forms.ImeMode.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un IME es un programa que permite a los usuarios escribir caracteres complejos y símbolos, como los caracteres Kanji del japonés, usar un teclado estándar. El <xref:System.Windows.Forms.Control.ImeMode%2A> propiedad se establece normalmente en <xref:System.Windows.Forms.ImeMode.Off?displayProperty=nameWithType> para un <xref:System.Windows.Forms.TextBox> control que está pensado para que escriba sólo valores numéricos. El <xref:System.Windows.Forms.Control.ImeMode%2A> el valor de propiedad se establece en <xref:System.Windows.Forms.ImeMode.NoControl?displayProperty=nameWithType> para el <xref:System.Windows.Forms.Form> clase.  
  
 La mayoría de las clases que directamente no admite editores de métodos de entrada o permitir la entrada directa de un IME, establecerá el valor de esta propiedad en <xref:System.Windows.Forms.ImeMode.NoControl>.  
  
> [!IMPORTANT]
>  El usuario puede cambiar de forma interactiva el <xref:System.Windows.Forms.Control.ImeMode%2A> a menos que se ha establecido mediante programación en <xref:System.Windows.Forms.ImeMode.Disable?displayProperty=nameWithType>. En este caso, el usuario no podrá usar el IME.  
>   
>  El <xref:System.Windows.Forms.Control.ImeMode%2A> propiedad se omite en Windows 8 cuando el modo de entrada global está en vigor. Para obtener más información, consulte [conmutador texto entrada cambió de cada subproceso a cada usuario](http://go.microsoft.com/fwlink/?LinkID=256509).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El valor asignado no es uno de los valores de enumeración <see cref="T:System.Windows.Forms.ImeMode" />.</exception>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.Control.DefaultImeMode" />
      </Docs>
    </Member>
    <Member MemberName="ImeModeBase">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode ImeModeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeModeBase" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeModeBase" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property ImeModeBase As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode ImeModeBase { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ImeModeBase : System.Windows.Forms.ImeMode with get, set" Usage="System.Windows.Forms.Control.ImeModeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el modo IME de un control.</summary>
        <value>Modo IME del control.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeModeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ImeModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ImeModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeModeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeModeChanged;" />
      <MemberSignature Language="F#" Value="member this.ImeModeChanged : EventHandler " Usage="member this.ImeModeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando ha cambiado la propiedad <see cref="P:System.Windows.Forms.Control.ImeMode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.ImeMode%2A> se cambia la propiedad mediante programación o a través de la interacción.  
  
 Los controles que no admiten administradores del método de entrada, nunca producen este evento.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente es un controlador de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre *PropertyName* `Changed` que se genera cuando correspondiente *PropertyName* cambia el valor (* PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> que contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
        <altmember cref="T:System.Windows.Forms.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="InitLayout">
      <MemberSignature Language="C#" Value="protected virtual void InitLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InitLayout" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitLayout ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitLayout();" />
      <MemberSignature Language="F#" Value="abstract member InitLayout : unit -&gt; unit&#xA;override this.InitLayout : unit -&gt; unit" Usage="control.InitLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se llama a este método cuando el control se ha agregado a otro contenedor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.InitLayout%2A> se llama al método inmediatamente después de agregar un control a un contenedor. El <xref:System.Windows.Forms.Control.InitLayout%2A> método permite a un control inicializar el estado de diseño en función de su contenedor. Por ejemplo, normalmente se aplicaría delimitar y acoplar en el control en el <xref:System.Windows.Forms.Control.InitLayout%2A> método.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.InitLayout" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.InitLayout" /> método para que el control se muestre correctamente.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Anchor" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invalidate">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invalida una región específica del control y hace que se envíe un mensaje de dibujo al control.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate();" />
      <MemberSignature Language="F#" Value="member this.Invalidate : unit -&gt; unit" Usage="control.Invalidate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Invalida toda la superficie del control y hace que se vuelva a dibujar el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a la <xref:System.Windows.Forms.Control.Invalidate%2A> método no fuerza una operación de dibujo sincrónica; para forzar una operación de dibujo sincrónica, llame a la <xref:System.Windows.Forms.Control.Update%2A> método después de llamar a la <xref:System.Windows.Forms.Control.Invalidate%2A> método. Cuando este método se llama sin parámetros, toda el área cliente se agrega a la región de actualización.  
  
   
  
## Examples  
 Habilita de ejemplo de código siguiente se quita al usuario arrastrar una imagen o un archivo de imagen del formulario y se muestra en el punto. El <xref:System.Windows.Forms.Control.OnPaint%2A> se invalida el método para volver a dibujar la imagen cada vez que se pinta el formulario; en caso contrario, la imagen sólo se conserva hasta la siguiente operación de dibujo. El <xref:System.Windows.Forms.Control.DragEnter> método de control de eventos determina el tipo de datos que se arrastran al formulario y proporciona la información apropiada. El <xref:System.Windows.Forms.Control.DragDrop> método de control de eventos muestra la imagen en el formulario, si un <xref:System.Drawing.Image> pueden crearse a partir de los datos. Dado que el <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> y <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> los valores son las coordenadas de pantalla, el ejemplo se usa el <xref:System.Windows.Forms.Control.PointToClient%2A> método convertirlos a coordenadas de cliente.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (invalidateChildren As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : bool -&gt; unit" Usage="control.Invalidate invalidateChildren" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidateChildren">Es <see langword="true" /> para invalidar los controles secundarios del control; en caso contrario, es <see langword="false" />.</param>
        <summary>Invalida una región específica del control y hace que se envíe un mensaje de dibujo al control. También puede invalidar los controles secundarios asignados al control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a la <xref:System.Windows.Forms.Control.Invalidate%2A> método no fuerza una operación de dibujo sincrónica; para forzar una operación de dibujo sincrónica, llame a la <xref:System.Windows.Forms.Control.Update%2A> método después de llamar a la <xref:System.Windows.Forms.Control.Invalidate%2A> método. Cuando este método se llama sin parámetros, toda el área cliente se agrega a la región de actualización.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (rc As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Rectangle rc);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Rectangle -&gt; unit" Usage="control.Invalidate rc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rc">
          <see cref="T:System.Drawing.Rectangle" /> que representa la región que se va a invalidar.</param>
        <summary>Invalida la región especificada del control (agrega esta región a la región de actualización del control, que es el área que volverá a pintarse en la siguiente operación de dibujo) y hace que se envíe un mensaje de dibujo al control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a la <xref:System.Windows.Forms.Control.Invalidate%2A> método no fuerza una operación de dibujo sincrónica; para forzar una operación de dibujo sincrónica, llame a la <xref:System.Windows.Forms.Control.Update%2A> método después de llamar a la <xref:System.Windows.Forms.Control.Invalidate%2A> método. Cuando este método se llama sin parámetros, toda el área cliente se agrega a la región de actualización.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Region -&gt; unit" Usage="control.Invalidate region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">
          <see cref="T:System.Drawing.Region" /> que se va a invalidar.</param>
        <summary>Invalida la región especificada del control (agrega esta región a la región de actualización del control, que es el área que volverá a pintarse en la siguiente operación de dibujo) y hace que se envíe un mensaje de dibujo al control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a la <xref:System.Windows.Forms.Control.Invalidate%2A> método no fuerza una operación de dibujo sincrónica; para forzar una operación de dibujo sincrónica, llame a la <xref:System.Windows.Forms.Control.Update%2A> método después de llamar a la <xref:System.Windows.Forms.Control.Invalidate%2A> método. Cuando este método se llama sin parámetros, toda el área cliente se agrega a la región de actualización.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (rc As Rectangle, invalidateChildren As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Rectangle rc, bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Rectangle * bool -&gt; unit" Usage="control.Invalidate (rc, invalidateChildren)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rc">
          <see cref="T:System.Drawing.Rectangle" /> que representa la región que se va a invalidar.</param>
        <param name="invalidateChildren">Es <see langword="true" /> para invalidar los controles secundarios del control; en caso contrario, es <see langword="false" />.</param>
        <summary>Invalida la región especificada del control (agrega esta región a la región de actualización del control, que es el área que volverá a pintarse en la siguiente operación de dibujo) y hace que se envíe un mensaje de dibujo al control. También puede invalidar los controles secundarios asignados al control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a la <xref:System.Windows.Forms.Control.Invalidate%2A> método no fuerza una operación de dibujo sincrónica; para forzar una operación de dibujo sincrónica, llame a la <xref:System.Windows.Forms.Control.Update%2A> método después de llamar a la <xref:System.Windows.Forms.Control.Invalidate%2A> método. Cuando este método se llama sin parámetros, toda el área cliente se agrega a la región de actualización.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Region ^ region, bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Region * bool -&gt; unit" Usage="control.Invalidate (region, invalidateChildren)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="region">
          <see cref="T:System.Drawing.Region" /> que se va a invalidar.</param>
        <param name="invalidateChildren">Es <see langword="true" /> para invalidar los controles secundarios del control; en caso contrario, es <see langword="false" />.</param>
        <summary>Invalida la región especificada del control (agrega esta región a la región de actualización del control, que es el área que volverá a pintarse en la siguiente operación de dibujo) y hace que se envíe un mensaje de dibujo al control. También puede invalidar los controles secundarios asignados al control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a la <xref:System.Windows.Forms.Control.Invalidate%2A> método no fuerza una operación de dibujo sincrónica; para forzar una operación de dibujo sincrónica, llame a la <xref:System.Windows.Forms.Control.Update%2A> método después de llamar a la <xref:System.Windows.Forms.Control.Invalidate%2A> método. Cuando este método se llama sin parámetros, toda el área cliente se agrega a la región de actualización.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidated">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InvalidateEventHandler Invalidated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InvalidateEventHandler Invalidated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Invalidated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Invalidated As InvalidateEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InvalidateEventHandler ^ Invalidated;" />
      <MemberSignature Language="F#" Value="member this.Invalidated : System.Windows.Forms.InvalidateEventHandler " Usage="member this.Invalidated : System.Windows.Forms.InvalidateEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InvalidateEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando es necesario volver a dibujar un control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.Invalidated> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.Invalidated> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#40)]
 [!code-vb[System.Windows.Forms.EventExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#40)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ejecuta un delegado en el subproceso que posee el identificador de ventana subyacente del control.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate -&gt; obj" Usage="control.Invoke method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Delegado que contiene un método al que se va a llamar en el contexto del subproceso del control.</param>
        <summary>Ejecuta el delegado especificado en el subproceso que posee el identificador de ventana subyacente del control.</summary>
        <returns>Valor devuelto desde el delegado al que se ha invocado o <see langword="null" /> si el delegado no devuelve ningún valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los delegados son similares a los punteros de función en los lenguajes C o C++. Los delegados encapsular una referencia a un método dentro de un objeto de delegado. A continuación, se puede pasar el objeto de delegado al código que llama al método que se hace referencia y que se invoque el método puede ser desconocido en tiempo de compilación. A diferencia de los punteros de función en C o C++, los delegados son orientada a objetos, seguridad de tipos y más seguro.  
  
 El <xref:System.Windows.Forms.Control.Invoke%2A> búsquedas de los métodos de la cadena del control primario hasta que encuentra un control o formulario que tiene una ventana de controlan si el identificador de ventana subyacente del control actual aún no existe. Si no se encuentra ningún identificador adecuado, el <xref:System.Windows.Forms.Control.Invoke%2A> método producirá una excepción. Las excepciones que se producen durante la llamada se propagará de vuelta al llamador.  
  
> [!NOTE]
>  Además el <xref:System.Windows.Forms.Control.InvokeRequired%2A> propiedad, hay cuatro métodos en un control que son seguros para subprocesos: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, y <xref:System.Windows.Forms.Control.CreateGraphics%2A> si ya se ha creado el identificador del control. Una llamada a <xref:System.Windows.Forms.Control.CreateGraphics%2A> antes de que se ha creado el identificador del control en un subproceso en segundo plano puede provocar no válidas entre las llamadas de subprocesos. Para todas las demás llamadas de método, debe usar uno de los métodos de invocación para calcular las referencias de la llamada al subproceso del control.  
  
 El delegado puede ser una instancia de <xref:System.EventHandler>, en cuyo caso el parámetro remitente contendrá este control y el parámetro de evento contendrá <xref:System.EventArgs.Empty?displayProperty=nameWithType>. El delegado también puede ser una instancia de <xref:System.Windows.Forms.MethodInvoker>, o cualquier otro delegado que toma una lista de parámetros void. Una llamada a un <xref:System.EventHandler> o <xref:System.Windows.Forms.MethodInvoker> delegado será más rápido que una llamada a otro tipo de delegado.  
  
> [!NOTE]
>  Es posible que se produce una excepción si el subproceso que se va a procesar el mensaje ya no está activo.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra los controles que contienen a un delegado. El delegado encapsula un método que agrega elementos al cuadro de lista, y este método se ejecuta en el subproceso que posee el identificador subyacente del formulario. Cuando el usuario hace clic en el botón, `Invoke` se ejecuta el delegado.  
  
 [!code-cpp[Control_Invoke2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke2/CPP/control_invoke2.cpp#1)]
 [!code-csharp[Control_Invoke2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke2/CS/control_invoke2.cs#1)]
 [!code-vb[Control_Invoke2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke2/VB/control_invoke2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MethodInvoker" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member Invoke : Delegate * obj[] -&gt; obj&#xA;override this.Invoke : Delegate * obj[] -&gt; obj" Usage="control.Invoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegado de un método que obtiene los parámetros del mismo número y tipo que los incluidos en el parámetro <c>args</c>.</param>
        <param name="args">Matriz de objetos cuyos valores se pasan como argumentos al método especificado. Este parámetro puede ser <see langword="null" /> si el método no toma ningún argumento.</param>
        <summary>Ejecuta el delegado especificado en el subproceso que posee el identificador de la ventana subyacente del control, con la lista de argumentos especificada.</summary>
        <returns>
          <see cref="T:System.Object" /> que contiene el valor devuelto por el delegado al que se ha invocado, o <see langword="null" /> si el delegado no devuelve ningún valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los delegados son similares a los punteros de función en los lenguajes C o C++. Los delegados encapsular una referencia a un método dentro de un objeto de delegado. A continuación, se puede pasar el objeto de delegado al código que llama al método que se hace referencia y que se invoque el método puede ser desconocido en tiempo de compilación. A diferencia de los punteros de función en C o C++, los delegados son orientada a objetos, seguridad de tipos y más seguro.  
  
 Si el identificador del control no existe aún, este método buscará la cadena del control primario hasta que encuentra un control o formulario que tiene un identificador de ventana. Si no se encuentra ningún identificador apropiado, este método produce una excepción. Las excepciones que se producen durante la llamada se propagará de vuelta al llamador.  
  
> [!NOTE]
>  Además el <xref:System.Windows.Forms.Control.InvokeRequired%2A> propiedad, hay cuatro métodos en un control que son seguros para subprocesos: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, y <xref:System.Windows.Forms.Control.CreateGraphics%2A> si ya se ha creado el identificador del control. Una llamada a <xref:System.Windows.Forms.Control.CreateGraphics%2A> antes de que se ha creado el identificador del control en un subproceso en segundo plano puede provocar no válidas entre las llamadas de subprocesos. Para todas las demás llamadas de método, debe usar uno de los métodos de invocación para calcular las referencias de la llamada al subproceso del control.  
  
 El delegado puede ser una instancia de <xref:System.EventHandler>, en cuyo caso el parámetro remitente contendrá este control y el parámetro de evento contendrá <xref:System.EventArgs.Empty?displayProperty=nameWithType>. El delegado también puede ser una instancia de <xref:System.Windows.Forms.MethodInvoker>, o cualquier otro delegado que toma una lista de parámetros void. Una llamada a un <xref:System.EventHandler> o <xref:System.Windows.Forms.MethodInvoker> delegado será más rápido que una llamada a otro tipo de delegado.  
  
> [!NOTE]
>  Es posible que se produce una excepción si el subproceso que se va a procesar el mensaje ya no está activo.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra los controles que contienen a un delegado. El delegado encapsula un método que agrega elementos al cuadro de lista, y este método se ejecuta en el subproceso que posee el identificador subyacente del formulario, utilizando los argumentos especificados. Cuando el usuario hace clic en el botón, `Invoke` se ejecuta el delegado.  
  
 [!code-cpp[Control_Invoke1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke1/CPP/control_invoke1.cpp#1)]
 [!code-csharp[Control_Invoke1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke1/CS/control_invoke1.cs#1)]
 [!code-vb[Control_Invoke1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke1/VB/control_invoke1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MethodInvoker" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="InvokeGotFocus">
      <MemberSignature Language="C#" Value="protected void InvokeGotFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeGotFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeGotFocus (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeGotFocus(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeGotFocus : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeGotFocus (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">
          <see cref="T:System.Windows.Forms.Control" /> al que se va a asignar el evento.</param>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.GotFocus" /> para el control especificado.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeLostFocus">
      <MemberSignature Language="C#" Value="protected void InvokeLostFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeLostFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeLostFocus (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeLostFocus(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeLostFocus : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeLostFocus (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">
          <see cref="T:System.Windows.Forms.Control" /> al que se va a asignar el evento.</param>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.LostFocus" /> para el control especificado.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeOnClick">
      <MemberSignature Language="C#" Value="protected void InvokeOnClick (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeOnClick(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeOnClick (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeOnClick(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeOnClick : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeOnClick (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">
          <see cref="T:System.Windows.Forms.Control" /> al que se va a asignar el evento <see cref="E:System.Windows.Forms.Control.Click" />.</param>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.Click" /> para el control especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokePaint">
      <MemberSignature Language="C#" Value="protected void InvokePaint (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaint(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokePaint (c As Control, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokePaint(System::Windows::Forms::Control ^ c, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokePaint : System.Windows.Forms.Control * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.InvokePaint (c, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c">
          <see cref="T:System.Windows.Forms.Control" /> al que se va a asignar el evento <see cref="E:System.Windows.Forms.Control.Paint" />.</param>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.PaintEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.Paint" /> para el control especificado.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="InvokePaintBackground">
      <MemberSignature Language="C#" Value="protected void InvokePaintBackground (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaintBackground(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokePaintBackground (c As Control, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokePaintBackground(System::Windows::Forms::Control ^ c, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokePaintBackground : System.Windows.Forms.Control * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.InvokePaintBackground (c, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c">
          <see cref="T:System.Windows.Forms.Control" /> al que se va a asignar el evento <see cref="E:System.Windows.Forms.Control.Paint" />.</param>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.PaintEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see langword="PaintBackground" /> para el control especificado.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeRequired">
      <MemberSignature Language="C#" Value="public bool InvokeRequired { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InvokeRequired" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.InvokeRequired" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InvokeRequired As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InvokeRequired { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.InvokeRequired : bool" Usage="System.Windows.Forms.Control.InvokeRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el llamador debe llamar a un método de invocación cuando realiza llamadas a métodos del control porque el llamador se encuentra en un subproceso distinto al del control donde se creó.</summary>
        <value>
          <see langword="true" /> si <see cref="P:System.Windows.Forms.Control.Handle" /> del control se creó en un subproceso distinto al subproceso que realiza la llamada (lo que indica que debe realizar llamadas al control mediante un método de invocación); en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los controles de Windows Forms están enlazados a un subproceso específico y no son seguros para subprocesos. Por lo tanto, si se llama a un método de control desde un subproceso diferente, debe usar uno del control invocara métodos para serializar la llamada al subproceso adecuado. Esta propiedad puede utilizarse para determinar si debe llamarse a un método de invocación, que puede ser útil si no sabe qué subproceso posee un control.  
  
> [!NOTE]
>  Además el <xref:System.Windows.Forms.Control.InvokeRequired%2A> propiedad, hay cuatro métodos en un control que es seguro para subprocesos llamar a: <xref:System.Windows.Forms.Control.Invoke%2A>,<xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> y <xref:System.Windows.Forms.Control.CreateGraphics%2A> si ya se ha creado el identificador del control. Una llamada a <xref:System.Windows.Forms.Control.CreateGraphics%2A> antes de que se ha creado el identificador del control en un subproceso en segundo plano puede provocar no válidas entre las llamadas de subprocesos. Todas las demás llamadas de método, debe usar uno de estos métodos de invocación cuando una llamada desde un subproceso diferente.  
  
 Si el identificador del control no existe todavía, <xref:System.Windows.Forms.Control.InvokeRequired%2A> búsquedas de seguridad de la cadena del control primario hasta que encuentra un control o formulario que tiene un identificador de ventana. Si no se encuentra ningún identificador adecuado, el <xref:System.Windows.Forms.Control.InvokeRequired%2A> devuelve del método `false`.  
  
 Esto significa que <xref:System.Windows.Forms.Control.InvokeRequired%2A> puede devolver `false` si <xref:System.Windows.Forms.Control.Invoke%2A> no es necesario (la llamada se produce en el mismo subproceso), o si se creó el control en un subproceso diferente, pero aún no se ha creado el identificador del control.  
  
 En el caso donde el identificador del control ha no se han creado, debe no basta con llamar a propiedades, métodos o eventos en el control. Esto puede provocar que el identificador del control que se crearán en el subproceso en segundo plano, aislar el control en un subproceso sin un bombeo de mensajes y hacer que la aplicación inestable.  
  
 Puede proteger con respecto a este caso, compruebe también el valor de <xref:System.Windows.Forms.Control.IsHandleCreated%2A> cuando <xref:System.Windows.Forms.Control.InvokeRequired%2A> devuelve `false` en un subproceso en segundo plano. Si aún no se ha creado el identificador de control, debe esperar hasta que se ha creado antes de llamar a <xref:System.Windows.Forms.Control.Invoke%2A> o <xref:System.Windows.Forms.Control.BeginInvoke%2A>. Normalmente, esto solo sucede si se crea un subproceso en segundo plano en el constructor del formulario principal de la aplicación (como en `Application.Run(new MainForm())`, antes de que haya demostrado el formulario o `Application.Run` se ha llamado.  
  
 Una solución es esperar hasta que se ha creado el identificador del formulario antes de iniciar el subproceso en segundo plano. Ya sea forzar la creación de identificador mediante una llamada a la <xref:System.Windows.Forms.Control.Handle%2A> propiedad o espere a que el <xref:System.Windows.Forms.Form.Load> evento para iniciar el proceso en segundo plano.  
  
 Una solución aún mejor es usar el `SynchronizationContext` devuelto por <xref:System.Threading.SynchronizationContext> en lugar de un control para la serialización entre subprocesos.  
  
> [!NOTE]
>  Es posible que se produce una excepción si el subproceso que se va a procesar el mensaje ya no está activo.  
  
 Para obtener más información acerca de los controles de Windows Forms multiproceso, vea [Cómo: usar un subproceso en segundo plano para buscar archivos](~/docs/framework/winforms/controls/how-to-use-a-background-thread-to-search-for-files.md) y [Cómo: realizar llamadas de subprocesos a controles de formularios Windows Forms](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsAccessible">
      <MemberSignature Language="C#" Value="public bool IsAccessible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAccessible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsAccessible" />
      <MemberSignature Language="VB.NET" Value="Public Property IsAccessible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAccessible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsAccessible : bool with get, set" Usage="System.Windows.Forms.Control.IsAccessible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el control es visible para las aplicaciones de accesibilidad.</summary>
        <value>
          <see langword="true" /> si el control es visible para las aplicaciones de accesibilidad; en caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Windows.Forms.Control.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el control se ha eliminado.</summary>
        <value>
          <see langword="true" /> si control se ha eliminado; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando esta propiedad devuelve `true`, el control se elimina y ya no se puede hacer referencia como un control de Windows válido. Aunque se elimine la instancia de un control de, todavía se mantiene en memoria hasta que se quita de la memoria a través de la recolección de elementos. Cuando se elimina un control, no puede llamar a su <xref:System.Windows.Forms.Control.RecreateHandle%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
        <altmember cref="T:System.GC" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="IsHandleCreated">
      <MemberSignature Language="C#" Value="public bool IsHandleCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHandleCreated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsHandleCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHandleCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHandleCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHandleCreated : bool" Usage="System.Windows.Forms.Control.IsHandleCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el control tiene un identificador asociado.</summary>
        <value>
          <see langword="true" /> si se ha asignado un identificador al control; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Windows.Forms.Control.IsHandleCreated%2A> propiedad para determinar si <xref:System.Windows.Forms.Control.CreateHandle%2A> se ha llamado.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="IsInputChar">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsInputChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsInputChar(char charCode);" />
      <MemberSignature Language="F#" Value="abstract member IsInputChar : char -&gt; bool&#xA;override this.IsInputChar : char -&gt; bool" Usage="control.IsInputChar charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Carácter que se va a probar.</param>
        <summary>Determina si un carácter es un carácter de entrada que el control reconoce.</summary>
        <returns>
          <see langword="true" /> si el carácter debe enviarse directamente al control sin preprocesamiento; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a la <xref:System.Windows.Forms.Control.IsInputChar%2A> método para determinar si el carácter especificado por el `charCode` parámetro es un carácter de entrada que solicita el control. Este método se llama durante el preprocesamiento de mensajes de ventana para determinar si el carácter de entrada especificado debe preprocesarse o enviarse directamente al control. Si <xref:System.Windows.Forms.Control.IsInputChar%2A> devuelve `true`, el carácter especificado se envía directamente al control. Si <xref:System.Windows.Forms.Control.IsInputChar%2A> devuelve `false`, el carácter especificado se preprocesa y sólo se envía al control si no se consume en la fase de preprocesamiento. El preprocesamiento de un carácter incluye la comprobación de si el carácter es una tecla de acceso de otro control.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas para la herencia de clases para llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="IsInputKey">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsInputKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsInputKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member IsInputKey : System.Windows.Forms.Keys -&gt; bool&#xA;override this.IsInputKey : System.Windows.Forms.Keys -&gt; bool" Usage="control.IsInputKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Uno de los valores de <see cref="T:System.Windows.Forms.Keys" />.</param>
        <summary>Determina si la tecla especificada es una tecla de entrada normal o una tecla especial que requiere preprocesamiento.</summary>
        <returns>
          <see langword="true" /> si la tecla especificada es una tecla de entrada normal; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a la <xref:System.Windows.Forms.Control.IsInputKey%2A> método para determinar si la clave especificada por el `keyData` parámetro es una tecla de entrada que solicita el control. Este método se llama durante el preprocesamiento de mensajes de ventana para determinar si la clave de entrada especificada debe preprocesarse o enviarse directamente al control. Si <xref:System.Windows.Forms.Control.IsInputKey%2A> devuelve `true`, la clave especificada se envía directamente al control. Si <xref:System.Windows.Forms.Control.IsInputKey%2A> devuelve `false`, la clave especificada se preprocesa y sólo se envía al control si no se consume en la fase de preprocesamiento. Las claves que previamente incluyen la ficha, si la devolución, ESC y las teclas de flecha arriba, flecha abajo, flecha izquierda y flecha derecha.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo invalidar el <xref:System.Windows.Forms.Control.IsInputKey%2A> método para un <xref:System.Windows.Forms.TextBox> control. En este ejemplo, el `TabTextBox` clase controla la tecla TAB. Cuando el `TabTextBox` tiene el foco y el usuario presiona la tecla TAB se agregan cuatro espacios en el punto de inserción de texto, reemplazando el texto seleccionado. De forma predeterminada, el <xref:System.Windows.Forms.TextBox> control administra la tecla TAB al mover el foco de entrada al siguiente control. En este caso, nunca alcanza el keypress el <xref:System.Windows.Forms.Control.OnKeyDown%2A> invalidación del método. Para evitar este comportamiento predeterminado, el <xref:System.Windows.Forms.Control.IsInputKey%2A> método invalidar devuelve `true` cuando el usuario presiona la tecla TAB. Para todos los demás de pulsaciones de teclas, el <xref:System.Windows.Forms.Control.IsInputKey%2A> invalidación del método devuelve el resultado de llamar a la versión de la clase base del método.  
  
 [!code-csharp[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/cs/form1.cs#0)]
 [!code-vb[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/vb/form1.vb#0)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas para la herencia de clases para llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="T:System.Windows.Forms.Keys" />
        <altmember cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
        <altmember cref="P:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyLocked">
      <MemberSignature Language="C#" Value="public static bool IsKeyLocked (System.Windows.Forms.Keys keyVal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyLocked(valuetype System.Windows.Forms.Keys keyVal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsKeyLocked(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsKeyLocked (keyVal As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsKeyLocked(System::Windows::Forms::Keys keyVal);" />
      <MemberSignature Language="F#" Value="static member IsKeyLocked : System.Windows.Forms.Keys -&gt; bool" Usage="System.Windows.Forms.Control.IsKeyLocked keyVal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyVal" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyVal">El miembro BLOQ MAYÚS, BLOQ NUM o BLOQ DESPL de la enumeración <see cref="T:System.Windows.Forms.Keys" />.</param>
        <summary>Determina si la tecla BLOQ MAYÚS, BLOQ NUM o BLOQ DESPL está en vigor.</summary>
        <returns>Es <see langword="true" /> si la tecla o las teclas especificadas están en vigor; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Windows.Forms.Control.IsKeyLocked%2A> propiedad para determinar si las teclas BLOQ MAYÚS, BLOQ NUM o BLOQ DESPL están en, ya sea individualmente o en combinación.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra un cuadro de mensaje que indica si la clave especificada (la tecla BLOQ en este caso) está en vigor.  
  
 [!code-cpp[ControlIsKeyLocked#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlIsKeyLocked/CPP/controliskeylocked.cpp#1)]
 [!code-csharp[ControlIsKeyLocked#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlIsKeyLocked/CS/controliskeylocked.cs#1)]
 [!code-vb[ControlIsKeyLocked#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlIsKeyLocked/VB/controliskeylocked.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El parámetro <paramref name="keyVal" /> hace referencia una tecla distinta de BLOQ MAYÚS, BLOQ NUM o BLOQ DESPL.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMirrored">
      <MemberSignature Language="C#" Value="public bool IsMirrored { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMirrored" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsMirrored" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMirrored As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMirrored { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMirrored : bool" Usage="System.Windows.Forms.Control.IsMirrored" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el control está reflejado.</summary>
        <value>
          <see langword="true" /> si el control está reflejado; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un control reflejado muestra tanto el diseño y el texto de derecha a izquierda. Para obtener más información, consulte [Cómo: crear formularios de Windows reflejados y controles](http://msdn.microsoft.com/library/7c5c4ecc-9bfb-4508-8383-753e306719b1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMnemonic">
      <MemberSignature Language="C#" Value="public static bool IsMnemonic (char charCode, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMnemonic(char charCode, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMnemonic (charCode As Char, text As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMnemonic(char charCode, System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member IsMnemonic : char * string -&gt; bool" Usage="System.Windows.Forms.Control.IsMnemonic (charCode, text)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="charCode">Carácter que se va a probar.</param>
        <param name="text">Cadena en la que se va a buscar.</param>
        <summary>Determina si el carácter especificado es una tecla de acceso asignada al control en la cadena especificada.</summary>
        <returns>Es <see langword="true" /> si el carácter <paramref name="charCode" /> es la tecla de acceso asignada al control; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El carácter de tecla de acceso es el carácter inmediatamente posterior a la primera instancia de "&" en un <xref:System.String>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra una extensión de la clase de botón que reemplaza el <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> método para presentar un comportamiento personalizado. El ejemplo también muestra el uso de la <xref:System.Windows.Forms.Control.CanSelect%2A> y <xref:System.Windows.Forms.Control.IsMnemonic%2A> propiedades. Para ejecutar este ejemplo, pegue el código siguiente después de una clase de formulario, en el mismo archivo. Agregue un botón de tipo `MnemonicButton` al formulario.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas para la herencia de clases para llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Forms.KeyEventHandler " Usage="member this.KeyDown : System.Windows.Forms.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se presiona una tecla mientras el control tiene el foco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se producen eventos claves en el orden siguiente:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Para controlar los eventos de teclado sólo en el nivel de formulario y no permitir que otros controles recibir eventos de teclado, establezca el <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> propiedad en el formulario <xref:System.Windows.Forms.Control.KeyPress> método de control de eventos para `true`. Determinadas teclas, como las teclas TAB, retorno, ESC y flecha se controlan automáticamente por los controles. Para que estas teclas provoquen el <xref:System.Windows.Forms.Control.KeyDown> eventos, debe invalidar el <xref:System.Windows.Forms.Control.IsInputKey%2A> método en cada control en el formulario. El código de la invalidación de la <xref:System.Windows.Forms.Control.IsInputKey%2A> necesitaría determinar si se presiona una de las teclas especiales y devolver un valor de `true`. En lugar de reemplazar el <xref:System.Windows.Forms.Control.IsInputKey%2A> método, puede controlar la <xref:System.Windows.Forms.Control.PreviewKeyDown> evento y establecer el <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> propiedad `true`. Para obtener un ejemplo de código, vea el <xref:System.Windows.Forms.Control.PreviewKeyDown> eventos.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.KeyDown> evento para determinar el tipo de carácter especificado en el control.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.KeyEventArgs" />
        <altmember cref="T:System.Windows.Forms.KeyEventHandler" />
        <altmember cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyPressEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyPressEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyPress As KeyPressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyPressEventHandler ^ KeyPress;" />
      <MemberSignature Language="F#" Value="member this.KeyPress : System.Windows.Forms.KeyPressEventHandler " Usage="member this.KeyPress : System.Windows.Forms.KeyPressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyPressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se presiona una tecla de espacio o retroceso mientras el control tiene el foco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se producen eventos claves en el orden siguiente:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 El <xref:System.Windows.Forms.Control.KeyPress> claves no son de caracteres que no sea espacio y retroceso no provoca eventos; sin embargo, las teclas de carácter que no es activan el <xref:System.Windows.Forms.Control.KeyDown> y <xref:System.Windows.Forms.Control.KeyUp> eventos.  
  
 Use el <xref:System.Windows.Forms.KeyPressEventArgs.KeyChar%2A> propiedad pulsaciones de teclas de ejemplo en tiempo de ejecución así como para consumir o modificar un subconjunto de pulsaciones de teclas comunes.  
  
 Para controlar los eventos de teclado sólo en el nivel de formulario y no permitir que otros controles recibir eventos de teclado, establezca el <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> propiedad en el formulario <xref:System.Windows.Forms.Control.KeyPress> método de control de eventos para `true`.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.KeyPress> eventos para evitar que los caracteres de escritura del control.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.KeyPressEventArgs.KeyChar" />
        <altmember cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Forms.KeyEventHandler " Usage="member this.KeyUp : System.Windows.Forms.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se suelta una tecla mientras el control tiene el foco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se producen eventos claves en el orden siguiente:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Para controlar los eventos de teclado sólo en el nivel de formulario y no permitir que otros controles recibir eventos de teclado, establezca el <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> propiedad en el formulario <xref:System.Windows.Forms.Control.KeyPress> método de control de eventos para `true`. Determinadas teclas, como las teclas TAB, retorno, ESC y flecha se controlan automáticamente por los controles. Para que estas teclas provoquen el <xref:System.Windows.Forms.Control.KeyUp> eventos, debe invalidar el <xref:System.Windows.Forms.Control.IsInputKey%2A> método en cada control en el formulario. El código de la invalidación de <xref:System.Windows.Forms.Control.IsInputKey%2A> necesitaría determinar si se presiona una de las teclas especiales y devolver un valor de `true`.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.KeyUp> evento con el <xref:System.Windows.Forms.Help> clase para mostrar la Ayuda de estilo emergente al usuario.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="Layout">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LayoutEventHandler Layout;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LayoutEventHandler Layout" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Layout" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Layout As LayoutEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::LayoutEventHandler ^ Layout;" />
      <MemberSignature Language="F#" Value="member this.Layout : System.Windows.Forms.LayoutEventHandler " Usage="member this.Layout : System.Windows.Forms.LayoutEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LayoutEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un control debe volver a colocar sus controles secundarios.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.Layout> evento tiene lugar cuando se agregan o se quitan, cuando los límites del control cambia, o cuando producen otros cambios que pueden afectar al diseño del control de los controles secundarios. El evento de diseño se puede suprimir con el <xref:System.Windows.Forms.Control.SuspendLayout%2A> y <xref:System.Windows.Forms.Control.ResumeLayout%2A> métodos. La suspensión del diseño le permite realizar varias acciones en un control sin tener que realizar un diseño para cada cambio. Por ejemplo, si el cambio de tamaño y mover un control, cada operación provocará un <xref:System.Windows.Forms.Control.Layout> eventos.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El siguiente código de ejemplo centros un <xref:System.Windows.Forms.Form> en la pantalla en la <xref:System.Windows.Forms.Control.Layout> eventos. Esto mantendrá el formulario centrado cuando el usuario lo modifica. En este ejemplo requiere que se haya creado un <xref:System.Windows.Forms.Form> control.  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
      </Docs>
    </Member>
    <Member MemberName="LayoutEngine">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Layout.LayoutEngine LayoutEngine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Layout.LayoutEngine LayoutEngine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.LayoutEngine" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LayoutEngine As LayoutEngine" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Layout::LayoutEngine ^ LayoutEngine { System::Windows::Forms::Layout::LayoutEngine ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LayoutEngine : System.Windows.Forms.Layout.LayoutEngine" Usage="System.Windows.Forms.Control.LayoutEngine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Layout.LayoutEngine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una instancia almacenada en memoria caché del motor de diseño del control.</summary>
        <value>
          <see cref="T:System.Windows.Forms.Layout.LayoutEngine" /> para el contenido del control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.LayoutEngine%2A> propiedad obtiene el motor de diseño para los elementos secundarios del control, en lugar de para el propio control.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Layout.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public event EventHandler Leave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Leave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Leave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Leave;" />
      <MemberSignature Language="F#" Value="member this.Leave : EventHandler " Usage="member this.Leave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el foco de entrada deja el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al cambiar el foco mediante el teclado (ficha, MAYÚS+TAB etc.), mediante una llamada a la <xref:System.Windows.Forms.Control.Select%2A> o <xref:System.Windows.Forms.Control.SelectNextControl%2A> métodos, o estableciendo la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> propiedad al formulario actual, se producen eventos de foco en el orden siguiente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Al cambiar el foco mediante el mouse o mediante una llamada a la <xref:System.Windows.Forms.Control.Focus%2A> método, se producen eventos de foco en el orden siguiente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Si el <xref:System.Windows.Forms.Control.CausesValidation%2A> propiedad está establecida en `false`, <xref:System.Windows.Forms.Control.Validating> y <xref:System.Windows.Forms.Control.Validated> se suprimen eventos.  
  
> [!NOTE]
>  El <xref:System.Windows.Forms.Control.Enter> y <xref:System.Windows.Forms.Control.Leave> eventos se han suprimido por el <xref:System.Windows.Forms.Form> clase. Los eventos equivalentes en el <xref:System.Windows.Forms.Form> clase son el <xref:System.Windows.Forms.Form.Activated> y <xref:System.Windows.Forms.Form.Deactivate> eventos. El <xref:System.Windows.Forms.Control.Enter> y <xref:System.Windows.Forms.Control.Leave> eventos son jerárquicos y se realizará en cascada arriba y abajo de la cadena primaria hasta que se alcance el control adecuado. Por ejemplo, suponga que tiene un <xref:System.Windows.Forms.Form> con dos <xref:System.Windows.Forms.GroupBox> controles y cada <xref:System.Windows.Forms.GroupBox> control tiene uno <xref:System.Windows.Forms.TextBox> control. Cuando se mueve el símbolo de intercalación de una <xref:System.Windows.Forms.TextBox> a otro, el <xref:System.Windows.Forms.Control.Leave> evento se desencadena para el <xref:System.Windows.Forms.TextBox> y <xref:System.Windows.Forms.GroupBox>y el <xref:System.Windows.Forms.Control.Enter> evento se desencadena para los demás <xref:System.Windows.Forms.GroupBox> y <xref:System.Windows.Forms.TextBox>.  
  
> [!CAUTION]
>  No intente establecer el foco desde el <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> controladores de eventos. Si lo hace, puede provocar la aplicación o el sistema operativo deja de responder. Para obtener más información, consulte el [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) tema.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.Leave> eventos para restablecer un control a su estado anterior.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public int Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Left { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Left : int with get, set" Usage="System.Windows.Forms.Control.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la distancia, en píxeles, que existe entre el borde izquierdo del control y el borde izquierdo del área cliente de su contenedor.</summary>
        <value>
          <see cref="T:System.Int32" /> que representa la distancia, en píxeles, que existe entre el borde izquierdo del control y el borde izquierdo del área cliente de su contenedor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.Left%2A> valor de propiedad es equivalente a la <xref:System.Drawing.Point.X%2A?displayProperty=nameWithType> propiedad de la <xref:System.Windows.Forms.Control.Location%2A> valor de propiedad del control.  
  
 Los cambios realizados en el <xref:System.Windows.Forms.Control.Width%2A> y <xref:System.Windows.Forms.Control.Left%2A> causa de los valores de propiedad el <xref:System.Windows.Forms.Control.Right%2A> valor de propiedad del control que se va a cambiar.  
  
   
  
## Examples  
 El ejemplo de código siguiente crea tres <xref:System.Windows.Forms.Button> controles de formularios y establece su tamaño y la ubicación mediante el uso de las diversas propiedades relacionadas con la ubicación y tamaño. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> que tiene un ancho y alto de al menos 300 píxeles.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Point.X" />
        <altmember cref="P:System.Windows.Forms.Control.Right" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Location { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.Location : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Control.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece las coordenadas de la esquina superior izquierda del control en relación con la esquina superior izquierda de su contenedor.</summary>
        <value>
          <see cref="T:System.Drawing.Point" /> que representa la esquina superior izquierda del control en relación con la esquina superior izquierda de su contenedor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dado que el <xref:System.Drawing.Point> clase es un tipo de valor (`Structure` en Visual Basic, `struct` en Visual C#), se devuelve por valor, lo que significa que el acceso a la propiedad devuelve una copia del punto superior izquierdo del control. Por lo tanto, ajustar el <xref:System.Drawing.Point.X%2A> o <xref:System.Drawing.Point.Y%2A> propiedades de la <xref:System.Drawing.Point> devuelto de esta propiedad no tendrá ningún efecto el <xref:System.Windows.Forms.Control.Left%2A>, <xref:System.Windows.Forms.Control.Right%2A>, <xref:System.Windows.Forms.Control.Top%2A>, o <xref:System.Windows.Forms.Control.Bottom%2A> los valores de propiedad del control. Para ajustar estas propiedades, establecer cada valor de propiedad individualmente, o establecer el <xref:System.Windows.Forms.Control.Location%2A> propiedad con un nuevo <xref:System.Drawing.Point>.  
  
 Si el <xref:System.Windows.Forms.Control> es un <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Control.Location%2A> valor de propiedad representa la esquina superior izquierda de la <xref:System.Windows.Forms.Form> en coordenadas de pantalla.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Windows.Forms.GroupBox> y se establecen algunas de sus propiedades comunes. El ejemplo se crea un <xref:System.Windows.Forms.TextBox> y establece su <xref:System.Windows.Forms.Control.Location%2A> dentro del cuadro de grupo. A continuación, Establece la <xref:System.Windows.Forms.Control.Text%2A> propiedad del cuadro de grupo y lo acopla el grupo de cuadro a la parte superior del formulario. Por último, deshabilita el cuadro de grupo estableciendo el <xref:System.Windows.Forms.Control.Enabled%2A> propiedad `false`, lo que hace que todos los controles contenidos en el cuadro de grupo va a deshabilitar.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.Location" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.Location%2A> se cambia la propiedad mediante programación o a través de la interacción.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El siguiente código de ejemplo genera el <xref:System.Windows.Forms.Control.LocationChanged> eventos en un <xref:System.Windows.Forms.StatusStrip> cuando se cambia el tamaño del formulario.  
  
 [!code-csharp[System.Windows.Forms.LocationChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.LocationChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="LogicalToDeviceUnits">
      <MemberSignature Language="C#" Value="public int LogicalToDeviceUnits (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LogicalToDeviceUnits(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.LogicalToDeviceUnits(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogicalToDeviceUnits (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LogicalToDeviceUnits(int value);" />
      <MemberSignature Language="F#" Value="member this.LogicalToDeviceUnits : int -&gt; int" Usage="control.LogicalToDeviceUnits value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valor lógico que se va a convertir.</param>
        <summary>Convierte un valor de PPP lógico en su valor de PPP DeviceUnit equivalente.</summary>
        <returns>El valor DeviceUnit resultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event EventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : EventHandler " Usage="member this.LostFocus : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el control pierde el foco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al cambiar el foco mediante el teclado (ficha, MAYÚS+TAB etc.), mediante una llamada a la <xref:System.Windows.Forms.Control.Select%2A> o <xref:System.Windows.Forms.Control.SelectNextControl%2A> métodos, o estableciendo la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> propiedad al formulario actual, se producen eventos de foco en el orden siguiente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Al cambiar el foco mediante el mouse o mediante una llamada a la <xref:System.Windows.Forms.Control.Focus%2A> método, se producen eventos de foco en el orden siguiente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Si el <xref:System.Windows.Forms.Control.CausesValidation%2A> propiedad está establecida en `false`, <xref:System.Windows.Forms.Control.Validating> y <xref:System.Windows.Forms.Control.Validated> se suprimen eventos.  
  
 Si el <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propiedad de la <xref:System.ComponentModel.CancelEventArgs> está establecido en `true` en el <xref:System.Windows.Forms.Control.Validating> delegado de eventos, todos los eventos que se producirían generalmente después el <xref:System.Windows.Forms.Control.Validating> se suprimen eventos.  
  
> [!NOTE]
>  El <xref:System.Windows.Forms.Control.GotFocus> y <xref:System.Windows.Forms.Control.LostFocus> son eventos de foco de bajo nivel que están vinculados a los mensajes de WM_KILLFOCUS y WM_SETFOCUS Windows. Normalmente, el <xref:System.Windows.Forms.Control.GotFocus> y <xref:System.Windows.Forms.Control.LostFocus> eventos solo se usan al actualizar <xref:System.Windows.Forms.UICues> o al escribir controles personalizados. En su lugar el <xref:System.Windows.Forms.Control.Enter> y <xref:System.Windows.Forms.Control.Leave> eventos deben utilizarse para todos los controles, excepto el <xref:System.Windows.Forms.Form> clase, que usa el <xref:System.Windows.Forms.Form.Activated> y <xref:System.Windows.Forms.Form.Deactivate> eventos. Para obtener más información sobre la <xref:System.Windows.Forms.Control.GotFocus> y <xref:System.Windows.Forms.Control.LostFocus> los eventos, vea el [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) y [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) temas.  
  
> [!CAUTION]
>  No intente establecer el foco desde el <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> controladores de eventos. Si lo hace, puede provocar la aplicación o el sistema operativo deja de responder. Para obtener más información, consulte el [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) tema.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo validar el texto de TextBox1. También muestra cómo tratar el <xref:System.Windows.Forms.Control.LostFocus> eventos estableciendo la <xref:System.Windows.Forms.FileDialog.InitialDirectory%2A?displayProperty=nameWithType> propiedad en el texto de TextBox1. El ejemplo de código usa el <xref:System.Windows.Forms.ErrorProvider.GetError%2A?displayProperty=nameWithType> método para comprobar si hay un error antes de abrir el cuadro de diálogo de archivo. Para ejecutar este ejemplo, pegue el código siguiente en un formulario que contenga un <xref:System.Windows.Forms.TextBox> denominado `TextBox1`, un <xref:System.Windows.Forms.OpenFileDialog> denominado `OpenFileDialog1`, un <xref:System.Windows.Forms.Button> denominado `Button1`y un <xref:System.Windows.Forms.ErrorProvider> denominado `ErrorProvider1`. Asegúrese de que todos los eventos están asociados con sus controladores de eventos.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#2)]
 [!code-csharp[System.Windows.Forms.FileDialog#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#2)]
 [!code-vb[System.Windows.Forms.FileDialog#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
        <altmember cref="E:System.Windows.Forms.Control.Leave" />
        <altmember cref="E:System.Windows.Forms.Form.Deactivate" />
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Margin { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.Control.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el espacio entre controles.</summary>
        <value>
          <see cref="T:System.Windows.Forms.Padding" /> que representa el espacio entre los controles.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los valores predeterminados para los controles reciben <xref:System.Windows.Forms.Control.Margin%2A> que están bastante cerca de directrices de interfaz de usuario de Windows. Pueden que algunos ajustes que sea necesarios para aplicaciones concretas.  
  
> [!NOTE]
>  Establecer el <xref:System.Windows.Forms.Control.Margin%2A> propiedad en un control acoplado no tiene ningún efecto en la distancia del control de los bordes de su contenedor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MarginChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MarginChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MarginChanged;" />
      <MemberSignature Language="F#" Value="member this.MarginChanged : EventHandler " Usage="member this.MarginChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el margen del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.MarginChanged> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.MarginChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#21)]
 [!code-vb[System.Windows.Forms.EventExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MaximumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.MaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.AmbientValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño que es el límite superior que <see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" /> puede especificar.</summary>
        <value>Un par ordenado de tipo <see cref="T:System.Drawing.Size" /> que representa el ancho y el alto de un rectángulo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MinimumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MinimumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.MinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño que es el límite inferior que <see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" /> puede especificar.</summary>
        <value>Un par ordenado de tipo <see cref="T:System.Drawing.Size" /> que representa el ancho y el alto de un rectángulo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifierKeys">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Keys ModifierKeys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.Keys ModifierKeys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ModifierKeys" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ModifierKeys As Keys" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Keys ModifierKeys { System::Windows::Forms::Keys get(); };" />
      <MemberSignature Language="F#" Value="member this.ModifierKeys : System.Windows.Forms.Keys" Usage="System.Windows.Forms.Control.ModifierKeys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Keys</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica cuál de las teclas modificadoras (MAYÚS, CTRL y ALT) está presionada.</summary>
        <value>Combinación bit a bit de los valores de <see cref="T:System.Windows.Forms.Keys" />. El valor predeterminado es <see cref="F:System.Windows.Forms.Keys.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código oculta un botón cuando se presiona la tecla CTRL mientras hace clic con el botón. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Button> denominado `button1` en un <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Keys" />
      </Docs>
    </Member>
    <Member MemberName="MouseButtons">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.MouseButtons MouseButtons { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.MouseButtons MouseButtons" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MouseButtons" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MouseButtons As MouseButtons" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::MouseButtons MouseButtons { System::Windows::Forms::MouseButtons get(); };" />
      <MemberSignature Language="F#" Value="member this.MouseButtons : System.Windows.Forms.MouseButtons" Usage="System.Windows.Forms.Control.MouseButtons" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseButtons</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica cuál de los botones del mouse está presionado.</summary>
        <value>Una combinación bit a bit de los valores de la enumeración <see cref="T:System.Windows.Forms.MouseButtons" />. El valor predeterminado es <see cref="F:System.Windows.Forms.MouseButtons.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>, y <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> miembros. Para ejecutar el ejemplo, pegue el código siguiente en un formulario denominado Form1 que contiene varios controles. Este ejemplo requiere que el <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, y <xref:System.Windows.Forms.Control.MouseUp> eventos están conectados a los controladores de eventos definidos en el ejemplo.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MouseButtons" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseCaptureChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MouseCaptureChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseCaptureChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseCaptureChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseCaptureChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseCaptureChanged;" />
      <MemberSignature Language="F#" Value="member this.MouseCaptureChanged : EventHandler " Usage="member this.MouseCaptureChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aparece cuando el control pierde la captura del mouse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En casos poco frecuentes, es posible que deberá detectar entrada inesperada. Por ejemplo, considere los siguientes escenarios.  
  
-   Durante una operación del mouse, el usuario abre el menú Inicio, presione la tecla de Windows o CTRL + ESC.  
  
-   Durante una operación del mouse, el usuario cambia a otro programa presionando ALT+TAB.  
  
-   Durante una operación del mouse, otro programa muestra una ventana o un cuadro de mensaje que toma el foco fuera de la aplicación actual.  
  
 Pueden incluir operaciones del mouse haciendo clic y mantenga el mouse en un formulario o un control, o realizar un mouse de la operación de arrastrar. Si tiene que detectar cuándo un formulario o un control pierde la captura del mouse para estos y escenarios inesperados relacionados, puede usar el <xref:System.Windows.Forms.Control.MouseCaptureChanged> eventos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Windows.Forms.Control.MouseCaptureChanged> eventos para un <xref:System.Windows.Forms.Button> control.  
  
 [!code-csharp[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/vb/form1.vb#1)]  
  
 Para probar este ejemplo, ejecútelo en el depurador presionando F5. Abra el **salida** ventana de Visual Studio para que puedan ver cuando se generan eventos. Haga clic en el <xref:System.Windows.Forms.Button> y observe el siguiente resultado.  
  
 `button1_MouseDown`  
  
 `button1_MouseUp`  
  
 `button1_MouseCaptureChanged`  
  
 Ahora, haga clic y mantenga presionado el botón primario del mouse el <xref:System.Windows.Forms.Button> control. Mientras sigue haciendo clic en el mouse, presione ALT + TAB para cambiar a otro programa. Tenga en cuenta que el <xref:System.Windows.Forms.Control.MouseCaptureChanged> evento se produce lo que le permite controlar potencialmente este escenario. Dependiendo de sus acciones, el <xref:System.Windows.Forms.Control.MouseUp> no es posible que se produce el evento. También puede probar esta prueba con la clave de Windows o CTRL + ESC.  
  
 `button1_MouseDown`  
  
 `button1_MouseCaptureChanged`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseClick;" />
      <MemberSignature Language="F#" Value="member this.MouseClick : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseClick : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se hace clic con el mouse en el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deprimente un botón del mouse cuando el cursor está sobre un control normalmente genera la siguiente serie de eventos del control:  
  
1.  Evento <xref:System.Windows.Forms.Control.MouseDown>.  
  
2.  Evento <xref:System.Windows.Forms.Control.Click>.  
  
3.  Evento <xref:System.Windows.Forms.Control.MouseClick>.  
  
4.  Evento <xref:System.Windows.Forms.Control.MouseUp>.  
  
 Para que esto, no se puede deshabilitar los distintos eventos en la clase del control.  
  
 Dos simples clics que se producen en el tiempo, según lo determinado por la configuración del mouse del sistema operativo del usuario, se generará un <xref:System.Windows.Forms.Control.MouseDoubleClick> eventos en lugar de la segunda <xref:System.Windows.Forms.Control.MouseClick> eventos.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.Click> los eventos son eventos lógicos de nivel superior de un control. A menudo se generan por otras acciones, como presionar la tecla ENTRAR cuando el control tiene el foco.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.MouseClick> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.MouseClick> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#54](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#54)]
 [!code-vb[System.Windows.Forms.EventExamples#54](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDoubleClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseDoubleClick;" />
      <MemberSignature Language="F#" Value="member this.MouseDoubleClick : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseDoubleClick : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se hace doble clic con el mouse en el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.MouseDoubleClick> evento tiene lugar cuando el usuario presiona un botón del mouse dos veces en rápida sucesión cuando el cursor está sobre el control. El intervalo de tiempo que separa dos clics únicos de un doble clic viene determinada por la configuración del mouse del sistema operativo del usuario.  
  
 La siguiente serie de eventos es provocada por el control cuando realiza una acción del usuario tal:  
  
1.  Evento <xref:System.Windows.Forms.Control.MouseDown>.  
  
2.  Evento <xref:System.Windows.Forms.Control.Click>.  
  
3.  Evento <xref:System.Windows.Forms.Control.MouseClick>.  
  
4.  Evento <xref:System.Windows.Forms.Control.MouseUp>.  
  
5.  Evento <xref:System.Windows.Forms.Control.MouseDown>.  
  
6.  Evento <xref:System.Windows.Forms.Control.DoubleClick>.  
  
7.  Evento <xref:System.Windows.Forms.Control.MouseDoubleClick>.  
  
8.  Evento <xref:System.Windows.Forms.Control.MouseUp>.  
  
 Para que esto, no se puede deshabilitar los distintos eventos en la clase del control.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.DoubleClick> los eventos son eventos lógicos de nivel superior de un control. Se pueden producir por otras acciones del usuario, como combinaciones de teclas de método abreviado.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.MouseDoubleClick> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.MouseDoubleClick> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#55](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#55)]
 [!code-vb[System.Windows.Forms.EventExamples#55](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#55)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseDown : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el puntero del mouse se encuentra sobre el control y se presiona un botón del mouse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los eventos del mouse se producen en el siguiente orden:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Los siguientes eventos no se generan para el <xref:System.Windows.Forms.TabControl> a menos que haya al menos una de las clases <xref:System.Windows.Forms.TabPage> en el <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> colección: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> y <xref:System.Windows.Forms.Control.MouseMove>. Si hay al menos un <xref:System.Windows.Forms.TabPage> en la colección, y el usuario interactúa con el encabezado del control de ficha (donde el <xref:System.Windows.Forms.TabPage> aparecen nombres), el <xref:System.Windows.Forms.TabControl> provoca el evento adecuado. Sin embargo, si la interacción del usuario está dentro del área de cliente de la página de ficha, el <xref:System.Windows.Forms.TabPage> provoca el evento adecuado.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar distintos eventos de mouse para dibujar la ruta de acceso del puntero del mouse en un <xref:System.Windows.Forms.Panel>. Un segmento de línea se agrega a la <xref:System.Drawing.Drawing2D.GraphicsPath> para cada <xref:System.Windows.Forms.Control.MouseMove> y <xref:System.Windows.Forms.Control.MouseDown> eventos que se producen. Para actualizar los gráficos, el <xref:System.Windows.Forms.Control.Invalidate%2A> se llama al método para el <xref:System.Windows.Forms.Panel> en cada `MouseDown` y `MouseUp` eventos. Además, la ruta de gráfico se desplaza hacia arriba o hacia abajo cuando la <xref:System.Windows.Forms.Control.MouseWheel> se produce el evento. Al igual que otros eventos de mouse, <xref:System.Windows.Forms.Control.MouseHover>, se identifican en pantalla también. También se muestra en la pantalla es información adicional sobre el mouse desde el <xref:System.Windows.Forms.SystemInformation> clase.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event EventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : EventHandler " Usage="member this.MouseEnter : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el puntero del mouse entra en el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los eventos del mouse se producen en el siguiente orden:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Los siguientes eventos no se generan para el <xref:System.Windows.Forms.TabControl> a menos que haya al menos una de las clases <xref:System.Windows.Forms.TabPage> en el <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> colección: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> y <xref:System.Windows.Forms.Control.MouseMove>. Si hay al menos un <xref:System.Windows.Forms.TabPage> en la colección, y el usuario interactúa con el encabezado del control de ficha (donde el <xref:System.Windows.Forms.TabPage> aparecen nombres), el <xref:System.Windows.Forms.TabControl> provoca el evento adecuado. Sin embargo, si la interacción del usuario está dentro del área de cliente de la página de ficha, el <xref:System.Windows.Forms.TabPage> provoca el evento adecuado.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar distintos eventos de mouse para dibujar la ruta de acceso del puntero del mouse en un <xref:System.Windows.Forms.Panel>. Un segmento de línea se agrega a la <xref:System.Drawing.Drawing2D.GraphicsPath> para cada <xref:System.Windows.Forms.Control.MouseMove> y <xref:System.Windows.Forms.Control.MouseDown> eventos que se producen. Para actualizar los gráficos, el <xref:System.Windows.Forms.Control.Invalidate%2A> se llama al método para el <xref:System.Windows.Forms.Panel> en cada `MouseDown` y `MouseUp` eventos. Además, la ruta de gráfico se desplaza hacia arriba o hacia abajo cuando la <xref:System.Windows.Forms.Control.MouseWheel> se produce el evento. Al igual que otros eventos de mouse, <xref:System.Windows.Forms.Control.MouseHover>, se identifican en pantalla también. También se muestra en la pantalla es información adicional sobre el mouse desde el <xref:System.Windows.Forms.SystemInformation> clase.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.MouseLeave" />
        <altmember cref="E:System.Windows.Forms.Control.MouseHover" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseHover">
      <MemberSignature Language="C#" Value="public event EventHandler MouseHover;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseHover" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseHover" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseHover As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseHover;" />
      <MemberSignature Language="F#" Value="member this.MouseHover : EventHandler " Usage="member this.MouseHover : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el puntero del mouse se sitúa sobre el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un uso típico de <xref:System.Windows.Forms.Control.MouseHover> consiste en mostrar una información sobre herramientas cuando el mouse se detenga sobre un control dentro de un área especificada alrededor del control (el "rectángulo"). La pausa necesaria para que se genere este evento se especifica en milisegundos por la <xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A> propiedad.  
  
 El <xref:System.Windows.Forms.Control.MouseHover> evento se define y se ha detectado la conexión con el <xref:System.Windows.Forms.SystemInformation.MouseHoverSize%2A> y <xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A> propiedades.  
  
 Los eventos del mouse se producen en el siguiente orden:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Los siguientes eventos no se generan para el <xref:System.Windows.Forms.TabControl> a menos que haya al menos una de las clases <xref:System.Windows.Forms.TabPage> en el <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> colección: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> y <xref:System.Windows.Forms.Control.MouseMove>. Si hay al menos un <xref:System.Windows.Forms.TabPage> en la colección, y el usuario interactúa con el encabezado del control de ficha (donde el <xref:System.Windows.Forms.TabPage> aparecen nombres), el <xref:System.Windows.Forms.TabControl> provoca el evento adecuado. Sin embargo, si la interacción del usuario está dentro del área de cliente de la página de ficha, el <xref:System.Windows.Forms.TabPage> provoca el evento adecuado.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar distintos eventos de mouse para dibujar la ruta de acceso del puntero del mouse en un <xref:System.Windows.Forms.Panel>. Un segmento de línea se agrega a la <xref:System.Drawing.Drawing2D.GraphicsPath> para cada <xref:System.Windows.Forms.Control.MouseMove> y <xref:System.Windows.Forms.Control.MouseDown> eventos que se producen. Para actualizar los gráficos, el <xref:System.Windows.Forms.Control.Invalidate%2A> se llama al método para el <xref:System.Windows.Forms.Panel> en cada `MouseDown` y `MouseUp` eventos. Además, la ruta de gráfico se desplaza hacia arriba o hacia abajo cuando la <xref:System.Windows.Forms.Control.MouseWheel> se produce el evento. Al igual que otros eventos de mouse, <xref:System.Windows.Forms.Control.MouseHover>, se identifican en pantalla también. También se muestra en la pantalla es información adicional sobre el mouse desde el <xref:System.Windows.Forms.SystemInformation> clase.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.SystemInformation.MouseHoverTime" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event EventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : EventHandler " Usage="member this.MouseLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el puntero del mouse deja el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los eventos del mouse se producen en el siguiente orden:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Los siguientes eventos no se generan para el <xref:System.Windows.Forms.TabControl> a menos que haya al menos una de las clases <xref:System.Windows.Forms.TabPage> en el <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> colección: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> y <xref:System.Windows.Forms.Control.MouseMove>. Si hay al menos un <xref:System.Windows.Forms.TabPage> en la colección, y el usuario interactúa con el encabezado del control de ficha (donde el <xref:System.Windows.Forms.TabPage> aparecen nombres), el <xref:System.Windows.Forms.TabControl> provoca el evento adecuado. Sin embargo, si la interacción del usuario está dentro del área de cliente de la página de ficha, el <xref:System.Windows.Forms.TabPage> provoca el evento adecuado.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar distintos eventos de mouse para dibujar la ruta de acceso del puntero del mouse en un <xref:System.Windows.Forms.Panel>. Un segmento de línea se agrega a la <xref:System.Drawing.Drawing2D.GraphicsPath> para cada <xref:System.Windows.Forms.Control.MouseMove> y <xref:System.Windows.Forms.Control.MouseDown> eventos que se producen. Para actualizar los gráficos, el <xref:System.Windows.Forms.Control.Invalidate%2A> se llama al método para el <xref:System.Windows.Forms.Panel> en cada `MouseDown` y `MouseUp` eventos. Además, la ruta de gráfico se desplaza hacia arriba o hacia abajo cuando la <xref:System.Windows.Forms.Control.MouseWheel> se produce el evento. Al igual que otros eventos de mouse, <xref:System.Windows.Forms.Control.MouseHover>, se identifican en pantalla también. También se muestra en la pantalla es información adicional sobre el mouse desde el <xref:System.Windows.Forms.SystemInformation> clase.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el puntero del mouse se mueve sobre el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los usos típicos de <xref:System.Windows.Forms.Control.MouseMove> son para cambiar el color del control o para pintar un rectángulo elevado alrededor del control.  
  
 Los eventos del mouse se producen en el siguiente orden:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Los siguientes eventos no se generan para el <xref:System.Windows.Forms.TabControl> a menos que haya al menos una de las clases <xref:System.Windows.Forms.TabPage> en el <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> colección: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> y <xref:System.Windows.Forms.Control.MouseMove>. Si hay al menos un <xref:System.Windows.Forms.TabPage> en la colección, y el usuario interactúa con el encabezado del control de ficha (donde el <xref:System.Windows.Forms.TabPage> aparecen nombres), el <xref:System.Windows.Forms.TabControl> provoca el evento adecuado. Sin embargo, si la interacción del usuario está dentro del área de cliente de la página de ficha, el <xref:System.Windows.Forms.TabPage> provoca el evento adecuado.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar distintos eventos de mouse para dibujar la ruta de acceso del puntero del mouse en un <xref:System.Windows.Forms.Panel>. Un segmento de línea se agrega a la <xref:System.Drawing.Drawing2D.GraphicsPath> para cada <xref:System.Windows.Forms.Control.MouseMove> y <xref:System.Windows.Forms.Control.MouseDown> eventos que se producen. Para actualizar los gráficos, el <xref:System.Windows.Forms.Control.Invalidate%2A> se llama al método para el <xref:System.Windows.Forms.Panel> en cada `MouseDown` y `MouseUp` eventos. Además, la ruta de gráfico se desplaza hacia arriba o hacia abajo cuando la <xref:System.Windows.Forms.Control.MouseWheel> se produce el evento. Al igual que otros eventos de mouse, <xref:System.Windows.Forms.Control.MouseHover>, se identifican en pantalla también. También se muestra en la pantalla es información adicional sobre el mouse desde el <xref:System.Windows.Forms.SystemInformation> clase.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MousePosition">
      <MemberSignature Language="C#" Value="public static System.Drawing.Point MousePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Point MousePosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MousePosition" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MousePosition As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Point MousePosition { System::Drawing::Point get(); };" />
      <MemberSignature Language="F#" Value="member this.MousePosition : System.Drawing.Point" Usage="System.Windows.Forms.Control.MousePosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la posición del cursor del mouse en coordenadas de pantalla.</summary>
        <value>
          <see cref="T:System.Drawing.Point" /> que contiene las coordenadas del cursor del mouse con relación a la esquina superior izquierda de la pantalla.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.MousePosition%2A> propiedad devuelve un <xref:System.Drawing.Point> que representa la posición del cursor del mouse en el momento en que se hace referencia a la propiedad. Las coordenadas indican la posición en la pantalla, no en relación con el control y se devuelven independientemente de si se coloca el cursor sobre el control. Las coordenadas de la esquina superior izquierda de la pantalla son 0,0.  
  
 El <xref:System.Windows.Forms.Control.MousePosition%2A> propiedad es idéntica a la <xref:System.Windows.Forms.Cursor.Position%2A?displayProperty=nameWithType> propiedad.  
  
   
  
## Examples  
 El siguiente código en el ejemplo se coloca un <xref:System.Windows.Forms.TreeNode> etiqueta en un estado modificable cuando el usuario presiona ALT + E mientras el cursor del mouse está sobre el nodo de árbol. Una vez realizado el usuario edita la etiqueta, las etiquetas no se puede editar otra vez hasta que se presione la combinación de teclas ALT + E de nuevo. En este ejemplo requiere que haya un <xref:System.Windows.Forms.TreeView> en un <xref:System.Windows.Forms.Form>. La vista de árbol debe tener al menos un <xref:System.Windows.Forms.TreeNode> en su <xref:System.Windows.Forms.TreeView.Nodes%2A> colección.  
  
 [!code-cpp[Windows.Forms.Control Members4#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members4#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#3)]
 [!code-vb[Windows.Forms.Control Members4#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseUp : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el puntero del mouse se encuentra sobre el control y se suelta un botón del mouse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los eventos del mouse se producen en el siguiente orden:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Los siguientes eventos no se generan para el <xref:System.Windows.Forms.TabControl> a menos que haya al menos una de las clases <xref:System.Windows.Forms.TabPage> en el <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> colección: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> y <xref:System.Windows.Forms.Control.MouseMove>. Si hay al menos un <xref:System.Windows.Forms.TabPage> en la colección, y el usuario interactúa con el encabezado del control de ficha (donde el <xref:System.Windows.Forms.TabPage> aparecen nombres), el <xref:System.Windows.Forms.TabControl> provoca el evento adecuado. Sin embargo, si la interacción del usuario está dentro del área de cliente de la página de ficha, el <xref:System.Windows.Forms.TabPage> provoca el evento adecuado.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar distintos eventos de mouse para dibujar la ruta de acceso del puntero del mouse en un <xref:System.Windows.Forms.Panel>. Un segmento de línea se agrega a la <xref:System.Drawing.Drawing2D.GraphicsPath> para cada <xref:System.Windows.Forms.Control.MouseMove> y <xref:System.Windows.Forms.Control.MouseDown> eventos que se producen. Para actualizar los gráficos, el <xref:System.Windows.Forms.Control.Invalidate%2A> se llama al método para el <xref:System.Windows.Forms.Panel> en cada `MouseDown` y `MouseUp` eventos. Además, la ruta de gráfico se desplaza hacia arriba o hacia abajo cuando la <xref:System.Windows.Forms.Control.MouseWheel> se produce el evento. Al igual que otros eventos de mouse, <xref:System.Windows.Forms.Control.MouseHover>, se identifican en pantalla también. También se muestra en la pantalla es información adicional sobre el mouse desde el <xref:System.Windows.Forms.SystemInformation> clase.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseWheel;" />
      <MemberSignature Language="F#" Value="member this.MouseWheel : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseWheel : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la rueda del mouse se mueve mientras el control tiene el foco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al controlar la <xref:System.Windows.Forms.Control.MouseWheel> eventos es importante seguir los estándares de interfaz (IU) del usuario asociados con la rueda del mouse. El <xref:System.Windows.Forms.MouseEventArgs.Delta%2A?displayProperty=nameWithType> valor de propiedad indica que se ha movido la rueda del mouse. La interfaz de usuario debe desplazarse cuando el incremento acumulado es más o menos 120. La interfaz de usuario debe desplazar el número de líneas lógicas devuelto por la <xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType> alcanza la propiedad para cada valor de incremento. También puede desplazarse más fácilmente en más pequeños incrementos de esa 120 unidad, la proporción debe permanecer constante, es decir <xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType> líneas desplazadas por cada 120 unidades de movimiento de la rueda.  
  
 Para obtener más información sobre el control de mensajes que la rueda del mouse, consulte la[WM_MOUSEWHEEL](http://msdn.microsoft.com/library/windows/desktop/ms645617\(v=vs.85\).aspx)tema.  
  
 Los eventos del mouse se producen en el siguiente orden:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar distintos eventos de mouse para dibujar la ruta de acceso del puntero del mouse en un <xref:System.Windows.Forms.Panel>. Un segmento de línea se agrega a la <xref:System.Drawing.Drawing2D.GraphicsPath> para cada <xref:System.Windows.Forms.Control.MouseMove> y <xref:System.Windows.Forms.Control.MouseDown> eventos que se producen. Para actualizar los gráficos, el <xref:System.Windows.Forms.Control.Invalidate%2A> se llama al método para el <xref:System.Windows.Forms.Panel> en cada `MouseDown` y `MouseUp` eventos. Además, la ruta de gráfico se desplaza hacia arriba o hacia abajo cuando la <xref:System.Windows.Forms.Control.MouseWheel> se produce el evento. Al igual que otros eventos de mouse, <xref:System.Windows.Forms.Control.MouseHover>, se identifican en pantalla también. También se muestra en la pantalla es información adicional sobre el mouse desde el <xref:System.Windows.Forms.SystemInformation> clase.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public event EventHandler Move;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Move" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Move" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Move As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Move;" />
      <MemberSignature Language="F#" Value="member this.Move : EventHandler " Usage="member this.Move : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se mueve el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.Move> eventos para mostrar la ubicación del formulario en coordenadas de pantalla en la barra de título del formulario.  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.Control.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del control.</summary>
        <value>Nombre del control. El valor predeterminado es una cadena vacía ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.Name%2A> propiedad se puede utilizar en tiempo de ejecución para evaluar el objeto por nombre en lugar de tipo y nombre de programación. Dado que el <xref:System.Windows.Forms.Control.Name%2A> propiedad devuelve un <xref:System.String> tipo, se puede evaluar en instrucciones lógicas (`Select` instrucción en Visual Basic, `switch` instrucción en Visual C# y [!INCLUDE[vcprvc](~/includes/vcprvc-md.md)]).  
  
   
  
## Examples  
 El siguiente código de ejemplo se muestra el <xref:System.Windows.Forms.Control.Name%2A> de un control en un <xref:System.Windows.Forms.MessageBox> cuando el control se agrega o quita de un formulario.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.ISite.Name" />
      </Docs>
    </Member>
    <Member MemberName="NotifyInvalidate">
      <MemberSignature Language="C#" Value="protected virtual void NotifyInvalidate (System.Drawing.Rectangle invalidatedArea);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void NotifyInvalidate(valuetype System.Drawing.Rectangle invalidatedArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.NotifyInvalidate(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub NotifyInvalidate (invalidatedArea As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void NotifyInvalidate(System::Drawing::Rectangle invalidatedArea);" />
      <MemberSignature Language="F#" Value="abstract member NotifyInvalidate : System.Drawing.Rectangle -&gt; unit&#xA;override this.NotifyInvalidate : System.Drawing.Rectangle -&gt; unit" Usage="control.NotifyInvalidate invalidatedArea" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidatedArea" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="invalidatedArea">
          <see cref="T:System.Drawing.Rectangle" /> que representa el área que se va a invalidar.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.Invalidated" /> con una región especificada del control para invalidar.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAutoSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAutoSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAutoSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAutoSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAutoSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAutoSizeChanged : EventArgs -&gt; unit&#xA;override this.OnAutoSizeChanged : EventArgs -&gt; unit" Usage="control.OnAutoSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.AutoSizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnAutoSizeChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackColorChanged : EventArgs -&gt; unit&#xA;override this.OnBackColorChanged : EventArgs -&gt; unit" Usage="control.OnBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.BackColorChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnBackColorChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundImageChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackgroundImageChanged : EventArgs -&gt; unit&#xA;override this.OnBackgroundImageChanged : EventArgs -&gt; unit" Usage="control.OnBackgroundImageChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnBackgroundImageChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundImageLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundImageLayoutChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackgroundImageLayoutChanged : EventArgs -&gt; unit&#xA;override this.OnBackgroundImageLayoutChanged : EventArgs -&gt; unit" Usage="control.OnBackgroundImageLayoutChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBindingContextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBindingContextChanged : EventArgs -&gt; unit&#xA;override this.OnBindingContextChanged : EventArgs -&gt; unit" Usage="control.OnBindingContextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.BindingContextChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnBindingContextChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BindingContext" />
      </Docs>
    </Member>
    <Member MemberName="OnCausesValidationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCausesValidationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCausesValidationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCausesValidationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCausesValidationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCausesValidationChanged : EventArgs -&gt; unit&#xA;override this.OnCausesValidationChanged : EventArgs -&gt; unit" Usage="control.OnCausesValidationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.CausesValidationChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnCausesValidationChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.CausesValidationChanged" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
      </Docs>
    </Member>
    <Member MemberName="OnChangeUICues">
      <MemberSignature Language="C#" Value="protected virtual void OnChangeUICues (System.Windows.Forms.UICuesEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChangeUICues(class System.Windows.Forms.UICuesEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChangeUICues (e As UICuesEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChangeUICues(System::Windows::Forms::UICuesEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnChangeUICues : System.Windows.Forms.UICuesEventArgs -&gt; unit&#xA;override this.OnChangeUICues : System.Windows.Forms.UICuesEventArgs -&gt; unit" Usage="control.OnChangeUICues e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.UICuesEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.UICuesEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.ChangeUICues" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnChangeUICues%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
        <altmember cref="T:System.Windows.Forms.UICues" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClick : EventArgs -&gt; unit&#xA;override this.OnClick : EventArgs -&gt; unit" Usage="control.OnClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.Click" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnClick%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El ejemplo de código siguiente se muestra cómo reemplazar el <xref:System.Windows.Forms.Control.OnClick%2A> método en una clase derivada. Para ejecutar el ejemplo, pegue el código siguiente después de una clase de formulario, en el mismo archivo. Agregar un cuadro de texto de tipo `SingleClickTextBox` al formulario.  
  
 [!code-cpp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/VB/form1.vb#1)]  
  
 El ejemplo de código siguiente muestra uno de los muchos usos de la <xref:System.Windows.Forms.Control.Click> evento y controlador de eventos.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Click" />
      </Docs>
    </Member>
    <Member MemberName="OnClientSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnClientSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClientSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClientSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClientSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClientSizeChanged : EventArgs -&gt; unit&#xA;override this.OnClientSizeChanged : EventArgs -&gt; unit" Usage="control.OnClientSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.ClientSizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnClientSizeChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuChanged : EventArgs -&gt; unit&#xA;override this.OnContextMenuChanged : EventArgs -&gt; unit" Usage="control.OnContextMenuChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.ContextMenuChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnContextMenuChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ContextMenuChanged" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuStripChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuStripChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuStripChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuStripChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuStripChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuStripChanged : EventArgs -&gt; unit&#xA;override this.OnContextMenuStripChanged : EventArgs -&gt; unit" Usage="control.OnContextMenuStripChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.ContextMenuStripChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnContextMenuStripChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnControlAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnControlAdded (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlAdded(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnControlAdded (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnControlAdded(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnControlAdded : System.Windows.Forms.ControlEventArgs -&gt; unit&#xA;override this.OnControlAdded : System.Windows.Forms.ControlEventArgs -&gt; unit" Usage="control.OnControlAdded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.ControlEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.ControlAdded" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama cuando se agrega un control secundario para el control.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnControlAdded%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.Control.ControlAdded> para agregar un control a un formulario y muestra el nombre del control se ha agregado en un <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ControlAdded" />
      </Docs>
    </Member>
    <Member MemberName="OnControlRemoved">
      <MemberSignature Language="C#" Value="protected virtual void OnControlRemoved (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlRemoved(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnControlRemoved (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnControlRemoved(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnControlRemoved : System.Windows.Forms.ControlEventArgs -&gt; unit&#xA;override this.OnControlRemoved : System.Windows.Forms.ControlEventArgs -&gt; unit" Usage="control.OnControlRemoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.ControlEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.ControlRemoved" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama cuando se quita un control secundario del control.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnControlRemoved%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.Control.ControlRemoved> para quitar un control de un formulario y muestra el nombre del control eliminado en un <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ControlRemoved" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected virtual void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCreateControl();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateControl : unit -&gt; unit&#xA;override this.OnCreateControl : unit -&gt; unit" Usage="control.OnCreateControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provoca el método <see cref="M:System.Windows.Forms.Control.CreateControl" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.OnCreateControl%2A> método se llama cuando el control se crea por primera vez.  
  
 El método <xref:System.Windows.Forms.Control.OnCreateControl%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
      </Docs>
    </Member>
    <Member MemberName="OnCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCursorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCursorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCursorChanged : EventArgs -&gt; unit&#xA;override this.OnCursorChanged : EventArgs -&gt; unit" Usage="control.OnCursorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.CursorChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnCursorChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.CursorChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="OnDockChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDockChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDockChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDockChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDockChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDockChanged : EventArgs -&gt; unit&#xA;override this.OnDockChanged : EventArgs -&gt; unit" Usage="control.OnDockChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.DockChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnDockChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DockChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
      </Docs>
    </Member>
    <Member MemberName="OnDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnDoubleClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoubleClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDoubleClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDoubleClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDoubleClick : EventArgs -&gt; unit&#xA;override this.OnDoubleClick : EventArgs -&gt; unit" Usage="control.OnDoubleClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.DoubleClick" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnDoubleClick%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.DoubleClick> eventos de un <xref:System.Windows.Forms.ListBox> para cargar los archivos de texto que aparece en el <xref:System.Windows.Forms.ListBox> en un <xref:System.Windows.Forms.TextBox> control.  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedAfterParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedAfterParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedAfterParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedAfterParent(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChangedAfterParent (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChangedAfterParent(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChangedAfterParent : EventArgs -&gt; unit&#xA;override this.OnDpiChangedAfterParent : EventArgs -&gt; unit" Usage="control.OnDpiChangedAfterParent e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.DpiChangedEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.DpiChangedAfterParent" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedBeforeParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedBeforeParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedBeforeParent(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChangedBeforeParent (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChangedBeforeParent(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChangedBeforeParent : EventArgs -&gt; unit&#xA;override this.OnDpiChangedBeforeParent : EventArgs -&gt; unit" Usage="control.OnDpiChangedBeforeParent e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.DpiChangedEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.DpiChangedBeforeParent" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDragDrop (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragDrop(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragDrop (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragDrop(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragDrop : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragDrop : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragDrop drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragDrop(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Objeto <see cref="T:System.Windows.Forms.DragEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.DragDrop" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnDragDrop%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragEnter (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragEnter(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragEnter drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragEnter(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Objeto <see cref="T:System.Windows.Forms.DragEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.DragEnter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnDragEnter%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : EventArgs -&gt; unit&#xA;override this.OnDragLeave : EventArgs -&gt; unit" Usage="control.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragLeave(System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.DragLeave" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnDragLeave%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragOver (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragOver(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragOver drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragOver(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Objeto <see cref="T:System.Windows.Forms.DragEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.DragOver" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnDragOver%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnabledChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEnabledChanged : EventArgs -&gt; unit&#xA;override this.OnEnabledChanged : EventArgs -&gt; unit" Usage="control.OnEnabledChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.EnabledChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnEnabledChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.EnabledChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnter(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEnter : EventArgs -&gt; unit&#xA;override this.OnEnter : EventArgs -&gt; unit" Usage="control.OnEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.Enter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnEnter%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.Enter> eventos para cambiar los colores de primer plano y fondo un <xref:System.Windows.Forms.TextBox> bajo ciertas condiciones.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFontChanged : EventArgs -&gt; unit&#xA;override this.OnFontChanged : EventArgs -&gt; unit" Usage="control.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.FontChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnFontChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnForeColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnForeColorChanged : EventArgs -&gt; unit&#xA;override this.OnForeColorChanged : EventArgs -&gt; unit" Usage="control.OnForeColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.ForeColorChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnForeColorChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.Forms.GiveFeedbackEventArgs gfbevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.Forms.GiveFeedbackEventArgs gfbevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGiveFeedback (gfbevent As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGiveFeedback(System::Windows::Forms::GiveFeedbackEventArgs ^ gfbevent);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.Forms.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.Forms.GiveFeedbackEventArgs -&gt; unit" Usage="control.OnGiveFeedback gfbevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gfbevent" Type="System.Windows.Forms.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="gfbevent">Objeto <see cref="T:System.Windows.Forms.GiveFeedbackEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.GiveFeedback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnGiveFeedback%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotFocus : EventArgs -&gt; unit&#xA;override this.OnGotFocus : EventArgs -&gt; unit" Usage="control.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.GotFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnGotFocus%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHandleCreated : EventArgs -&gt; unit&#xA;override this.OnHandleCreated : EventArgs -&gt; unit" Usage="control.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.HandleCreated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnHandleCreated%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.HandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHandleDestroyed : EventArgs -&gt; unit&#xA;override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="control.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.HandleDestroyed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnHandleDestroyed%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.HandleDestroyed" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnHelpRequested">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpRequested (System.Windows.Forms.HelpEventArgs hevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpRequested(class System.Windows.Forms.HelpEventArgs hevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHelpRequested (hevent As HelpEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHelpRequested(System::Windows::Forms::HelpEventArgs ^ hevent);" />
      <MemberSignature Language="F#" Value="abstract member OnHelpRequested : System.Windows.Forms.HelpEventArgs -&gt; unit&#xA;override this.OnHelpRequested : System.Windows.Forms.HelpEventArgs -&gt; unit" Usage="control.OnHelpRequested hevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hevent" Type="System.Windows.Forms.HelpEventArgs" />
      </Parameters>
      <Docs>
        <param name="hevent">Objeto <see cref="T:System.Windows.Forms.HelpEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.HelpRequested" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnHelpRequested%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.HelpRequested" />
      </Docs>
    </Member>
    <Member MemberName="OnImeModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnImeModeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeModeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnImeModeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnImeModeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnImeModeChanged : EventArgs -&gt; unit&#xA;override this.OnImeModeChanged : EventArgs -&gt; unit" Usage="control.OnImeModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.ImeModeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnImeModeChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ImeModeChanged" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="OnInvalidated">
      <MemberSignature Language="C#" Value="protected virtual void OnInvalidated (System.Windows.Forms.InvalidateEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInvalidated(class System.Windows.Forms.InvalidateEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInvalidated (e As InvalidateEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInvalidated(System::Windows::Forms::InvalidateEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInvalidated : System.Windows.Forms.InvalidateEventArgs -&gt; unit&#xA;override this.OnInvalidated : System.Windows.Forms.InvalidateEventArgs -&gt; unit" Usage="control.OnInvalidated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InvalidateEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.InvalidateEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.Invalidated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnInvalidated%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Invalidated" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyDown(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyDown : System.Windows.Forms.KeyEventArgs -&gt; unit&#xA;override this.OnKeyDown : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.KeyEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.KeyDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnKeyDown%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.KeyDown> evento para determinar el tipo de carácter especificado en el control.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyPress">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyPress (System.Windows.Forms.KeyPressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyPress(class System.Windows.Forms.KeyPressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyPress (e As KeyPressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyPress(System::Windows::Forms::KeyPressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyPress : System.Windows.Forms.KeyPressEventArgs -&gt; unit&#xA;override this.OnKeyPress : System.Windows.Forms.KeyPressEventArgs -&gt; unit" Usage="control.OnKeyPress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyPressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.KeyPressEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.KeyPress" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnKeyPress%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.KeyPress> eventos para evitar que los caracteres de escritura del control.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyUp(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyUp : System.Windows.Forms.KeyEventArgs -&gt; unit&#xA;override this.OnKeyUp : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.KeyEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.KeyUp" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnKeyUp%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.KeyUp> evento con el <xref:System.Windows.Forms.Help> clase para mostrar la Ayuda de estilo emergente al usuario.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected virtual void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLayout (levent As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLayout(System::Windows::Forms::LayoutEventArgs ^ levent);" />
      <MemberSignature Language="F#" Value="abstract member OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit&#xA;override this.OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit" Usage="control.OnLayout levent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">Objeto <see cref="T:System.Windows.Forms.LayoutEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.Layout" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnLayout%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> método para que los delegados registrados reciban el evento y para típico de acoplamiento y delimitación de funciones para trabajar. Las clases derivadas deben invalidar este método para realizar cualquier lógica de diseño personalizado.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="OnLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLeave : EventArgs -&gt; unit&#xA;override this.OnLeave : EventArgs -&gt; unit" Usage="control.OnLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.Leave" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnLeave%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.Leave> eventos para restablecer un control a su estado anterior.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Leave" />
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="control.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.LocationChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnLocationChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.LocationChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostFocus : EventArgs -&gt; unit&#xA;override this.OnLostFocus : EventArgs -&gt; unit" Usage="control.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.LostFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnLostFocus%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnMarginChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMarginChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMarginChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMarginChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMarginChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMarginChanged : EventArgs -&gt; unit&#xA;override this.OnMarginChanged : EventArgs -&gt; unit" Usage="control.OnMarginChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.MarginChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnMarginChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseCaptureChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseCaptureChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseCaptureChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseCaptureChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseCaptureChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseCaptureChanged : EventArgs -&gt; unit&#xA;override this.OnMouseCaptureChanged : EventArgs -&gt; unit" Usage="control.OnMouseCaptureChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.MouseCaptureChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnMouseCaptureChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseClick : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseClick : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.MouseEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.MouseClick" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnMouseClick%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDoubleClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDoubleClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDoubleClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDoubleClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDoubleClick : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseDoubleClick : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseDoubleClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.MouseEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.MouseDoubleClick" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnMouseDoubleClick%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDown (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDown(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.MouseEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.MouseDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnMouseDown%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseEnter(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : EventArgs -&gt; unit&#xA;override this.OnMouseEnter : EventArgs -&gt; unit" Usage="control.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.MouseEnter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnMouseEnter%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseEnter" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseHover">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseHover (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseHover(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseHover (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseHover(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseHover : EventArgs -&gt; unit&#xA;override this.OnMouseHover : EventArgs -&gt; unit" Usage="control.OnMouseHover e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.MouseHover" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnMouseHover%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo invalidar el <xref:System.Windows.Forms.Control.OnMouseHover%2A> y <xref:System.Windows.Forms.Control.OnMouseMove%2A> métodos en una clase derivada. Para ejecutar el ejemplo, pegue el código siguiente en un formulario nuevo y pegue esta clase, que forman el mismo archivo, después del formulario. Agregue un botón de tipo `FunButton` al formulario.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseHover" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : EventArgs -&gt; unit&#xA;override this.OnMouseLeave : EventArgs -&gt; unit" Usage="control.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.MouseLeave" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnMouseLeave%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseLeave" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseMove(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseMove : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseMove : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.MouseEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.MouseMove" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnMouseMove%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo invalidar el <xref:System.Windows.Forms.Control.OnMouseHover%2A> y <xref:System.Windows.Forms.Control.OnMouseMove%2A> métodos en una clase derivada. Para ejecutar el ejemplo, pegue el código siguiente en un formulario nuevo y pegue esta clase, que forman el mismo archivo, después del formulario. Agregue un botón de tipo `FunButton` al formulario.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseMove" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseUp (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseUp(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.MouseEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.MouseUp" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnMouseUp%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseWheel (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseWheel(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseWheel : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseWheel : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.MouseEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.MouseWheel" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnMouseWheel%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseWheel" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMove (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMove(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMove (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMove(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMove : EventArgs -&gt; unit&#xA;override this.OnMove : EventArgs -&gt; unit" Usage="control.OnMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.Move" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnMove%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.Move> eventos para mostrar la ubicación del formulario en coordenadas de pantalla en la barra de título del formulario.  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Move" />
      </Docs>
    </Member>
    <Member MemberName="OnNotifyMessage">
      <MemberSignature Language="C#" Value="protected virtual void OnNotifyMessage (System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNotifyMessage(valuetype System.Windows.Forms.Message m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNotifyMessage (m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNotifyMessage(System::Windows::Forms::Message m);" />
      <MemberSignature Language="F#" Value="abstract member OnNotifyMessage : System.Windows.Forms.Message -&gt; unit&#xA;override this.OnNotifyMessage : System.Windows.Forms.Message -&gt; unit" Usage="control.OnNotifyMessage m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" />
      </Parameters>
      <Docs>
        <param name="m">
          <see cref="T:System.Windows.Forms.Message" /> que representa el mensaje de Windows.</param>
        <summary>Notifica al control los mensajes de Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.OnNotifyMessage%2A> se llama al método si el control `EnableNotifyMessage` bit de estilo se establece <xref:System.Windows.Forms.ControlStyles>. El `EnableNotifyMessage` aplicar un estilo en <xref:System.Windows.Forms.ControlStyles> habilita el control que se le notifique cuando el <xref:System.Windows.Forms.Control.WndProc%2A> método recibe un mensaje de Windows. Con este método, los controles de confianza parcial pueden escuchar mensajes de Windows sin lo que les permite modificar el mensaje.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" /> en una clase derivada, una llamada a la clase base <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" /> método no es necesario porque no hay ninguna implementación inicial.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPaddingChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPaddingChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaddingChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaddingChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaddingChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPaddingChanged : EventArgs -&gt; unit&#xA;override this.OnPaddingChanged : EventArgs -&gt; unit" Usage="control.OnPaddingChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.PaddingChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnPaddingChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected virtual void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPaint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.PaintEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.Paint" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnPaint%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El ejemplo de código siguiente permite al usuario arrastrar una imagen o un archivo de imagen del formulario y se muestran en el punto en el que se quita. El <xref:System.Windows.Forms.Control.OnPaint%2A> se invalida el método para volver a dibujar la imagen cada vez que se pinta el formulario; en caso contrario, la imagen sólo se conserva hasta la siguiente operación de dibujo. El <xref:System.Windows.Forms.Control.DragEnter> método de control de eventos determina el tipo de datos que se arrastran al formulario y proporciona la información apropiada. El <xref:System.Windows.Forms.Control.DragDrop> método de control de eventos muestra la imagen en el formulario, si un <xref:System.Drawing.Image> pueden crearse a partir de los datos. Dado que el <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> y <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> los valores son las coordenadas de pantalla, el ejemplo se usa el <xref:System.Windows.Forms.Control.PointToClient%2A> método convertirlos a coordenadas de cliente.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="OnPaintBackground">
      <MemberSignature Language="C#" Value="protected virtual void OnPaintBackground (System.Windows.Forms.PaintEventArgs pevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaintBackground(class System.Windows.Forms.PaintEventArgs pevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaintBackground (pevent As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaintBackground(System::Windows::Forms::PaintEventArgs ^ pevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPaintBackground : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPaintBackground : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPaintBackground pevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pevent" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="pevent">
          <see cref="T:System.Windows.Forms.PaintEventArgs" /> que contiene información sobre el control que se va a pintar.</param>
        <summary>Pinta el fondo del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.OnPaintBackground%2A> método permite que las clases derivadas controlen en segundo plano de Windows borrar las solicitudes.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Las clases herederas deben invalidar este método para controlar la solicitud de borrado en segundo plano de windows. Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" /> en una clase derivada no es necesario llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBackColorChanged : EventArgs -&gt; unit&#xA;override this.OnParentBackColorChanged : EventArgs -&gt; unit" Usage="control.OnParentBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento <see cref="E:System.Windows.Forms.Control.BackColorChanged" /> cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.BackColor" /> del contenedor del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnParentBackColorChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBackgroundImageChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBackgroundImageChanged : EventArgs -&gt; unit&#xA;override this.OnParentBackgroundImageChanged : EventArgs -&gt; unit" Usage="control.OnParentBackgroundImageChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /> cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> del contenedor del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnParentBackgroundImageChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBindingContextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBindingContextChanged : EventArgs -&gt; unit&#xA;override this.OnParentBindingContextChanged : EventArgs -&gt; unit" Usage="control.OnParentBindingContextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento <see cref="E:System.Windows.Forms.Control.BindingContextChanged" /> cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.BindingContext" /> del contenedor del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnParentBindingContextChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentChanged : EventArgs -&gt; unit&#xA;override this.OnParentChanged : EventArgs -&gt; unit" Usage="control.OnParentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.ParentChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnParentChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ParentChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentCursorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentCursorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentCursorChanged : EventArgs -&gt; unit&#xA;override this.OnParentCursorChanged : EventArgs -&gt; unit" Usage="control.OnParentCursorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.CursorChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnParentCursorChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentEnabledChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentEnabledChanged : EventArgs -&gt; unit&#xA;override this.OnParentEnabledChanged : EventArgs -&gt; unit" Usage="control.OnParentEnabledChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento <see cref="E:System.Windows.Forms.Control.EnabledChanged" /> cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.Enabled" /> del contenedor del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnParentEnabledChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.EnabledChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentFontChanged : EventArgs -&gt; unit&#xA;override this.OnParentFontChanged : EventArgs -&gt; unit" Usage="control.OnParentFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento <see cref="E:System.Windows.Forms.Control.FontChanged" /> cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.Font" /> del contenedor del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnParentFontChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentForeColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentForeColorChanged : EventArgs -&gt; unit&#xA;override this.OnParentForeColorChanged : EventArgs -&gt; unit" Usage="control.OnParentForeColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento <see cref="E:System.Windows.Forms.Control.ForeColorChanged" /> cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.ForeColor" /> del contenedor del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnParentForeColorChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentRightToLeftChanged : EventArgs -&gt; unit&#xA;override this.OnParentRightToLeftChanged : EventArgs -&gt; unit" Usage="control.OnParentRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /> cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.RightToLeft" /> del contenedor del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnParentRightToLeftChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.RightToLeftChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentVisibleChanged : EventArgs -&gt; unit&#xA;override this.OnParentVisibleChanged : EventArgs -&gt; unit" Usage="control.OnParentVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento <see cref="E:System.Windows.Forms.Control.VisibleChanged" /> cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.Visible" /> del contenedor del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnParentVisibleChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Forms.PreviewKeyDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Forms.PreviewKeyDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewKeyDown (e As PreviewKeyDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewKeyDown(System::Windows::Forms::PreviewKeyDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventArgs -&gt; unit&#xA;override this.OnPreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventArgs -&gt; unit" Usage="control.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PreviewKeyDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.PreviewKeyDownEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.PreviewKeyDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnPreviewKeyDown%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPrint">
      <MemberSignature Language="C#" Value="protected virtual void OnPrint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPrint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPrint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPrint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPrint : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPrint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPrint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.PaintEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.Paint" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `UserPaint` de bits de la <xref:System.Windows.Forms.ControlStyles> está establecido, se puede reemplazar <xref:System.Windows.Forms.Control.OnPrint%2A> hacer dibujar en capas. Vea <xref:System.Windows.Forms.Control.SetStyle%2A> para obtener más información.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="e" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.Forms.QueryContinueDragEventArgs qcdevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.Forms.QueryContinueDragEventArgs qcdevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnQueryContinueDrag (qcdevent As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnQueryContinueDrag(System::Windows::Forms::QueryContinueDragEventArgs ^ qcdevent);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryContinueDrag : System.Windows.Forms.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnQueryContinueDrag : System.Windows.Forms.QueryContinueDragEventArgs -&gt; unit" Usage="control.OnQueryContinueDrag qcdevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qcdevent" Type="System.Windows.Forms.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="qcdevent">Objeto <see cref="T:System.Windows.Forms.QueryContinueDragEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.QueryContinueDrag" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una vez iniciada la operación de arrastre, este método se llama varias veces en el [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] hasta que se cancela o finaliza la operación de arrastre.  
  
> [!NOTE]
>  Invalide este método si desea cambiar el punto en que se cancela el arrastre o en que se produce una colocación.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnQueryContinueDrag%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnRegionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRegionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRegionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRegionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRegionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRegionChanged : EventArgs -&gt; unit&#xA;override this.OnRegionChanged : EventArgs -&gt; unit" Usage="control.OnRegionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.RegionChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.Control.OnRegionChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected virtual void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResize(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResize : EventArgs -&gt; unit&#xA;override this.OnResize : EventArgs -&gt; unit" Usage="control.OnResize e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.Resize" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnResize%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> método para que los delegados registrados reciban el evento. El <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> método se puede llamar durante la construcción, por lo que si se reemplaza <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> puede llamarse antes de que se llama al constructor del control.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRightToLeftChanged : EventArgs -&gt; unit&#xA;override this.OnRightToLeftChanged : EventArgs -&gt; unit" Usage="control.OnRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnRightToLeftChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.RightToLeftChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSizeChanged : EventArgs -&gt; unit&#xA;override this.OnSizeChanged : EventArgs -&gt; unit" Usage="control.OnSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.SizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnSizeChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStyleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : EventArgs -&gt; unit&#xA;override this.OnStyleChanged : EventArgs -&gt; unit" Usage="control.OnStyleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.StyleChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnStyleChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.StyleChanged" />
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnSystemColorsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSystemColorsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSystemColorsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSystemColorsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSystemColorsChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSystemColorsChanged : EventArgs -&gt; unit&#xA;override this.OnSystemColorsChanged : EventArgs -&gt; unit" Usage="control.OnSystemColorsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.SystemColorsChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnSystemColorsChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.SystemColorsChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTabIndexChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabIndexChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabIndexChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTabIndexChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTabIndexChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTabIndexChanged : EventArgs -&gt; unit&#xA;override this.OnTabIndexChanged : EventArgs -&gt; unit" Usage="control.OnTabIndexChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.TabIndexChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnTabIndexChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.TabIndexChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTabStopChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabStopChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabStopChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTabStopChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTabStopChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTabStopChanged : EventArgs -&gt; unit&#xA;override this.OnTabStopChanged : EventArgs -&gt; unit" Usage="control.OnTabStopChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.TabStopChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnTabStopChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.TabStopChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextChanged : EventArgs -&gt; unit&#xA;override this.OnTextChanged : EventArgs -&gt; unit" Usage="control.OnTextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.TextChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnTextChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.TextChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnValidated">
      <MemberSignature Language="C#" Value="protected virtual void OnValidated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnValidated : EventArgs -&gt; unit&#xA;override this.OnValidated : EventArgs -&gt; unit" Usage="control.OnValidated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.Validated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnValidated%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="OnValidating">
      <MemberSignature Language="C#" Value="protected virtual void OnValidating (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidating(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidating (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidating(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnValidating : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnValidating : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="control.OnValidating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.ComponentModel.CancelEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.Validating" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnValidating%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnVisibleChanged : EventArgs -&gt; unit&#xA;override this.OnVisibleChanged : EventArgs -&gt; unit" Usage="control.OnVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.VisibleChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El <xref:System.Windows.Forms.Control.OnVisibleChanged%2A> método también permite que las clases derivadas controlen el evento sin asociar un delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 El siguiente ejemplo de código es un método de generación de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre `On` *PropertyName* `Changed` que genere las correspondientes *PropertyName* `Changed` eventos cuando el *PropertyName* cambia el valor (*PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda de clase derivada. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que tenga una clase que deriva la <xref:System.Windows.Forms.TextBox> clase.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Show" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Padding { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Padding : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.Control.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el relleno dentro del control.</summary>
        <value>
          <see cref="T:System.Windows.Forms.Padding" /> que representa las características del espaciado interno del control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para contenedores como <xref:System.Windows.Forms.GroupBox> y <xref:System.Windows.Forms.TabControl>, <xref:System.Windows.Forms.Control.Padding%2A> propiedad obtiene o establece sus respectivas <xref:System.Windows.Forms.Control.DisplayRectangle%2A> propiedades. El <xref:System.Windows.Forms.ScrollableControl.DockPadding%2A?displayProperty=nameWithType> propiedad es igual a su <xref:System.Windows.Forms.Control.Padding%2A?displayProperty=nameWithType> propiedad.  
  
 Los valores predeterminados para los controles reciben <xref:System.Windows.Forms.Control.Padding%2A> que están bastante cerca de directrices de interfaz de usuario de Windows. Pueden que algunos ajustes que sea necesarios para aplicaciones concretas.  
  
 Todos los controles que implementan <xref:System.Windows.Forms.Control.GetPreferredSize%2A> se amplía en la cantidad de <xref:System.Windows.Forms.Control.Padding%2A> cuando <xref:System.Windows.Forms.Control.AutoSize%2A> es `true`.  
  
 No use los siguientes controles <xref:System.Windows.Forms.Control.Padding%2A>:  
  
-   Los controles que no implementan <xref:System.Windows.Forms.Control.AutoSize%2A> a través de <xref:System.Windows.Forms.Control.GetPreferredSize%2A>  
  
-   Controles personalizados que heredan directamente de <xref:System.Windows.Forms.Control>  
  
-   <xref:System.Windows.Forms.AxHost>  
  
-   <xref:System.Windows.Forms.ComboBox>  
  
-   <xref:System.Windows.Forms.DataGridView>  
  
-   <xref:System.Windows.Forms.DateTimePicker>  
  
-   <xref:System.Windows.Forms.HScrollBar>  
  
-   <xref:System.Windows.Forms.ListView>  
  
-   <xref:System.Windows.Forms.MaskedTextBox>  
  
-   <xref:System.Windows.Forms.MonthCalendar>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.PropertyGrid>  
  
-   <xref:System.Windows.Forms.RichTextBox>  
  
-   <xref:System.Windows.Forms.SplitContainer>  
  
-   <xref:System.Windows.Forms.TextBox>  
  
-   <xref:System.Windows.Forms.TextBoxBase>  
  
-   <xref:System.Windows.Forms.TreeView>  
  
-   <xref:System.Windows.Forms.VScrollBar>  
  
-   <xref:System.Windows.Forms.WebBrowser>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PaddingChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaddingChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PaddingChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PaddingChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PaddingChanged;" />
      <MemberSignature Language="F#" Value="member this.PaddingChanged : EventHandler " Usage="member this.PaddingChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el relleno del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.PaddingChanged> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.PaddingChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#41](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#41)]
 [!code-vb[System.Windows.Forms.EventExamples#41](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#41)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PaintEventHandler Paint;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PaintEventHandler Paint" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Paint" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Paint As PaintEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PaintEventHandler ^ Paint;" />
      <MemberSignature Language="F#" Value="member this.Paint : System.Windows.Forms.PaintEventHandler " Usage="member this.Paint : System.Windows.Forms.PaintEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PaintEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando vuelve a dibujarse el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.Paint> evento se produce cuando se vuelve a dibujar el control. Pasa una instancia de <xref:System.Windows.Forms.PaintEventArgs> a los métodos que controla la <xref:System.Windows.Forms.Control.Paint> eventos.  
  
 Al crear un nuevo control personalizado o un control heredado con una apariencia visual diferente, debe proporcionar código para representar el control invalidando el <xref:System.Windows.Forms.Control.OnPaint%2A> método. Para obtener más información, consulte [reemplazar el método OnPaint](~/docs/framework/winforms/controls/overriding-the-onpaint-method.md) y [Custom Control Painting and Rendering](~/docs/framework/winforms/controls/custom-control-painting-and-rendering.md).  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Windows.Forms.PictureBox> control en el formulario y usa el <xref:System.Windows.Forms.Control.Paint> eventos para dibujarlo.  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control Parent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Property Parent As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ Parent { System::Windows::Forms::Control ^ get(); void set(System::Windows::Forms::Control ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.Control with get, set" Usage="System.Windows.Forms.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el contenedor primario del control.</summary>
        <value>
          <see cref="T:System.Windows.Forms.Control" /> que representa el control primario o el control contenedor del control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer el <xref:System.Windows.Forms.Control.Parent%2A> valor de propiedad `null` quita el control de la <xref:System.Windows.Forms.Control.ControlCollection> de su control primario actual.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.Parent%2A> propiedad y el <xref:System.Windows.Forms.Control.FindForm%2A> método para establecer propiedades en el control primario de un botón y su formulario.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas obtener este valor de propiedad. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ParentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ParentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ParentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ParentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ParentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ParentChanged;" />
      <MemberSignature Language="F#" Value="member this.ParentChanged : EventHandler " Usage="member this.ParentChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.Parent" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.Parent%2A> propiedad se modifica mediante programación o interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PerformLayout">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obliga al control a aplicar la lógica de diseño a los controles secundarios.</summary>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </MemberGroup>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout();" />
      <MemberSignature Language="F#" Value="member this.PerformLayout : unit -&gt; unit" Usage="control.PerformLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obliga al control a aplicar la lógica de diseño a todos sus controles secundarios.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Forms.Control.SuspendLayout%2A> se llamó al método antes de llamar a la <xref:System.Windows.Forms.Control.PerformLayout%2A> método, el <xref:System.Windows.Forms.Control.Layout> se suprime el evento.  
  
 El <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A> y <xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A> propiedades de la <xref:System.Windows.Forms.LayoutEventArgs> creado están configurados para `null` si se proporcionó ningún valor cuando el <xref:System.Windows.Forms.Control.PerformLayout%2A> se llamó al método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el método <xref:System.Windows.Forms.Control.PerformLayout%2A>. También muestra las formas en que el <xref:System.Windows.Forms.Control.Layout> provoca el evento. En este ejemplo, el `Click` controlador de eventos para `Button1` llama explícitamente a <xref:System.Windows.Forms.Control.PerformLayout%2A>. El `Click` controlador de eventos para `Button2` llama implícitamente a <xref:System.Windows.Forms.Control.PerformLayout%2A>. <xref:System.Windows.Forms.Control.PerformLayout%2A> También se llama cuando se carga el formulario. `Button3` Devuelve el control al estado que estaba cuando se cargó. En cada caso, el <xref:System.Windows.Forms.Control.Layout> provoca el evento.  
  
 Esto es un ejemplo completo. Para ejecutar el ejemplo, pegue el código siguiente en un formulario en blanco.  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout (System.Windows.Forms.Control affectedControl, string affectedProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout(class System.Windows.Forms.Control affectedControl, string affectedProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout (affectedControl As Control, affectedProperty As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout(System::Windows::Forms::Control ^ affectedControl, System::String ^ affectedProperty);" />
      <MemberSignature Language="F#" Value="member this.PerformLayout : System.Windows.Forms.Control * string -&gt; unit" Usage="control.PerformLayout (affectedControl, affectedProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="affectedControl" Type="System.Windows.Forms.Control" />
        <Parameter Name="affectedProperty" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="affectedControl">
          <see cref="T:System.Windows.Forms.Control" /> que representa al control modificado más recientemente.</param>
        <param name="affectedProperty">Nombre de propiedad modificada más recientemente en el control.</param>
        <summary>Obliga al control a aplicar la lógica de diseño a todos sus controles secundarios.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Forms.Control.SuspendLayout%2A> se llamó al método antes de llamar a la <xref:System.Windows.Forms.Control.PerformLayout%2A> método, el <xref:System.Windows.Forms.Control.Layout> se suprime el evento.  
  
 El `affectedControl` y `affectedProperty` parámetros pueden establecerse en ambos casos `null`. Si lo hace el <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A> y <xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A> propiedades de la <xref:System.Windows.Forms.LayoutEventArgs> creado para establecerse en `null`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el método <xref:System.Windows.Forms.Control.PerformLayout%2A>. También muestra las formas en que el <xref:System.Windows.Forms.Control.Layout> provoca el evento. En este ejemplo, el `Click` controlador de eventos para `Button1` llama explícitamente a <xref:System.Windows.Forms.Control.PerformLayout%2A>. El `Click` controlador de eventos para `Button2` llama implícitamente a <xref:System.Windows.Forms.Control.PerformLayout%2A>. <xref:System.Windows.Forms.Control.PerformLayout%2A> También se llama cuando se carga el formulario. `Button3` Devuelve el control al estado que estaba cuando se cargó. En cada caso, el <xref:System.Windows.Forms.Control.Layout> provoca el evento.  
  
 Esto es un ejemplo completo. Para ejecutar el ejemplo, pegue el código siguiente en un formulario en blanco.  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="PointToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToClient (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToClient(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function PointToClient (p As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point PointToClient(System::Drawing::Point p);" />
      <MemberSignature Language="F#" Value="member this.PointToClient : System.Drawing.Point -&gt; System.Drawing.Point" Usage="control.PointToClient p" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">
          <see cref="T:System.Drawing.Point" /> en coordenadas de pantalla que se va a convertir.</param>
        <summary>Calcula la ubicación del punto especificado de la pantalla, en coordenadas de cliente.</summary>
        <returns>
          <see cref="T:System.Drawing.Point" /> que representa el <see cref="T:System.Drawing.Point" /> convertido, <paramref name="p" />, en coordenadas de cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Habilita de ejemplo de código siguiente se quita al usuario arrastrar una imagen o un archivo de imagen del formulario y se muestra en el punto. El <xref:System.Windows.Forms.Control.OnPaint%2A> se invalida el método para volver a dibujar la imagen cada vez que se pinta el formulario; en caso contrario, la imagen sólo se conserva hasta la siguiente operación de dibujo. El <xref:System.Windows.Forms.Control.DragEnter> método de control de eventos determina el tipo de datos que se arrastran al formulario y proporciona la información apropiada. El <xref:System.Windows.Forms.Control.DragDrop> método de control de eventos muestra la imagen en el formulario, si un <xref:System.Drawing.Image> pueden crearse a partir de los datos. Dado que el <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> y <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> los valores son las coordenadas de pantalla, el ejemplo se usa el <xref:System.Windows.Forms.Control.PointToClient%2A> método convertirlos a coordenadas de cliente.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="PointToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToScreen (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToScreen(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function PointToScreen (p As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point PointToScreen(System::Drawing::Point p);" />
      <MemberSignature Language="F#" Value="member this.PointToScreen : System.Drawing.Point -&gt; System.Drawing.Point" Usage="control.PointToScreen p" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">
          <see cref="T:System.Drawing.Point" /> en coordenadas de cliente que se va a convertir.</param>
        <summary>Calcula la ubicación del punto especificado de cliente en coordenadas de pantalla.</summary>
        <returns>
          <see cref="T:System.Drawing.Point" /> que representa el <see cref="T:System.Drawing.Point" /> convertido, <paramref name="p" />, en coordenadas de pantalla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>, y <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> miembros. Para ejecutar el ejemplo, pegue el código siguiente en un formulario denominado Form1 que contiene varios controles. Este ejemplo requiere que el <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, y <xref:System.Windows.Forms.Control.MouseUp> eventos están conectados a los controladores de eventos definidos en el ejemplo.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="PreferredSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size PreferredSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size PreferredSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PreferredSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size PreferredSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.PreferredSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño de un área rectangular en la que cabe el control.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> que contiene el alto y el ancho, en píxeles.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessControlMessage">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.PreProcessControlState PreProcessControlMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.PreProcessControlState PreProcessControlMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessControlMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function PreProcessControlMessage (ByRef msg As Message) As PreProcessControlState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::PreProcessControlState PreProcessControlMessage(System::Windows::Forms::Message % msg);" />
      <MemberSignature Language="F#" Value="member this.PreProcessControlMessage :  -&gt; System.Windows.Forms.PreProcessControlState" Usage="control.PreProcessControlMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreProcessControlState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="msg">
          <see cref="T:System.Windows.Forms.Message" /> que representa el mensaje que se va a procesar.</param>
        <summary>Preprocesa los mensajes de teclado o de entrada en el bucle de mensajes antes de enviarlos.</summary>
        <returns>Uno de los valores de <see cref="T:System.Windows.Forms.PreProcessControlState" />, en función de si <see cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" /> es <see langword="true" /> o <see langword="false" /> y si <see cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" /> o <see cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" /> son <see langword="true" /> o <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessMessage">
      <MemberSignature Language="C#" Value="public virtual bool PreProcessMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PreProcessMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PreProcessMessage (ByRef msg As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PreProcessMessage(System::Windows::Forms::Message % msg);" />
      <MemberSignature Language="F#" Value="abstract member PreProcessMessage :  -&gt; bool&#xA;override this.PreProcessMessage :  -&gt; bool" Usage="control.PreProcessMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="msg">
          <see cref="T:System.Windows.Forms.Message" /> que se pasa por referencia y que representa el mensaje que se va a procesar. Los valores posibles son WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR y WM_SYSCHAR.</param>
        <summary>Preprocesa los mensajes de teclado o de entrada en el bucle de mensajes antes de enviarlos.</summary>
        <returns>
          <see langword="true" /> si el control procesó el mensaje; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.PreProcessMessage%2A> se llama al bucle de mensajes de la aplicación para preprocesar los mensajes de entrada antes de enviarlos. Los valores posibles para el `msg` parámetro son WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR y WM_SYSCHAR.  
  
 Cuando se reemplaza <xref:System.Windows.Forms.Control.PreProcessMessage%2A>, debe devolver un control `true` para indicar que ha procesado el mensaje. Para los mensajes que no son procesados por el control, el resultado de `base.PreProcessMessage` se deben devolver. Controles reemplazarán normalmente uno de los métodos más especializados como <xref:System.Windows.Forms.Control.IsInputChar%2A>, <xref:System.Windows.Forms.Control.IsInputKey%2A>, <xref:System.Windows.Forms.Control.ProcessCmdKey%2A>, <xref:System.Windows.Forms.Control.ProcessDialogChar%2A>, o <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> en lugar de reemplazar <xref:System.Windows.Forms.Control.PreProcessMessage%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas para que el llamador inmediato llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As PreviewKeyDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PreviewKeyDownEventHandler ^ PreviewKeyDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventHandler " Usage="member this.PreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreviewKeyDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce antes que el evento <see cref="E:System.Windows.Forms.Control.KeyDown" /> cuando se presiona una tecla mientras el foco está en este control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunos controles normalmente omite algunas pulsaciones de teclas, por ejemplo, la ficha, si la devolución, ESC y teclas de dirección porque no se consideran presiones de tecla de entrada. Por ejemplo, de forma predeterminada, un <xref:System.Windows.Controls.Button> control ignora las teclas de dirección. Al presionar las teclas de dirección normalmente hace que el foco se desplace al control anterior o siguiente. Las teclas de dirección se consideran teclas de navegación y presionar estas claves normalmente no provocan la <xref:System.Windows.Forms.Control.KeyDown> eventos para un <xref:System.Windows.Controls.Button>. Sin embargo, al presionar la flecha de claves para un <xref:System.Windows.Controls.Button> elevar el <xref:System.Windows.Forms.Control.PreviewKeyDown> eventos. Controlando la <xref:System.Windows.Forms.Control.PreviewKeyDown> eventos para un <xref:System.Windows.Controls.Button> y configuración de la <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> propiedad a `true`, puede elevar la <xref:System.Windows.Forms.Control.KeyDown> eventos cuando se presionan las teclas de flecha. Sin embargo, si administra las teclas de dirección, ya no se moverá el foco al control anterior o siguiente.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra un <xref:System.Windows.Forms.Button> que incluye un <xref:System.Windows.Forms.ContextMenuStrip>. Cuando el <xref:System.Windows.Forms.Button> tiene el foco y presione las teclas flecha arriba o flecha abajo, el <xref:System.Windows.Forms.ContextMenuStrip> aparece. El <xref:System.Windows.Forms.Control.PreviewKeyDown> controlador de eventos detecta cuando se presionan las teclas flecha arriba o flecha abajo y establece el <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> propiedad `true`. Esto provoca la <xref:System.Windows.Forms.Control.KeyDown> eventos para que pueda mostrar el <xref:System.Windows.Forms.ContextMenuStrip>. No debe incluir cualquier lógica el <xref:System.Windows.Forms.Control.PreviewKeyDown> controlador de eventos, sí que la configuración de la <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> propiedad. En su lugar, debe colocar la lógica el <xref:System.Windows.Forms.Control.KeyDown> controlador de eventos.  
  
 [!code-csharp[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/vb/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool&#xA;override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="control.ProcessCmdKey (msg, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">
          <see cref="T:System.Windows.Forms.Message" /> que se pasa por referencia y que representa el mensaje de ventana que se va a procesar.</param>
        <param name="keyData">Uno de los valores de <see cref="T:System.Windows.Forms.Keys" /> que representa la tecla que se va a procesar.</param>
        <summary>Procesa una tecla de comando.</summary>
        <returns>
          <see langword="true" /> si el control procesó el carácter; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama durante el preprocesamiento de mensajes para controlar las teclas de comando. Teclas de comando son claves que siempre tienen prioridad sobre las teclas de entrada normales. Algunos ejemplos de las teclas de comando son los aceleradores y accesos directos del menú. El método debe devolver `true` para indicar que procesó la tecla de comando, o `false` para indicar que la clave no es una tecla de comando. Este método solo se llama cuando el control se hospeda en una aplicación de Windows Forms o como un control ActiveX.  
  
 El <xref:System.Windows.Forms.Control.ProcessCmdKey%2A> método determina si el control tiene un <xref:System.Windows.Forms.ContextMenu>y si es así, permite la <xref:System.Windows.Forms.ContextMenu> para procesar la tecla de comando. Si la tecla de comando no es un acceso directo del menú y el control tiene un elemento primario, la clave se pasa a la principal <xref:System.Windows.Forms.Control.ProcessCmdKey%2A> método. El efecto neto es que ese comando claves hacen una "burbuja" por la jerarquía de controles. Además de la clave que el usuario ha presionado, los datos de clave indican también que, si los hay, las teclas modificadoras se presionaron al mismo tiempo que la clave. Teclas modificadoras incluyen las teclas MAYÚS, CTRL y ALT.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para el llamador inmediato y las clases herederas llamar a este método. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" /> método en una clase derivada, debe devolver un control <see langword="true" /> para indicar que ha procesado la clave. Para las claves que no son procesadas por el control, el resultado de llamar a la clase base <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" /> método se debe devolver. Controles rara vez, si alguna vez, debe invalidar este método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessDialogChar(char charCode);" />
      <MemberSignature Language="F#" Value="abstract member ProcessDialogChar : char -&gt; bool&#xA;override this.ProcessDialogChar : char -&gt; bool" Usage="control.ProcessDialogChar charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Carácter que se va a procesar.</param>
        <summary>Procesa un carácter de diálogo.</summary>
        <returns>
          <see langword="true" /> si el control procesó el carácter; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama durante el preprocesamiento de mensajes para controlar los caracteres del cuadro de diálogo, como teclas de acceso de control. Se llama a este método solo si el <xref:System.Windows.Forms.Control.IsInputChar%2A> método indica que el control no está procesando el carácter. El <xref:System.Windows.Forms.Control.ProcessDialogChar%2A> método simplemente envía el carácter a la principal <xref:System.Windows.Forms.Control.ProcessDialogChar%2A> método, o se devuelve `false` si el control no tiene ningún elemento primario. La <xref:System.Windows.Forms.Form> clase reemplaza este método para llevar a cabo el procesamiento real de caracteres del cuadro de diálogo. Este método solo se llama cuando el control se hospeda en una aplicación de Windows Forms o como un control ActiveX.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas para la herencia de clases para llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> método en una clase derivada, debe devolver un control <see langword="true" /> para indicar que ha procesado el carácter. Para los caracteres que no son procesados por el control, el resultado de llamar a la clase base <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> método se debe devolver. Controles rara vez, si alguna vez, debe invalidar este método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool&#xA;override this.ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool" Usage="control.ProcessDialogKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Uno de los valores de <see cref="T:System.Windows.Forms.Keys" /> que representa la tecla que se va a procesar.</param>
        <summary>Procesa una tecla de diálogo.</summary>
        <returns>
          <see langword="true" /> si el control procesó la tecla; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama durante el preprocesamiento de mensajes para controlar los caracteres del cuadro de diálogo, como las teclas de flecha, la devolución, ESC y PESTAÑA. Se llama a este método solo si el <xref:System.Windows.Forms.Control.IsInputKey%2A> método indica que el control no está procesando la clave. El <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> simplemente envía el carácter a la principal <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> método, o se devuelve `false` si el control no tiene ningún elemento primario. La <xref:System.Windows.Forms.Form> clase reemplaza este método para realizar el procesamiento de las claves del cuadro de diálogo. Este método solo se llama cuando el control se hospeda en una aplicación de Windows Forms o como un control ActiveX.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas para la herencia de clases para llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" /> método en una clase derivada, debe devolver un control <see langword="true" /> para indicar que ha procesado la clave. Para las claves que no son procesadas por el control, el resultado de llamar a la clase base <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> método se debe devolver. Controles rara vez, si alguna vez, debe invalidar este método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyEventArgs">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyEventArgs (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyEventArgs(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessKeyEventArgs (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessKeyEventArgs(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyEventArgs :  -&gt; bool&#xA;override this.ProcessKeyEventArgs :  -&gt; bool" Usage="control.ProcessKeyEventArgs m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">
          <see cref="T:System.Windows.Forms.Message" /> que se pasa por referencia y que representa el mensaje de ventana que se va a procesar.</param>
        <summary>Procesa un mensaje de tecla y genera los eventos de control correspondientes.</summary>
        <returns>
          <see langword="true" /> si el control procesó el mensaje; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama cuando un control recibe un mensaje del teclado. El método es responsable de generar los eventos clave adecuados para el mensaje mediante una llamada a la <xref:System.Windows.Forms.Control.OnKeyPress%2A>, <xref:System.Windows.Forms.Control.OnKeyDown%2A>, o <xref:System.Windows.Forms.Control.OnKeyUp%2A> métodos. El `m` parámetro contiene el mensaje de ventana que se debe procesar. Los valores posibles para el <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> propiedad son WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP, WM_SYSKEYUP y WM_IME_CHAR.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas para la herencia de clases para llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para que el llamador inmediato llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> método en una clase derivada, debe devolver un control <see langword="true" /> para indicar que ha procesado la clave. Para las claves que no son procesadas por el control, el resultado de llamar a la clase base <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> método se debe devolver. Controles rara vez, si alguna vez, debe invalidar este método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyMessage">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessKeyMessage (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessKeyMessage(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessKeyMessage (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessKeyMessage(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyMessage :  -&gt; bool&#xA;override this.ProcessKeyMessage :  -&gt; bool" Usage="control.ProcessKeyMessage m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">
          <see cref="T:System.Windows.Forms.Message" /> que se pasa por referencia y que representa el mensaje de ventana que se va a procesar.</param>
        <summary>Procesa un mensaje de teclado.</summary>
        <returns>
          <see langword="true" /> si el control procesó el mensaje; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama cuando un control recibe un mensaje del teclado. En primer lugar, el método determina si el control tiene un elemento primario; Si por lo tanto, llama a los padres <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> método. Si el primario <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> método no procesa el mensaje el <xref:System.Windows.Forms.Control.ProcessKeyEventArgs%2A> se invoca para generar los eventos de teclado correspondiente. El `m` parámetro contiene el mensaje de ventana que se debe procesar. Los valores posibles para el <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> propiedad son WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP y WM_SYSKEYUP.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas para la herencia de clases para llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" /> método, debe devolver un control <see langword="true" /> para indicar que ha procesado la clave. Para las claves que no son procesadas por el control, el resultado de la clase base <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> se deben devolver. Controles rara vez, si alguna vez, debe invalidar este método.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessKeyPreview (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessKeyPreview(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyPreview :  -&gt; bool&#xA;override this.ProcessKeyPreview :  -&gt; bool" Usage="control.ProcessKeyPreview m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">
          <see cref="T:System.Windows.Forms.Message" /> que se pasa por referencia y que representa el mensaje de ventana que se va a procesar.</param>
        <summary>Muestra una vista preliminar de un mensaje del teclado.</summary>
        <returns>
          <see langword="true" /> si el control procesó el mensaje; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama mediante un control secundario cuando el control secundario recibe un mensaje del teclado. El control secundario llama a este método antes de generar los eventos de teclado para el mensaje. Si este método devuelve `true`, el control secundario considera que el mensaje procesado y no genera ningún evento de teclado. El `m` parámetro contiene el mensaje de ventana para obtener una vista previa. Los valores posibles para el <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> propiedad son WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP y WM_SYSKEYUP. El <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> método simplemente envía el carácter a la principal <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> método, o se devuelve `false` si el control no tiene ningún elemento primario. La <xref:System.Windows.Forms.Form> clase reemplaza este método para realizar el procesamiento de las claves del cuadro de diálogo.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas para la herencia de clases para llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para que el llamador inmediato llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" /> método en una clase derivada, debe devolver un control <see langword="true" /> para indicar que ha procesado la clave. Para las claves que no son procesadas por el control, el resultado de llamar a la clase base <see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" /> método se debe devolver.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessMnemonic (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessMnemonic(char charCode);" />
      <MemberSignature Language="F#" Value="abstract member ProcessMnemonic : char -&gt; bool&#xA;override this.ProcessMnemonic : char -&gt; bool" Usage="control.ProcessMnemonic charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Carácter que se va a procesar.</param>
        <summary>Procesa un carácter de tecla de acceso.</summary>
        <returns>
          <see langword="true" /> si el control procesó el carácter como carácter de tecla de acceso; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama para dar la oportunidad de procesar un carácter de tecla de acceso a un control. El método debe determinar si el control está en un estado de las teclas de acceso del proceso y si si el carácter especificado representa una tecla de acceso. Si es así, el método debe realizar la acción asociada con la tecla de acceso y devolver `true`. Si no, el método debe devolver `false`. Las implementaciones de este método se utilizan a menudo el <xref:System.Windows.Forms.Control.IsMnemonic%2A> método para determinar si el carácter especificado coincide con una tecla de acceso en el texto del control.  
  
 Por ejemplo:  
  
```csharp  
if (CanSelect && IsMnemonic(charCode, MyControl.Text) {  
      // Perform action associated with mnemonic.  
       }  
```  
  
 Esta implementación predeterminada de la <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> método simplemente devuelve `false` para indicar que el control no tiene ningún carácter de tecla de acceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra una extensión de la clase de botón que reemplaza el <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> método para presentar un comportamiento personalizado. El ejemplo también muestra el uso de la <xref:System.Windows.Forms.Control.CanSelect%2A> y <xref:System.Windows.Forms.Control.IsMnemonic%2A> propiedades. Para ejecutar este ejemplo, pegue el código siguiente después de una clase de formulario, en el mismo archivo. Agregue un botón de tipo `MnemonicButton` al formulario.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas para la herencia de clases para llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Control.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de producto del ensamblado que contiene el control.</summary>
        <value>Nombre de producto del ensamblado que contiene el control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.ProductName%2A> propiedad es una propiedad de solo lectura. Para cambiar el valor de esta propiedad, establezca el <xref:System.Reflection.AssemblyProductAttribute.Product%2A> valor de propiedad de la <xref:System.Reflection.AssemblyProductAttribute>. La siguiente línea de conjuntos de código de C# del <xref:System.Windows.Forms.Control.ProductName%2A> propiedad.  
  
```  
[assembly: AssemblyProduct("MyApplication")]  
```  
  
> [!NOTE]
>  Se recomienda encarecidamente que proporcione el nombre de la compañía, nombre de producto y versión del producto. Proporcionar esta información permite el uso de características de Windows Forms como <xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType> que facilitar la escritura de aplicaciones compatibles con el programa "Certificado para Windows". Para obtener más información acerca del programa de certificación para Windows, consulte http://msdn.microsoft.com/certification.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra información acerca de la aplicación en un <xref:System.Windows.Forms.Label> contenidos en un <xref:System.Windows.Forms.Form>. Este ejemplo requiere que el <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> y <xref:System.Windows.Forms.Control.ProductVersion%2A> se han establecido.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyProductAttribute.Product" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Control.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la versión del ensamblado que contiene el control.</summary>
        <value>Versión de archivo del ensamblado que contiene el control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.ProductVersion%2A> propiedad es una propiedad de solo lectura. Para cambiar el valor de esta propiedad, establezca el <xref:System.Reflection.AssemblyVersionAttribute.Version%2A> valor de propiedad de la <xref:System.Reflection.AssemblyVersionAttribute>. La siguiente línea de conjuntos de código de C# del <xref:System.Windows.Forms.Control.ProductVersion%2A> propiedad.  
  
```  
[assembly: AssemblyVersion("1.0.1")]  
```  
  
> [!NOTE]
>  Se recomienda encarecidamente que proporcione el nombre de la compañía, nombre de producto y versión del producto. Proporcionar esta información permite el uso de características de Windows Forms como <xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType> que facilitar la escritura de aplicaciones compatibles con el programa "Certificado para Windows". Para obtener más información acerca del programa de certificación para Windows, consulte http://msdn.microsoft.com/certification.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra información acerca de la aplicación en un <xref:System.Windows.Forms.Label> contenidos en un <xref:System.Windows.Forms.Form>. Este ejemplo requiere que el <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> y <xref:System.Windows.Forms.Control.ProductVersion%2A> se han establecido.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyVersionAttribute.Version" />
      </Docs>
    </Member>
    <Member MemberName="PropagatingImeMode">
      <MemberSignature Language="C#" Value="protected static System.Windows.Forms.ImeMode PropagatingImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.ImeMode PropagatingImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PropagatingImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly Property PropagatingImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static property System::Windows::Forms::ImeMode PropagatingImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberSignature Language="F#" Value="member this.PropagatingImeMode : System.Windows.Forms.ImeMode" Usage="System.Windows.Forms.Control.PropagatingImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que representa un modo IME de propagación.</summary>
        <value>Objeto que representa un modo IME de propagación.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAccessibilityHelp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryAccessibilityHelp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryAccessibilityHelp As QueryAccessibilityHelpEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryAccessibilityHelpEventHandler ^ QueryAccessibilityHelp;" />
      <MemberSignature Language="F#" Value="member this.QueryAccessibilityHelp : System.Windows.Forms.QueryAccessibilityHelpEventHandler " Usage="member this.QueryAccessibilityHelp : System.Windows.Forms.QueryAccessibilityHelpEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryAccessibilityHelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando <see cref="T:System.Windows.Forms.AccessibleObject" /> proporciona ayuda para aplicaciones de accesibilidad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe usar el <xref:System.Windows.Forms.HelpProvider> clase para permitir que los usuarios invocar la Ayuda en el objeto accesible presionando la tecla F1. Mediante el <xref:System.Windows.Forms.HelpProvider> le proporciona información completa en el <xref:System.Windows.Forms.QueryAccessibilityHelpEventArgs>. Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la creación de un gráfico de accesibilidad para controlar, mediante el <xref:System.Windows.Forms.AccessibleObject> y <xref:System.Windows.Forms.Control.ControlAccessibleObject> clases para exponer información accesible. El control traza dos curvas junto con una leyenda. El `ChartControlAccessibleObject` (clase), que se deriva de `ControlAccessibleObject`, se usa en el <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> método para proporcionar información personalizada accesible para el control chart. Dado que la leyenda del gráfico no es un real <xref:System.Windows.Forms.Control> -control basado en, pero en su lugar se dibuja mediante el control chart, lo hace no ninguna información accesible. Por este motivo, el `ChartControlAccessibleObject` clase invalida el <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> método para devolver el `CurveLegendAccessibleObject` que representa la información accesible de cada parte de la leyenda. Cuando una aplicación accesible para usa este control, el control puede proporcionar la información de acceso necesaria.  
  
 Este fragmento de código muestra cómo tratar el <xref:System.Windows.Forms.Control.QueryAccessibilityHelp> eventos. Consulte la <xref:System.Windows.Forms.AccessibleObject> información general de clases para el ejemplo de código completo.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#3)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#3)]
 [!code-vb[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.AccessibleObject.GetHelpTopic(System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce durante una operación de arrastrar y colocar, y permite al origen de arrastre determinar si la operación de arrastrar y colocar tiene que cancelarse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.QueryContinueDrag> evento se desencadena cuando hay un cambio en el estado del teclado o mouse durante una operación de arrastrar y colocar. El <xref:System.Windows.Forms.Control.QueryContinueDrag> eventos permite que el origen de arrastre determinar si la operación de arrastrar y colocar tiene que cancelarse.  
  
 A continuación, se describe cómo y cuándo se generan eventos relacionados con operaciones de arrastrar y colocar.  
  
 El <xref:System.Windows.Forms.Control.DoDragDrop%2A> método determina el control en la ubicación actual del cursor. A continuación, comprueba si el control es un destino de colocación válido.  
  
 Si el control es un destino válido, el <xref:System.Windows.Forms.Control.GiveFeedback> se provoca el evento con el efecto de arrastrar y colocar especificado. Para obtener una lista de efectos de arrastrar y colocar, vea la enumeración <xref:System.Windows.Forms.DragDropEffects>.  
  
 Se realiza el seguimiento de la posición del cursor del mouse, del estado del teclado y del estado de los botones del mouse.  
  
-   Si el usuario desplaza el mouse fuera de una ventana, se genera el evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Si el mouse entra en otro control, se genera el evento <xref:System.Windows.Forms.Control.DragEnter> para ese control.  
  
-   Si se mueve el mouse dentro del mismo control, se genera el evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Si hay un cambio en el estado del botón teclado o mouse, el <xref:System.Windows.Forms.Control.QueryContinueDrag> se provoca el evento y determina si debe continuar la operación de arrastrar, colocar los datos, o cancelar la operación en función del valor de la <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> propiedad del evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Continue`, <xref:System.Windows.Forms.Control.DragOver> evento se provoca para continuar con la operación y el <xref:System.Windows.Forms.Control.GiveFeedback> evento se genera con el nuevo efecto, por lo que se puede establecer la información visual apropiada. Para obtener una lista de efectos de colocar válidos, vea la enumeración <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  El <xref:System.Windows.Forms.Control.DragOver> y <xref:System.Windows.Forms.Control.GiveFeedback> eventos están emparejados de forma que cuando el mouse se desplace por el destino de colocación, el usuario reciba la información más actualizada sobre la posición del mouse.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Drop`, el valor del efecto de colocar se devuelve al origen, para que la aplicación de origen pueda realizar la operación apropiada en los datos de origen; por ejemplo, cortar los datos si la operación es un movimiento.  
  
-   Si el valor de <xref:System.Windows.Forms.DragAction> es `Cancel`, el <xref:System.Windows.Forms.Control.DragLeave> provoca el evento.  
  
 De forma predeterminada, el <xref:System.Windows.Forms.Control.QueryContinueDrag> evento establece <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> a `Cancel` en <xref:System.Windows.Forms.DragAction> si se presionó la tecla ESC y se establece <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> a `Drop` en <xref:System.Windows.Forms.DragAction> si se presiona el botón izquierdo, central o derecho del mouse.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra una operación de arrastrar y colocar entre dos <xref:System.Windows.Forms.ListBox> controles. El ejemplo llama a la <xref:System.Windows.Forms.Control.DoDragDrop%2A> método cuando se inicia la acción de arrastrar. La acción de arrastrar se inicia si se ha movido el mouse más de <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> desde la ubicación del mouse durante el <xref:System.Windows.Forms.Control.MouseDown> eventos. El <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> método se utiliza para determinar el índice del elemento que se va a arrastrar durante el `MouseDown` eventos.  
  
 El ejemplo también muestra cómo utilizar cursores personalizados para la operación de arrastrar y colocar. El ejemplo requiere que dos archivos de cursor`3dwarro.cur` y `3dwno.cur`, existe en el directorio de aplicación para la operación de arrastre personalizado y no colocar cursores, respectivamente. Los cursores personalizados que se usará si el `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> está activada. Los cursores personalizados se establecen el <xref:System.Windows.Forms.Control.GiveFeedback> controlador de eventos.  
  
 El estado del teclado se evalúa en el <xref:System.Windows.Forms.Control.DragOver> controlador de eventos para el derecho `ListBox`, para determinar cuál será la operación de arrastre según el estado de las teclas MAYÚS, CTRL, ALT o CTRL + ALT. La ubicación en la `ListBox` donde se produciría la operación de colocar también se determina durante el `DragOver` eventos. Si los datos que se va a quitar no están un `String`, el <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> está establecido en `None` en <xref:System.Windows.Forms.DragDropEffects>. Por último, se muestra el estado de la operación de colocar en el `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 Los datos que se va a quitar de la derecha `ListBox` viene determinada en el <xref:System.Windows.Forms.Control.DragDrop> controlador de eventos y el `String` valor se agrega en el lugar adecuado en el `ListBox`. Si la operación de arrastre sobrepasa los límites del formulario y, después, se cancela la operación de arrastrar y colocar en el <xref:System.Windows.Forms.Control.QueryContinueDrag> controlador de eventos.  
  
 Este fragmento de código muestra cómo utilizar el <xref:System.Windows.Forms.Control.QueryContinueDrag> eventos. Consulte la <xref:System.Windows.Forms.Control.DoDragDrop%2A> método para el ejemplo de código completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseDragEvent">
      <MemberSignature Language="C#" Value="protected void RaiseDragEvent (object key, System.Windows.Forms.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseDragEvent(object key, class System.Windows.Forms.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseDragEvent (key As Object, e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseDragEvent(System::Object ^ key, System::Windows::Forms::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseDragEvent : obj * System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.RaiseDragEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Evento que debe generarse.</param>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.DragEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento de arrastre adecuado.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseKeyEvent">
      <MemberSignature Language="C#" Value="protected void RaiseKeyEvent (object key, System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseKeyEvent(object key, class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseKeyEvent (key As Object, e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseKeyEvent(System::Object ^ key, System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseKeyEvent : obj * System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.RaiseKeyEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Evento que debe generarse.</param>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.KeyEventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento de tecla adecuado.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseMouseEvent">
      <MemberSignature Language="C#" Value="protected void RaiseMouseEvent (object key, System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseMouseEvent(object key, class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseMouseEvent (key As Object, e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseMouseEvent(System::Object ^ key, System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseMouseEvent : obj * System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.RaiseMouseEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Evento que debe generarse.</param>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.MouseEventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento del mouse adecuado.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaisePaintEvent">
      <MemberSignature Language="C#" Value="protected void RaisePaintEvent (object key, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaisePaintEvent(object key, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaisePaintEvent (key As Object, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaisePaintEvent(System::Object ^ key, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaisePaintEvent : obj * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.RaisePaintEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Evento que debe generarse.</param>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.PaintEventArgs" /> que contiene los datos del evento.</param>
        <summary>Provoca el evento de dibujo adecuado.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RecreateHandle">
      <MemberSignature Language="C#" Value="protected void RecreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RecreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RecreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RecreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RecreateHandle();" />
      <MemberSignature Language="F#" Value="member this.RecreateHandle : unit -&gt; unit" Usage="control.RecreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obliga a que se vuelva a crear el identificador del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.RecreateHandle%2A> se llama al método cada vez que se necesitan parámetros para un nuevo control, pero mediante una llamada de <xref:System.Windows.Forms.Control.UpdateStyles%2A> a <xref:System.Windows.Forms.Control.CreateParams%2A> no es suficiente. Este método también llama <xref:System.Windows.Forms.Control.DestroyHandle%2A> y <xref:System.Windows.Forms.Control.CreateHandle%2A> y establece <xref:System.Windows.Forms.Control.RecreatingHandle%2A> a `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="RecreatingHandle">
      <MemberSignature Language="C#" Value="public bool RecreatingHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RecreatingHandle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RecreatingHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecreatingHandle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RecreatingHandle { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RecreatingHandle : bool" Usage="System.Windows.Forms.Control.RecreatingHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el control está volviendo a crear su identificador en la actualidad.</summary>
        <value>
          <see langword="true" /> si el control está volviendo a crear su identificador en la actualidad; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.RecreatingHandle%2A> propiedad devuelve `true` si el <xref:System.Windows.Forms.Control.RecreateHandle%2A> método todavía se está ejecutando en el control.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="RectangleToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToClient (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToClient(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function RectangleToClient (r As Rectangle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle RectangleToClient(System::Drawing::Rectangle r);" />
      <MemberSignature Language="F#" Value="member this.RectangleToClient : System.Drawing.Rectangle -&gt; System.Drawing.Rectangle" Usage="control.RectangleToClient r" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">
          <see cref="T:System.Drawing.Rectangle" /> en coordenadas de pantalla que se va a convertir.</param>
        <summary>Calcula el tamaño y la ubicación del rectángulo de pantalla especificado, en coordenadas de cliente.</summary>
        <returns>
          <see cref="T:System.Drawing.Rectangle" /> que representa el <see cref="T:System.Drawing.Rectangle" /> convertido, <paramref name="r" />, en coordenadas de cliente.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="RectangleToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToScreen (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToScreen(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function RectangleToScreen (r As Rectangle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle RectangleToScreen(System::Drawing::Rectangle r);" />
      <MemberSignature Language="F#" Value="member this.RectangleToScreen : System.Drawing.Rectangle -&gt; System.Drawing.Rectangle" Usage="control.RectangleToScreen r" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">
          <see cref="T:System.Drawing.Rectangle" /> en coordenadas de cliente que se va a convertir.</param>
        <summary>Calcula el tamaño y la ubicación del rectángulo de cliente especificado, en coordenadas de pantalla.</summary>
        <returns>
          <see cref="T:System.Drawing.Rectangle" /> que representa el <see cref="T:System.Drawing.Rectangle" /> convertido, <paramref name="p" />, en coordenadas de pantalla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>, y <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> miembros. Para ejecutar el ejemplo, pegue el código siguiente en un formulario denominado **Form1** que contiene varios controles. Este ejemplo requiere que el <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, y <xref:System.Windows.Forms.Control.MouseUp> eventos están conectados a los controladores de eventos definidos en el ejemplo.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="ReflectMessage">
      <MemberSignature Language="C#" Value="protected static bool ReflectMessage (IntPtr hWnd, ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool ReflectMessage(native int hWnd, valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ReflectMessage(System.IntPtr,System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function ReflectMessage (hWnd As IntPtr, ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool ReflectMessage(IntPtr hWnd, System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="static member ReflectMessage : nativeint *  -&gt; bool" Usage="System.Windows.Forms.Control.ReflectMessage (hWnd, m)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hWnd" Type="System.IntPtr" />
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="hWnd">
          <see cref="T:System.IntPtr" /> que representa el identificador del control donde se va a reflejar el mensaje.</param>
        <param name="m">
          <see cref="T:System.Windows.Forms.Message" /> que representa al mensaje de Windows que se va a reflejar.</param>
        <summary>Refleja el mensaje especificado en el control que está enlazado al identificador especificado.</summary>
        <returns>Es <see langword="true" /> si se ha reflejado el mensaje; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.ReflectMessage%2A> método es un método de infraestructura y normalmente no debe llamarse desde el código.  
  
 Si el `hWnd` parámetro no representa un control válido, el <xref:System.Windows.Forms.Control.ReflectMessage%2A> devuelve del método `false`.  
  
 Dado que los mensajes de Windows se devuelven a la ventana de nivel superior, el <xref:System.Windows.Forms.Control.ReflectMessage%2A> método se usa para propagar el mensaje devuelto al control que envió el mensaje.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas llamar a este método. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public virtual void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Refresh();" />
      <MemberSignature Language="F#" Value="abstract member Refresh : unit -&gt; unit&#xA;override this.Refresh : unit -&gt; unit" Usage="control.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obliga al control a invalidar su área cliente y, acto seguido, obliga a que vuelva a dibujarse el control y sus controles secundarios.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.Refresh" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.Refresh" /> método por lo que se invaliden y se vuelve a dibujarse el control y sus controles secundarios.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.Update" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <Member MemberName="Region">
      <MemberSignature Language="C#" Value="public System.Drawing.Region Region { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Region Region" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Region" />
      <MemberSignature Language="VB.NET" Value="Public Property Region As Region" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Region ^ Region { System::Drawing::Region ^ get(); void set(System::Drawing::Region ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Region : System.Drawing.Region with get, set" Usage="System.Windows.Forms.Control.Region" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la región de ventana asociada al control.</summary>
        <value>
          <see cref="T:System.Drawing.Region" /> de ventana asociada al control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La región de ventana es una colección de píxeles dentro de la ventana donde el sistema operativo permite dibujar. El sistema operativo no muestra ninguna parte de una ventana que se encuentra fuera de la región de ventana. Las coordenadas de la región de un control son relativas a la esquina superior izquierda del control, no en el área cliente del control.  
  
> [!NOTE]
>  La colección de píxeles que contiene la región puede ser no contigua.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Windows.Forms.Control.Region%2A> propiedad mediante la creación de un botón redondo. Para ejecutar el ejemplo, pegue el código siguiente en un formulario que contenga un botón denominado `roundButton`. Este ejemplo requiere que el <xref:System.Windows.Forms.Control.Paint> evento está conectado al controlador de eventos definido en el ejemplo.  
  
 [!code-cpp[System.Windows.Forms.Control.Region#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.Region#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.Region#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas establecer este valor de propiedad. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="RegionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RegionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RegionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RegionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RegionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RegionChanged;" />
      <MemberSignature Language="F#" Value="member this.RegionChanged : EventHandler " Usage="member this.RegionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.RegionChanged> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.RegionChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#22)]
 [!code-vb[System.Windows.Forms.EventExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderRightToLeft">
      <MemberSignature Language="C#" Value="protected internal bool RenderRightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RenderRightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RenderRightToLeft" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property RenderRightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool RenderRightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderRightToLeft : bool" Usage="System.Windows.Forms.Control.RenderRightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This property has been deprecated. Please use RightToLeft instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta propiedad está obsoleta.</summary>
        <value>Es <see langword="true" /> si el control se representa de derecha a izquierda; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RescaleConstantsForDpi">
      <MemberSignature Language="C#" Value="protected virtual void RescaleConstantsForDpi (int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RescaleConstantsForDpi(int32 deviceDpiOld, int32 deviceDpiNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RescaleConstantsForDpi(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RescaleConstantsForDpi (deviceDpiOld As Integer, deviceDpiNew As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RescaleConstantsForDpi(int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="F#" Value="abstract member RescaleConstantsForDpi : int * int -&gt; unit&#xA;override this.RescaleConstantsForDpi : int * int -&gt; unit" Usage="control.RescaleConstantsForDpi (deviceDpiOld, deviceDpiNew)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">Valor de PPP antes del cambio.</param>
        <param name="deviceDpiNew">El valor de PPP después del cambio.</param>
        <summary>Proporciona constantes para cambiar la escala del control cuando se produce un cambio de PPP.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBackColor">
      <MemberSignature Language="C#" Value="public virtual void ResetBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetBackColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetBackColor();" />
      <MemberSignature Language="F#" Value="abstract member ResetBackColor : unit -&gt; unit&#xA;override this.ResetBackColor : unit -&gt; unit" Usage="control.ResetBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el valor predeterminado de la propiedad <see cref="P:System.Windows.Forms.Control.BackColor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBindings">
      <MemberSignature Language="C#" Value="public void ResetBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBindings" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetBindings ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetBindings();" />
      <MemberSignature Language="F#" Value="member this.ResetBindings : unit -&gt; unit" Usage="control.ResetBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hace que un control enlazado a <see cref="T:System.Windows.Forms.BindingSource" /> vuelva a leer todos los elementos de la lista y actualice los valores mostrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.DataBindings" />
      </Docs>
    </Member>
    <Member MemberName="ResetCursor">
      <MemberSignature Language="C#" Value="public virtual void ResetCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetCursor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetCursor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetCursor();" />
      <MemberSignature Language="F#" Value="abstract member ResetCursor : unit -&gt; unit&#xA;override this.ResetCursor : unit -&gt; unit" Usage="control.ResetCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el valor predeterminado de la propiedad <see cref="P:System.Windows.Forms.Control.Cursor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetFont">
      <MemberSignature Language="C#" Value="public virtual void ResetFont ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetFont() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetFont" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetFont ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetFont();" />
      <MemberSignature Language="F#" Value="abstract member ResetFont : unit -&gt; unit&#xA;override this.ResetFont : unit -&gt; unit" Usage="control.ResetFont " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el valor predeterminado de la propiedad <see cref="P:System.Windows.Forms.Control.Font" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetForeColor">
      <MemberSignature Language="C#" Value="public virtual void ResetForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetForeColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetForeColor();" />
      <MemberSignature Language="F#" Value="abstract member ResetForeColor : unit -&gt; unit&#xA;override this.ResetForeColor : unit -&gt; unit" Usage="control.ResetForeColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el valor predeterminado de la propiedad <see cref="P:System.Windows.Forms.Control.ForeColor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetImeMode">
      <MemberSignature Language="C#" Value="public void ResetImeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetImeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetImeMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetImeMode();" />
      <MemberSignature Language="F#" Value="member this.ResetImeMode : unit -&gt; unit" Usage="control.ResetImeMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el valor predeterminado de la propiedad <see cref="P:System.Windows.Forms.Control.ImeMode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetMouseEventArgs">
      <MemberSignature Language="C#" Value="protected void ResetMouseEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ResetMouseEventArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetMouseEventArgs" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ResetMouseEventArgs ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ResetMouseEventArgs();" />
      <MemberSignature Language="F#" Value="member this.ResetMouseEventArgs : unit -&gt; unit" Usage="control.ResetMouseEventArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el control para controlar el evento <see cref="E:System.Windows.Forms.Control.MouseLeave" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetRightToLeft">
      <MemberSignature Language="C#" Value="public virtual void ResetRightToLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetRightToLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetRightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetRightToLeft ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetRightToLeft();" />
      <MemberSignature Language="F#" Value="abstract member ResetRightToLeft : unit -&gt; unit&#xA;override this.ResetRightToLeft : unit -&gt; unit" Usage="control.ResetRightToLeft " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el valor predeterminado de la propiedad <see cref="P:System.Windows.Forms.Control.RightToLeft" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetText">
      <MemberSignature Language="C#" Value="public virtual void ResetText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetText" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetText ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetText();" />
      <MemberSignature Language="F#" Value="abstract member ResetText : unit -&gt; unit&#xA;override this.ResetText : unit -&gt; unit" Usage="control.ResetText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el valor predeterminado de la propiedad <see cref="P:System.Windows.Forms.Control.Text" /> (<see cref="F:System.String.Empty" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, utilice este método si se está creando un diseñador para el <xref:System.Windows.Forms.Control> o crear su propio control que incorpore el <xref:System.Windows.Forms.Control>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="Resize">
      <MemberSignature Language="C#" Value="public event EventHandler Resize;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Resize" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Resize" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resize As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Resize;" />
      <MemberSignature Language="F#" Value="member this.Resize : EventHandler " Usage="member this.Resize : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se cambia el tamaño del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar el <xref:System.Windows.Forms.Control.Size%2A> del control cuyo tamaño ha cambiado, puede convertir el `sender` parámetro de registrado <xref:System.Windows.Forms.ControlEventHandler> método a un <xref:System.Windows.Forms.Control> y obtenga su <xref:System.Windows.Forms.Control.Size%2A> propiedad (o <xref:System.Windows.Forms.Control.Height%2A> y <xref:System.Windows.Forms.Control.Width%2A> propiedades individualmente).  
  
 Para controlar los diseños personalizados, utilice el <xref:System.Windows.Forms.Control.Layout> eventos en lugar del evento de cambio de tamaño. El <xref:System.Windows.Forms.Control.Layout> evento se genera en respuesta a un <xref:System.Windows.Forms.Control.Resize> eventos, sino también en respuesta a otros cambios que afectan al diseño del control.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El siguiente código de ejemplo controla el <xref:System.Windows.Forms.Control.Resize> eventos de un <xref:System.Windows.Forms.Form>. Cuando se cambia el tamaño del formulario, el controlador de eventos garantiza que el formulario permanece cuadrado (su <xref:System.Windows.Forms.Control.Height%2A> y <xref:System.Windows.Forms.Control.Width%2A> permanecen igual). Para ejecutar este ejemplo, asegúrese de que y asociar a este método de control de eventos con el formulario <xref:System.Windows.Forms.Control.Resize> eventos.  
  
 [!code-cpp[WinForms.Control.Resize#1](~/samples/snippets/cpp/VS_Snippets_Winforms/WinForms.Control.Resize/CPP/form1.cpp#1)]
 [!code-csharp[WinForms.Control.Resize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/WinForms.Control.Resize/CS/form1.cs#1)]
 [!code-vb[WinForms.Control.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/WinForms.Control.Resize/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="ResizeRedraw">
      <MemberSignature Language="C#" Value="protected bool ResizeRedraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResizeRedraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ResizeRedraw" />
      <MemberSignature Language="VB.NET" Value="Protected Property ResizeRedraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ResizeRedraw { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeRedraw : bool with get, set" Usage="System.Windows.Forms.Control.ResizeRedraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el control vuelve a dibujarse automáticamente cuando cambia de tamaño.</summary>
        <value>
          <see langword="true" /> si el control vuelve a dibujarse automáticamente cuando cambia de tamaño; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.ResizeRedraw%2A> valor de propiedad es equivalente al valor devuelto de la <xref:System.Windows.Forms.Control.GetStyle%2A> método cuando se pasan en el <xref:System.Windows.Forms.ControlStyles.ResizeRedraw?displayProperty=nameWithType> valor como un parámetro.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.ResizeRedraw" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ResumeLayout">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reanuda la lógica de diseño habitual.</summary>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeLayout();" />
      <MemberSignature Language="F#" Value="member this.ResumeLayout : unit -&gt; unit" Usage="control.ResumeLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reanuda la lógica de diseño habitual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a la <xref:System.Windows.Forms.Control.ResumeLayout%2A> método fuerza un diseño inmediato si hay solicitudes de diseño pendientes.  
  
 El <xref:System.Windows.Forms.Control.SuspendLayout%2A> y <xref:System.Windows.Forms.Control.ResumeLayout%2A> métodos se usan conjuntamente para suprimir varios <xref:System.Windows.Forms.Control.Layout> eventos mientras se ajustan varios atributos del control. Por ejemplo, normalmente se llamaría a la <xref:System.Windows.Forms.Control.SuspendLayout%2A> método, a continuación, establezca el <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, o <xref:System.Windows.Forms.Control.Dock%2A> propiedades del control y, a continuación, llame el <xref:System.Windows.Forms.Control.ResumeLayout%2A> método para habilitar los cambios surtan efecto.  
  
 No debe haber ninguna llamada pendiente a <xref:System.Windows.Forms.Control.SuspendLayout%2A> para <xref:System.Windows.Forms.Control.ResumeLayout%2A> llamará correctamente.  
  
   
  
## Examples  
 El ejemplo de código siguiente agrega dos botones a un formulario. Las transacciones de ejemplo la adición de los botones mediante el uso de la <xref:System.Windows.Forms.Control.SuspendLayout%2A> y <xref:System.Windows.Forms.Control.ResumeLayout%2A> métodos.  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout (bool performLayout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout(bool performLayout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeLayout (performLayout As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeLayout(bool performLayout);" />
      <MemberSignature Language="F#" Value="member this.ResumeLayout : bool -&gt; unit" Usage="control.ResumeLayout performLayout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="performLayout" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="performLayout">Es <see langword="true" /> para ejecutar solicitudes de diseño pendientes; en caso contrario, es <see langword="false" />.</param>
        <summary>Reanuda la lógica de diseño habitual, forzando opcionalmente un diseño inmediato de las solicitudes de diseño pendientes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a la <xref:System.Windows.Forms.Control.ResumeLayout%2A> método fuerza un diseño inmediato si hay solicitudes de diseño pendientes. Cuando el `performLayout` parámetro se establece en `true`, se produce un diseño inmediato si hay solicitudes de diseño pendientes.  
  
 El <xref:System.Windows.Forms.Control.SuspendLayout%2A> y <xref:System.Windows.Forms.Control.ResumeLayout%2A> métodos se usan conjuntamente para suprimir varios <xref:System.Windows.Forms.Control.Layout> eventos mientras se ajustan varios atributos del control. Por ejemplo, normalmente se llamaría a la <xref:System.Windows.Forms.Control.SuspendLayout%2A> método, a continuación, establezca el <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, o <xref:System.Windows.Forms.Control.Dock%2A> propiedades del control y, a continuación, llame el <xref:System.Windows.Forms.Control.ResumeLayout%2A> método para habilitar los cambios surtan efecto.  
  
 No debe haber ninguna llamada pendiente a <xref:System.Windows.Forms.Control.SuspendLayout%2A> para <xref:System.Windows.Forms.Control.ResumeLayout%2A> llamará correctamente.  
  
> [!NOTE]
>  Al agregar varios controles a un control principal, se recomienda que llame el <xref:System.Windows.Forms.Control.SuspendLayout%2A> método antes de inicializar los controles que se va a agregar. Después de agregar los controles al control primario, llame a la <xref:System.Windows.Forms.Control.ResumeLayout%2A> método. Esto aumentará el rendimiento de aplicaciones con muchos controles.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="Right">
      <MemberSignature Language="C#" Value="public int Right { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Right" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Right" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Right As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Right { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Right : int" Usage="System.Windows.Forms.Control.Right" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la distancia, en píxeles, que existe entre el borde derecho del control y el borde izquierdo del área cliente de su contenedor.</summary>
        <value>
          <see cref="T:System.Int32" /> que representa la distancia, en píxeles, que existe entre el borde derecho del control y el borde izquierdo del área cliente de su contenedor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de la <xref:System.Windows.Forms.Control.Right%2A> propiedad es igual a la suma de los <xref:System.Windows.Forms.Control.Left%2A> valor de propiedad y el <xref:System.Windows.Forms.Control.Width%2A> valor de propiedad.  
  
 La propiedad <xref:System.Windows.Forms.Control.Right%2A> es de sólo lectura. Puede cambiar este valor de propiedad indirectamente cambiando el valor de la <xref:System.Windows.Forms.Control.Left%2A> o <xref:System.Windows.Forms.Control.Width%2A> propiedades o llamar a la <xref:System.Windows.Forms.Control.SetBounds%2A>, <xref:System.Windows.Forms.Control.SetBoundsCore%2A>, <xref:System.Windows.Forms.Control.UpdateBounds%2A>, o <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> métodos.  
  
   
  
## Examples  
 El ejemplo de código siguiente crea tres <xref:System.Windows.Forms.Button> controles de formularios y establece su tamaño y la ubicación mediante el uso de las diversas propiedades relacionadas con la ubicación y tamaño. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> que tiene un ancho y alto de al menos 300 píxeles.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Right" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.RightToLeft RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RightToLeft RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RightToLeft As RightToLeft" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::RightToLeft RightToLeft { System::Windows::Forms::RightToLeft get(); void set(System::Windows::Forms::RightToLeft value); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : System.Windows.Forms.RightToLeft with get, set" Usage="System.Windows.Forms.Control.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RightToLeft</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si los elementos del control se alinean para admitir configuraciones regionales que utilizan fuentes de derecha a izquierda.</summary>
        <value>Uno de los valores de <see cref="T:System.Windows.Forms.RightToLeft" />. El valor predeterminado es <see cref="F:System.Windows.Forms.RightToLeft.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.RightToLeft%2A> es una propiedad de ambiente. Una propiedad de ambiente es una propiedad de control que, si no establece, se recupera desde el control primario. Por ejemplo, un <xref:System.Windows.Forms.Button> tendrá el mismo <xref:System.Windows.Forms.Control.BackColor%2A> como su elemento primario <xref:System.Windows.Forms.Form> de forma predeterminada. Para obtener más información acerca de las propiedades de ambiente, vea la <xref:System.Windows.Forms.AmbientProperties> clase o el <xref:System.Windows.Forms.Control> información general de clases.  
  
 El <xref:System.Windows.Forms.Control.RightToLeft%2A> propiedad se utiliza para aplicaciones internacionales donde el idioma se escribe de derecha a izquierda, como el hebreo o árabe. Cuando esta propiedad se establece en <xref:System.Windows.Forms.RightToLeft.Yes?displayProperty=nameWithType>, elementos de control que incluyen texto se muestran de derecha a izquierda.  
  
> [!NOTE]
>  Si el valor de la <xref:System.Windows.Forms.Control.RightToLeft%2A> se cambia una propiedad en tiempo de ejecución, se conserva solo texto sin formato.  
  
 Los siguientes son algunos ejemplos de cómo los elementos del control se ven afectados por la <xref:System.Windows.Forms.Control.RightToLeft%2A> el valor de propiedad <xref:System.Windows.Forms.RightToLeft.Yes?displayProperty=nameWithType> :  
  
-   Se muestran las barras de desplazamiento vertical en el lado izquierdo en lugar de en el lado derecho de los controles desplazables (por ejemplo, <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Panel>multilínea <xref:System.Windows.Forms.TextBox>, y <xref:System.Windows.Forms.RichTextBox>).  
  
-   Las barras de desplazamiento horizontal se inicie con el cuadro de desplazamiento (control) alineado a la derecha.  
  
-   La alineación del elemento de casilla de verificación, controlada por el `CheckAlign` , se invierte para <xref:System.Windows.Forms.CheckBox> y <xref:System.Windows.Forms.RadioButton> controles.  
  
-   Elementos de cuadro de lista, cuadro combinado y flechas controles están alineados a la derecha.  
  
-   Botones arriba y abajo están alineados a la izquierda en <xref:System.Windows.Forms.NumericUpDown> y <xref:System.Windows.Forms.DomainUpDown> controles.  
  
-   Menús (<xref:System.Windows.Forms.MainMenu>, <xref:System.Windows.Forms.MenuItem>, y <xref:System.Windows.Forms.ContextMenu>) se muestra alineado a la derecha.  
  
-   La alineación de los botones de barra de herramientas en un <xref:System.Windows.Forms.ToolBar> control o la alineación del texto en un <xref:System.Windows.Forms.ToolBarButton> no se ve afectado por la <xref:System.Windows.Forms.Control.RightToLeft%2A> propiedad.  
  
-   <xref:System.Windows.Forms.AxHost> admite la alineación de derecha a izquierda; Sin embargo, el efecto en un control ActiveX depende de la extensión a la que el autor del control había implementado la compatibilidad para la presentación de derecha a izquierda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El valor asignado no es uno de los valores de <see cref="T:System.Windows.Forms.RightToLeft" />.</exception>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.RightToLeft" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.RightToLeft" /> propiedad para extender la implementación base. En caso contrario, debe proporcionar toda la implementación. No es necesario reemplazar ambos el <see langword="get" /> y <see langword="set" /> descriptores de acceso de la <see cref="P:System.Windows.Forms.Control.RightToLeft" /> propiedad; se puede reemplazar sólo uno, si es necesario.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeftChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RightToLeftChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RightToLeftChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RightToLeftChanged;" />
      <MemberSignature Language="F#" Value="member this.RightToLeftChanged : EventHandler " Usage="member this.RightToLeftChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.RightToLeft" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.RightToLeft%2A> propiedad se modifica mediante programación o interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente es un controlador de eventos que se ejecuta cuando el <xref:System.Windows.Forms.Control.Text%2A> cambios de valor de propiedad. El <xref:System.Windows.Forms.Control> clase tiene varios métodos con el patrón de nombre *PropertyName* `Changed` que se genera cuando correspondiente *PropertyName* cambia el valor (* PropertyName* representa el nombre de la propiedad correspondiente).  
  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> que contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RtlTranslateAlignment">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte la alineación actual en la alineación correspondiente para que admita texto de derecha a izquierda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Drawing.ContentAlignment RtlTranslateAlignment (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateAlignment(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Drawing.ContentAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As ContentAlignment) As ContentAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Drawing::ContentAlignment RtlTranslateAlignment(System::Drawing::ContentAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Drawing.ContentAlignment -&gt; System.Drawing.ContentAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno de los valores de <see cref="T:System.Drawing.ContentAlignment" />.</param>
        <summary>Convierte la <see cref="T:System.Drawing.ContentAlignment" /> especificada en la <see cref="T:System.Drawing.ContentAlignment" /> correspondiente para que admita texto de derecha a izquierda.</summary>
        <returns>Uno de los valores de <see cref="T:System.Drawing.ContentAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Forms.Control.RightToLeft%2A> propiedad de <xref:System.Windows.Forms.RightToLeft> está establecido en `No`, el valor devuelto es igual que el `align` parámetro pasado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Drawing.ContentAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As HorizontalAlignment) As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::HorizontalAlignment RtlTranslateAlignment(System::Windows::Forms::HorizontalAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Windows.Forms.HorizontalAlignment -&gt; System.Windows.Forms.HorizontalAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno de los valores de <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</param>
        <summary>Convierte la <see cref="T:System.Windows.Forms.HorizontalAlignment" /> especificada en la <see cref="T:System.Windows.Forms.HorizontalAlignment" /> correspondiente para que admita texto de derecha a izquierda.</summary>
        <returns>Uno de los valores de <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Forms.Control.RightToLeft%2A> propiedad de <xref:System.Windows.Forms.RightToLeft> está establecido en `No`, el valor devuelto es igual que el `align` parámetro pasado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As LeftRightAlignment) As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::LeftRightAlignment RtlTranslateAlignment(System::Windows::Forms::LeftRightAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Windows.Forms.LeftRightAlignment -&gt; System.Windows.Forms.LeftRightAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno de los valores de <see cref="T:System.Windows.Forms.LeftRightAlignment" />.</param>
        <summary>Convierte la <see cref="T:System.Windows.Forms.LeftRightAlignment" /> especificada en la <see cref="T:System.Windows.Forms.LeftRightAlignment" /> correspondiente para que admita texto de derecha a izquierda.</summary>
        <returns>Uno de los valores de <see cref="T:System.Windows.Forms.LeftRightAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Forms.Control.RightToLeft%2A> propiedad de <xref:System.Windows.Forms.RightToLeft> está establecido en `No`, el valor devuelto es igual que el `align` parámetro pasado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.LeftRightAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateContent">
      <MemberSignature Language="C#" Value="protected internal System.Drawing.ContentAlignment RtlTranslateContent (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateContent(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function RtlTranslateContent (align As ContentAlignment) As ContentAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Drawing::ContentAlignment RtlTranslateContent(System::Drawing::ContentAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateContent : System.Drawing.ContentAlignment -&gt; System.Drawing.ContentAlignment" Usage="control.RtlTranslateContent align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno de los valores de <see cref="T:System.Drawing.ContentAlignment" />.</param>
        <summary>Convierte la <see cref="T:System.Drawing.ContentAlignment" /> especificada en la <see cref="T:System.Drawing.ContentAlignment" /> correspondiente para que admita texto de derecha a izquierda.</summary>
        <returns>Uno de los valores de <see cref="T:System.Drawing.ContentAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Forms.Control.RightToLeft%2A> propiedad de <xref:System.Windows.Forms.RightToLeft> está establecido en `No`, el valor devuelto es igual que el `align` parámetro pasado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Drawing.ContentAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateHorizontal">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateHorizontal (align As HorizontalAlignment) As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::HorizontalAlignment RtlTranslateHorizontal(System::Windows::Forms::HorizontalAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateHorizontal : System.Windows.Forms.HorizontalAlignment -&gt; System.Windows.Forms.HorizontalAlignment" Usage="control.RtlTranslateHorizontal align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno de los valores de <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</param>
        <summary>Convierte la <see cref="T:System.Windows.Forms.HorizontalAlignment" /> especificada en la <see cref="T:System.Windows.Forms.HorizontalAlignment" /> correspondiente para que admita texto de derecha a izquierda.</summary>
        <returns>Uno de los valores de <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Forms.Control.RightToLeft%2A> propiedad de <xref:System.Windows.Forms.RightToLeft> está establecido en `No`, el valor devuelto es igual que el `align` parámetro pasado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateLeftRight">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateLeftRight (align As LeftRightAlignment) As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::LeftRightAlignment RtlTranslateLeftRight(System::Windows::Forms::LeftRightAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateLeftRight : System.Windows.Forms.LeftRightAlignment -&gt; System.Windows.Forms.LeftRightAlignment" Usage="control.RtlTranslateLeftRight align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno de los valores de <see cref="T:System.Windows.Forms.LeftRightAlignment" />.</param>
        <summary>Convierte la <see cref="T:System.Windows.Forms.LeftRightAlignment" /> especificada en la <see cref="T:System.Windows.Forms.LeftRightAlignment" /> correspondiente para que admita texto de derecha a izquierda.</summary>
        <returns>Uno de los valores de <see cref="T:System.Windows.Forms.LeftRightAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Forms.Control.RightToLeft%2A> propiedad de <xref:System.Windows.Forms.RightToLeft> está establecido en `No`, el valor devuelto es igual que el `align` parámetro pasado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.LeftRightAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Scale">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajusta la escala del control y de todos los controles secundarios.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (System.Drawing.SizeF factor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(valuetype System.Drawing.SizeF factor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Drawing.SizeF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (factor As SizeF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(System::Drawing::SizeF factor);" />
      <MemberSignature Language="F#" Value="member this.Scale : System.Drawing.SizeF -&gt; unit" Usage="control.Scale factor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
      </Parameters>
      <Docs>
        <param name="factor">
          <see cref="T:System.Drawing.SizeF" /> que contiene los factores de escala horizontal y vertical.</param>
        <summary>Escala el control y todos los controles secundarios según el factor de escala especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.Scale%2A> método escala el control mediante el ajuste de escala especificado `factor`. También recursivamente escala todos los controles secundarios si el <xref:System.Windows.Forms.Control.ScaleChildren%2A> propiedad es `true`. Internamente, este método llama a <xref:System.Windows.Forms.Control.ScaleControl%2A> escalar cada control.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ScaleChildren" />
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float ratio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 ratio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (ratio As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(float ratio);" />
      <MemberSignature Language="F#" Value="member this.Scale : single -&gt; unit" Usage="control.Scale ratio" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ratio" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="ratio">La proporción que se debe utilizar para ajustar a escala.</param>
        <summary>Ajusta la escala del control y de todos los controles secundarios.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.Scale : single * single -&gt; unit" Usage="control.Scale (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Factor de escala horizontal.</param>
        <param name="dy">Factor de escala vertical.</param>
        <summary>Ajusta a escala todo el control y los controles secundarios.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleBitmapLogicalToDevice">
      <MemberSignature Language="C#" Value="public void ScaleBitmapLogicalToDevice (ref System.Drawing.Bitmap logicalBitmap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleBitmapLogicalToDevice(class System.Drawing.Bitmap&amp; logicalBitmap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleBitmapLogicalToDevice(System.Drawing.Bitmap@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleBitmapLogicalToDevice (ByRef logicalBitmap As Bitmap)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleBitmapLogicalToDevice(System::Drawing::Bitmap ^ % logicalBitmap);" />
      <MemberSignature Language="F#" Value="member this.ScaleBitmapLogicalToDevice :  -&gt; unit" Usage="control.ScaleBitmapLogicalToDevice logicalBitmap" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalBitmap" Type="System.Drawing.Bitmap" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="logicalBitmap">El mapa de bits que se escalará.</param>
        <summary>Escala un valor de mapa de bits lógico a su valor DeviceUnit equivalente cuando se produce un cambio de PPP.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleChildren">
      <MemberSignature Language="C#" Value="protected virtual bool ScaleChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ScaleChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ScaleChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ScaleChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ScaleChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ScaleChildren : bool" Usage="System.Windows.Forms.Control.ScaleChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que determina el escalado de los controles secundarios.</summary>
        <value>
          <see langword="true" /> si se escalarán los controles secundarios cuando se llame al método <see cref="M:System.Windows.Forms.Control.Scale(System.Single)" /> en este control; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Forms.Control.ScaleChildren%2A> propiedad es `true`, el <xref:System.Windows.Forms.Control.Scale%2A> método le llamada de forma recursiva el <xref:System.Windows.Forms.Control.ScaleControl%2A> método de cada uno de sus controles secundarios.  
  
 La implementación predeterminada de <xref:System.Windows.Forms.Control.ScaleChildren%2A> siempre devuelve `true`. Las clases derivadas pueden invalidar <xref:System.Windows.Forms.Control.ScaleChildren%2A> para devolver `false` para indicar que el escalado no debería realizarse en sus elementos secundarios.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Scale(System.Single)" />
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected virtual void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ScaleControl (factor As SizeF, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ScaleControl(System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member ScaleControl : System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; unit&#xA;override this.ScaleControl : System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.ScaleControl (factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="factor">Factor por el que se escalarán el alto y ancho del control.</param>
        <param name="specified">Un valor <see cref="T:System.Windows.Forms.BoundsSpecified" /> que especifica los límites del control que se usarán al definir su tamaño y posición.</param>
        <summary>Escala la ubicación, el tamaño, el relleno y el margen de un control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el control es de nivel superior, no escalará la ubicación del control. No se escala los elementos secundarios o el tamaño de los controles de tamaños automáticamente. Puede omitir el escalado en cualquier dirección cambiando el valor de la `specified` parámetro.  
  
   
  
## Examples  
 <xref:System.Windows.Forms.BoundsSpecified>  
  
 <xref:System.Windows.Forms.Control.Scale%2A>  
  
 <xref:System.Windows.Forms.Control.GetScaledBounds%2A>  
  
 <xref:System.Windows.Forms.Control.SetBoundsCore%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected virtual void ScaleCore (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleCore(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleCore(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ScaleCore (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ScaleCore(float dx, float dy);" />
      <MemberSignature Language="F#" Value="abstract member ScaleCore : single * single -&gt; unit&#xA;override this.ScaleCore : single * single -&gt; unit" Usage="control.ScaleCore (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Factor de escala horizontal.</param>
        <param name="dy">Factor de escala vertical.</param>
        <summary>Este método no es relevante para esta clase.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Activa un control.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; unit" Usage="control.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Activa el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.Select%2A> método activa el control si el control `Selectable` bit de estilo se establece en `true` en <xref:System.Windows.Forms.ControlStyles>, que está contenida en otro control y todos sus controles principales son visibles y están habilitados.  
  
 Los controles de Windows Forms en la lista siguiente no son seleccionables. Controles derivados de controles en la lista también se pueden seleccionables no.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel> (cuando no hay ningún vínculo en el control)  
  
   
  
## Examples  
 En el ejemplo de código siguiente se selecciona especificado <xref:System.Windows.Forms.Control>, si puede seleccionarse.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
 [!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
 [!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected virtual void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Select(bool directed, bool forward);" />
      <MemberSignature Language="F#" Value="abstract member Select : bool * bool -&gt; unit&#xA;override this.Select : bool * bool -&gt; unit" Usage="control.Select (directed, forward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed">
          <see langword="true" /> para especificar la dirección del control que se va a seleccionar; en caso contrario, <see langword="false" />.</param>
        <param name="forward">Es <see langword="true" /> para moverse hacia delante en el orden de tabulación; es <see langword="false" /> para moverse hacia atrás en el orden de tabulación.</param>
        <summary>Activa un control secundario. Opcionalmente, especifica la dirección en que se seleccionará el control en el orden de tabulación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `directed` y `forward` parámetros se usan controles de estilo contenedor. Cuando el `directed` parámetro está establecido en `true`, el `forward` parámetro se evalúa para determinar el control para seleccionar. Cuando `forward` está establecido en `true`, se selecciona el siguiente control en el orden de tabulación; cuando `false`, se selecciona el control anterior en el orden de tabulación.  
  
 El <xref:System.Windows.Forms.Control.Select%2A> método activa el control si el control `Selectable` bit de estilo se establece en `true` en <xref:System.Windows.Forms.ControlStyles>, que está contenida en otro control y todos sus controles principales son visibles y están habilitados.  
  
 Los controles de Windows Forms en la lista siguiente no son seleccionables. Controles derivados de controles en la lista también se pueden seleccionables no.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel> (cuando no hay ningún vínculo en el control)  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="M:System.Windows.Forms.Control.Select" />
      </Docs>
    </Member>
    <Member MemberName="SelectNextControl">
      <MemberSignature Language="C#" Value="public bool SelectNextControl (System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SelectNextControl(class System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectNextControl (ctl As Control, forward As Boolean, tabStopOnly As Boolean, nested As Boolean, wrap As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SelectNextControl(System::Windows::Forms::Control ^ ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberSignature Language="F#" Value="member this.SelectNextControl : System.Windows.Forms.Control * bool * bool * bool * bool -&gt; bool" Usage="control.SelectNextControl (ctl, forward, tabStopOnly, nested, wrap)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
        <Parameter Name="tabStopOnly" Type="System.Boolean" />
        <Parameter Name="nested" Type="System.Boolean" />
        <Parameter Name="wrap" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">
          <see cref="T:System.Windows.Forms.Control" /> donde va a comenzar la búsqueda.</param>
        <param name="forward">Es <see langword="true" /> para moverse hacia delante en el orden de tabulación; es <see langword="false" /> para moverse hacia atrás en el orden de tabulación.</param>
        <param name="tabStopOnly">Es <see langword="true" /> para pasar por alto los controles cuya propiedad <see cref="P:System.Windows.Forms.Control.TabStop" /> está establecida en <see langword="false" />; en caso contrario, es <see langword="false" />.</param>
        <param name="nested">Es <see langword="true" /> para incluir controles secundarios anidados (es decir, controles secundarios de controles secundarios); en caso contrario, es <see langword="false" />.</param>
        <param name="wrap">Es <see langword="true" /> para continuar la búsqueda a partir del primer control en el orden de tabulación después de haber llegado hasta el último; en caso contrario, es <see langword="false" />.</param>
        <summary>Activa el siguiente control.</summary>
        <returns>
          <see langword="true" /> si se activó un control; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.SelectNextControl%2A> método activa el siguiente control en el orden de tabulación, si el control `Selectable` bit de estilo se establece en `true` en <xref:System.Windows.Forms.ControlStyles>, que está contenida en otro control y todos sus controles principales son visibles y están habilitados.  
  
 Los controles de Windows Forms en la lista siguiente no son seleccionables. Controles derivados de controles en la lista también se pueden seleccionables no.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel> (cuando no hay ningún vínculo en el control)  
  
 Al cambiar el foco mediante el teclado (ficha, MAYÚS+TAB etc.), mediante una llamada a la <xref:System.Windows.Forms.Control.Select%2A> o <xref:System.Windows.Forms.Control.SelectNextControl%2A> métodos, o estableciendo la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> propiedad al formulario actual, se producen eventos de foco en el orden siguiente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Si el <xref:System.Windows.Forms.Control.CausesValidation%2A> propiedad está establecida en `false`, <xref:System.Windows.Forms.Control.Validating> y <xref:System.Windows.Forms.Control.Validated> se suprimen eventos.  
  
   
  
## Examples  
 El siguiente código EjemploMuestra el <xref:System.Windows.Forms.Control.SelectNextControl%2A> método que se utiliza en un formulario con algunos controles. Cada vez que haga clic en el formulario, se activa el siguiente control. El <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> propiedad obtiene el control activo en el control contenedor.  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#1)]  
  
 El siguiente ejemplo de código muestra la <xref:System.Windows.Forms.Control.SelectNextControl%2A> método que se va a utilizar en un formulario que tiene un <xref:System.Windows.Forms.Button> y algunos otros controles. Al hacer clic en el <xref:System.Windows.Forms.Button>, el siguiente control después de la <xref:System.Windows.Forms.Button> está activado. Tenga en cuenta que tendrá que obtener el elemento primario de la <xref:System.Windows.Forms.Button> control. Puesto que <xref:System.Windows.Forms.Button> no es un contenedor, una llamada a <xref:System.Windows.Forms.Control.SelectNextControl%2A> directamente en el <xref:System.Windows.Forms.Button> no cambiaría la activación.  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#2)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
      </Docs>
    </Member>
    <Member MemberName="SendToBack">
      <MemberSignature Language="C#" Value="public void SendToBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendToBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SendToBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendToBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendToBack();" />
      <MemberSignature Language="F#" Value="member this.SendToBack : unit -&gt; unit" Usage="control.SendToBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Envía el control al final del orden Z.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El control se mueve a la parte posterior del orden z. Si el control es un elemento secundario de otro control, el control secundario se mueve a la parte posterior del orden z. Si el control es un control de nivel superior, este método no funcionará correctamente a menos que el control está activo. Un control de nivel superior es un control, como un <xref:System.Windows.Forms.Form>, que es un elemento secundario de otro control. Un control activo es un control visible que tiene el foco de entrada. Para usar el <xref:System.Windows.Forms.Control.SendToBack%2A> método con un control inactivo de nivel superior, primero llame a la <xref:System.Windows.Forms.Control.BringToFront%2A> método en el control.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.BringToFront" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
      </Docs>
    </Member>
    <Member MemberName="SetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected void SetAutoSizeMode (System.Windows.Forms.AutoSizeMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetAutoSizeMode(valuetype System.Windows.Forms.AutoSizeMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetAutoSizeMode(System.Windows.Forms.AutoSizeMode)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetAutoSizeMode (mode As AutoSizeMode)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetAutoSizeMode(System::Windows::Forms::AutoSizeMode mode);" />
      <MemberSignature Language="F#" Value="member this.SetAutoSizeMode : System.Windows.Forms.AutoSizeMode -&gt; unit" Usage="control.SetAutoSizeMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.AutoSizeMode" />
      </Parameters>
      <Docs>
        <param name="mode">Uno de los valores de <see cref="T:System.Windows.Forms.AutoSizeMode" />.</param>
        <summary>Establece un valor que indica cómo se comportará un control cuando su propiedad <see cref="P:System.Windows.Forms.Control.AutoSize" /> esté habilitada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece los límites del control.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBounds(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.SetBounds : int * int * int * int -&gt; unit" Usage="control.SetBounds (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Nuevo valor de la propiedad <see cref="P:System.Windows.Forms.Control.Left" /> del control.</param>
        <param name="y">Nuevo valor de la propiedad <see cref="P:System.Windows.Forms.Control.Top" /> del control.</param>
        <param name="width">Nuevo valor de la propiedad <see cref="P:System.Windows.Forms.Control.Width" /> del control.</param>
        <param name="height">Nuevo valor de la propiedad <see cref="P:System.Windows.Forms.Control.Height" /> del control.</param>
        <summary>Establece los límites del control en la ubicación y en el tamaño especificados.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBounds (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBounds(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="member this.SetBounds : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.SetBounds (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Nuevo valor de la propiedad <see cref="P:System.Windows.Forms.Control.Left" /> del control.</param>
        <param name="y">Nuevo valor de la propiedad <see cref="P:System.Windows.Forms.Control.Top" /> del control.</param>
        <param name="width">Nuevo valor de la propiedad <see cref="P:System.Windows.Forms.Control.Width" /> del control.</param>
        <param name="height">Nuevo valor de la propiedad <see cref="P:System.Windows.Forms.Control.Height" /> del control.</param>
        <param name="specified">Combinación bit a bit de los valores de <see cref="T:System.Windows.Forms.BoundsSpecified" />. En el caso de que no se especifique un parámetro, se utilizará el valor actual.</param>
        <summary>Establece los límites especificados del control en la ubicación y en el tamaño especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente código de ejemplo centros un <xref:System.Windows.Forms.Form> en la pantalla en la <xref:System.Windows.Forms.Control.Layout> eventos. Esto mantendrá el formulario centrado cuando el usuario lo modifica. En este ejemplo requiere que se haya creado un <xref:System.Windows.Forms.Form> control.  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected virtual void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit&#xA;override this.SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.SetBoundsCore (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Nuevo valor de la propiedad <see cref="P:System.Windows.Forms.Control.Left" /> del control.</param>
        <param name="y">Nuevo valor de la propiedad <see cref="P:System.Windows.Forms.Control.Top" /> del control.</param>
        <param name="width">Nuevo valor de la propiedad <see cref="P:System.Windows.Forms.Control.Width" /> del control.</param>
        <param name="height">Nuevo valor de la propiedad <see cref="P:System.Windows.Forms.Control.Height" /> del control.</param>
        <param name="specified">Combinación bit a bit de los valores de <see cref="T:System.Windows.Forms.BoundsSpecified" />.</param>
        <summary>Realiza la tarea de configurar los límites especificados de este control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, los parámetros que corresponden a los límites no incluidos en el `specified` parámetros se pasan con sus valores actuales. Por ejemplo, el <xref:System.Windows.Forms.Control.Height%2A>, <xref:System.Windows.Forms.Control.Width%2A>, o el <xref:System.Drawing.Point.X%2A> o <xref:System.Drawing.Point.Y%2A> propiedades de la <xref:System.Windows.Forms.Control.Location%2A> propiedad se puede pasar con una referencia a la instancia actual del control. Sin embargo todos los valores pasados son respeta y aplicados al control.  
  
 El `boundsSpecified` parámetro representa los elementos de los controles <xref:System.Windows.Forms.Control.Bounds%2A> modificados por la aplicación. Por ejemplo, si cambia el <xref:System.Windows.Forms.Control.Size%2A> del control, el `boundsSpecified` valor del parámetro es el `Size` valor <xref:System.Windows.Forms.BoundsSpecified>. Sin embargo, si la <xref:System.Windows.Forms.Control.Size%2A> se ajusta en respuesta a la <xref:System.Windows.Forms.Control.Dock%2A> propiedad que se establece, el `boundsSpecified` valor del parámetro es el `None` valor de <xref:System.Windows.Forms.BoundsSpecified>.  
  
> [!NOTE]
>  En los sistemas Windows Server 2003, el tamaño de un <xref:System.Windows.Forms.Form> está restringido por el ancho de píxel máximo y el alto del monitor.  
  
   
  
## Examples  
 El siguiente código de ejemplo invalida el <xref:System.Windows.Forms.Control.SetBoundsCore%2A> método para asegurarse de que el control mantiene un tamaño fijo. En este ejemplo requiere que tenga una clase que derive directa o indirectamente de la <xref:System.Windows.Forms.Control> clase.  
  
 [!code-cpp[Windows.Forms.Control_Methods#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#1)]
 [!code-csharp[Windows.Forms.Control_Methods#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#1)]
 [!code-vb[Windows.Forms.Control_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> método para forzar los límites del control que se va a cambiar. Las clases derivadas pueden agregar restricciones de tamaño para el <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> método.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected virtual void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetClientSizeCore (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetClientSizeCore(int x, int y);" />
      <MemberSignature Language="F#" Value="abstract member SetClientSizeCore : int * int -&gt; unit&#xA;override this.SetClientSizeCore : int * int -&gt; unit" Usage="control.SetClientSizeCore (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Ancho del área cliente, en píxeles.</param>
        <param name="y">Alto del área cliente, en píxeles.</param>
        <summary>Establece el tamaño del área cliente del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El área de cliente se inicia en el (0, 0) ubicación y se extiende a la (`x`, `y`) ubicación.  
  
 Por lo general, no debe establecer el <xref:System.Windows.Forms.Control.ClientSize%2A> del control.  
  
   
  
## Examples  
 El siguiente código de ejemplo invalida el <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> método para asegurarse de que el control sigue siendo un cuadrado. En este ejemplo requiere que tenga una clase que derive directa o indirectamente de la <xref:System.Windows.Forms.Control> clase.  
  
 [!code-cpp[Windows.Forms.Control_Methods#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#2)]
 [!code-csharp[Windows.Forms.Control_Methods#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#2)]
 [!code-vb[Windows.Forms.Control_Methods#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" /> método para que el <see cref="P:System.Windows.Forms.Control.ClientSize" /> se ajusta la propiedad.  Para obtener más información sobre el dibujo de controles, vea [representar un Control de Windows Forms](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
      </Docs>
    </Member>
    <Member MemberName="SetStyle">
      <MemberSignature Language="C#" Value="protected void SetStyle (System.Windows.Forms.ControlStyles flag, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetStyle(valuetype System.Windows.Forms.ControlStyles flag, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetStyle (flag As ControlStyles, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetStyle(System::Windows::Forms::ControlStyles flag, bool value);" />
      <MemberSignature Language="F#" Value="member this.SetStyle : System.Windows.Forms.ControlStyles * bool -&gt; unit" Usage="control.SetStyle (flag, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flag">Bit <see cref="T:System.Windows.Forms.ControlStyles" /> que se va a establecer.</param>
        <param name="value">Es <see langword="true" /> para aplicar el estilo especificado al control; en caso contrario, es <see langword="false" />.</param>
        <summary>Establece un marcador <see cref="T:System.Windows.Forms.ControlStyles" /> en <see langword="true" /> o <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Marcas de bit de estilo de control se usan para categorizar el comportamiento compatible. Un control puede habilitar un estilo mediante una llamada a la <xref:System.Windows.Forms.Control.SetStyle%2A> método y pasando adecuado <xref:System.Windows.Forms.ControlStyles> bits (o bits) y el valor booleano para establecer los bits. Para determinar el valor asignado a un determinado <xref:System.Windows.Forms.ControlStyles> de bits, utilice el <xref:System.Windows.Forms.Control.GetStyle%2A> método y pase el <xref:System.Windows.Forms.ControlStyles> miembro para evaluar.  
  
> [!CAUTION]
>  Establecer el control de bits de estilo puede cambiar sustancialmente el comportamiento del control. Revise el <xref:System.Windows.Forms.ControlStyles> documentación de la enumeración para comprender los efectos de modificar los bits de estilo del control antes de llamar a la <xref:System.Windows.Forms.Control.SetStyle%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se habilita el búfer doble en un <xref:System.Windows.Forms.Form> y actualiza los estilos para reflejar los cambios.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="SetTopLevel">
      <MemberSignature Language="C#" Value="protected void SetTopLevel (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetTopLevel(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetTopLevel (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetTopLevel(bool value);" />
      <MemberSignature Language="F#" Value="member this.SetTopLevel : bool -&gt; unit" Usage="control.SetTopLevel value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Es <see langword="true" /> para establecer el control como el control de nivel superior; en caso contrario, es <see langword="false" />.</param>
        <summary>Establece el control como el control de nivel superior.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se llama a la <xref:System.Windows.Forms.Control.SetTopLevel%2A> método de un <xref:System.Windows.Forms.Form> y pasar un valor de `false`, el formulario no estará visible hasta que llame a <xref:System.Windows.Forms.Control.SetTopLevel%2A> nuevo, pasando un valor de `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El parámetro <paramref name="value" /> está establecido en <see langword="true" /> y el control es un control ActiveX.</exception>
        <exception cref="T:System.Exception">El valor devuelto por <see cref="M:System.Windows.Forms.Control.GetTopLevel" /> no es igual al parámetro <paramref name="value" />, y la propiedad <see cref="P:System.Windows.Forms.Control.Parent" /> no es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para establecer el control como un control de nivel superior si es distinto de cualquier tipo <see cref="T:System.Windows.Forms.Form" />. Este permiso se solicita únicamente si el <paramref name="value" /> parámetro es <see langword="true" /> y el control no es un control ActiveX. Enumeración asociada: <see langword="AllWindows" /> valor <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.GetTopLevel" />
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected virtual void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetVisibleCore (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetVisibleCore(bool value);" />
      <MemberSignature Language="F#" Value="abstract member SetVisibleCore : bool -&gt; unit&#xA;override this.SetVisibleCore : bool -&gt; unit" Usage="control.SetVisibleCore value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Es <see langword="true" /> para que el control sea visible; en caso contrario, es <see langword="false" />.</param>
        <summary>Establece el control en el estado de visibilidad especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, debe reemplazar este método para cambiar el comportamiento de visibilidad del control.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" /> método para forzar la visibilidad del control que se va a cambiar.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="control.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Muestra el control al usuario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mostrar el control es equivalente a establecer el <xref:System.Windows.Forms.Control.Visible%2A> propiedad `true`. Después de la <xref:System.Windows.Forms.Control.Show%2A> se invoca el <xref:System.Windows.Forms.Control.Visible%2A> propiedad devuelve un valor de `true` hasta que el <xref:System.Windows.Forms.Control.Hide%2A> se llama al método.  
  
   
  
## Examples  
 El siguiente código de ejemplo se muestra un cuadro de diálogo acerca y se dibuja temporalmente un cuadrado azul en su superficie. Este ejemplo requiere que haya definido una clase que derive de <xref:System.Windows.Forms.Form> denominado `AboutDialog`.  
  
 [!code-cpp[Windows.Forms.Control Members2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#1)]
 [!code-vb[Windows.Forms.Control Members2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
      </Docs>
    </Member>
    <Member MemberName="ShowFocusCues">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShowFocusCues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowFocusCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowFocusCues" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property ShowFocusCues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool ShowFocusCues { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShowFocusCues : bool" Usage="System.Windows.Forms.Control.ShowFocusCues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el control debe mostrar rectángulos de foco.</summary>
        <value>
          <see langword="true" /> si el control debe mostrar rectángulos de foco; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre esta característica, consulte el[WM_CHANGEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx),[WM_QUERYUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx)y el [WM_UPDATEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx)temas.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.ShowFocusCues" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.ShowFocusCues" /> propiedad para extender la implementación base. En caso contrario, debe proporcionar toda la implementación.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
        <altmember cref="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      </Docs>
    </Member>
    <Member MemberName="ShowKeyboardCues">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShowKeyboardCues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowKeyboardCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property ShowKeyboardCues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool ShowKeyboardCues { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShowKeyboardCues : bool" Usage="System.Windows.Forms.Control.ShowKeyboardCues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la interfaz de usuario está en el estado adecuado para mostrar u ocultar los aceleradores de teclado.</summary>
        <value>
          <see langword="true" /> si los aceleradores de teclado son visibles; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En los controles creados en el Diseñador de Windows Forms, los aceleradores de teclado son visibles de forma predeterminada.  
  
 Para obtener más información sobre esta característica, consulte el[WM_CHANGEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx),[WM_QUERYUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx)y el [WM_UPDATEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx)temas.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="P:System.Windows.Forms.Control.ShowFocusCues" />
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Windows.Forms.Control.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el sitio del control.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> asociado a <see cref="T:System.Windows.Forms.Control" />, en caso de que exista.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.ISite" />
        <altmember cref="P:System.ComponentModel.IComponent.Site" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el alto y el ancho del control.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> que representa el ancho y el alto del control en píxeles.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dado que el <xref:System.Drawing.Size> clase es un tipo de valor (`Structure` en Visual Basic, `struct` en Visual C#), se devuelve por valor, lo que significa que el acceso a la propiedad devuelve una copia del tamaño del control. Por lo tanto, ajustar el <xref:System.Drawing.Size.Width%2A> o <xref:System.Drawing.Size.Height%2A> propiedades de la <xref:System.Drawing.Size> devuelto de esta propiedad no tendrá ningún efecto el <xref:System.Windows.Forms.Control.Width%2A> o <xref:System.Windows.Forms.Control.Height%2A> del control. Para ajustar el <xref:System.Windows.Forms.Control.Width%2A> o <xref:System.Windows.Forms.Control.Height%2A> del control, debe establecer el control <xref:System.Windows.Forms.Control.Width%2A> o <xref:System.Windows.Forms.Control.Height%2A> o establecer el <xref:System.Windows.Forms.Control.Size%2A> propiedad con un nuevo <xref:System.Drawing.Size>.  
  
> [!NOTE]
>  Para mantener un rendimiento óptimo, no establezca la <xref:System.Drawing.Size> de un control en su constructor. El método preferido es invalidar el <xref:System.Windows.Forms.Control.DefaultSize%2A> propiedad.  
  
> [!NOTE]
>  En los sistemas Windows Server 2003, el tamaño de un <xref:System.Windows.Forms.Form> está restringido por el ancho de píxel máximo y el alto del monitor.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se agrega un <xref:System.Windows.Forms.Button> a un formulario y se establecen algunas de sus propiedades comunes. En el ejemplo se ancla el botón a la esquina inferior derecha del formulario, por lo que mantiene su posición relativa, como el tamaño del formulario. A continuación establece el <xref:System.Windows.Forms.Control.BackgroundImage%2A> y cambia el tamaño del botón en el mismo tamaño que el <xref:System.Drawing.Image>. En el ejemplo, a continuación, Establece el <xref:System.Windows.Forms.Control.TabStop%2A> a `true` y establece el <xref:System.Windows.Forms.Control.TabIndex%2A> propiedad. Por último, agrega un controlador de eventos para controlar la <xref:System.Windows.Forms.Control.Click> eventos del botón. En este ejemplo requiere que haya un <xref:System.Windows.Forms.ImageList> denominado `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : EventHandler " Usage="member this.SizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.Size" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es preferible usar el <xref:System.Windows.Forms.Control.Layout> eventos para controlar los diseños personalizados. El <xref:System.Windows.Forms.Control.Layout> evento se genera en respuesta a <xref:System.Windows.Forms.Control.Resize> eventos, sino también en otras condiciones al diseño posible que deba aplicarse.  
  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.Size%2A> propiedad se modifica mediante programación o interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Windows.Forms.Control.SizeChanged> eventos. Una instancia de un <xref:System.Windows.Forms.Button> control ha sido siempre que se puede escalar horizontal y verticalmente. Un <xref:System.Windows.Forms.NumericUpDown> instancia proporciona el valor de escala horizontal y vertical. El <xref:System.Windows.Forms.Button> instancia denominada **Aceptar** se usa para establecer los valores de escala para el <xref:System.Windows.Forms.Button> instancia del control. Cada vez que cambia el tamaño del control, el controlador de eventos asociado con el <xref:System.Windows.Forms.Control.SizeChanged> se llama al evento del control. Este controlador de eventos muestra un cuadro de mensaje que indica que ha cambiado el tamaño del control.  
  
 [!code-cpp[Control_Scale1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Scale1/CPP/control_scale1.cpp#2)]
 [!code-csharp[Control_Scale1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Scale1/CS/control_scale1.cs#2)]
 [!code-vb[Control_Scale1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Scale1/VB/control_scale1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="SizeFromClientSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size SizeFromClientSize (System.Drawing.Size clientSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Size SizeFromClientSize(valuetype System.Drawing.Size clientSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SizeFromClientSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SizeFromClientSize (clientSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Size SizeFromClientSize(System::Drawing::Size clientSize);" />
      <MemberSignature Language="F#" Value="abstract member SizeFromClientSize : System.Drawing.Size -&gt; System.Drawing.Size&#xA;override this.SizeFromClientSize : System.Drawing.Size -&gt; System.Drawing.Size" Usage="control.SizeFromClientSize clientSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="clientSize">Valor <see cref="T:System.Drawing.Size" /> que representa el alto y el ancho del área cliente del control.</param>
        <summary>Determina el tamaño de todo el control a partir del alto y el ancho de su área cliente.</summary>
        <returns>Valor <see cref="T:System.Drawing.Size" /> que representa el alto y el ancho de todo el control.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StyleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StyleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.StyleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StyleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StyleChanged;" />
      <MemberSignature Language="F#" Value="member this.StyleChanged : EventHandler " Usage="member this.StyleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el estilo del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.StyleChanged> evento tiene lugar cuando <xref:System.Windows.Forms.ControlStyles> marcas se han agregado o cambiado.  
  
 Este evento se desencadena si se cambia el estilo de control mediante programación o por la interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.StyleChanged> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.StyleChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#68](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#68)]
 [!code-vb[System.Windows.Forms.EventExamples#68](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#68)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="SuspendLayout">
      <MemberSignature Language="C#" Value="public void SuspendLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SuspendLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SuspendLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub SuspendLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SuspendLayout();" />
      <MemberSignature Language="F#" Value="member this.SuspendLayout : unit -&gt; unit" Usage="control.SuspendLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Suspende temporalmente la lógica de diseño del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La lógica de diseño del control se suspende hasta que el <xref:System.Windows.Forms.Control.ResumeLayout%2A> se llama al método.  
  
 El <xref:System.Windows.Forms.Control.SuspendLayout%2A> y <xref:System.Windows.Forms.Control.ResumeLayout%2A> métodos se usan conjuntamente para suprimir varios <xref:System.Windows.Forms.Control.Layout> eventos mientras se ajustan varios atributos del control. Por ejemplo, normalmente se llamaría a la <xref:System.Windows.Forms.Control.SuspendLayout%2A> método, a continuación, establezca el <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, o <xref:System.Windows.Forms.Control.Dock%2A> propiedades del control y, a continuación, llame el <xref:System.Windows.Forms.Control.ResumeLayout%2A> método para habilitar los cambios surtan efecto.  
  
 No debe haber ninguna llamada pendiente a <xref:System.Windows.Forms.Control.SuspendLayout%2A> para <xref:System.Windows.Forms.Control.ResumeLayout%2A> llamará correctamente.  
  
> [!NOTE]
>  Al agregar varios controles a un control principal, se recomienda que llame el <xref:System.Windows.Forms.Control.SuspendLayout%2A> método antes de inicializar los controles que se va a agregar. Después de agregar los controles al control primario, llame a la <xref:System.Windows.Forms.Control.ResumeLayout%2A> método. Esto aumentará el rendimiento de aplicaciones con muchos controles.  
  
   
  
## Examples  
 El ejemplo de código siguiente agrega dos botones a un formulario. Las transacciones de ejemplo la adición de los botones mediante el uso de la <xref:System.Windows.Forms.Control.SuspendLayout%2A> y <xref:System.Windows.Forms.Control.ResumeLayout%2A> métodos.  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragDrop">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragDrop (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragDrop(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragDrop (drgEvent As DragEventArgs) Implements IDropTarget.OnDragDrop" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragDrop(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragDrop;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragDrop(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Objeto <see cref="T:System.Windows.Forms.DragEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.DragDrop" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragEnter">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragEnter (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragEnter(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragEnter (drgEvent As DragEventArgs) Implements IDropTarget.OnDragEnter" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragEnter(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragEnter;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragEnter(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Objeto <see cref="T:System.Windows.Forms.DragEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.DragEnter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragLeave">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragLeave (e As EventArgs) Implements IDropTarget.OnDragLeave" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragLeave(EventArgs ^ e) = System::Windows::Forms::IDropTarget::OnDragLeave;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragLeave(System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.DragLeave" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragOver">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragOver (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragOver(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragOver (drgEvent As DragEventArgs) Implements IDropTarget.OnDragOver" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragOver(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragOver;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragOver(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Objeto <see cref="T:System.Windows.Forms.DragEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.DragOver" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemColorsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SystemColorsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SystemColorsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SystemColorsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SystemColorsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SystemColorsChanged;" />
      <MemberSignature Language="F#" Value="member this.SystemColorsChanged : EventHandler " Usage="member this.SystemColorsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se modifican los colores del sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Drawing.SystemColors> se modifica mediante programación o interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.SystemColorsChanged> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.SystemColorsChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#69](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#69)]
 [!code-vb[System.Windows.Forms.EventExamples#69](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#69)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TabIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TabIndex : int with get, set" Usage="System.Windows.Forms.Control.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el orden de tabulación del control en su contenedor.</summary>
        <value>Valor de índice del control dentro del conjunto de controles dentro de su contenedor. Los controles del contenedor están incluidos en el orden de tabulación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un índice de tabulación puede constar de un número entero válido mayor que o igual que cero, los números más bajos que se va a anteriormente en el orden de tabulación. Si más de un control en el mismo control primario tiene el mismo índice de tabulación, el orden z de los controles determina el orden para desplazarse por los controles.  
  
 Para un control que se incluirán en el orden de tabulación, su <xref:System.Windows.Forms.Control.TabStop%2A> propiedad debe establecerse en `true`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se agrega un <xref:System.Windows.Forms.Button> a un formulario y se establecen algunas de sus propiedades comunes. En el ejemplo se ancla el botón a la esquina inferior derecha del formulario, por lo que mantiene su posición relativa, como el tamaño del formulario. A continuación establece el <xref:System.Windows.Forms.Control.BackgroundImage%2A> y cambia el tamaño del botón en el mismo tamaño que el <xref:System.Drawing.Image>. En el ejemplo, a continuación, Establece el <xref:System.Windows.Forms.Control.TabStop%2A> a `true` y establece el <xref:System.Windows.Forms.Control.TabIndex%2A> propiedad. Por último, agrega un controlador de eventos para controlar la <xref:System.Windows.Forms.Control.Click> eventos del botón. En este ejemplo requiere que haya un <xref:System.Windows.Forms.ImageList> denominado `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabIndexChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabIndexChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabIndexChanged;" />
      <MemberSignature Language="F#" Value="member this.TabIndexChanged : EventHandler " Usage="member this.TabIndexChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.TabIndex" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.TabIndex%2A> propiedad se modifica mediante programación o interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.TabIndexChanged> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.TabIndexChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#25)]
 [!code-vb[System.Windows.Forms.EventExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#25)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabStop" />
      <MemberSignature Language="VB.NET" Value="Public Property TabStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TabStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TabStop : bool with get, set" Usage="System.Windows.Forms.Control.TabStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el usuario puede dar el foco a este control mediante la tecla TAB.</summary>
        <value>
          <see langword="true" /> si el usuario puede dar el foco al control mediante la tecla TAB; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.  
  
 <block subset="none" type="note"><para> Esta propiedad siempre devolverá <see langword="true" /> para una instancia de la <see cref="T:System.Windows.Forms.Form" /> clase.  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el usuario presiona la tecla TAB, el foco de entrada se establece en el siguiente control en el orden de tabulación. Los controles con el <xref:System.Windows.Forms.Control.TabStop%2A> el valor de propiedad `false` no se incluyen en la colección de controles en el orden de tabulación. El orden de tabulación se puede manipular mediante el establecimiento del control <xref:System.Windows.Forms.Control.TabIndex%2A> valor de propiedad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se agrega un <xref:System.Windows.Forms.Button> a un formulario y se establecen algunas de sus propiedades comunes. En el ejemplo se ancla el botón a la esquina inferior derecha del formulario, por lo que mantiene su posición relativa, como el tamaño del formulario. A continuación establece el <xref:System.Windows.Forms.Control.BackgroundImage%2A> y cambia el tamaño del botón en el mismo tamaño que el <xref:System.Drawing.Image>. En el ejemplo, a continuación, Establece el <xref:System.Windows.Forms.Control.TabStop%2A> a `true` y establece el <xref:System.Windows.Forms.Control.TabIndex%2A> propiedad. Por último, agrega un controlador de eventos para controlar la <xref:System.Windows.Forms.Control.Click> eventos del botón. En este ejemplo requiere que haya un <xref:System.Windows.Forms.ImageList> denominado `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabStopChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabStopChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabStopChanged;" />
      <MemberSignature Language="F#" Value="member this.TabStopChanged : EventHandler " Usage="member this.TabStopChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.TabStop" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.TabStop%2A> propiedad se modifica mediante programación o interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Control.TabStopChanged> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.Control>, como un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. A continuación, asigne a la instancia `Control1` y asegúrese de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Control.TabStopChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#26)]
 [!code-vb[System.Windows.Forms.EventExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.Forms.Control.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto que contiene datos sobre el control.</summary>
        <value>
          <see cref="T:System.Object" /> que contiene datos sobre el control. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquier tipo derivado de la <xref:System.Object> clase puede asignarse a esta propiedad. Si el <xref:System.Windows.Forms.Control.Tag%2A> propiedad se establece mediante el Diseñador de Windows Forms, se puede asignar solo texto.  
  
 Un uso común para el <xref:System.Windows.Forms.Control.Tag%2A> propiedad consiste en almacenar datos estrechamente relacionados con el control. Por ejemplo, si tiene un control que muestra información sobre un cliente, podría almacenar un <xref:System.Data.DataSet> que contiene el historial de pedidos del cliente en ese control <xref:System.Windows.Forms.Control.Tag%2A> propiedad, por lo que pueden obtener acceso a los datos rápidamente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra un formulario y almacena una `Customer` en su <xref:System.Windows.Forms.Control.Tag%2A> propiedad. Este ejemplo requiere que haya definido una clase que derive de <xref:System.Windows.Forms.Form> denominado `CustomerForm` y que ha definido un `Customer`.  
  
 [!code-cpp[Windows.Forms.Control Members2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#3)]
 [!code-vb[Windows.Forms.Control Members2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public virtual string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.Control.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(-517)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el texto asociado al control.</summary>
        <value>Texto asociado al control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.Text%2A> propiedad del control se usa de forma diferente por cada clase derivada. Por ejemplo el <xref:System.Windows.Forms.Control.Text%2A> propiedad de un <xref:System.Windows.Forms.Form> se muestra en la barra de título en la parte superior del formulario, de recuento de caracteres es bastante pequeño y normalmente se muestra el nombre de aplicación o documento. Sin embargo, el <xref:System.Windows.Forms.Control.Text%2A> propiedad de un <xref:System.Windows.Forms.RichTextBox> pueden ser grandes y pueden incluir numerosos caracteres no visuales que se utilizan para dar formato al texto. Por ejemplo, el texto mostrado en un <xref:System.Windows.Forms.RichTextBox> puede tener el formato ajustando el <xref:System.Drawing.Font> propiedades, o mediante la adición de espacios o caracteres de tabulación para alinear el texto.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Windows.Forms.GroupBox> y se establecen algunas de sus propiedades comunes. El ejemplo se crea un <xref:System.Windows.Forms.TextBox> y establece su <xref:System.Windows.Forms.Control.Location%2A> dentro del cuadro de grupo. A continuación, Establece la <xref:System.Windows.Forms.Control.Text%2A> propiedad del cuadro de grupo y lo acopla el grupo de cuadro a la parte superior del formulario. Por último, deshabilita el cuadro de grupo estableciendo el <xref:System.Windows.Forms.Control.Enabled%2A> propiedad `false`, lo que hace que todos los controles contenidos en el cuadro de grupo va a deshabilitar.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza el <see cref="P:System.Windows.Forms.Control.Text" /> propiedad en una clase derivada, utilice la clase base <see cref="P:System.Windows.Forms.Control.Text" /> propiedad para extender la implementación base. En caso contrario, debe proporcionar toda la implementación. No es necesario reemplazar ambos el <see langword="get" /> y <see langword="set" /> descriptores de acceso de la <see cref="P:System.Windows.Forms.Control.Text" /> propiedad; se puede reemplazar sólo uno, si es necesario.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.TextLength" />
      </Docs>
    </Member>
    <Member MemberName="TextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TextChanged;" />
      <MemberSignature Language="F#" Value="member this.TextChanged : EventHandler " Usage="member this.TextChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.Text" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.Text%2A> propiedad se modifica mediante programación o interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El siguiente código de ejemplo se cambia el <xref:System.Windows.Forms.Control.ForeColor%2A> de un <xref:System.Windows.Forms.TextBox> muestra datos de moneda. El ejemplo convierte el texto de un número decimal y los cambios en el <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> si el número es negativo y a <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> si el número es positivo. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> que contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public int Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Top { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Top : int with get, set" Usage="System.Windows.Forms.Control.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la distancia, en píxeles, que existe entre el borde superior del control y el borde superior del área cliente de su contenedor.</summary>
        <value>
          <see cref="T:System.Int32" /> que representa la distancia, en píxeles, que existe entre el borde inferior del control y el borde superior del área cliente de su contenedor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.Top%2A> valor de propiedad es equivalente a la <xref:System.Drawing.Point.Y%2A?displayProperty=nameWithType> propiedad de la <xref:System.Windows.Forms.Control.Location%2A> valor de propiedad del control.  
  
 Los cambios realizados en el <xref:System.Windows.Forms.Control.Height%2A> y <xref:System.Windows.Forms.Control.Top%2A> causa de los valores de propiedad el <xref:System.Windows.Forms.Control.Bottom%2A> valor de propiedad del control que se va a cambiar.  
  
   
  
## Examples  
 El ejemplo de código siguiente crea tres <xref:System.Windows.Forms.Button> controles de formularios y establece su tamaño y la ubicación mediante el uso de las diversas propiedades relacionadas con la ubicación y tamaño. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> que tiene un ancho y alto de al menos 300 píxeles.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Point.Y" />
        <altmember cref="P:System.Windows.Forms.Control.Bottom" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="TopLevelControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control TopLevelControl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control TopLevelControl" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TopLevelControl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TopLevelControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ TopLevelControl { System::Windows::Forms::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TopLevelControl : System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.TopLevelControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el control primario que no es secundario de ningún otro control de formularios Windows Forms. Normalmente, se trata del <see cref="T:System.Windows.Forms.Form" /> más externo en el que está contenido el control.</summary>
        <value>
          <see cref="T:System.Windows.Forms.Control" /> que representa al control de nivel superior que contiene el control actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El control de nivel superior se define como el control primario que no es secundario de ningún otro control de Windows Forms. Normalmente, se trata del <xref:System.Windows.Forms.Form> más externo en el que está contenido el control. Por ejemplo, si el control está incluido en un formulario MDI secundario <xref:System.Windows.Forms.Form>, entonces el control de nivel superior es el elemento primario de la interfaz de múltiples documentos (MDI) <xref:System.Windows.Forms.Form>. Si el control no tiene un elemento primario en una <xref:System.Windows.Forms.Form>, esta propiedad devolverá `null`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas obtener este valor de propiedad. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public void Update ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Update() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Update" />
      <MemberSignature Language="VB.NET" Value="Public Sub Update ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Update();" />
      <MemberSignature Language="F#" Value="member this.Update : unit -&gt; unit" Usage="control.Update " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hace que el control vuelva a dibujar las regiones no válidas en su área de cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ejecuta las solicitudes pendientes para pintar.  
  
 Hay dos maneras de dibujar un formulario y su contenido:  
  
-   Puede usar una de las sobrecargas de los <xref:System.Windows.Forms.Control.Invalidate%2A> método con el <xref:System.Windows.Forms.Control.Update%2A> método.  
  
-   Puede llamar a la <xref:System.Windows.Forms.Control.Refresh%2A> método, que obliga al control a dibujarse, así como todos sus elementos secundarios. Esto es equivalente a establecer el <xref:System.Windows.Forms.Control.Invalidate%2A> método `true` y su uso con <xref:System.Windows.Forms.Control.Update%2A>.  
  
 El <xref:System.Windows.Forms.Control.Invalidate%2A> método controla lo que se dibuja o vuelva a dibujar. El <xref:System.Windows.Forms.Control.Update%2A> rige el método cuando dibuja o cuándo se produce. Si usas el <xref:System.Windows.Forms.Control.Invalidate%2A> y <xref:System.Windows.Forms.Control.Update%2A> juntas en lugar de llamar a métodos <xref:System.Windows.Forms.Control.Refresh%2A>, lo que se vuelve a dibujar depende de qué sobrecarga de <xref:System.Windows.Forms.Control.Invalidate%2A> utilice. El <xref:System.Windows.Forms.Control.Update%2A> método obliga a que el control se dibuje inmediatamente, pero la <xref:System.Windows.Forms.Control.Invalidate%2A> método controla lo que se dibuja cuando se llama a la <xref:System.Windows.Forms.Control.Update%2A> método.  
  
 Para obtener más información, consulte el[WM_PAINT](http://msdn.microsoft.com/library/dd145213\(v=vs.85\).aspx)tema.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Actualiza los límites del control.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected internal void UpdateBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void UpdateBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub UpdateBounds ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void UpdateBounds();" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : unit -&gt; unit" Usage="control.UpdateBounds " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Actualiza los límites del control con la ubicación y el tamaño actuales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el nuevo <xref:System.Windows.Forms.Control.Size%2A> del control es diferente del anterior <xref:System.Drawing.Size>, el <xref:System.Windows.Forms.Control.SizeChanged> provoca el evento. Del mismo modo, si la <xref:System.Windows.Forms.Control.Location%2A> del control cambia, el <xref:System.Windows.Forms.Control.LocationChanged> provoca el evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : int * int * int * int -&gt; unit" Usage="control.UpdateBounds (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada <see cref="P:System.Drawing.Point.X" /> del control.</param>
        <param name="y">Coordenada <see cref="P:System.Drawing.Point.Y" /> del control.</param>
        <param name="width">
          <see cref="P:System.Drawing.Size.Width" /> del control.</param>
        <param name="height">
          <see cref="P:System.Drawing.Size.Height" /> del control.</param>
        <summary>Actualiza los límites del control con la ubicación y el tamaño especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el nuevo <xref:System.Windows.Forms.Control.Size%2A> del control si es diferente del anterior <xref:System.Drawing.Size>, el <xref:System.Windows.Forms.Control.SizeChanged> provoca el evento. Del mismo modo, es el <xref:System.Windows.Forms.Control.Location%2A> del control cambia, el <xref:System.Windows.Forms.Control.LocationChanged> provoca el evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height, int32 clientWidth, int32 clientHeight) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds (x As Integer, y As Integer, width As Integer, height As Integer, clientWidth As Integer, clientHeight As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds(int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : int * int * int * int * int * int -&gt; unit" Usage="control.UpdateBounds (x, y, width, height, clientWidth, clientHeight)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="clientWidth" Type="System.Int32" />
        <Parameter Name="clientHeight" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada <see cref="P:System.Drawing.Point.X" /> del control.</param>
        <param name="y">Coordenada <see cref="P:System.Drawing.Point.Y" /> del control.</param>
        <param name="width">
          <see cref="P:System.Drawing.Size.Width" /> del control.</param>
        <param name="height">
          <see cref="P:System.Drawing.Size.Height" /> del control.</param>
        <param name="clientWidth">
          <see cref="P:System.Drawing.Size.Width" /> de cliente del control.</param>
        <param name="clientHeight">
          <see cref="P:System.Drawing.Size.Height" /> de cliente del control.</param>
        <summary>Actualiza los límites del control con el tamaño, la ubicación y el tamaño de cliente especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el nuevo <xref:System.Windows.Forms.Control.Size%2A> del control es diferente del anterior <xref:System.Drawing.Size>, el <xref:System.Windows.Forms.Control.SizeChanged> provoca el evento. Del mismo modo, si la <xref:System.Windows.Forms.Control.Location%2A> del control cambia, el <xref:System.Windows.Forms.Control.LocationChanged> provoca el evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
      </Docs>
    </Member>
    <Member MemberName="UpdateStyles">
      <MemberSignature Language="C#" Value="protected void UpdateStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateStyles" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateStyles ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateStyles();" />
      <MemberSignature Language="F#" Value="member this.UpdateStyles : unit -&gt; unit" Usage="control.UpdateStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obliga a que los estilos asignados vuelvan a aplicarse al control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método llama a la <xref:System.Windows.Forms.Control.CreateParams%2A> método para obtener los estilos que se va a aplicar. Los estilos asignados a la <xref:System.Windows.Forms.CreateParams.Style%2A> y <xref:System.Windows.Forms.CreateParams.ExStyle%2A> propiedades de la <xref:System.Windows.Forms.CreateParams> asignado al control <xref:System.Windows.Forms.Control.CreateParams%2A> se vuelven a aplicar la propiedad. El control se actualiza para reflejar los cambios de estilo si es necesario.  
  
 El <xref:System.Windows.Forms.Control.UpdateStyles%2A> método no tiene ningún efecto si la <xref:System.Windows.Forms.Control.IsHandleCreated%2A> es el valor de propiedad `false`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se habilita el búfer doble en un <xref:System.Windows.Forms.Form> y actualiza los estilos para reflejar los cambios.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="UpdateZOrder">
      <MemberSignature Language="C#" Value="protected void UpdateZOrder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateZOrder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateZOrder" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateZOrder ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateZOrder();" />
      <MemberSignature Language="F#" Value="member this.UpdateZOrder : unit -&gt; unit" Usage="control.UpdateZOrder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Actualiza el control en el orden Z de su control primario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Control.UpdateZOrder%2A> método actualiza la posición del control en el orden z de su control principal. Por ejemplo, si este control es un control recién creado que se agregó a un <xref:System.Windows.Forms.Control.ControlCollection>, el orden z se actualiza con el nuevo control se agrega a la parte trasera.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Control.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se utiliza el cursor de espera para el control actual y todos los controles secundarios.</summary>
        <value>Es <see langword="true" /> para usar el cursor de espera para el control actual y todos los controles secundarios; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice un cursor de espera siempre se realiza una operación que tarda bastante tiempo. Sin embargo, tenga en cuenta que las operaciones que bloquean el subproceso de interfaz de usuario, también se bloquearán acursor cambio. Por lo tanto, esta propiedad sólo debe usarse al realizar operaciones que requieren mucho tiempo en otro subproceso. Para cambiar el cursor inmediatamente y globalmente, como ve, <xref:System.Windows.Forms.Cursor.Current%2A> propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validated">
      <MemberSignature Language="C#" Value="public event EventHandler Validated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Validated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Validated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Validated;" />
      <MemberSignature Language="F#" Value="member this.Validated : EventHandler " Usage="member this.Validated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando finaliza la validación del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al cambiar el foco mediante el teclado (ficha, MAYÚS+TAB etc.), mediante una llamada a la <xref:System.Windows.Forms.Control.Select%2A> o <xref:System.Windows.Forms.Control.SelectNextControl%2A> métodos, o estableciendo la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> propiedad al formulario actual, se producen eventos de foco en el orden siguiente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Al cambiar el foco mediante el mouse o mediante una llamada a la <xref:System.Windows.Forms.Control.Focus%2A> método, se producen eventos de foco en el orden siguiente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Si el <xref:System.Windows.Forms.Control.CausesValidation%2A> propiedad está establecida en `false`, <xref:System.Windows.Forms.Control.Validating> y <xref:System.Windows.Forms.Control.Validated> se suprimen eventos.  
  
 Si el <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propiedad de la <xref:System.ComponentModel.CancelEventArgs> está establecido en `true` en el <xref:System.Windows.Forms.Control.Validating> delegado de eventos, todos los eventos que se producirían generalmente después el <xref:System.Windows.Forms.Control.Validating> se suprimen eventos.  
  
> [!CAUTION]
>  No intente establecer el foco desde el <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> controladores de eventos. Si lo hace, puede provocar la aplicación o el sistema operativo deja de responder. Para obtener más información, consulte el[WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx)tema y la sección "Mensaje interbloqueos" de la [acerca de los mensajes y las colas de mensajes](http://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx) tema.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se utiliza la clase derivada <xref:System.Windows.Forms.TextBox> y valida una dirección de correo electrónico que el usuario escribe. Si la dirección de correo electrónico no está en el formato estándar (que contiene "@" and "."), se produce un error en la validación, un <xref:System.Windows.Forms.ErrorProvider> icono se muestra y se cancela el evento. Este ejemplo requiere que un <xref:System.Windows.Forms.TextBox> y <xref:System.Windows.Forms.ErrorProvider> se han creado los controles en un formulario.  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
      </Docs>
    </Member>
    <Member MemberName="Validating">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Validating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Validating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Validating As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Validating;" />
      <MemberSignature Language="F#" Value="member this.Validating : System.ComponentModel.CancelEventHandler " Usage="member this.Validating : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el control se está validando.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al cambiar el foco mediante el teclado (ficha, MAYÚS+TAB etc.), mediante una llamada a la <xref:System.Windows.Forms.Control.Select%2A> o <xref:System.Windows.Forms.Control.SelectNextControl%2A> métodos, o estableciendo la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> propiedad al formulario actual, se producen eventos de foco en el orden siguiente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Al cambiar el foco mediante el mouse o mediante una llamada a la <xref:System.Windows.Forms.Control.Focus%2A> método, se producen eventos de foco en el orden siguiente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Si el <xref:System.Windows.Forms.Control.CausesValidation%2A> propiedad está establecida en `false`, <xref:System.Windows.Forms.Control.Validating> y <xref:System.Windows.Forms.Control.Validated> se suprimen eventos.  
  
 Si el <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propiedad de la <xref:System.ComponentModel.CancelEventArgs> está establecido en `true` en el <xref:System.Windows.Forms.Control.Validating> delegado de eventos, todos los eventos que se producirían generalmente después el <xref:System.Windows.Forms.Control.Validating> se suprimen eventos.  
  
> [!CAUTION]
>  No intente establecer el foco desde el <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> controladores de eventos. Si lo hace, puede provocar la aplicación o el sistema operativo deja de responder. Para obtener más información, consulte el `WM_KILLFOCUS` tema en la sección "Referencia de la entrada de teclado" y la sección "Mensaje interbloqueos" del tema "Acerca de los mensajes y las colas de mensajes" en MSDN library en http://msdn.microsoft.com/library.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se utiliza la clase derivada <xref:System.Windows.Forms.TextBox> y valida una dirección de correo electrónico que el usuario escribe. Si la dirección de correo electrónico no está en el formato estándar (que contiene "@" and "."), se produce un error en la validación, un <xref:System.Windows.Forms.ErrorProvider> icono se muestra y se cancela el evento. Este ejemplo requiere que un <xref:System.Windows.Forms.TextBox> y <xref:System.Windows.Forms.ErrorProvider> se han creado los controles en un formulario.  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Windows.Forms.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se muestran el control y todos sus controles secundarios.</summary>
        <value>
          <see langword="true" /> si se muestran el control y todos sus controles secundarios; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que incluso si `Visible` está establecido en `true`, el control podría no ser visible para el usuario si se oculta detrás de otros controles.  
  
   
  
## Examples  
 El ejemplo de código siguiente utiliza las clases derivadas <xref:System.Windows.Forms.VScrollBar> y <xref:System.Windows.Forms.HScrollBar> y establece su <xref:System.Windows.Forms.Control.Visible%2A> valores de propiedad, según el tamaño de un <xref:System.Drawing.Image> que se muestran en un <xref:System.Windows.Forms.PictureBox> control. Este ejemplo requiere que un <xref:System.Windows.Forms.PictureBox> se ha creado en un formulario y que <xref:System.Windows.Forms.HScrollBar> y <xref:System.Windows.Forms.VScrollBar> controles se han creado en el <xref:System.Windows.Forms.PictureBox>. Este código se debe llamar cuando se carga la imagen en el cuadro de imagen y por la <xref:System.Windows.Forms.Control.Resize> evento del formulario.  
  
 [!code-cpp[Classic Control.Visible Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.Visible Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.Visible Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.Visible Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Visible Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.Visible Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="VisibleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler VisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.VisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VisibleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ VisibleChanged;" />
      <MemberSignature Language="F#" Value="member this.VisibleChanged : EventHandler " Usage="member this.VisibleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.Control.Visible" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena si el <xref:System.Windows.Forms.Control.Visible%2A> propiedad se modifica mediante programación o interacción del usuario.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El siguiente código de ejemplo genera el <xref:System.Windows.Forms.Control.VisibleChanged> eventos cuando el <xref:System.Windows.Forms.Control.Visible%2A> valor de propiedad de la <xref:System.Windows.Forms.Label> control ha cambiado.  
  
 [!code-cpp[Control_VisibleChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_VisibleChanged/CPP/control_visiblechanged.cpp#1)]
 [!code-csharp[Control_VisibleChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_VisibleChanged/CS/control_visiblechanged.cs#1)]
 [!code-vb[Control_VisibleChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_VisibleChanged/VB/control_visiblechanged.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public int Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Width { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Width : int with get, set" Usage="System.Windows.Forms.Control.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el ancho del control.</summary>
        <value>Ancho del control, en píxeles.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los cambios realizados en el <xref:System.Windows.Forms.Control.Width%2A> y <xref:System.Windows.Forms.Control.Left%2A> causa de los valores de propiedad el <xref:System.Windows.Forms.Control.Right%2A> valor de propiedad del control que se va a cambiar.  
  
   
  
## Examples  
 El ejemplo de código siguiente crea tres <xref:System.Windows.Forms.Button> controles de formularios y establece su tamaño y la ubicación mediante el uso de las diversas propiedades relacionadas con la ubicación y tamaño. En este ejemplo requiere que haya un <xref:System.Windows.Forms.Form> que tiene un ancho y alto de al menos 300 píxeles.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Drawing.Size.Width" />
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WindowTarget">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IWindowTarget WindowTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IWindowTarget WindowTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.WindowTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowTarget As IWindowTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IWindowTarget ^ WindowTarget { System::Windows::Forms::IWindowTarget ^ get(); void set(System::Windows::Forms::IWindowTarget ^ value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTarget : System.Windows.Forms.IWindowTarget with get, set" Usage="System.Windows.Forms.Control.WindowTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IWindowTarget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta propiedad no es relevante para esta clase.</summary>
        <value>El NativeWindow contenido dentro del control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected virtual void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member WndProc :  -&gt; unit&#xA;override this.WndProc :  -&gt; unit" Usage="control.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">
          <see cref="T:System.Windows.Forms.Message" /> de Windows que se va a procesar.</param>
        <summary>Procesa los mensajes de Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los mensajes se envían a la <xref:System.Windows.Forms.Control.WndProc%2A> método una vez filtrados a través de la <xref:System.Windows.Forms.Control.PreProcessMessage%2A> método.  
  
 El método <xref:System.Windows.Forms.Control.WndProc%2A> corresponde exactamente a la función `WindowProc` de Windows. Para obtener más información acerca de cómo procesar mensajes de Windows, consulte el [función WindowProc](http://go.microsoft.com/fwlink/?LinkId=181565).  
  
   
  
## Examples  
 El ejemplo de código siguiente se muestra cómo reemplazar el <xref:System.Windows.Forms.Control.WndProc%2A> método para controlar los mensajes de sistema operativo identificados en el <xref:System.Windows.Forms.Message> estructura. El[WM_ACTIVATEAPP](http://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx)se controla el mensaje del sistema operativo en este ejemplo para saber cuando otra aplicación se está convirtiendo en activo. Vea los temas siguientes para entender el disponibles <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Message.LParam%2A?displayProperty=nameWithType>, y <xref:System.Windows.Forms.Message.WParam%2A?displayProperty=nameWithType> valores. Los valores constantes reales se pueden encontrar en el archivo de encabezado de Windows.h.  
  
 [!code-cpp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para que el llamador inmediato llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides">
          <para>Los controles heredados deben llamar a la clase base <see cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" /> método para procesar los mensajes que no controlan.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
  </Members>
</Type>