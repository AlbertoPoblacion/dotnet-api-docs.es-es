<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="08260dbf008a513572cd54d0850b022db58deb81" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39736049" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona métodos y propiedades <see langword="static" /> para administrar una aplicación, como métodos para iniciar y detener una aplicación o para procesar mensajes de Windows, y propiedades para obtener información sobre una aplicación. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Forms.Application> clase tiene métodos para iniciar y detener aplicaciones y subprocesos y para procesar mensajes de Windows, como sigue:  
  
-   <xref:System.Windows.Forms.Application.Run%2A> inicia un bucle de mensajes de aplicación en el subproceso actual y, opcionalmente, hace que un formulario sea visible.  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> o <xref:System.Windows.Forms.Application.ExitThread%2A> detiene un bucle de mensajes.  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> procesa los mensajes mientras el programa está en un bucle.  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> Agrega un filtro de mensajes para el suministro de mensajes de la aplicación para supervisar los mensajes de Windows.  
  
-   <xref:System.Windows.Forms.IMessageFilter> le permite impedir que se produzca un evento o realizar operaciones especiales antes de invocar un controlador de eventos.  
  
 Esta clase tiene <xref:System.Windows.Forms.Application.CurrentCulture%2A> y <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> propiedades para obtener o establecer la referencia cultural información para el subproceso actual.  
  
 No se puede crear una instancia de esta clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra números en un cuadro de lista en un formulario. Cada vez que haga clic en `button1`, la aplicación agrega otro número a la lista.  
  
 El `Main` llamadas al método <xref:System.Windows.Forms.Application.Run%2A> para iniciar la aplicación, que crea el formulario, `listBox1` y `button1`. Cuando el usuario hace clic en `button1`, `button1_Click` método muestra un <xref:System.Windows.Forms.MessageBox>. Si el usuario hace clic `No` en el <xref:System.Windows.Forms.MessageBox>, el `button1_Click` método agrega un número a la lista. Si el usuario hace clic `Yes`, la aplicación llama a <xref:System.Windows.Forms.Application.Exit%2A> para procesar todos los mensajes restantes en la cola y, a continuación, para salir.  
  
> [!NOTE]
>  La llamada a <xref:System.Windows.Forms.Application.Exit%2A> se producirá un error en confianza parcial.  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Implementación de la interfaz <see cref="T:System.Windows.Forms.IMessageFilter" /> que se desea instalar.</param>
        <summary>Agrega un filtro de mensajes que controla los mensajes de Windows conforme se enrutan a sus destinos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice un filtro de mensajes para evitar que se produzcan eventos específicos o llevar a cabo operaciones especiales para un evento antes de que se pasa a un controlador de eventos. Filtros de mensajes son únicos en un subproceso concreto.  
  
 Para evitar que un mensaje que se va a enviar, la `value` instancia del parámetro que se pasa a este método se debe invalidar el <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> método con el código para controlar el mensaje. El método debe devolver `false`.  
  
> [!CAUTION]
>  Agregar filtros de mensajes al bombeo de mensajes de una aplicación puede degradar el rendimiento.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un filtro de mensaje denominado `TestMessageFilter`. Este filtro bloquea todos los mensajes relacionados con el botón primario del mouse. Para poder usar un filtro de mensajes, debe proporcionar una implementación para el <xref:System.Windows.Forms.IMessageFilter> interfaz.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para que el llamador inmediato llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el llamador puede cerrar la aplicación.</summary>
        <value>Es <see langword="true" /> si el llamador puede cerrar la aplicación; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve `false` si se llama desde un <xref:System.Windows.Forms.Control> alojarse en un explorador Web. Por lo tanto, el <xref:System.Windows.Forms.Control> no se puede salir el <xref:System.Windows.Forms.Application>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la aplicación se va a cerrar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe asociar los controladores de eventos para el <xref:System.Windows.Forms.Application.Exit%2A> evento para que realice no controlada, requiere tareas antes de la aplicación deja de ejecutarse. Puede cerrar archivos abiertos por la aplicación o desechar los objetos que la recolección de elementos no recuperó.  
  
 Se trata de un evento estático, debe desasociar cualquier controlador de eventos asociado a este evento en el <xref:System.Windows.Forms.Application.ApplicationExit> propio controlador de eventos. Si no se desasocia estos controladores, dejarán permanecen adjuntas al evento y continúan consumiendo memoria.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra dos formularios y sale de la aplicación cuando se cierren ambas formas. Cuando la aplicación se inicia y se cierra, se recuerda la posición de cada formulario. En este ejemplo se muestra cómo utilizar el <xref:System.Windows.Forms.Application.ApplicationExit> evento saber cuándo se deben conservar las posiciones de formulario en el archivo y cuando el `FileStream` debe cerrarse.  
  
 La clase `MyApplicationContext` hereda <xref:System.Windows.Forms.ApplicationContext> y realiza un seguimiento de cuando se cierra cada formulario y sale del subproceso actual cuando ambos están. La clase recuerda la posición de cada formulario cuando está cerrado. Cuando el <xref:System.Windows.Forms.Application.ApplicationExit> evento se produce, la clase escribe las posiciones de cada uno para el usuario en el archivo. Los datos de posición del formulario se almacenan en un archivo denominado `appdata.txt` que se crea en la ubicación determinada por <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. El `Main` llamadas al método `Application.Run(context)` para iniciar la aplicación dado el <xref:System.Windows.Forms.ApplicationContext>.  
  
 Este código es un extracto del ejemplo se muestra en el <xref:System.Windows.Forms.ApplicationContext> información general de clases. Consulte <xref:System.Windows.Forms.ApplicationContext> para obtener el código completo.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso de los datos de aplicación compartidos por todos los usuarios.</summary>
        <value>Ruta de acceso de los datos de aplicación compartidos por todos los usuarios.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no existe una ruta de acceso, se crea uno en el formato siguiente:  
  
 *Ruta de acceso base*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> busca primero para ver si el ensamblado que contiene el archivo ejecutable principal tiene el `AssemblyInformationalVersion` atributo en él. Si este atributo no existe, se usa para ambos <xref:System.Windows.Forms.Application.ProductVersion%2A> y <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Si este atributo no existe, ambas propiedades utilizan la versión del archivo ejecutable en su lugar.  
  
 La ruta de acceso será diferente dependiendo de si la aplicación de Windows Forms se implementa mediante [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] las aplicaciones se almacenan en una caché de aplicaciones por usuario en la C:\Documents and Settings\\*username* directory. Para obtener más información, consulte [obtener acceso Local y remota de datos en aplicaciones ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la clave del Registro de los datos de aplicación compartidos por todos los usuarios.</summary>
        <value>
          <see cref="T:Microsoft.Win32.RegistryKey" /> que representa la clave del Registro de los datos de aplicación compartidos por todos los usuarios.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clave no existe, crearlo en el formato siguiente:  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de la compañía asociado a la aplicación.</summary>
        <value>Nombre de la compañía.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se obtiene esta propiedad y su valor se muestra en un cuadro de texto. El ejemplo requiere que `textBox1` se ha colocado en un formulario.  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la información de referencia cultural del subproceso actual.</summary>
        <value>
          <see cref="T:System.Globalization.CultureInfo" /> que representa la información de referencia cultural del subproceso actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se obtiene esta propiedad y su valor se muestra en un cuadro de texto. El ejemplo requiere que `textBox1` se ha colocado en un formulario.  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas establecer esta propiedad. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el idioma de entrada actual para el subproceso actual.</summary>
        <value>
          <see cref="T:System.Windows.Forms.InputLanguage" /> que representa el idioma de entrada actual para el subproceso actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se obtiene esta propiedad y su valor se muestra en un cuadro de texto. El ejemplo requiere que `textBox1` se ha colocado en un formulario.  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para que el llamador inmediato llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Procesa todos los mensajes de Windows que hay actualmente en la cola de mensajes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se ejecuta un formulario de Windows, crea el nuevo formulario, que, a continuación, espera a controlar eventos. Cada vez que el formulario controla un evento, lo procesa todo el código asociado al evento. Todos los demás eventos de espera en la cola. Mientras que el código controla el evento, la aplicación no responde. Por ejemplo, la ventana no vuelve a dibujarse si se arrastra otra ventana en la parte superior.  
  
 Si se llama a <xref:System.Windows.Forms.Application.DoEvents%2A> en el código, la aplicación puede controlar los demás eventos. Por ejemplo, si tiene un formulario que agrega datos a un <xref:System.Windows.Forms.ListBox> y agregue <xref:System.Windows.Forms.Application.DoEvents%2A> al código, el formulario se vuelve a dibujar cuando se arrastra otra ventana. Si quita <xref:System.Windows.Forms.Application.DoEvents%2A> desde el código, el formulario no volverá a dibujarse hasta que finalice el controlador de eventos click del botón ejecutar. Para obtener más información acerca de la mensajería, vea [entrada del usuario en Windows Forms](~/docs/framework/winforms/user-input-in-windows-forms.md).  
  
 A diferencia de Visual Basic 6.0, el <xref:System.Windows.Forms.Application.DoEvents%2A> no llama al método el <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método.  
  
 Por lo general, use este método en un bucle para procesar los mensajes.  
  
> [!CAUTION]
>  Llamar a este método hace que el subproceso actual se suspenden mientras se procesan todos los mensajes de ventana de espera. Si un mensaje provoca un evento que se desencadene, pueden ejecutar otras áreas del código de aplicación. Esto puede hacer que la aplicación exhiben comportamientos inesperados que resultan difíciles de depurar. Si lleva a cabo las operaciones o los cálculos que toman mucho tiempo, a menudo es preferible realizar esas operaciones en un nuevo subproceso. Para obtener más información sobre la programación asincrónica, vea [Asynchronous Programming Model (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Windows.Forms.Application.DoEvents%2A> método. Cuando se ejecuta el ejemplo, un usuario puede seleccionar archivos de gráficos desde una <xref:System.Windows.Forms.OpenFileDialog>. Los archivos seleccionados se muestran en el formulario. El <xref:System.Windows.Forms.Application.DoEvents%2A> método obliga a que vuelva a dibujarse el formulario para cada archivo gráfico abierto. Para ejecutar este ejemplo, pegue el código siguiente en un formulario que contenga un <xref:System.Windows.Forms.PictureBox> denominado `PictureBox1`, un <xref:System.Windows.Forms.OpenFileDialog> denominado `OpenFileDialog1`y un botón denominado `fileButton`. Llame a la `InitializePictureBox` y `InitializeOpenFileDialog` métodos desde el constructor del formulario o `Load` método.  
  
> [!NOTE]
>  En Visual Studio, si agrega un <xref:System.Windows.Forms.OpenFileDialog> al formulario mediante el uso de una operación de arrastre, tendrá que modificar el siguiente `InitializeOpenFileDialog` método mediante la eliminación de la línea que crea una nueva instancia de <xref:System.Windows.Forms.OpenFileDialog>.  
  
 El ejemplo también requiere que el <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> eventos de la <xref:System.Windows.Forms.Button> control y el <xref:System.Windows.Forms.FileDialog.FileOk> eventos de la <xref:System.Windows.Forms.OpenFileDialog> están conectados a los controladores de eventos definidos en el ejemplo. Cuando se ejecuta el ejemplo, mostrar el cuadro de diálogo, haga clic en el botón.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Habilita los estilos visuales para la aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método habilita los estilos visuales para la aplicación. Los estilos visuales están los colores, fuentes y otros elementos visuales que forman un tema del sistema operativo. Los controles se dibujarán con estilos visuales si el control y el sistema operativo compatible. Para tener un efecto, <xref:System.Windows.Forms.Application.EnableVisualStyles> debe llamarse antes de crear los controles de la aplicación; por lo general, <xref:System.Windows.Forms.Application.EnableVisualStyles> es la primera línea en el `Main` función. No se necesita un manifiesto independiente para habilitar estilos visuales al llamar a <xref:System.Windows.Forms.Application.EnableVisualStyles>.  
  
> [!NOTE]
>  Antes de .NET Framework 2.0, el `FlatStyle` propiedad de algunos controles, como los controles que derivan de <xref:System.Windows.Forms.ButtonBase>, tenía que establecerse en <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> en orden para los controles que se dibuja con estilos visuales. En las aplicaciones escritas con .NET Framework 2.0, esto ya no es necesario.  
  
> [!NOTE]
>  Este método no tendrá ningún efecto sobre los controles alojados en Internet Explorer.  
  
   
  
## Examples  
 El ejemplo de código siguiente se muestra cómo llamar <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> en el `Main` función para habilitar los estilos visuales para la aplicación.  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la aplicación está a punto de entrar en un estado modal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Application.EnterThreadModal> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un formulario Windows Forms y asegurarse de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Application.EnterThreadModal> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Requiere <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> permiso para escuchar el evento.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso del archivo ejecutable que inició la aplicación, incluido el nombre del archivo ejecutable.</summary>
        <value>Ruta de acceso y nombre del archivo ejecutable que inició la aplicación.  
  
Esta ruta de acceso será diferente en función de si la aplicación Windows Forms se implementa mediante [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] las aplicaciones se almacenan en una caché de aplicaciones por usuario en la C:\Documents and Settings\\*username* directory. Para obtener más información, consulte [obtener acceso Local y remota de datos en aplicaciones ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener la ruta de acceso. Enumeración asociada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Notifica a todos los surtidores de mensajes que deben terminar y, a continuación, cierra todas las ventanas de la aplicación una vez procesados todos los mensajes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica a todos los surtidores de mensajes que deben terminar y, a continuación, cierra todas las ventanas de la aplicación una vez procesados todos los mensajes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Application.Exit%2A> método detiene la ejecución de todos los bucles de mensajes en todos los subprocesos y cierra todas las ventanas de la aplicación. Este método no necesariamente forzar el cierre de la aplicación. El <xref:System.Windows.Forms.Application.Exit%2A> método normalmente se llama desde dentro de un bucle de mensajes y se exige que <xref:System.Windows.Forms.Application.Run%2A> para devolver. Para salir de un bucle de mensajes sólo el subproceso actual, llame a <xref:System.Windows.Forms.Application.ExitThread%2A>.  
  
 <xref:System.Windows.Forms.Application.Exit%2A> genera los eventos siguientes y realiza las acciones condicionales asociadas:  
  
-   Un <xref:System.Windows.Forms.Form.FormClosing> evento se desencadena para cada formulario representado por la <xref:System.Windows.Forms.Application.OpenForms%2A> propiedad. Este evento puede cancelarse estableciendo el <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propiedad de sus <xref:System.Windows.Forms.FormClosingEventArgs> parámetro `true`.  
  
-   Si uno o varios de los controladores cancela el evento, a continuación, <xref:System.Windows.Forms.Application.Exit%2A> devuelve sin realizar más acciones. En caso contrario, un <xref:System.Windows.Forms.Form.FormClosed> evento se desencadena para cada formulario abierto, a continuación, se cierran todos los bucles de mensajes y formularios de ejecución.  
  
> [!NOTE]
>  El <xref:System.Windows.Forms.Application.Exit%2A> método no genera el <xref:System.Windows.Forms.Form.Closed> y <xref:System.Windows.Forms.Form.Closing> eventos, que están obsoletos a partir de [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra números en un cuadro de lista en un formulario. Cada vez que haga clic en `button1`, la aplicación agrega otro número a la lista.  
  
 El `Main` llamadas al método <xref:System.Windows.Forms.Application.Run%2A> para iniciar la aplicación, que crea el formulario, `listBox1`, y `button1`. Cuando el usuario hace clic en `button1`, `button1_Click` método suma uno a tres en el cuadro de lista de números y muestra un <xref:System.Windows.Forms.MessageBox>. Si el usuario hace clic **No** en el <xref:System.Windows.Forms.MessageBox>, el `button1_Click` método agrega otro número a la lista. Si el usuario hace clic **Sí**, la aplicación llama a <xref:System.Windows.Forms.Application.Exit%2A>, para procesar todos los mensajes restantes en la cola y, a continuación, para salir.  
  
 El ejemplo requiere que `listBox1` y `button1` han sido crea una instancia y colocado en un formulario.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para que el llamador inmediato llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Devuelve si algún <see cref="T:System.Windows.Forms.Form" /> de la aplicación canceló la salida.</param>
        <summary>Notifica a todos los surtidores de mensajes que deben terminar y, a continuación, cierra todas las ventanas de la aplicación una vez procesados todos los mensajes.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">Permiso terminar un ejecución del subproceso de la aplicación. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Abandona el bucle de mensajes del subproceso actual y cierra todas las ventanas del subproceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para salir del bucle de mensajes del subproceso actual. Este método realiza la llamada a <xref:System.Windows.Forms.Application.Run%2A> para devolver el subproceso actual. Para cerrar toda la aplicación, llame a <xref:System.Windows.Forms.Application.Exit%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para que el llamador inmediato llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="message">Mensaje de evento de Windows que va a filtrarse.</param>
        <summary>Ejecuta cualquier filtro respecto a un mensaje de ventana y devuelve una copia del mensaje modificado.</summary>
        <returns>
          <see langword="True" /> si se han procesado los filtros; de lo contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la aplicación termina el procesamiento y se dispone a entrar en estado de inactividad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tiene tareas que se deben realizar antes de que el subproceso se vuelve inactivo, deberá asociarlas a este evento.  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Application.Idle> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un formulario de Windows y asegúrese de que el controlador de eventos está asociado con el <xref:System.Windows.Forms.Application.Idle> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la aplicación está a punto de abandonar un estado modal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Application.LeaveThreadModal> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un formulario Windows Forms y asegurarse de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Application.LeaveThreadModal> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso de los datos de aplicación de un usuario local no móvil.</summary>
        <value>Ruta de acceso de los datos de aplicación de un usuario local no móvil.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un usuario local es aquel cuyo perfil de usuario se almacena en el sistema en el que el usuario inició sesión. Si no existe una ruta de acceso, se crea uno en el formato siguiente:  
  
 *Ruta de acceso base*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Una ruta de acceso base típica es C:\Documents and Settings\\*username*\Local datos. Esta ruta de acceso será diferente, sin embargo, si se implementa la aplicación de Windows Forms mediante el uso de [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] crea su propio directorio de datos de aplicación que está aislada de todas las demás aplicaciones. Para obtener más información, consulte [obtener acceso Local y remota de datos en aplicaciones ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra dos formularios y sale de la aplicación cuando se cierren ambas formas. Cuando la aplicación se inicia y se cierra, se recuerda la posición de cada formulario. Aunque este ejemplo muestra cómo utilizar el <xref:System.Windows.Forms.Application.UserAppDataPath%2A> propiedad para almacenar datos de aplicación para el usuario, el <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> se puede usar en su lugar.  
  
 El `MyApplicationContext` clase hereda de <xref:System.Windows.Forms.ApplicationContext> y realiza un seguimiento cuando se cierra cada formulario y sale del subproceso actual cuando ambos están. La clase almacena las posiciones de cada formulario para el usuario. Los datos de posición del formulario se almacenan en un archivo denominado `Appdata.txt` que se crea en la ubicación determinada por <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. El `Main` llamadas al método `Application.Run(context)` para iniciar la aplicación dado el <xref:System.Windows.Forms.ApplicationContext>.  
  
 Este código es un extracto del ejemplo se muestra en el <xref:System.Windows.Forms.ApplicationContext> información general de clases. No se muestra parte del código con el fin de brevedad. Consulte <xref:System.Windows.Forms.ApplicationContext> para obtener el código completo.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si existe un bucle de mensajes en el subproceso.</summary>
        <value>Es <see langword="true" /> si existe un bucle de mensajes; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se hospedan Windows Forms en otros entornos, como las aplicaciones no administradas, esta propiedad siempre devolverá `false`. Use <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> para indicar a Windows Forms si el entorno de hospedaje tiene todavía un bucle de mensajes activos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicializa OLE en el subproceso actual.</summary>
        <returns>Uno de los valores de <see cref="T:System.Threading.ApartmentState" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a este método antes de llamar a cualquier `Microsoft.Win32` método que requiera OLE. <xref:System.Windows.Forms.Application.OleRequired%2A> en primer lugar comprueba si se ha inicializado OLE en el subproceso actual. Si no es así, inicializa el subproceso de OLE.  
  
> [!NOTE]
>  A menos que un subproceso llama a métodos OLE directamente, no es necesario llamar a este método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">
          <see cref="T:System.Exception" /> que representa la excepción que se produjo.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Application.ThreadException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a <xref:System.Windows.Forms.Application.OnThreadException%2A> para generar una excepción que se detendrá el procesamiento de la aplicación.  
  
 El <xref:System.Windows.Forms.Application> clase tiene un <xref:System.Windows.Forms.Application.ThreadException> eventos. Puede adjuntar un controlador de eventos a este evento para realizar cualquier procesamiento personalizado que necesita para las excepciones no controladas. Si no asocia un controlador de eventos, <xref:System.Windows.Forms.Application.OnThreadException%2A> se ejecutará el comportamiento predeterminado, que consiste en mostrar un cuadro de diálogo para informar al usuario que ha habido un error.  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> sólo implementa el comportamiento de excepción predeterminado para las excepciones no controladas que se producen en subprocesos de Windows Forms. Las excepciones no controladas en otros subprocesos se controlan mediante el <xref:System.AppDomain.UnhandledException> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de formularios abiertos que posee la aplicación.</summary>
        <value>
          <see cref="T:System.Windows.Forms.FormCollection" /> que contiene todos los formularios actualmente abiertos que posee esta aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.Application.OpenForms%2A> propiedad representa una colección de solo lectura de formularios que posee la aplicación. Esta colección se puede buscar por la posición de índice o por la <xref:System.Windows.Forms.Control.Name%2A> de la <xref:System.Windows.Forms.Form>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Autor de llamada debe tener permiso para tener acceso a todas las ventanas, tal como se define por la <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> valor de la <see cref="T:System.Security.Permissions.UIPermissionWindow" /> enumeración.</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de producto asociado a la aplicación.</summary>
        <value>Nombre del producto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` procede de los metadatos del ensamblado que contiene el formulario principal de la aplicación actual. Se puede establecer mediante <xref:System.Reflection.AssemblyProductAttribute> dentro de su manifiesto del ensamblado. Para obtener más información, consulte [manifiesto del ensamblado](~/docs/framework/app-domains/assembly-manifest.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene esta propiedad y su valor se muestra en un cuadro de texto. El ejemplo requiere que `textBox1` se ha colocado en un formulario.  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la versión de producto asociada a la aplicación.</summary>
        <value>Versión del producto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, se muestra como un número de versión *número principal*.* número secundario*.* número de compilación*.* número de parte privada*. Puede establecer explícitamente mediante el establecimiento de la versión del ensamblado en el manifiesto del ensamblado. Para obtener más información, consulte [manifiesto del ensamblado](~/docs/framework/app-domains/assembly-manifest.md).  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> busca primero para ver si el ensamblado que contiene el archivo ejecutable principal tiene el `AssemblyInformationalVersion` atributo en él. Si este atributo no existe, se usa para ambos <xref:System.Windows.Forms.Application.ProductVersion%2A> y <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Si este atributo no existe, ambas propiedades utilizan la versión del archivo ejecutable en su lugar.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene esta propiedad y su valor se muestra en un cuadro de texto. El ejemplo requiere que `textBox1` se ha colocado en un formulario.  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objetos <see cref="T:System.EventArgs" /> que se van a pasar al evento <see cref="E:System.Windows.Forms.Application.Idle" />.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Application.Idle" /> en escenarios hospedados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se usa al hospedar formularios de Windows en otro entorno, por ejemplo, una aplicación no administrada. Debe llamar a <xref:System.Windows.Forms.Application.RaiseIdle%2A> cuando la aplicación de hospedaje entra en un estado de inactividad. Esto permite que algunos controles de formularios Windows Forms y componentes para realizar trabajo importante en segundo plano mientras el usuario no está interactuando con la aplicación.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Método al que se debe llamar cuando los formularios Windows Forms necesitan comprobar si el entorno host continúa enviando mensajes.</param>
        <summary>Registra una devolución de llamada para comprobar si el bucle de mensajes se está ejecutando en entornos hospedados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se usa al hospedar formularios de Windows en otro entorno, por ejemplo, una aplicación no administrada. En entornos hospedados, el <xref:System.Windows.Forms.Application.MessageLoop%2A> propiedad siempre devolverá false si Windows Forms no está procesando mensajes. Utilice esta devolución de llamada para indicar a Windows Forms si el entorno host todavía está procesando los mensajes.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Implementación del <see cref="T:System.Windows.Forms.IMessageFilter" /> que se quitará de la aplicación.</param>
        <summary>Quita un filtro de mensajes del surtidor de mensajes de la aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede quitar un filtro de mensajes cuando ya no desee capturar los mensajes de Windows antes de enviarlos.  
  
   
  
## Examples  
 Para poder usar un filtro de mensajes, debe proporcionar una implementación para el <xref:System.Windows.Forms.IMessageFilter> interfaz. La clase siguiente crea un filtro de mensajes denominado `TestMessageFilter`. Este filtro bloquea todos los mensajes relacionados con el botón primario del mouse.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que especifica si la aplicación actual dibuja los controles con estilos visuales.</summary>
        <value>
          <see langword="true" /> si los estilos visuales se habilitan para los controles en el área cliente de las ventanas de la aplicación; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se dibuja un control personalizado, utilice esta propiedad para decidir si se va a dibujar el control con o sin estilos visuales, por lo que su apariencia es coherente con otros controles de la aplicación.  
  
 La tabla siguiente muestran las cuatro condiciones que deben cumplirse para <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> para devolver `true`.  
  
|Condición|Descripción|  
|---------------|-----------------|  
|El sistema operativo admite estilos visuales|Para comprobar esta condición por separado, use la propiedad <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> de la clase <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> .|  
|El usuario ha habilitado los estilos visuales en el sistema operativo|Para comprobar esta condición por separado, use la propiedad <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> de la clase <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> .|  
|Los estilos visuales están habilitados en la aplicación|Los estilos visuales se pueden habilitar en una aplicación mediante una llamada al método <xref:System.Windows.Forms.Application.EnableVisualStyles> o usando una aplicación de manifiesto que especifique que se usará la versión 6 o posterior de ComCtl32.dll para dibujar los controles.|  
|Los estilos visuales se emplean para dibujar el área cliente de windows de la aplicación|Para comprobar esta condición por separado, use la propiedad <xref:System.Windows.Forms.Application.VisualStyleState%2A> de la clase <xref:System.Windows.Forms.Application> y compruebe que tiene el valor <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> o <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra la aplicación e inicia una nueva instancia inmediatamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La razón más común para llamar a `Restart` consiste en iniciar una nueva versión de la aplicación que ha descargado mediante [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] utilizando el `Update` o `UpdateAsync` método.  
  
 En el contexto en el que se ejecute inicialmente, se reinician las aplicaciones. Si la aplicación se inició con una dirección URL que apunta directamente al archivo ejecutable principal de la aplicación, se reiniciará con la misma dirección URL. Si la aplicación es un [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicación, se reiniciará con [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].  
  
 Si la aplicación se ha proporcionado originalmente las opciones de línea de comandos cuando ejecuta en primer lugar, <xref:System.Windows.Forms.Application.Restart%2A> iniciará la aplicación de nuevo con las mismas opciones.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Su código no es una aplicación de Windows Forms. No puede llamar a este método en este contexto.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Requiere <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> permiso.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicia la ejecución de un bucle de mensajes de aplicación estándar en el subproceso actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia la ejecución de un bucle de mensajes de aplicación estándar en el subproceso actual, sin un formulario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En Windows Forms o basadas en Win32, aplicación de un bucle de mensajes es una rutina en el código que procesa los eventos de usuario, como clics del mouse y pulsaciones de teclas. Cada aplicación basada en Windows en ejecución requiere un bucle de mensaje activo, denominado el bucle de mensajes principal. Cuando se cierra el bucle de mensajes principal, se cierra la aplicación. En Windows Forms, este bucle se cierra cuando el <xref:System.Windows.Forms.Application.Exit%2A> método se llama, o cuando el <xref:System.Windows.Forms.Application.ExitThread%2A> se llama al método en el subproceso que se ejecuta el bucle de mensajes principal.  
  
 La mayoría de los desarrolladores de Windows Forms no necesitará utilizar esta versión del método. Debe usar el <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> sobrecarga para iniciar una aplicación con un formulario principal, de modo que la aplicación finaliza cuando se cierra el formulario principal. Para todas las otras situaciones, utilice el <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> sobrecarga, que admite que se proporcione un <xref:System.Windows.Forms.ApplicationContext> objeto para un mejor control sobre la duración de la aplicación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ya se está ejecutando un bucle de mensajes principal en este subproceso.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Windows.Forms.ApplicationContext" /> en el que se ejecuta la aplicación.</param>
        <summary>Inicia la ejecución de un bucle de mensajes de aplicación estándar en el subproceso actual, con un <see cref="T:System.Windows.Forms.ApplicationContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El bucle de mensajes se ejecuta hasta <xref:System.Windows.Forms.Application.Exit%2A> o <xref:System.Windows.Forms.Application.ExitThread%2A> se denomina o <xref:System.Windows.Forms.Application.ThreadExit> evento se desencadena en el objeto de contexto.  
  
   
  
## Examples  
 En el ejemplo se muestra dos formularios y sale de la aplicación cuando se cierren ambas formas. Cuando la aplicación se inicia y se cierra, se recuerda la posición de cada formulario. Este ejemplo muestra cómo usar un <xref:System.Windows.Forms.ApplicationContext>, junto con el `Application.Run(context)` método para mostrar varios formularios cuando se inicia la aplicación.  
  
 La clase `MyApplicationContext` hereda <xref:System.Windows.Forms.ApplicationContext> y realiza un seguimiento cuando se cierra cada formulario y sale del subproceso actual cuando ambos están. La clase almacena las posiciones de cada formulario para el usuario. Los datos de posición del formulario se almacenan en un archivo denominado `Appdata.txt` que se crea en la ubicación determinada por <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. El `Main` llamadas al método `Application.Run(context)` para iniciar la aplicación dado el <xref:System.Windows.Forms.ApplicationContext>.  
  
 El código para el `AppForm1` y `AppForm2` forms no se muestra con el fin de brevedad. Consulte la <xref:System.Windows.Forms.ApplicationContext> información general de clases para obtener el código completo.  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ya se está ejecutando un bucle de mensajes principal en este subproceso.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">
          <see cref="T:System.Windows.Forms.Form" /> que representa el formulario que va a estar visible.</param>
        <summary>Inicia la ejecución de un bucle de mensajes de aplicación estándar en el subproceso actual y hace que el formulario especificado esté visible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, la función principal de una aplicación llama a este método y le pasa la ventana principal de la aplicación.  
  
 Este método agrega un controlador de eventos para el `mainForm` parámetro para el <xref:System.Windows.Forms.Form.Closed> eventos. El controlador de eventos llama a <xref:System.Windows.Forms.Application.ExitThread%2A> para limpiar la aplicación.  
  
> [!NOTE]
>  El <xref:System.Windows.Forms.Control.Dispose%2A> método de la <xref:System.Windows.Forms.Form> clase se llamará antes de la devolución de este método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra números en un cuadro de lista en un formulario. Cada vez que haga clic en `button1`, la aplicación agrega otro número a la lista.  
  
 El `Main` llamadas al método <xref:System.Windows.Forms.Application.Run%2A> para iniciar la aplicación, que crea el formulario, `listBox1`, y `button1`. Cuando el usuario hace clic en `button1`, `button1_Click` método suma uno a tres en el cuadro de lista de números y muestra un <xref:System.Windows.Forms.MessageBox>. Si el usuario hace clic **No** en el <xref:System.Windows.Forms.MessageBox>, el `button1_Click` método agrega otro número a la lista. Si el usuario hace clic **Sí**, la aplicación llama a <xref:System.Windows.Forms.Application.Exit%2A> para procesar todos los mensajes restantes en la cola y, a continuación, para salir.  
  
 El ejemplo requiere que `listBox1` y `button1` se han creado y colocado en un formulario.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Un bucle de mensajes principal ya se está ejecutando en el subproceso actual.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la cadena de formato que se va a aplicar a los títulos de las ventanas de nivel superior cuando se muestren con un titular de advertencia.</summary>
        <value>Cadena de formato que se va aplicar a los títulos de las ventanas de nivel superior.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas establecer esta propiedad. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valor predeterminado que se va a utilizar con los nuevos controles. Si es <see langword="true" />, los nuevos controles que admiten <c>UseCompatibleTextRendering</c> usan la clase [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] basada en <see cref="T:System.Drawing.Graphics" /> para la representación de texto; si es <see langword="false" />, los nuevos controles usan la clase [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] basada en <see cref="T:System.Windows.Forms.TextRenderer" />.</param>
        <summary>Establece el valor predeterminado de la aplicación para la propiedad <c>UseCompatibleTextRendering</c> definida en ciertos controles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciertos controles de Windows Forms pueden representar texto mediante el <xref:System.Windows.Forms.TextRenderer> (clase), que se basa en el [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] biblioteca de gráficos, o la <xref:System.Drawing.Graphics> (clase), que se basa en el [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] biblioteca de gráficos. Este cambio se realizó en el [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] debido a problemas de rendimiento y la localización con [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. Use <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> para establecer el valor predeterminado de la `UseCompatibleTextRendering` propiedad para los controles que lo admiten.  
  
 El `UseCompatibleTextRendering` propiedad está pensada para proporcionar compatibilidad visual entre los controles de formularios Windows Forms ese texto de presentación mediante el <xref:System.Windows.Forms.TextRenderer> clase y [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] y [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] las aplicaciones que realizan la representación de texto personalizado mediante la <xref:System.Drawing.Graphics>clase. En la mayoría de los casos, si la aplicación no se está actualizando desde [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] o [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], se recomienda que deje `UseCompatibleTextRendering` establecido en el valor predeterminado de `false`.  
  
 El [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] basado <xref:System.Windows.Forms.TextRenderer> clase se introdujo en la [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] para mejorar el rendimiento, convertir texto tenga mejor aspecto y mejorar la compatibilidad con fuentes internacionales. En versiones anteriores de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], el [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] basado <xref:System.Drawing.Graphics> clase se utiliza para realizar la representación de texto de todas. [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] calcula el espaciado entre caracteres y el ajuste de línea de forma diferente de [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. En una aplicación de Windows Forms que usa el <xref:System.Drawing.Graphics> de clases para representar texto, esto podría provocar que el texto para los controles que usan <xref:System.Windows.Forms.TextRenderer> para tener un aspecto diferente de otros textos de la aplicación. Para resolver esta incompatibilidad, puede establecer el `UseCompatibleTextRendering` propiedad `true`. Para establecer `UseCompatibleTextRendering` a `true` para todos los controles compatibles en la aplicación, llame a la <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> método con un parámetro de `true`.  
  
 Nunca debe llamar a este método si el código de Windows Forms se hospeda en otra aplicación, como Internet Explorer. Solo llame a este método en aplicaciones de Windows Forms independientes.  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  Para establecer el valor predeterminado de `UseCompatibleTextRendering` en [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] o una versión posterior, consulte <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>.  
  
 En [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] o posterior, una llamada a <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> se genera automáticamente en el archivo Program.cs. Para cambiar el valor predeterminado de representación de texto, modifique el código generado.  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Sólo puede llamar a este método antes de que la aplicación de Windows Forms cree la primera ventana.</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" />
        <Parameter Name="force" Type="System.Boolean" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Windows.Forms.PowerState" /> que indica el modo de actividad de energía al que se va a transicionar.</param>
        <param name="force">Es <see langword="true" /> para forzar inmediatamente el modo de suspensión; es <see langword="false" /> para hacer que Windows envíe una solicitud de suspensión a cada aplicación.</param>
        <param name="disableWakeEvent">
          <see langword="true" /> para deshabilitar que el estado de energía del sistema se restaure para la actividad como consecuencia de un evento de activación; <see langword="false" /> para habilitar que el estado de energía del sistema se restaure para la actividad como consecuencia de un evento de activación.</param>
        <summary>Suspende o hiberna el sistema o solicita que el sistema se suspenda o hiberne.</summary>
        <returns>
          <see langword="true" /> si se suspende el sistema; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si una aplicación no respondió a una solicitud de suspensión durante 20 segundos, Windows determina que se encuentra en un estado no responde y que la aplicación se puede poner en modo de suspensión o finalizada. Sin embargo, una vez que una aplicación responde a una solicitud de suspensión, puede tomar todo el tiempo necesario limpiar los recursos y apagar los procesos activos.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica a la aplicación cómo responder a las excepciones no controladas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente establece los controladores de eventos para las excepciones que se producen en los subprocesos de Windows Forms y las excepciones que se producen en otros subprocesos. Establece <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> para que todas las excepciones se controlan mediante la aplicación, independientemente de la configuración en el archivo de configuración de usuario de la aplicación. Usa el <xref:System.Windows.Forms.Application.ThreadException> eventos para controlar las excepciones del subproceso de interfaz de usuario y el <xref:System.AppDomain.UnhandledException> eventos para controlar las excepciones de subprocesos que no son de interfaz de usuario. Puesto que <xref:System.AppDomain.UnhandledException> no se puede impedir que una aplicación de terminación, el ejemplo simplemente registra el error en el registro de eventos de aplicación antes de la finalización.  
  
 En este ejemplo se da por supuesto que ha definido dos <xref:System.Windows.Forms.Button> controles, `button1` y `button2`, en su <xref:System.Windows.Forms.Form> clase.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
      </Parameters>
      <Docs>
        <param name="mode">Valor <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> que describe cómo debe comportarse la aplicación si se produce una excepción no detectada.</param>
        <summary>Indica a la aplicación cómo responder a las excepciones no controladas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A menudo no resulta factible para detectar todas las excepciones producidas por Windows Forms. Con este método, puede indicar a la aplicación si debe detectar excepciones no controladas todo producidas por componentes de Windows Forms y seguir funcionando, o si debe exponerlos al usuario y detener la ejecución.  
  
 Llame a <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> antes de crear una instancia del formulario principal de la aplicación mediante el <xref:System.Windows.Forms.Application.Run%2A> método.  
  
 Para detectar las excepciones que se producen en los subprocesos no se ha creado y que pertenecen a Windows Forms, utilice el <xref:System.AppDomain.UnhandledException> controlador de eventos.  
  
   
  
## Examples  
 El ejemplo de código siguiente establece los controladores de eventos para las excepciones que se producen en los subprocesos de Windows Forms y las excepciones que se producen en otros subprocesos. Establece <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> para que todas las excepciones se controlan mediante la aplicación, independientemente de la configuración en el archivo de configuración de usuario de la aplicación. Usa el <xref:System.Windows.Forms.Application.ThreadException> eventos para controlar las excepciones del subproceso de interfaz de usuario y el <xref:System.AppDomain.UnhandledException> eventos para controlar las excepciones de subprocesos que no son de interfaz de usuario. Puesto que <xref:System.AppDomain.UnhandledException> no se puede impedir que una aplicación de terminación, el ejemplo simplemente registra el error en el registro de eventos de aplicación antes de la finalización.  
  
 En este ejemplo se da por supuesto que ha definido dos <xref:System.Windows.Forms.Button> controles, `button1` y `button2`, en su <xref:System.Windows.Forms.Form> clase.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No puede establecer el modo de excepción después de que la aplicación ya ha creado su primera ventana.</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
        <Parameter Name="threadScope" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mode">Valor <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> que describe cómo debe comportarse la aplicación si se produce una excepción no detectada.</param>
        <param name="threadScope">
          <see langword="true" /> para establecer el modo de excepción del subproceso; de lo contrario, <see langword="false" />.</param>
        <summary>Indica a la aplicación cómo responder a las excepciones no controladas, aplicando opcionalmente el comportamiento específico del subproceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A menudo no resulta factible para detectar todas las excepciones producidas por Windows Forms. Con este método, puede indicar a la aplicación si debe detectar excepciones no controladas todo producidas por componentes de Windows Forms y seguir funcionando, o si debe exponerlos al usuario y detener la ejecución.  
  
 Llame a <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> antes de crear una instancia del formulario principal de la aplicación mediante el <xref:System.Windows.Forms.Application.Run%2A> método.  
  
 Cuando `threadScope` es `true`, se establece el modo de excepción de subproceso. El modo de excepción del subproceso reemplaza el modo de excepción de aplicación si `mode` no está establecido en <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>.  
  
 Cuando `threadScope` es `false`, se establece el modo de excepción de aplicación. Se utiliza el modo de excepción de aplicación para todos los subprocesos que tienen el <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> modo. Establecer el modo de excepción de aplicación no afecta a la configuración del subproceso actual.  
  
 Para detectar las excepciones que se producen en los subprocesos no se ha creado y que pertenecen a Windows Forms, utilice el <xref:System.AppDomain.UnhandledException> controlador de eventos.  
  
   
  
## Examples  
 El ejemplo de código siguiente establece los controladores de eventos para las excepciones que se producen en los subprocesos de Windows Forms y las excepciones que se producen en otros subprocesos. Establece <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> para que todas las excepciones se controlan mediante la aplicación, independientemente de la configuración en el archivo de configuración de usuario de la aplicación. Usa el <xref:System.Windows.Forms.Application.ThreadException> eventos para controlar las excepciones del subproceso de interfaz de usuario y el <xref:System.AppDomain.UnhandledException> eventos para controlar las excepciones de subprocesos que no son de interfaz de usuario. Puesto que <xref:System.AppDomain.UnhandledException> no se puede impedir que una aplicación de terminación, el ejemplo simplemente registra el error en el registro de eventos de aplicación antes de la finalización.  
  
 En este ejemplo se da por supuesto que ha definido dos <xref:System.Windows.Forms.Button> controles, `button1` y `button2`, en su <xref:System.Windows.Forms.Form> clase.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No puede establecer el modo de excepción después de que la aplicación ya ha creado su primera ventana.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso del archivo ejecutable que inició la aplicación, sin incluir el nombre del archivo ejecutable.</summary>
        <value>Ruta de acceso del archivo ejecutable que inició la aplicación.  
  
Esta ruta de acceso será diferente en función de si la aplicación Windows Forms se implementa mediante [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] las aplicaciones se almacenan en una caché de aplicaciones por usuario en la C:\Documents and Settings\\*username* directory. Para obtener más información, consulte [obtener acceso Local y remota de datos en aplicaciones ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se obtiene esta propiedad y su valor se muestra en un cuadro de texto. El ejemplo requiere que `textBox1` se ha colocado en un formulario.  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener la ruta de acceso. Enumeración asociada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocurre cuando se produce una excepción de subproceso no interceptada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento permite que la aplicación de Windows Forms para controlar no controlada las excepciones que se producen en los subprocesos de Windows Forms. Asocie los controladores de eventos para el <xref:System.Windows.Forms.Application.ThreadException> eventos para tratar con estas excepciones, lo que dejarán a la aplicación en un estado desconocido. Siempre que sea posible, las excepciones deben controlarse mediante un bloque de control de excepciones estructurado.  
  
 Puede cambiar si se usa esta devolución de llamada para excepciones no controladas de subproceso de Windows Forms mediante el establecimiento <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>. Para detectar las excepciones que se producen en los subprocesos no se ha creado y que pertenecen a Windows Forms, utilice el <xref:System.AppDomain.UnhandledException> controlador de eventos.  
  
> [!NOTE]
>  Para garantizar que no se ha perdido ninguna activaciones de este evento, debe adjuntar un controlador antes de llamar a <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
   
  
## Examples  
 El ejemplo de código siguiente establece los controladores de eventos para las excepciones que se producen en los subprocesos de Windows Forms y las excepciones que se producen en otros subprocesos. Establece <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> para que todas las excepciones se controlan mediante la aplicación, independientemente de la configuración en el archivo de configuración de usuario de la aplicación. Usa el <xref:System.Windows.Forms.Application.ThreadException> eventos para controlar las excepciones del subproceso de interfaz de usuario y el <xref:System.AppDomain.UnhandledException> eventos para controlar las excepciones de subprocesos que no son de interfaz de usuario. Puesto que <xref:System.AppDomain.UnhandledException> no se puede impedir que una aplicación de terminación, el ejemplo simplemente registra el error en el registro de eventos de aplicación antes de la finalización.  
  
 En este ejemplo se da por supuesto que ha definido dos <xref:System.Windows.Forms.Button> controles, `button1` y `button2`, en su <xref:System.Windows.Forms.Form> clase.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para que el llamador inmediato llamar a código no administrado al agregar un controlador a este evento. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se va a cerrar un subproceso. Cuando el subproceso principal de una aplicación está a punto de cerrarse, se genera primero este evento, seguido de un evento <see cref="E:System.Windows.Forms.Application.ApplicationExit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe asociar los controladores de eventos para el <xref:System.Windows.Forms.Application.ThreadExit> evento para realizar cualquier no controlada, tareas necesarias antes de que el subproceso deje de ejecutarse. Cerrar archivos abiertos por el subproceso o desechar los objetos que el recolector de elementos no utilizados no recuperó.  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos informa sobre la aparición de la <xref:System.Windows.Forms.Application.ThreadExit> eventos. Este informe le ayuda a saber cuándo el evento se produce y puede ayudarle a depurar. Para informar sobre varios eventos o en eventos que se producen con frecuencia, considere reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un formulario Windows Forms y asegurarse de que está asociado el controlador de eventos con el <xref:System.Windows.Forms.Application.ThreadExit> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anula el registro de la devolución de llamada del bucle de mensajes realizada con <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso de los datos de aplicación de un usuario.</summary>
        <value>Ruta de acceso de los datos de aplicación de un usuario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no existe una ruta de acceso, se crea uno en el formato siguiente:  
  
 *Ruta de acceso base*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 Datos almacenados en esta ruta de acceso forman parte del perfil de usuario que está habilitado para la movilidad. Un usuario móvil funciona en varios equipos en una red. El perfil de usuario para un usuario móvil se mantiene en un servidor en la red y se carga en un sistema cuando el usuario inicia sesión. Para un perfil de usuario tener en cuenta para la movilidad, el sistema operativo debe admitir los perfiles móviles y debe estar habilitada.  
  
 Una ruta de acceso base típica es C:\Documents and Settings\\*username*\Application Data. Esta ruta de acceso será diferente, sin embargo, si se implementa la aplicación de Windows Forms mediante el uso de [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] crea su propio directorio de datos de aplicación que está aislada de todas las demás aplicaciones. Para obtener más información, consulte [obtener acceso Local y remota de datos en aplicaciones ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra dos formularios y sale de la aplicación cuando se cierren ambas formas. Cuando la aplicación se inicia y se cierra, se recuerda la posición de cada formulario. En este ejemplo se muestra cómo utilizar el <xref:System.Windows.Forms.Application.UserAppDataPath%2A> propiedad para almacenar datos de aplicación para el usuario.  
  
 La clase `MyApplicationContext` hereda <xref:System.Windows.Forms.ApplicationContext> y realiza un seguimiento cuando se cierra cada formulario y sale del subproceso actual cuando ambos están. La clase almacena las posiciones de cada formulario para el usuario. Los datos de posición del formulario se almacenan en un archivo denominado `Appdata.txt` que se crea en la ubicación determinada por <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. El `Main` llamadas al método `Application.Run(context)` para iniciar la aplicación dado el <xref:System.Windows.Forms.ApplicationContext>.  
  
 Este código es un extracto del ejemplo se muestra en el <xref:System.Windows.Forms.ApplicationContext> información general de clases. No se muestra parte del código con el fin de brevedad. Consulte <xref:System.Windows.Forms.ApplicationContext> para obtener el código completo.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la clave del Registro de los datos de aplicación de un usuario.</summary>
        <value>
          <see cref="T:Microsoft.Win32.RegistryKey" /> que representa la clave del Registro de los datos de aplicación específicos del usuario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clave no existe, crearlo en el formato siguiente:  
  
 Usuarioactual\software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Datos almacenados en esta clave forman parte del perfil de usuario que está habilitado para la movilidad. Un usuario móvil funciona en varios equipos en una red. El perfil de usuario para un usuario móvil se mantiene en un servidor en la red y se carga en un sistema cuando el usuario inicia sesión. Para un perfil de usuario tener en cuenta para la movilidad, el sistema operativo debe admitir los perfiles móviles y debe estar habilitada.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece si el cursor de espera se utiliza para todos los formularios abiertos de la aplicación.</summary>
        <value>Es <see langword="true" /> si el cursor de espera se utiliza para todos los formularios abiertos; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando esta propiedad se establece en `true`, <xref:System.Windows.Forms.Control.UseWaitCursor%2A> propiedad de todos los formularios abiertos de la aplicación se establecerá en `true`. Esta llamada no se devolverá hasta que se ha establecido esta propiedad en todos los formularios. Use esta propiedad cuando tiene una operación de larga ejecución y desee indicar en todos los formularios de la aplicación que todavía está procesando la operación.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que especifica cómo se van a aplicar los estilos visuales a las ventanas de la aplicación.</summary>
        <value>Combinación bit a bit de los valores de <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esto <xref:System.Windows.Forms.Application.VisualStyleState%2A> propiedad determina si los estilos visuales están habilitados en las áreas cliente o áreas no cliente de windows de la aplicación. Por lo general, esta propiedad debe establecerse en el constructor del formulario principal o <xref:System.Windows.Forms.Form.Load> controlador de eventos.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Windows.Forms.Application.VisualStyleState%2A> propiedad en uno de los <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> los valores dentro de la <xref:System.Windows.Forms.Control.Click> controlador de eventos para un <xref:System.Windows.Forms.Button> control. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> enumeración.  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>