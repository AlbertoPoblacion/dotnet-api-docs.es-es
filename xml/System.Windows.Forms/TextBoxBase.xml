<Type Name="TextBoxBase" FullName="System.Windows.Forms.TextBoxBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6002af143f80f4fe4f8ba0d9d9a16115c4a0f305" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30651049" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TextBoxBase : System.Windows.Forms.Control" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TextBoxBase extends System.Windows.Forms.Control" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TextBoxBase&#xA;Inherits Control" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextBoxBase abstract : System::Windows::Forms::Control" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Control</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultBindingProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("TextChanged")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.TextBoxBaseDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementa la funcionalidad básica requerida por controles de texto.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta clase implementa las características principales de controles de manipulación de texto, como <xref:System.Windows.Forms.TextBox> y <xref:System.Windows.Forms.RichTextBox>. Puede tratarse de selección de texto, **Portapapeles** muchos eventos, funcionalidad y compatibilidad con controles de texto multilínea.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada, para crear una propiedad de multilínea <xref:System.Windows.Forms.TextBox> control con barras de desplazamiento vertical. Este ejemplo también utiliza el <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>, <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>, y <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> propiedades para hacer que el control de cuadro de texto multilínea sea útil para crear documentos de texto.  
  
 [!code-cpp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Normalmente no se hereda de <see cref="T:System.Windows.Forms.TextBoxBase" />. Para crear su propia clase de control de texto, debe heredar de <see cref="T:System.Windows.Forms.TextBox" /> o <see cref="T:System.Windows.Forms.RichTextBox" />.</para>
    </block>
    <altmember cref="T:System.Windows.Forms.TextBox" />
    <altmember cref="T:System.Windows.Forms.RichTextBox" />
  </Docs>
  <Members>
    <Member MemberName="AcceptsTab">
      <MemberSignature Language="C#" Value="public bool AcceptsTab { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AcceptsTab" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.AcceptsTab" />
      <MemberSignature Language="VB.NET" Value="Public Property AcceptsTab As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AcceptsTab { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si al presionar la tecla TAB en un control de cuadro de texto multilínea se escribe un carácter TAB en el control en lugar de moverse el foco al siguiente control en el orden de tabulación.</summary>
        <value>
          <see langword="true" /> si los usuarios pueden escribir tabuladores en un cuadro de texto multilínea mediante el uso de la tecla TAB; <see langword="false" /> si al presionar la tecla TAB se mueve el foco. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> propiedad también debe ser `true` para obtener un carácter de tabulación del control.  
  
 Si el <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A> propiedad está establecida en `true`, el usuario debe presionar CTRL + TAB para mover el foco al siguiente control en el orden de tabulación.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada, para crear una propiedad de multilínea <xref:System.Windows.Forms.TextBox> control con barras de desplazamiento vertical. Este ejemplo también utiliza el <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>, <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>, y <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> propiedades para hacer que el control de cuadro de texto multilínea sea útil para crear documentos de texto.  
  
 [!code-cpp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBox.AcceptsReturn" />
      </Docs>
    </Member>
    <Member MemberName="AcceptsTabChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AcceptsTabChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AcceptsTabChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.AcceptsTabChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AcceptsTabChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AcceptsTabChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.TextBoxBase.AcceptsTab" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el control de eventos, vea [NIB: consumir eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos notifica la aparición de la <xref:System.Windows.Forms.TextBoxBase.AcceptsTabChanged> eventos. Este informe le ayuda a obtener información cuando se produce el evento y puede ayudarle a depurar. Para informar sobre varios eventos o sobre eventos que se producen con frecuencia, considere la posibilidad de reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.TextBoxBase>, como un <xref:System.Windows.Forms.TextBox> o <xref:System.Windows.Forms.TextBoxBase>. A continuación, asigne a la instancia `TextBoxBase1` y asegurarse de que el controlador de eventos está asociado con el <xref:System.Windows.Forms.TextBoxBase.AcceptsTabChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#241](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#241)]
 [!code-vb[System.Windows.Forms.EventExamples#241](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#241)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.AcceptsTab" />
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public void AppendText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.AppendText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendText (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendText(System::String ^ text);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Texto que se va a anexar al contenido actual del cuadro de texto.</param>
        <summary>Anexa texto al texto actual de un cuadro de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar este método para agregar texto al texto existente en el control en lugar de utilizar el operador de concatenación (+) para concatenar texto a la <xref:System.Windows.Forms.TextBoxBase.Text%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Windows.Forms.TextBoxBase.AppendText%2A> método y <xref:System.Windows.Forms.TextBoxBase.TextLength%2A> propiedad que se va a copiar el texto de una <xref:System.Windows.Forms.TextBox> a otro. Este ejemplo requiere que dos <xref:System.Windows.Forms.TextBox> controles denominados, `textBox1` y `textBox2`, se agregaron a un formulario y que `textBox1` tiene texto asignado a su <xref:System.Windows.Forms.Control.Text%2A> propiedad.  
  
 [!code-cpp[TextBoxBase.AppendText#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TextBoxBase.AppendText/CPP/form1.cpp#1)]
 [!code-csharp[TextBoxBase.AppendText#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TextBoxBase.AppendText/CS/form1.cs#1)]
 [!code-vb[TextBoxBase.AppendText#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TextBoxBase.AppendText/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el alto del control se ajusta automáticamente cuando se cambia la fuente asignada al control.</summary>
        <value>
          <see langword="true" /> si el alto del control se ajusta automáticamente cuando se cambia la fuente; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al establecer el <xref:System.Windows.Forms.TextBoxBase.AutoSize%2A> propiedad `true` para un <xref:System.Windows.Forms.TextBox>, cuando la <xref:System.Windows.Forms.Control.Font%2A> cambios, el <xref:System.Windows.Forms.TextBox> se expandirán o contraerán el <xref:System.Windows.Forms.Control.Height%2A> para alojar el texto mayor o menor. El <xref:System.Windows.Forms.Control.Width%2A> de la <xref:System.Windows.Forms.TextBox> no cambia.  
  
 Si desea cambiar el tamaño del control cuando el usuario escribe texto, puede usar un <xref:System.Windows.Forms.RichTextBox> controlar y usar su <xref:System.Windows.Forms.RichTextBox.ContentsResized> eventos para cambiar su tamaño.  
  
   
  
## Examples  
 En este ejemplo se da por supuesto que tiene un formulario con dos cuadros de texto, dos botones y haga clic en eventos para cada uno de los botones. El ejemplo se muestra la <xref:System.Windows.Forms.TextBoxBase.AutoSize%2A> propiedad estableciéndolo en `true` para un cuadro de texto y `false` para los demás. Al hacer clic en un botón de los cuadros de texto se rellenan con un texto más pequeño y, al hacer clic en el botón otras los cuadros de texto se rellenan con texto de mayor tamaño. El cuadro de texto que tiene <xref:System.Windows.Forms.TextBoxBase.AutoSize%2A> establecido en `true` se expande en alto para alojar el texto mayor. El ancho no cambia.  
  
 [!code-csharp[SystemWindowsFormsAutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemWindowsFormsAutoSize/CS/Form1.cs#1)]
 [!code-vb[SystemWindowsFormsAutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemWindowsFormsAutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Este evento no es relevante para esta clase.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-501)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el color de fondo del control.</summary>
        <value>
          <see cref="T:System.Drawing.Color" /> que representa el fondo del control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el <xref:System.Windows.Forms.TextBoxBase.BackColor%2A> propiedad para cambiar el color de fondo del control de texto que se confundan con la combinación de colores de los formularios.  
  
 Para cambiar el color del texto dentro del control, use la <xref:System.Windows.Forms.TextBoxBase.ForeColor%2A> propiedad. Al establecer el <xref:System.Windows.Forms.TextBoxBase.BackColor%2A> propiedad del control de texto, asegúrese de que el color que elija no hacen que el texto del control que desaparezcan. Por ejemplo, si la <xref:System.Windows.Forms.TextBoxBase.BackColor%2A> y <xref:System.Windows.Forms.TextBoxBase.ForeColor%2A> propiedades se establecen en `Color.Black`, el texto dentro del control de cuadro de texto no estará visible.  
  
 Esta propiedad puede ser sobre if reemplazan la <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> propiedad de la <xref:System.Windows.Forms.TextBoxBase> está establecido en `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ForeColor" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta propiedad no es relevante para esta clase.</summary>
        <value>Imagen de fondo del objeto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.TextBoxBase.BackgroundImage" />. Este evento no es relevante para esta clase.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta propiedad no es relevante para esta clase.</summary>
        <value>Uno de los valores de <see cref="T:System.Windows.Forms.ImageLayout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.TextBoxBase.BackgroundImageLayout" />. Este evento no es relevante para esta clase.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BorderStyle BorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.BorderStyle BorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.BorderStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderStyle As BorderStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BorderStyle BorderStyle { System::Windows::Forms::BorderStyle get(); void set(System::Windows::Forms::BorderStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-504)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tipo de borde del control de cuadro de texto.</summary>
        <value>
          <see cref="T:System.Windows.Forms.BorderStyle" /> que representa el tipo de borde del control de cuadro de texto. El valor predeterminado es <see langword="Fixed3D" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el <xref:System.Windows.Forms.TextBoxBase.BorderStyle%2A> propiedad que se va a crear controles de estilo planos y sin borde, además del control tridimensional predeterminado.  
  
> [!NOTE]
>  La clase derivada, <xref:System.Windows.Forms.RichTextBox>, no es compatible con la `BorderStyle.FixedSingle` estilo. Este estilo hará que el <xref:System.Windows.Forms.BorderStyle> para usar el `BorderStyle.Fixed3D` estilo en su lugar.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada, para crear un cuadro de texto que puede mostrar correctamente el texto con fuente Arial de 20 puntos con un solo borde. Este ejemplo se utiliza la <xref:System.Windows.Forms.TextBoxBase.PreferredHeight%2A> propiedad para determinar el alto del control adecuado después de la fuente y <xref:System.Windows.Forms.TextBoxBase.BorderStyle%2A> se han asignado al control.  
  
 [!code-cpp[Classic TextBoxBase.BorderStyle Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.BorderStyle Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.BorderStyle Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.BorderStyle Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.BorderStyle Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.BorderStyle Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Se asignó a la propiedad un valor no situado dentro del intervalo de valores permitidos para la enumeración.</exception>
      </Docs>
    </Member>
    <Member MemberName="BorderStyleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BorderStyleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BorderStyleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.BorderStyleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BorderStyleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BorderStyleChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.TextBoxBase.BorderStyle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el control de eventos, vea [NIB: consumir eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos notifica la aparición de la <xref:System.Windows.Forms.TextBoxBase.BorderStyleChanged> eventos. Este informe le ayuda a obtener información cuando se produce el evento y puede ayudarle a depurar. Para informar sobre varios eventos o sobre eventos que se producen con frecuencia, considere la posibilidad de reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.TextBoxBase>, como un <xref:System.Windows.Forms.TextBox> o <xref:System.Windows.Forms.TextBoxBase>. A continuación, asigne a la instancia `TextBoxBase1` y asegurarse de que el controlador de eventos está asociado con el <xref:System.Windows.Forms.TextBoxBase.BorderStyleChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#242](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#242)]
 [!code-vb[System.Windows.Forms.EventExamples#242](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#242)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.BorderStyle" />
      </Docs>
    </Member>
    <Member MemberName="CanEnableIme">
      <MemberSignature Language="C#" Value="protected override bool CanEnableIme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnableIme" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.CanEnableIme" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CanEnableIme As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanEnableIme { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la propiedad <see cref="P:System.Windows.Forms.Control.ImeMode" /> puede establecerse en un valor activo para habilitar la compatibilidad con el IME.</summary>
        <value>
          <see langword="false" /> si la propiedad <see cref="P:System.Windows.Forms.TextBoxBase.ReadOnly" /> es <see langword="true" /> o si esta clase <see cref="T:System.Windows.Forms.TextBoxBase" /> está establecida para utilizar un carácter de máscara de contraseña; de lo contrario, <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanUndo">
      <MemberSignature Language="C#" Value="public bool CanUndo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanUndo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.CanUndo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanUndo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanUndo { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el usuario puede deshacer la operación realizada anteriormente en un control de cuadro de texto.</summary>
        <value>
          <see langword="true" /> si el usuario puede deshacer la operación anterior realizada en un control de cuadro de texto; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este método devuelve `true`, puede llamar a la <xref:System.Windows.Forms.TextBoxBase.Undo%2A> método para deshacer la última operación en un cuadro de texto. Puede usar este método en el <xref:System.Windows.Forms.MenuItem.Popup> eventos de un <xref:System.Windows.Forms.MenuItem>, o en el código que administra el estado de los botones en un <xref:System.Windows.Forms.ToolBar> para habilitar o deshabilitar la posibilidad de deshacer la operación anterior en un control de cuadro de texto.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada. Proporciona <xref:System.Windows.Forms.MenuItem.Click> controladores de eventos para <xref:System.Windows.Forms.MenuItem> objetos que llevan a cabo cortar, copiar, pegar y deshacer operaciones. Este ejemplo requiere que un <xref:System.Windows.Forms.TextBox> control denominado `textBox1` se ha creado.  
  
 [!code-cpp[Classic TextBoxBase.CanUndo Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.CanUndo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.CanUndo Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.CanUndo Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.CanUndo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.CanUndo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Cut" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra todo el texto del control de cuadro de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede utilizar este método para borrar el contenido del control en lugar de asignar la <xref:System.Windows.Forms.TextBoxBase.Text%2A> propiedad una cadena vacía.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada, para crear un controlador de eventos para el <xref:System.Windows.Forms.Control.TextChanged> eventos. El código en el controlador de eventos restringe los datos a los números. Una vez que se ha especificado el texto en el control, el código determina si el texto especificado es un número. Si el texto no es un número, el código borra el texto del control y un <xref:System.Windows.Forms.MessageBox> se muestra para generar una alerta al usuario que sólo se aceptan números. El ejemplo requiere que un `Boolean` variable denominada `flag` y un <xref:System.Windows.Forms.TextBox> control denominado `textBox1` se definen fuera de este método. Este ejemplo muestra cómo utilizar una variable de indicador para evitar un evento en cascada en el <xref:System.Windows.Forms.Control.TextChanged> eventos.  
  
 [!code-cpp[Classic TextBoxBase.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Cut" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.CanUndo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.ClearUndo" />
      </Docs>
    </Member>
    <Member MemberName="ClearUndo">
      <MemberSignature Language="C#" Value="public void ClearUndo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearUndo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.ClearUndo" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearUndo ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearUndo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra la información sobre la última operación realizada del búfer Deshacer del cuadro de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar este método para evitar que una operación de deshacer de repetición, en función del estado de la aplicación.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada. Proporciona <xref:System.Windows.Forms.MenuItem.Click> controladores de eventos para <xref:System.Windows.Forms.MenuItem> objetos que llevan a cabo cortar, copiar, pegar y deshacer operaciones. Este ejemplo requiere que un <xref:System.Windows.Forms.TextBox> control denominado `textBox1` se ha creado.  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Cut" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.CanUndo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se hace clic en el cuadro de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el control de eventos, vea [NIB: consumir eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo controlar la <xref:System.Windows.Forms.TextBoxBase.Click> eventos. Para ejecutar el ejemplo, pegue el siguiente código en un formulario que contenga un <xref:System.Windows.Forms.TextBox> control denominado TextBox1. Este ejemplo requiere que el método de control de eventos se ha asociado el <xref:System.Windows.Forms.TextBoxBase.Click> eventos.  
  
 [!code-cpp[System.Windows.Forms.TextBoxBaseScrolling#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.TextBoxBaseScrolling#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.TextBoxBaseScrolling#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public void Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Sub Copy ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Copy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia la selección actual del cuadro de texto en el **Portapapeles**.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar este método, en lugar de utilizar el <xref:System.Windows.Forms.Clipboard> (clase), para copiar texto en el cuadro de texto y colocarlo en la **Portapapeles**.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada. Proporciona <xref:System.Windows.Forms.MenuItem.Click> controladores de eventos para <xref:System.Windows.Forms.MenuItem> objetos que llevan a cabo cortar, copiar, pegar y deshacer operaciones. Este ejemplo requiere que un <xref:System.Windows.Forms.TextBox> control denominado `textBox1` se ha creado.  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Cut" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.CanUndo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Clear" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected override void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CreateHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un identificador para el control.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para trabajar con código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los parámetros de creación necesarios cuando se crea el identificador del control.</summary>
        <value>
          <see cref="T:System.Windows.Forms.CreateParams" /> que contiene los parámetros de creación necesarios cuando se crea el identificador del control.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="Cut">
      <MemberSignature Language="C#" Value="public void Cut ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cut() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Cut" />
      <MemberSignature Language="VB.NET" Value="Public Sub Cut ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Cut();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Mueve la selección actual del cuadro de texto al **Portapapeles**.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método solamente cortará texto del cuadro de texto si hay texto seleccionado en el control. Puede usar este método, en lugar de utilizar el <xref:System.Windows.Forms.Clipboard> (clase), puede copiar texto en el cuadro de texto y moverlo a la **Portapapeles**.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada. Proporciona <xref:System.Windows.Forms.MenuItem.Click> controladores de eventos para <xref:System.Windows.Forms.MenuItem> objetos que llevan a cabo cortar, copiar, pegar y deshacer operaciones. Este ejemplo requiere que un <xref:System.Windows.Forms.TextBox> control denominado `textBox1` se ha creado.  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.CanUndo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DefaultCursor">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.Cursor DefaultCursor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor DefaultCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.DefaultCursor" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Cursor ^ DefaultCursor { System::Windows::Forms::Cursor ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el cursor predeterminado para el control.</summary>
        <value>Un objeto de tipo <see cref="T:System.Windows.Forms.Cursor" /> que representa el cursor predeterminado actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalidar <xref:System.Windows.Forms.TextBoxBase.DefaultCursor%2A> para configurar un cursor predeterminado para el control. Esto es más eficaz que establecer el cursor en el constructor del control y proporciona compatibilidad automática para ciertas funciones del diseñador relacionadas con el cursor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño predeterminado del control.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> predeterminado del control.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DeselectAll">
      <MemberSignature Language="C#" Value="public void DeselectAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeselectAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.DeselectAll" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeselectAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeselectAll();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Especifica que el valor de la propiedad <see cref="P:System.Windows.Forms.TextBoxBase.SelectionLength" /> es cero para que no se seleccione ningún carácter en el control.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DoubleBuffered">
      <MemberSignature Language="C#" Value="protected override bool DoubleBuffered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DoubleBuffered" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.DoubleBuffered" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Property DoubleBuffered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool DoubleBuffered { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el dibujo del control se realiza en un búfer antes de que se muestre el control. Esta propiedad no es relevante para esta clase.</summary>
        <value>
          Es <see langword="true" /> para implementar el búfer doble en el control; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-513)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el color de primer plano del control.</summary>
        <value>
          <see cref="T:System.Drawing.Color" /> que representa el color de primer plano del control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el <xref:System.Windows.Forms.TextBoxBase.ForeColor%2A> propiedad para cambiar el color del texto dentro del control para que coincida con el texto de otros controles en el formulario. También puede utilizar esta propiedad para resaltar un cuadro de texto que contiene un valor no válido.  
  
 Para cambiar el color de fondo del control, use la <xref:System.Windows.Forms.TextBoxBase.BackColor%2A> propiedad. Al establecer el <xref:System.Windows.Forms.TextBoxBase.ForeColor%2A> propiedad del control de texto, asegúrese de que el color que elija no hacen que el texto del control que desaparezcan. Por ejemplo, si la <xref:System.Windows.Forms.TextBoxBase.ForeColor%2A> y <xref:System.Windows.Forms.TextBoxBase.BackColor%2A> propiedades se establecen en `Color.Black`, el texto dentro del control de cuadro de texto no estará visible.  
  
 Esta propiedad puede ser sobre if reemplazan la <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> propiedad de la <xref:System.Windows.Forms.TextBoxBase> está establecido en `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="GetCharFromPosition">
      <MemberSignature Language="C#" Value="public virtual char GetCharFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char GetCharFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetCharFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharFromPosition (pt As Point) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual char GetCharFromPosition(System::Drawing::Point pt);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">Lugar desde el que se buscará el carácter más cercano.</param>
        <summary>Recupera el carácter más próximo a la ubicación especificada en el control.</summary>
        <returns>Carácter de la ubicación especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la ubicación especificada en el `pt` parámetro está fuera del área cliente del control, el primer carácter de la cadena más cercana al punto especificado en `pt` se devuelve. Puede usar este método para determinar qué caracteres se encuentran cerca de un punto específico en el control. A continuación, puede usar este valor para realizar operaciones en el texto en esa ubicación.  
  
> [!NOTE]
>  Si la ubicación especificada en el `pt` parámetro se encuentra en el lado derecho del área cliente del control, el último carácter de la cadena más cercana al punto especificado en `pt` se devuelve.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetPositionFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetCharIndexFromPosition">
      <MemberSignature Language="C#" Value="public virtual int GetCharIndexFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharIndexFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetCharIndexFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharIndexFromPosition (pt As Point) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharIndexFromPosition(System::Drawing::Point pt);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">Ubicación donde se va a buscar.</param>
        <summary>Recupera el índice del carácter más cercano a la ubicación especificada.</summary>
        <returns>Índice de carácter de base cero de la ubicación especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve el índice de carácter más próximo a la posición especificada en el `pt` parámetro. El índice de carácter es un índice de base cero del texto en el control, incluidos los espacios. Puede usar este método para determinar donde en el texto con la que el usuario ha colocado pasar el mouse en coordenadas a este método el mouse. Esto puede ser útil si desea realizar tareas cuando el usuario sitúa el puntero del mouse sobre una palabra en el texto del control.  
  
> [!IMPORTANT]
>  Si la ubicación especificada no está dentro del rectángulo de cliente del control o está más allá del último carácter en el control, el valor devuelto es el índice del último carácter.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetPositionFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetFirstCharIndexFromLine">
      <MemberSignature Language="C#" Value="public int GetFirstCharIndexFromLine (int lineNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetFirstCharIndexFromLine(int32 lineNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFirstCharIndexFromLine (lineNumber As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetFirstCharIndexFromLine(int lineNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lineNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="lineNumber">Línea para la que obtener el índice de su primer carácter.</param>
        <summary>Recupera el índice del primer carácter de una línea determinada.</summary>
        <returns>El índice de base cero del primer carácter en la línea especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numeración de líneas en el cuadro de texto comienza en cero. Si el `lineNumber` parámetro es mayor que la última línea en el cuadro de texto, <xref:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine%2A> devuelve -1.  
  
 <xref:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine%2A> Devuelve el índice del primer carácter de una línea física. La línea física es la línea mostrada, no la línea asignada. El número de líneas mostradas puede ser mayor que el número de líneas asignadas debido al ajuste automático de línea. Por ejemplo, si asigna dos líneas largas a un <xref:System.Windows.Forms.RichTextBox> controlar y establecer <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> y <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> a `true`, dar lugar a las dos líneas asignadas largas en cuatro física (o líneas mostradas).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor del parámetro <paramref name="lineNumber" /> es menor que cero.</exception>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetPositionFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharFromPosition(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="GetFirstCharIndexOfCurrentLine">
      <MemberSignature Language="C#" Value="public int GetFirstCharIndexOfCurrentLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetFirstCharIndexOfCurrentLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexOfCurrentLine" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFirstCharIndexOfCurrentLine () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetFirstCharIndexOfCurrentLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera el índice del primer carácter de la línea actual.</summary>
        <returns>Índice de carácter de base cero situado en la línea actual.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineFromCharIndex">
      <MemberSignature Language="C#" Value="public virtual int GetLineFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetLineFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLineFromCharIndex (index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetLineFromCharIndex(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Posición del índice de carácter que se va a buscar.</param>
        <summary>Recupera el número de línea desde la posición de carácter especificada dentro del texto del control.</summary>
        <returns>Número de línea de base cero donde se encuentra el índice de carácter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método le permite determinar el número de línea basado en el índice de carácter especificado en el `index` parámetro del método. La primera línea de texto en el control devuelve el valor cero. El <xref:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex%2A> método devuelve el número de línea física donde el carácter indizado se encuentra dentro del control. Por ejemplo, si una parte de la primera línea lógica de texto en el control se ajusta a la línea siguiente, la <xref:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex%2A> método devuelve 1 si el carácter que ocupa el índice de carácter especificado ha saltado a la segunda línea física. Si <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> se establece en `false`, ninguna parte de la línea se ajusta a la siguiente y el método devuelve 0 para el índice de carácter especificado. Puede usar este método para determinar qué línea se encuentra dentro de un índice de carácter específico. Por ejemplo, después de llamar a la <xref:System.Windows.Forms.RichTextBox.Find%2A> método para buscar texto, puede obtener el índice de carácter donde se encuentran los resultados de búsqueda. Puede llamar a este método con el índice de carácter devuelto por el <xref:System.Windows.Forms.RichTextBox.Find%2A> se encontró el método para determinar qué línea de la palabra.  
  
> [!NOTE]
>  Si el índice de carácter especificado en el `index` parámetro queda fuera el número de líneas que contiene el control disponibles, se devuelve el último número de línea.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetPositionFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromCharIndex">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Point GetPositionFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.Point GetPositionFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetPositionFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPositionFromCharIndex (index As Integer) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Drawing::Point GetPositionFromCharIndex(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice del carácter cuya ubicación se desea recuperar.</param>
        <summary>Recupera la ubicación dentro del control en el índice de caracteres especificado.</summary>
        <returns>La ubicación del carácter especificado dentro del rectángulo de cliente del control.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método le permite determinar dónde se encuentra un índice de carácter específico en el control. Puede usar este método para realizar tareas tales como mostrar información de elementos o la Ayuda de menú de acceso directo para una palabra en el control. Por ejemplo, si desea mostrar un menú de opciones al usuario cuando el usuario hace clic en una palabra en el control, puede usar este método para determinar la posición de la palabra para mostrar correctamente un <xref:System.Windows.Forms.ContextMenu> control.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HideSelection">
      <MemberSignature Language="C#" Value="public bool HideSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HideSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.HideSelection" />
      <MemberSignature Language="VB.NET" Value="Public Property HideSelection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HideSelection { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el texto seleccionado en el control de cuadro de texto continúa resaltado cuando el control pierde foco.</summary>
        <value>
          <see langword="true" /> si el texto seleccionado no aparece resaltado cuando el control de cuadro de texto pierde foco; <see langword="false" /> si el texto seleccionado permanece resaltado cuando el control de cuadro de texto pierde foco. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede utilizar esta propiedad para mantener texto resaltado en un control de cuadro de texto mientras otro formulario o un cuadro de diálogo tiene el foco, como un cuadro de diálogo del corrector ortográfico.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Windows.Forms.TextBoxBase.HideSelection%2A> propiedad. Para ejecutar el ejemplo, pegue el siguiente código en un formulario. Llame a la `InitializeTextBox` método en el constructor del formulario o `Load` método.  
  
 [!code-cpp[System.Windows.Forms.TextBoxBaseScrolling#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.TextBoxBaseScrolling#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.TextBoxBaseScrolling#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HideSelectionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler HideSelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HideSelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.HideSelectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HideSelectionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HideSelectionChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.TextBoxBase.HideSelection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el control de eventos, vea [NIB: consumir eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos notifica la aparición de la <xref:System.Windows.Forms.TextBoxBase.HideSelectionChanged> eventos. Este informe le ayuda a obtener información cuando se produce el evento y puede ayudarle a depurar. Para informar sobre varios eventos o sobre eventos que se producen con frecuencia, considere la posibilidad de reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.TextBoxBase>, como un <xref:System.Windows.Forms.TextBox> o <xref:System.Windows.Forms.TextBoxBase>. A continuación, asigne a la instancia `TextBoxBase1` y asegurarse de que el controlador de eventos está asociado con el <xref:System.Windows.Forms.TextBoxBase.HideSelectionChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#245](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#245)]
 [!code-vb[System.Windows.Forms.EventExamples#245](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#245)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.HideSelection" />
      </Docs>
    </Member>
    <Member MemberName="ImeModeBase">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.ImeMode ImeModeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeModeBase" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.ImeModeBase" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Property ImeModeBase As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode ImeModeBase { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el modo de Editor de métodos de entrada (IME) del control.</summary>
        <value>Modo IME del control.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="IsInputKey">
      <MemberSignature Language="C#" Value="protected override bool IsInputKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsInputKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.IsInputKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsInputKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsInputKey(System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Uno de los valores de Keys.</param>
        <summary>Determina si la tecla especificada es una tecla de entrada o una tecla especial que requiere preprocesamiento.</summary>
        <returns>
          Es <see langword="true" /> si la tecla especificada es una tecla de entrada; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.TextBoxBase.IsInputKey%2A> método `true` cuando el `keyData` parámetro incluye el <xref:System.Windows.Forms.Keys.Tab> valor y el <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A> propiedad es `true`. <xref:System.Windows.Forms.TextBoxBase.IsInputKey%2A> Devuelve `false` si `keyData` contiene <xref:System.Windows.Forms.Keys.Tab> y <xref:System.Windows.Forms.Keys.Control>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Lines">
      <MemberSignature Language="C#" Value="public string[] Lines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Lines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.Lines" />
      <MemberSignature Language="VB.NET" Value="Public Property Lines As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Lines { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.StringArrayEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece las líneas de texto de un control de cuadro de texto.</summary>
        <value>Matriz de cadenas que contiene el texto en un control de cuadro de texto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento de la matriz se convierte en una línea de texto en el control de cuadro de texto. Si el <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> propiedad del control de cuadro de texto se establece en `true` y aparece un carácter de nueva línea en el texto, el texto que sigue al carácter de nueva línea se agrega a un nuevo elemento de la matriz y se muestra en una línea independiente.  
  
> [!NOTE]
>  De forma predeterminada, la colección de líneas es una copia de solo lectura de las líneas de la <xref:System.Windows.Forms.TextBox>. Para obtener una colección de líneas de escritura, use código similar al siguiente: `textBox1.Lines = new string[] { "abcd" };`  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada, para extraer todas las cadenas de texto de un control de cuadro de texto multilínea y las muestra mediante el <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> método. Este ejemplo requiere que un <xref:System.Windows.Forms.TextBox> se ha creado el control, denominado `textBox1`, y que se ha rellenado con líneas de texto.  
  
 [!code-cpp[Classic TextBoxBase.Lines Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.Lines Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.Lines Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.Lines Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.Lines Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.Lines Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="MaxLength">
      <MemberSignature Language="C#" Value="public virtual int MaxLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.MaxLength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MaxLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaxLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(32767)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número máximo de caracteres que el usuario puede escribir o pegar en el control de cuadro de texto.</summary>
        <value>Número de caracteres que pueden escribirse en el control. El valor predeterminado es 32767.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede utilizar esta propiedad para restringir la longitud del texto especificado en el control para valores como códigos postales y números de teléfono, o para restringir la longitud del texto escrito cuando los datos se deben especificar en una base de datos. Puede limitar el texto escrito en el control a la longitud máxima del campo correspondiente en la base de datos.  
  
> [!NOTE]
>  En el código, puede establecer el valor de la <xref:System.Windows.Forms.TextBoxBase.Text%2A> propiedad en un valor que tiene una longitud mayor que el valor especificado por el <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> propiedad. Esta propiedad solo afecta a texto escrito en el control en tiempo de ejecución.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se utiliza la clase derivada, <xref:System.Windows.Forms.TextBox>, para crear un cuadro de texto que se usa para aceptar una contraseña. Este ejemplo se utiliza la <xref:System.Windows.Forms.TextBox.CharacterCasing%2A> con tipo de propiedad que se va a cambiar todos los caracteres a mayúsculas y <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> propiedad para restringir la longitud de contraseña a ocho caracteres. Este ejemplo también utiliza el <xref:System.Windows.Forms.TextBox.TextAlign%2A> propiedad para centrar la contraseña en el <xref:System.Windows.Forms.TextBox> control.  
  
 [!code-cpp[Classic TextBoxBase.MaxLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.MaxLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.MaxLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.MaxLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.MaxLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.MaxLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor asignado a la propiedad es menor que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Modified">
      <MemberSignature Language="C#" Value="public bool Modified { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Modified" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.Modified" />
      <MemberSignature Language="VB.NET" Value="Public Property Modified As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Modified { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica que el usuario ha modificado el control de cuadro de texto desde que se creó el control o se estableció su contenido por última vez.</summary>
        <value>
          <see langword="true" /> si se ha modificado el contenido del control; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede utilizar esta propiedad para determinar si el usuario ha modificado el contenido del control de cuadro de texto. También puede establecer esta propiedad en el código para indicar que se realizaron cambios en el control de cuadro de texto por la aplicación. Esta propiedad puede utilizarse por métodos de almacenamiento de datos y validación para determinar si se realizaron cambios en un control de cuadro de texto, por lo que puede pueden validar o guardar el contenido cambiado.  
  
 Si cambia la <xref:System.Windows.Forms.TextBoxBase.Text%2A> propiedad mediante programación, el <xref:System.Windows.Forms.TextBoxBase.Modified%2A> propiedad vuelve a `false`. Esto no provoca la <xref:System.Windows.Forms.TextBoxBase.ModifiedChanged> eventos.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.Control.TextChanged> eventos para un <xref:System.Windows.Forms.TextBox>, una clase derivada, para determinar si el contenido de la <xref:System.Windows.Forms.TextBox> control han cambiado desde que se rellenó el control con datos. En el ejemplo se utiliza una cadena para almacenar el contenido original del control y los compara con el contenido de la <xref:System.Windows.Forms.TextBox> para determinar si el contenido ha cambiado. Si ha cambiado el contenido, la <xref:System.Windows.Forms.TextBoxBase.Modified%2A> propiedad está establecida en `true`. En caso contrario, se restablece en `false`. Este ejemplo requiere que un <xref:System.Windows.Forms.TextBox> control denominado `textBox1` se ha creado y que un `String` variable denominada `originalText` se ha creado para almacenar el texto original para el <xref:System.Windows.Forms.TextBox> control.  
  
 [!code-cpp[Classic TextBoxBase.Modified Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.Modified Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.Modified Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.Modified Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.Modified Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.Modified Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifiedChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ModifiedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ModifiedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.ModifiedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ModifiedChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ModifiedChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.TextBoxBase.Modified" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cambia la <xref:System.Windows.Forms.TextBoxBase.Text%2A> propiedad mediante programación, el <xref:System.Windows.Forms.TextBoxBase.Modified%2A> propiedad vuelve a `false`. Esto no provoca la <xref:System.Windows.Forms.TextBoxBase.ModifiedChanged> eventos.  
  
 Para obtener más información sobre el control de eventos, vea [NIB: consumir eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos notifica la aparición de la <xref:System.Windows.Forms.TextBoxBase.ModifiedChanged> eventos. Este informe le ayuda a obtener información cuando se produce el evento y puede ayudarle a depurar. Para informar sobre varios eventos o sobre eventos que se producen con frecuencia, considere la posibilidad de reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.TextBoxBase>, como un <xref:System.Windows.Forms.TextBox> o <xref:System.Windows.Forms.TextBoxBase>. A continuación, asigne a la instancia `TextBoxBase1` y asegurarse de que el controlador de eventos está asociado con el <xref:System.Windows.Forms.TextBoxBase.ModifiedChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#246](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#246)]
 [!code-vb[System.Windows.Forms.EventExamples#246](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#246)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Modified" />
      </Docs>
    </Member>
    <Member MemberName="MouseClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.MouseClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseClick;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se hace clic con el mouse en el control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.RichTextBox> control no provoca un <xref:System.Windows.Forms.TextBoxBase.Click> haga hace clic en el evento. El <xref:System.Windows.Forms.TextBoxBase.MouseClick> eventos proporciona el equivalente funcional.  
  
 Para obtener más información sobre el control de eventos, vea [NIB: consumir eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos notifica la aparición de la <xref:System.Windows.Forms.TextBoxBase.MouseClick> eventos. Este informe le ayuda a obtener información cuando se produce el evento y puede ayudarle a depurar. Para informar sobre varios eventos o sobre eventos que se producen con frecuencia, considere la posibilidad de reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.TextBoxBase>, como un <xref:System.Windows.Forms.TextBox> o <xref:System.Windows.Forms.TextBoxBase>. A continuación, asigne a la instancia `TextBoxBase1` y asegurarse de que el controlador de eventos está asociado con el <xref:System.Windows.Forms.TextBoxBase.MouseClick> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#244](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#244)]
 [!code-vb[System.Windows.Forms.EventExamples#244](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#244)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiline">
      <MemberSignature Language="C#" Value="public virtual bool Multiline { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Multiline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.Multiline" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Multiline As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Multiline { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si es un control de cuadro de texto multilínea.</summary>
        <value>
          <see langword="true" /> si el control es un control de cuadro de texto multilínea; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuadro de texto multilínea permite mostrar más de una línea de texto en el control. Si el <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> propiedad está establecida en `true`, texto escrito en el cuadro de texto multilínea se ajusta a la línea siguiente en el control. Si el <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> propiedad está establecida en `false`, texto escrito en el control de cuadro de texto multilínea se mostrará en la misma línea hasta que se escribe un carácter de nueva línea.  
  
 A continuación se puede usar como caracteres de nueva línea:  
  
-   <xref:System.Environment.NewLine%2A?displayProperty=nameWithType>  
  
-   ControlChars.CrLf  
  
-   vbCrLf (sólo Visual Basic)  
  
 Puede agregar barras de desplazamiento a un cuadro de texto mediante el <xref:System.Windows.Forms.TextBox.ScrollBars%2A> propiedad para mostrar las barras de desplazamiento horizontal o vertical. Esto permite al usuario desplazarse por el texto que se extiende más allá de las dimensiones del control.  
  
> [!NOTE]
>  Porque el valor predeterminado de la <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> propiedad es `false`, el tamaño predeterminado de un <xref:System.Windows.Forms.TextBox> será según el tamaño de fuente incluso si cambia el tamaño de la <xref:System.Windows.Forms.TextBox>. Para obtener un tamaño uniforme para su <xref:System.Windows.Forms.TextBox>, establezca su <xref:System.Windows.Forms.TextBox.Multiline%2A> propiedad `true`.  
  
> [!NOTE]
>  En japonés los sistemas operativos, si la <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> propiedad está establecida en `true`, y establece el <xref:System.Windows.Forms.TextBox.PasswordChar%2A> propiedad mostrará el texto de la contraseña, lo que poner en peligro la seguridad del sistema. Por lo tanto, en sistemas operativos japoneses, establezca la <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> propiedad `false` si establece la <xref:System.Windows.Forms.TextBox.PasswordChar%2A> propiedad.  
  
> [!NOTE]
>  Esta propiedad se establece en `false` de forma predeterminada para todas las clases derivadas, con la excepción de la <xref:System.Windows.Forms.RichTextBox> control.  
  
 Para una <xref:System.Windows.Forms.RichTextBox> (control), el <xref:System.Windows.Forms.RichTextBox.Multiline%2A?displayProperty=nameWithType> afecta la propiedad o no el control cambia de tamaño automáticamente, como se indica a continuación:  
  
-   Si <xref:System.Windows.Forms.RichTextBox.AutoSize%2A?displayProperty=nameWithType> está establecido en `true` y <xref:System.Windows.Forms.RichTextBox.Multiline%2A?displayProperty=nameWithType> está establecido en `true`, <xref:System.Windows.Forms.RichTextBox> no cambiará de tamaño automáticamente.  
  
-   Si <xref:System.Windows.Forms.RichTextBox.AutoSize%2A?displayProperty=nameWithType> está establecido en `true` y <xref:System.Windows.Forms.RichTextBox.Multiline%2A?displayProperty=nameWithType> está establecido en `false`, <xref:System.Windows.Forms.RichTextBox> cambiará de tamaño automáticamente.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada, para crear una propiedad de multilínea <xref:System.Windows.Forms.TextBox> control con barras de desplazamiento vertical. Este ejemplo también utiliza el <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>, <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>, y <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> propiedades para hacer que el control de cuadro de texto multilínea sea útil para crear documentos de texto.  
  
 [!code-cpp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Lines" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.WordWrap" />
        <altmember cref="P:System.Windows.Forms.TextBox.ScrollBars" />
      </Docs>
    </Member>
    <Member MemberName="MultilineChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MultilineChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MultilineChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.MultilineChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MultilineChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MultilineChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.TextBoxBase.Multiline" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el control de eventos, vea [NIB: consumir eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos notifica la aparición de la <xref:System.Windows.Forms.TextBoxBase.MultilineChanged> eventos. Este informe le ayuda a obtener información cuando se produce el evento y puede ayudarle a depurar. Para informar sobre varios eventos o sobre eventos que se producen con frecuencia, considere la posibilidad de reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.TextBoxBase>, como un <xref:System.Windows.Forms.TextBox> o <xref:System.Windows.Forms.TextBoxBase>. A continuación, asigne a la instancia `TextBoxBase1` y asegurarse de que el controlador de eventos está asociado con el <xref:System.Windows.Forms.TextBoxBase.MultilineChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#247](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#247)]
 [!code-vb[System.Windows.Forms.EventExamples#247](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#247)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="OnAcceptsTabChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAcceptsTabChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAcceptsTabChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnAcceptsTabChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAcceptsTabChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAcceptsTabChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.TextBoxBase.AcceptsTabChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.TextBoxBase.OnAcceptsTabChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.Forms.TextBoxBase.OnAcceptsTabChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.Windows.Forms.TextBoxBase.OnAcceptsTabChanged(System.EventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.AcceptsTab" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.AcceptsTabChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnBorderStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBorderStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBorderStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnBorderStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBorderStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBorderStyleChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.TextBoxBase.BorderStyleChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.TextBoxBase.OnBorderStyleChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.Forms.TextBoxBase.OnBorderStyleChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.Windows.Forms.TextBoxBase.OnBorderStyleChanged(System.EventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.BorderStyle" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.BorderStyleChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.FontChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.HandleCreated" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.HandleDestroyed" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHideSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnHideSelectionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHideSelectionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnHideSelectionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHideSelectionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHideSelectionChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Produce el evento <see cref="E:System.Windows.Forms.TextBoxBase.HideSelectionChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.TextBoxBase.OnHideSelectionChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.Forms.TextBoxBase.OnHideSelectionChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.Windows.Forms.TextBoxBase.OnHideSelectionChanged(System.EventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.HideSelection" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.HideSelectionChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnModifiedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnModifiedChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnModifiedChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnModifiedChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnModifiedChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnModifiedChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.TextBoxBase.ModifiedChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.TextBoxBase.OnModifiedChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.Forms.TextBoxBase.OnModifiedChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.Windows.Forms.TextBoxBase.OnModifiedChanged(System.EventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Modified" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.ModifiedChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected override void OnMouseUp (System.Windows.Forms.MouseEventArgs mevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs mevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseUp (mevent As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseUp(System::Windows::Forms::MouseEventArgs ^ mevent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mevent" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="mevent">Datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.MouseUp" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMultilineChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMultilineChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMultilineChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnMultilineChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMultilineChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMultilineChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.TextBoxBase.MultilineChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.TextBoxBase.OnMultilineChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.Forms.TextBoxBase.OnMultilineChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.Windows.Forms.TextBoxBase.OnMultilineChanged(System.EventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.MultilineChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnPaddingChanged">
      <MemberSignature Language="C#" Value="protected override void OnPaddingChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaddingChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnPaddingChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPaddingChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPaddingChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Este método no es relevante para esta clase.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnReadOnlyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnReadOnlyChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnReadOnlyChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnReadOnlyChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnReadOnlyChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnReadOnlyChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.TextBoxBase.ReadOnlyChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.TextBoxBase.OnReadOnlyChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.Forms.TextBoxBase.OnReadOnlyChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.Windows.Forms.TextBoxBase.OnReadOnlyChanged(System.EventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ReadOnly" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.ReadOnlyChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected override void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.TextChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Padding { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta propiedad no es relevante para esta clase.</summary>
        <value>Valor <see cref="T:System.Windows.Forms.Padding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PaddingChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaddingChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.PaddingChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PaddingChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PaddingChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Este evento no es relevante para esta clase.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PaintEventHandler Paint;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PaintEventHandler Paint" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.Paint" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Paint As PaintEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PaintEventHandler ^ Paint;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PaintEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando vuelve a dibujarse el control. Este evento no es relevante para esta clase.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento no es relevante para esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Paste" />
      <MemberSignature Language="VB.NET" Value="Public Sub Paste ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reemplaza la selección actual del cuadro de texto con el contenido del **Portapapeles**.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.TextBoxBase.Paste%2A> método solo pegar texto en el control si hay texto almacenado actualmente en el **Portapapeles**.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada. Proporciona <xref:System.Windows.Forms.MenuItem.Click> controladores de eventos para <xref:System.Windows.Forms.MenuItem> objetos que llevan a cabo cortar, copiar, pegar y deshacer operaciones. Este ejemplo requiere que un <xref:System.Windows.Forms.TextBox> control denominado `textBox1` se ha creado.  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para leer de la **Portapapeles**. Enumeración asociada: el <see langword="AllClipboard" /> valo <see cref="T:System.Security.Permissions.UIPermissionClipboard" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="PreferredHeight">
      <MemberSignature Language="C#" Value="public int PreferredHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PreferredHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.PreferredHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PreferredHeight { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el alto preferido de un cuadro de texto.</summary>
        <value>El alto preferido de un cuadro de texto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tamaño devuelto por esta propiedad se basa en el estilo de fuente de alto y el borde del cuadro de texto. Puede utilizar esta propiedad para determinar el tamaño adecuado del cuadro de texto para garantizar que el texto se muestre correctamente en el control. El valor devuelto por esta propiedad es en píxeles.  
  
 El valor de <xref:System.Windows.Forms.TextBoxBase.PreferredHeight%2A> representa el alto mínimo debe tener el cuadro de texto para mostrar una sola línea de texto sin ajustar el texto en la parte superior o inferior. Este valor es el mismo si la <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> propiedad está establecida en `true` o `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.AutoSize" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">
          <see cref="T:System.Windows.Forms.Message" /> que se pasa por referencia y que representa el mensaje de ventana que se va a procesar.</param>
        <param name="keyData">Uno de los valores de <see cref="T:System.Windows.Forms.Keys" /> que representa la tecla de método abreviado que se va a procesar.</param>
        <summary>Procesa una tecla de comando.</summary>
        <returns>
          Es <see langword="true" /> si el control procesó la tecla de comando; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para trabajar con código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Uno de los valores de <see cref="T:System.Windows.Forms.Keys" /> que representa la tecla que se va a procesar.</param>
        <summary>Procesa una tecla de diálogo.</summary>
        <returns>
          <see langword="true" /> si el control procesó la tecla; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el texto del cuadro de texto es de sólo lectura.</summary>
        <value>
          Es <see langword="true" /> si el cuadro de texto es de solo lectura; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando esta propiedad se establece en `true`, no se puede cambiar el contenido del control por el usuario en tiempo de ejecución. Con esta propiedad establecida en `true`, todavía se puede establecer el valor de la <xref:System.Windows.Forms.TextBoxBase.Text%2A> propiedad en el código. Puede utilizar esta característica en lugar de deshabilitar el control con el <xref:System.Windows.Forms.Control.Enabled%2A> propiedad para permitir que el contenido que se va a copiar e información sobre herramientas que se mostrará.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnlyChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ReadOnlyChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ReadOnlyChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.ReadOnlyChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReadOnlyChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ReadOnlyChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.TextBoxBase.ReadOnly" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el control de eventos, vea [NIB: consumir eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este miembro. En el ejemplo, un controlador de eventos notifica la aparición de la <xref:System.Windows.Forms.TextBoxBase.ReadOnlyChanged> eventos. Este informe le ayuda a obtener información cuando se produce el evento y puede ayudarle a depurar. Para informar sobre varios eventos o sobre eventos que se producen con frecuencia, considere la posibilidad de reemplazar <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o agregar el mensaje a un multilínea <xref:System.Windows.Forms.TextBox>.  
  
 Para ejecutar el ejemplo de código, péguelo en un proyecto que contiene una instancia de un tipo que hereda de <xref:System.Windows.Forms.TextBoxBase>, como un <xref:System.Windows.Forms.TextBox> o <xref:System.Windows.Forms.TextBoxBase>. A continuación, asigne a la instancia `TextBoxBase1` y asegurarse de que el controlador de eventos está asociado con el <xref:System.Windows.Forms.TextBoxBase.ReadOnlyChanged> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#248](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#248)]
 [!code-vb[System.Windows.Forms.EventExamples#248](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#248)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="ScrollToCaret">
      <MemberSignature Language="C#" Value="public void ScrollToCaret ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToCaret() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.ScrollToCaret" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToCaret ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToCaret();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desplaza el contenido del control a la posición del símbolo de intercalación actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método le permite desplazar el contenido del control hasta que el símbolo de intercalación está dentro del área visible del control. Si el símbolo de intercalación se coloca debajo de la región visible del control, el <xref:System.Windows.Forms.TextBoxBase.ScrollToCaret%2A> método desplazará el contenido del control hasta que el símbolo de intercalación está visible en la parte inferior del control. Si el símbolo de intercalación está situado por encima de la región visible del control, este método desplaza el contenido del control hasta que el símbolo de intercalación está visible en la parte superior del control. Puede usar este método en un cuadro de texto multilínea para asegurarse de que el punto de entrada de texto actual está dentro del área visible del control.  
  
> [!NOTE]
>  Este método no tiene ningún efecto si el control no tiene el foco o si el símbolo de intercalación ya se encuentra situado en la región visible del control.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Windows.Forms.Keys> enumeración y <xref:System.Windows.Forms.TextBoxBase.ScrollToCaret%2A> método para asegurarse de que el punto de inserción de texto, representado por el símbolo de intercalación, siempre está visible en la pantalla después de que se ha presionado la tecla ENTRAR. Para ejecutar el ejemplo, pegue el siguiente código en un formulario que contenga un <xref:System.Windows.Forms.TextBox> control denominado `TextBox1` y un <xref:System.Windows.Forms.RichTextBox> control denominado `RichTextBox1`. Este ejemplo requiere que el método de control de eventos se ha asociado el <xref:System.Windows.Forms.Control.KeyDown> eventos.  
  
 [!code-cpp[System.Windows.Forms.TextBoxBaseScrolling#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.TextBoxBaseScrolling#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.TextBoxBaseScrolling#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(int start, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Posición del primer carácter de la selección de texto actual dentro del cuadro de texto.</param>
        <param name="length">Número de caracteres que se va a seleccionar.</param>
        <summary>Selecciona un intervalo de texto en el cuadro de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si desea establecer la posición inicial en el primer carácter del texto del control, establezca el `start` parámetro en 0. Puede utilizar este método para seleccionar una subcadena del texto, como el destino al buscar a través del texto del control y reemplazar información.  
  
> [!NOTE]
>  Se puede mover el símbolo de intercalación en el cuadro de texto mediante programación estableciendo la `start` parámetro a la posición del cuadro de texto donde desea que el símbolo de intercalación para mover y establecer el `length` parámetro con un valor de cero (0). El cuadro de texto debe tener foco en orden para el símbolo de intercalación que se moverá.  
  
> [!NOTE]
>  Si se llama a este método sin ningún parámetro, se utiliza un método alternativo. Este método alternativo que se hereda de la <xref:System.Windows.Forms.Control> clase. Cuando se llama, Establece el foco de entrada en el control y selecciona el contenido del control. Para obtener más información, vea el método <xref:System.Windows.Forms.Control.Select%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada, para buscar en el contenido del control para la instancia de la palabra "fox". Si se encuentra, el código selecciona la palabra, en el control mediante la <xref:System.Windows.Forms.TextBoxBase.Select%2A> método. Este ejemplo requiere que un <xref:System.Windows.Forms.TextBox> denominado `textBox1` se ha creado y su <xref:System.Windows.Forms.TextBoxBase.Text%2A> propiedad contiene la frase "el veloz murciélago hindú comía feliz cardillo y kiwi."  
  
 [!code-cpp[Classic TextBoxBase.Select Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.Select Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.Select Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.Select Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor del parámetro <paramref name="start" /> es menor que cero.</exception>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.SelectAll" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionLength" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      </Docs>
    </Member>
    <Member MemberName="SelectAll">
      <MemberSignature Language="C#" Value="public void SelectAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SelectAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.SelectAll" />
      <MemberSignature Language="VB.NET" Value="Public Sub SelectAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SelectAll();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Selecciona todo el texto del cuadro de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método permite seleccionar todo el texto dentro del control. Puede utilizar este método junto con el <xref:System.Windows.Forms.TextBoxBase.Cut%2A> método, que requiere tener texto seleccionado en el control, todo el contenido del control de cortar y pegar en el **Portapapeles**.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada, para determinar si hay texto seleccionado en el control. Si no hay texto seleccionado, se realiza una llamada a la <xref:System.Windows.Forms.TextBoxBase.SelectAll%2A> método antes de copiar el contenido del control a la **Portapapeles**. Este ejemplo requiere que un <xref:System.Windows.Forms.TextBox> se ha creado con nombre `textBox1`.  
  
 [!code-cpp[Classic TextBoxBase.SelectAll Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectAll Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectAll Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectAll Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectAll Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectAll Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectedText">
      <MemberSignature Language="C#" Value="public virtual string SelectedText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SelectedText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SelectedText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica el texto seleccionado actualmente en el control.</summary>
        <value>Cadena que representa el texto seleccionado actualmente en el cuadro de texto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede asignar texto a esta propiedad para cambiar el texto seleccionado actualmente en el cuadro de texto. Si no hay texto seleccionado en el cuadro de texto, esta propiedad devuelve una cadena de longitud cero.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada. Proporciona <xref:System.Windows.Forms.MenuItem.Click> controladores de eventos para <xref:System.Windows.Forms.MenuItem> objetos que llevan a cabo cortar, copiar, pegar y deshacer operaciones. Este ejemplo requiere que un <xref:System.Windows.Forms.TextBox> control denominado `textBox1` se ha creado.  
  
 [!code-cpp[Classic TextBoxBase.SelectedText Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectedText Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectedText Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectedText Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectedText Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectedText Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionLength" />
      </Docs>
    </Member>
    <Member MemberName="SelectionLength">
      <MemberSignature Language="C#" Value="public virtual int SelectionLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.SelectionLength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SelectionLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int SelectionLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número de caracteres seleccionados en el cuadro de texto.</summary>
        <value>Número de caracteres seleccionados en el cuadro de texto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede utilizar esta propiedad para determinar si hay caracteres actualmente seleccionados en el control de cuadro de texto antes de realizar operaciones en el texto seleccionado. Cuando el valor de la <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> propiedad está establecida en un valor mayor que el número de caracteres en el texto del control, el valor de la <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> propiedad está establecida en toda la longitud del texto del control menos el valor de la <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> propiedad (si se especifica ningún valor para el <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> propiedad).  
  
> [!NOTE]
>  Se puede mover el símbolo de intercalación en el cuadro de texto mediante programación estableciendo la <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> a la posición del cuadro de texto donde desea que el símbolo de intercalación para mover y establecer el <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> en un valor de cero (0). El cuadro de texto debe tener foco en orden para el símbolo de intercalación que se moverá.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada. Proporciona <xref:System.Windows.Forms.MenuItem.Click> controladores de eventos para <xref:System.Windows.Forms.MenuItem> objetos que llevan a cabo cortar, copiar, pegar y deshacer operaciones. Este ejemplo requiere que un <xref:System.Windows.Forms.TextBox> control denominado `textBox1` se ha creado.  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor asignado es menor que cero.</exception>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      </Docs>
    </Member>
    <Member MemberName="SelectionStart">
      <MemberSignature Language="C#" Value="public int SelectionStart { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionStart As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionStart { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el punto de inicio del texto seleccionado en el cuadro de texto.</summary>
        <value>Posición de inicio del texto seleccionado en el cuadro de texto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay texto seleccionado en el control, esta propiedad indica el punto de inserción, o símbolo de intercalación para el texto nuevo. Si establece esta propiedad en una ubicación más allá de la longitud del texto en el control, la posición de inicio de la selección se colocarán después del último carácter. Cuando se selecciona texto en el control de cuadro de texto, el cambio de esta propiedad podría disminuir el valor de la <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> propiedad. Si el texto restante en el control después de la posición indicada por la <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> propiedad es menor que el valor de la <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> propiedad, el valor de la <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> propiedad se reduce automáticamente. El valor de la <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> propiedad nunca provoca un aumento en el <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> propiedad.  
  
 Se puede mover la selección del cuadro de texto mediante programación estableciendo la <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> y <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> propiedades.  
  
 Se puede mover el símbolo de intercalación en el cuadro de texto mediante programación estableciendo la <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> a la posición del cuadro de texto donde desea que el símbolo de intercalación para mover y establecer el <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> en un valor de cero (0).  
  
 El <xref:System.Windows.Forms.TextBox> debe tener el foco en orden para la selección o el símbolo de intercalación que se moverá. Puede establecer el <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> propiedad de un <xref:System.Windows.Forms.TextBox> decir <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> dándole el <xref:System.Windows.Forms.Control.Focus%2A> primero.  
  
   
  
## Examples  
 **Ejemplo 1**  
  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada. Proporciona <xref:System.Windows.Forms.MenuItem.Click> controladores de eventos para <xref:System.Windows.Forms.MenuItem> objetos que llevan a cabo cortar, copiar, pegar y deshacer operaciones. Este ejemplo requiere que un <xref:System.Windows.Forms.TextBox> control denominado `textBox1` se ha creado.  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 **Ejemplo 2**  
  
 El ejemplo siguiente se establece la <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> propiedad de un <xref:System.Windows.Forms.TextBox> que es <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> dándole el <xref:System.Windows.Forms.Control.Focus%2A> primero.  
  
 [!code-csharp[SystemWindowsFormsTextBoxBase#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemWindowsFormsTextBoxBase/CS/Form1.cs#1)]
 [!code-vb[SystemWindowsFormsTextBoxBase#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemWindowsFormsTextBoxBase/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor asignado es menor que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected override void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Nuevo valor de la propiedad <see cref="P:System.Windows.Forms.Control.Left" /> del control.</param>
        <param name="y">Nuevo valor de la propiedad <see cref="P:System.Windows.Forms.Control.Top" /> del control.</param>
        <param name="width">Nuevo valor de la propiedad <see cref="P:System.Windows.Forms.Control.Width" /> del control.</param>
        <param name="height">No usado.</param>
        <param name="specified">Combinación bit a bit de los valores de <see cref="T:System.Windows.Forms.BoundsSpecified" />.</param>
        <summary>Establece los límites especificados del control <see cref="T:System.Windows.Forms.TextBoxBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.TextBoxBase> control usa la <xref:System.Windows.Forms.TextBoxBase.PreferredHeight%2A> propiedad para establecer los límites si el <xref:System.Windows.Forms.TextBoxBase.AutoSize%2A> propiedad es `true` y <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> propiedad es `false`.  
  
 Normalmente, los parámetros que se corresponden con los límites no incluidos en el `specified` parámetro se pasan con sus valores actuales. Por ejemplo, el <xref:System.Windows.Forms.Control.Height%2A>, <xref:System.Windows.Forms.Control.Width%2A>, o la <xref:System.Drawing.Point.X%2A> o <xref:System.Drawing.Point.Y%2A> propiedades de la <xref:System.Windows.Forms.Control.Location%2A> propiedad se puede pasar con una referencia a la instancia actual del control. Sin embargo se garantizan todos los valores pasados en y se aplica al control.  
  
 El `specified` parámetro representa los elementos de los controles <xref:System.Windows.Forms.Control.Bounds%2A> modificados por la aplicación. Por ejemplo, si cambia la <xref:System.Windows.Forms.Control.Size%2A> del control, el `specified` valor del parámetro es el `Size` valo <xref:System.Windows.Forms.BoundsSpecified>. Sin embargo, si la <xref:System.Windows.Forms.Control.Size%2A> se ajusta en respuesta a la <xref:System.Windows.Forms.Control.Dock%2A> propiedad se ha establecido, el `specified` valor del parámetro es el `None` valo <xref:System.Windows.Forms.BoundsSpecified>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.Forms.TextBoxBase.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.TextBoxBase.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> método para forzar los límites del control que se va a cambiar. Las clases derivadas pueden agregar restricciones de tamaño para el <see cref="M:System.Windows.Forms.TextBoxBase.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ShortcutsEnabled">
      <MemberSignature Language="C#" Value="public virtual bool ShortcutsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShortcutsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.ShortcutsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ShortcutsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ShortcutsEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si están habilitados los accesos directos definidos.</summary>
        <value>
          <see langword="true" /> para habilitar los accesos directos; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Windows.Forms.TextBoxBase.ShortcutsEnabled%2A> propiedad para habilitar o deshabilitar las siguientes combinaciones de teclas de método abreviado y menú contextual del control:  
  
-   CTRL+Z  
  
-   CTRL+E  
  
-   CTRL+C  
  
-   CTRL+Y  
  
-   CTRL+X  
  
-   CTRL+RETROCESO  
  
-   CTRL+V  
  
-   CTRL+SUPR  
  
-   CTRL+A  
  
-   MAYÚS + SUPR  
  
-   CTRL+L  
  
-   MAYÚS + INSERT  
  
-   CTRL+R  
  
 Puede invalidar esta propiedad para especificar otras teclas de método abreviado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.MultilineStringEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el texto actual del cuadro de texto.</summary>
        <value>Texto que se muestra en el control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para mostrar varias líneas de texto en un cuadro de texto, establezca la <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> propiedad `true`. Para leer o establecer el texto de un cuadro de texto multilínea, utilice la <xref:System.Windows.Forms.TextBoxBase.Lines%2A> propiedad. La cantidad de texto que puede escribirse en el <xref:System.Windows.Forms.RichTextBox> control está limitado únicamente por la memoria disponible del sistema.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada, para crear una propiedad de multilínea <xref:System.Windows.Forms.TextBox> control con barras de desplazamiento vertical. Este ejemplo también utiliza el <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>, <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>, y <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> propiedades para hacer que el control de cuadro de texto multilínea sea útil para crear documentos de texto.  
  
 [!code-cpp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Lines" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="TextLength">
      <MemberSignature Language="C#" Value="public virtual int TextLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TextLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.TextLength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TextLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int TextLength { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la longitud del texto en el control.</summary>
        <value>Número de caracteres contenidos en el texto del control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede utilizar esta propiedad para determinar el número de caracteres de una cadena para tareas como la búsqueda de cadenas específicas del texto en el texto del control, que es necesario conocer el número total de caracteres.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Windows.Forms.TextBoxBase.AppendText%2A> método y <xref:System.Windows.Forms.TextBoxBase.TextLength%2A> propiedad que se va a copiar el texto de una <xref:System.Windows.Forms.TextBox> a otro. Este ejemplo requiere que dos <xref:System.Windows.Forms.TextBox> controles denominados, `textBox1` y `textBox2`, se agregaron a un formulario y que `textBox1` tiene texto asignado a su <xref:System.Windows.Forms.Control.Text%2A> propiedad.  
  
 [!code-cpp[TextBoxBase.AppendText#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TextBoxBase.AppendText/CPP/form1.cpp#1)]
 [!code-csharp[TextBoxBase.AppendText#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TextBoxBase.AppendText/CS/form1.cs#1)]
 [!code-vb[TextBoxBase.AppendText#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TextBoxBase.AppendText/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una cadena que representa el control <see cref="T:System.Windows.Forms.TextBoxBase" />.</summary>
        <returns>Cadena que representa el objeto <see cref="T:System.Windows.Forms.TextBoxBase" /> actual. La cadena incluye el tipo y la propiedad <see cref="T:System.Windows.Forms.TextBoxBase" /> del control.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Undo">
      <MemberSignature Language="C#" Value="public void Undo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Undo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Undo" />
      <MemberSignature Language="VB.NET" Value="Public Sub Undo ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Undo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deshace la última operación de edición del cuadro de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método deshará la última **Portapapeles** operación realizada en el control de cuadro de texto si cambio de texto o la <xref:System.Windows.Forms.TextBoxBase.CanUndo%2A> propiedad devuelve `true`.  
  
> [!NOTE]
>  El <xref:System.Windows.Forms.TextBoxBase.Undo%2A> método no funciona con la <xref:System.Windows.Forms.Control.KeyPress> o <xref:System.Windows.Forms.Control.TextChanged> eventos.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada. Proporciona <xref:System.Windows.Forms.MenuItem.Click> controladores de eventos para <xref:System.Windows.Forms.MenuItem> objetos que llevan a cabo cortar, copiar, pegar y deshacer operaciones. Este ejemplo requiere que un <xref:System.Windows.Forms.TextBox> control denominado `textBox1` se ha creado.  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Cut" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.CanUndo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Clear" />
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">
          <see cref="T:System.Windows.Forms.Message" /> de Windows que se va a procesar.</param>
        <summary>Procesa los mensajes de Windows.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="WordWrap">
      <MemberSignature Language="C#" Value="public bool WordWrap { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WordWrap" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.WordWrap" />
      <MemberSignature Language="VB.NET" Value="Public Property WordWrap As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WordWrap { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica si un control de cuadro de texto multilínea ajusta las palabras de forma automática al principio de la línea siguiente cuando es necesario.</summary>
        <value>
          <see langword="true" /> si el control de cuadro de texto multilínea ajusta palabras; <see langword="false" /> si el control de cuadro de texto se desplaza horizontalmente de forma automática cuando el usuario escribe más allá del borde derecho del control. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si esta propiedad se establece en `true`, no se muestran barras de desplazamiento horizontal con independencia de la <xref:System.Windows.Forms.TextBox.ScrollBars%2A> configuración de la propiedad.  
  
> [!NOTE]
>  En la clase derivada, <xref:System.Windows.Forms.TextBox>, texto dentro del control siempre se ajustará independientemente de la configuración de esta propiedad, a menos que la <xref:System.Windows.Forms.TextBox.TextAlign%2A> propiedad está establecida en `HorizontalAlignment.Left`.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Windows.Forms.TextBox>, una clase derivada, para crear una propiedad de multilínea <xref:System.Windows.Forms.TextBox> control con barras de desplazamiento vertical. Este ejemplo también utiliza el <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>, <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>, y <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> propiedades para hacer que el control de cuadro de texto multilínea sea útil para crear documentos de texto.  
  
 [!code-cpp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>