<Type Name="ContainerControl" FullName="System.Windows.Forms.ContainerControl">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5896f22eee2fe1c471aebd93babef34af8ab2c94" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56369059" /></Metadata><TypeSignature Language="C#" Value="public class ContainerControl : System.Windows.Forms.ScrollableControl, System.Windows.Forms.IContainerControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ContainerControl extends System.Windows.Forms.ScrollableControl implements class System.Windows.Forms.IContainerControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="VB.NET" Value="Public Class ContainerControl&#xA;Inherits ScrollableControl&#xA;Implements IContainerControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContainerControl : System::Windows::Forms::ScrollableControl, System::Windows::Forms::IContainerControl" />
  <TypeSignature Language="F#" Value="type ContainerControl = class&#xA;    inherit ScrollableControl&#xA;    interface IContainerControl" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.ScrollableControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Forms.IContainerControl</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona funcionalidad de administración de foco para controles que pueden funcionar como contenedores de otros controles.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Forms.ContainerControl> representa un control que puede funcionar como un contenedor para otros controles y proporciona administración del foco. Los controles que heredan de esta clase pueden realizar un seguimiento del control activo que contienen, incluso cuando el foco se mueve en algún lugar dentro de un contenedor diferente.  
  
 <xref:System.Windows.Forms.ContainerControl> los objetos proporcionan un límite lógico para los controles contenidos. El control contenedor puede capturar la pulsación de tecla de PESTAÑA y mover el foco al siguiente control en la colección.  
  
> [!NOTE]
>  El control contenedor no recibe el foco; el foco siempre se establece en el primer control secundario de la colección de controles contenidos.  
  
 Normalmente, no se hereda directamente desde el <xref:System.Windows.Forms.ContainerControl> clase. <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.UserControl>, y <xref:System.Windows.Forms.UpDownBase> clases heredan de <xref:System.Windows.Forms.ContainerControl>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.Form" />
    <altmember cref="T:System.Windows.Forms.UserControl" />
    <altmember cref="T:System.Windows.Forms.UpDownBase" />
    <altmember cref="T:System.Windows.Forms.IContainerControl" />
    <altmember cref="T:System.Windows.Forms.ScrollableControl" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContainerControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContainerControl();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Forms.ContainerControl" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código se hereda de la <xref:System.Windows.Forms.ScrollableControl> clase e implementa el <xref:System.Windows.Forms.IContainerControl> interfaz. Se agrega a la implementación del <xref:System.Windows.Forms.IContainerControl.ActiveControl%2A> propiedad y el <xref:System.Windows.Forms.IContainerControl.ActivateControl%2A> método.  
  
 [!code-cpp[IContainerControl Implementation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/IContainerControl Implementation/CPP/mycontainercontrol.cpp#1)]
 [!code-csharp[IContainerControl Implementation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/IContainerControl Implementation/CS/mycontainercontrol.cs#1)]
 [!code-vb[IContainerControl Implementation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/IContainerControl Implementation/VB/mycontainercontrol.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control ActiveControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control ActiveControl" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.ActiveControl" />
      <MemberSignature Language="VB.NET" Value="Public Property ActiveControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ ActiveControl { System::Windows::Forms::Control ^ get(); void set(System::Windows::Forms::Control ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActiveControl : System.Windows.Forms.Control with get, set" Usage="System.Windows.Forms.ContainerControl.ActiveControl" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IContainerControl.ActiveControl</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el control activo en el control contenedor.</summary>
        <value><see cref="T:System.Windows.Forms.Control" /> que está activo actualmente en <see cref="T:System.Windows.Forms.ContainerControl" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> propiedad activa o recupera el control activo en el control contenedor.  
  
 Con el fin de recibir un valor válido de esta propiedad, el objeto que lo llama debe contener o incluirse en el control al que llama. Si un formulario intenta llamar a otro formulario <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> propiedades, recibirá un valor indefinido. En este caso, deberá definir su propio mecanismo de comunicación entre los formularios para pasar estos datos.  
  
   
  
## Examples  
 El siguiente ejemplo de código se hereda de la <xref:System.Windows.Forms.ScrollableControl> clase e implementa el <xref:System.Windows.Forms.IContainerControl> interfaz. Se agrega a la implementación del <xref:System.Windows.Forms.IContainerControl.ActiveControl%2A> propiedad y el <xref:System.Windows.Forms.IContainerControl.ActivateControl%2A> método.  
  
 [!code-cpp[IContainerControl Implementation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/IContainerControl Implementation/CPP/mycontainercontrol.cpp#1)]
 [!code-csharp[IContainerControl Implementation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/IContainerControl Implementation/CS/mycontainercontrol.cs#1)]
 [!code-vb[IContainerControl Implementation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/IContainerControl Implementation/VB/mycontainercontrol.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No se pudo activar el objeto <see cref="T:System.Windows.Forms.Control" /> asignado.</exception>
        <altmember cref="T:System.Windows.Forms.ScrollableControl" />
        <altmember cref="T:System.Windows.Forms.Control" />
      </Docs>
    </Member>
    <Member MemberName="AdjustFormScrollbars">
      <MemberSignature Language="C#" Value="protected override void AdjustFormScrollbars (bool displayScrollbars);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void AdjustFormScrollbars(bool displayScrollbars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.AdjustFormScrollbars(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub AdjustFormScrollbars (displayScrollbars As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void AdjustFormScrollbars(bool displayScrollbars);" />
      <MemberSignature Language="F#" Value="override this.AdjustFormScrollbars : bool -&gt; unit" Usage="containerControl.AdjustFormScrollbars displayScrollbars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="displayScrollbars" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="displayScrollbars"><see langword="true" /> para mostrar las barras de desplazamiento; de lo contrario, <see langword="false" />.</param>
        <summary>Ajusta las barras de desplazamiento del contenedor en función de las posiciones actuales de los controles y del control que está seleccionado.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ScrollableControl.AdjustFormScrollbars(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="AutoScaleDimensions">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF AutoScaleDimensions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.SizeF AutoScaleDimensions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.AutoScaleDimensions" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoScaleDimensions As SizeF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::SizeF AutoScaleDimensions { System::Drawing::SizeF get(); void set(System::Drawing::SizeF value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScaleDimensions : System.Drawing.SizeF with get, set" Usage="System.Windows.Forms.ContainerControl.AutoScaleDimensions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece las dimensiones a las que se diseñó el control.</summary>
        <value><see cref="T:System.Drawing.SizeF" /> que contiene los puntos por pulgada o (PPP) tamaño <see cref="T:System.Drawing.Font" /> al que se diseñó el control.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A> propiedad representa la configuración de PPP o la fuente de la pantalla que se escala el control o diseñado para. En concreto, en el diseño de esta propiedad se establecerá el Diseñador de Windows Forms en el valor del monitor de tiempo está usando actualmente. A continuación, cuando se carga el formulario en tiempo de ejecución si el <xref:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions%2A> propiedad es diferente de la <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A>, el <xref:System.Windows.Forms.ContainerControl.PerformAutoScale%2A> método se llamará para realizar la escala del control y todos sus elementos secundarios. Después, <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A> se actualizará para reflejar el nuevo tamaño de escala.  
  
 Para obtener más información sobre el escalado automático, consulte [el escalado automático en Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El ancho o alto del valor <see cref="T:System.Drawing.SizeF" /> es menor que 0 al establecer este valor.</exception>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleFactor" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.PerformAutoScale" />
      </Docs>
    </Member>
    <Member MemberName="AutoScaleFactor">
      <MemberSignature Language="C#" Value="protected System.Drawing.SizeF AutoScaleFactor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.SizeF AutoScaleFactor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.AutoScaleFactor" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property AutoScaleFactor As SizeF" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Drawing::SizeF AutoScaleFactor { System::Drawing::SizeF get(); };" />
      <MemberSignature Language="F#" Value="member this.AutoScaleFactor : System.Drawing.SizeF" Usage="System.Windows.Forms.ContainerControl.AutoScaleFactor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el factor de escala entre las dimensiones de la escala automática actual y en tiempo de diseño.</summary>
        <value><see cref="T:System.Drawing.SizeF" /> que contiene la proporción de escala entre las dimensiones de escala automática actual y en tiempo de diseño.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.ContainerControl.AutoScaleFactor%2A> propiedad representa el factor de escala entre las <xref:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions%2A> y <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A> propiedades. Este valor se calcula cuando sea necesario. Por ejemplo, si <xref:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions%2A> es (192, 144) y <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A> es (96, 96) el <xref:System.Windows.Forms.ContainerControl.AutoScaleFactor%2A> es (2.0, 1.5).  
  
 Para obtener más información sobre el escalado automático, consulte [el escalado automático en Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleDimensions" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.PerformAutoScale" />
      </Docs>
    </Member>
    <Member MemberName="AutoScaleMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoScaleMode AutoScaleMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoScaleMode AutoScaleMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoScaleMode As AutoScaleMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AutoScaleMode AutoScaleMode { System::Windows::Forms::AutoScaleMode get(); void set(System::Windows::Forms::AutoScaleMode value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScaleMode : System.Windows.Forms.AutoScaleMode with get, set" Usage="System.Windows.Forms.ContainerControl.AutoScaleMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoScaleMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el modo de escala automática del control.</summary>
        <value><see cref="T:System.Windows.Forms.AutoScaleMode" /> que representa el modo de escala actual. De manera predeterminada, es <see cref="F:System.Windows.Forms.AutoScaleMode.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A> propiedad especifica el modo de escala automática actual de este control. Escalado mediante <xref:System.Windows.Forms.AutoScaleMode.Font> es útil si desea tener un control o formulario ampliará o reducirá según el tamaño de las fuentes en el sistema operativo y debe usarse cuando no importa el tamaño absoluto del control o formulario. Escalado mediante <xref:System.Windows.Forms.AutoScaleMode.Dpi> resulta útil cuando desea cambiar el tamaño de un control o formulario respecto a la pantalla. Por ejemplo, desea utilizar puntos por pulgada (PPP) el escalado en un control que muestra un gráfico u otro gráfico para que siempre ocupe un porcentaje determinado de la pantalla.  
  
 Para obtener más información sobre el escalado automático, consulte [el escalado automático en Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Para establecer esta propiedad se utilizó un valor <see cref="T:System.Windows.Forms.AutoScaleMode" /> no válido.</exception>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleFactor" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleDimensions" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.PerformAutoScale" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidate">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AutoValidate AutoValidate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoValidate AutoValidate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.AutoValidate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoValidate As AutoValidate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AutoValidate AutoValidate { System::Windows::Forms::AutoValidate get(); void set(System::Windows::Forms::AutoValidate value); };" />
      <MemberSignature Language="F#" Value="member this.AutoValidate : System.Windows.Forms.AutoValidate with get, set" Usage="System.Windows.Forms.ContainerControl.AutoValidate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoValidate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si los controles de este contenedor se validarán automáticamente al cambiar el foco.</summary>
        <value>Un valor <see cref="T:System.Windows.Forms.AutoValidate" /> enumerado que indica si los controles incluidos se validan implícitamente al cambiar el foco. De manera predeterminada, es <see cref="F:System.Windows.Forms.AutoValidate.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor predeterminado de <xref:System.Windows.Forms.ContainerControl.AutoValidate%2A> será diferente para cada control. Para obtener más información sobre la validación implícita, vea [User Input Validation in Windows Forms](~/docs/framework/winforms/user-input-validation-in-windows-forms.md).  
  
 Establecer esta propiedad en un nuevo valor, se producirá la <xref:System.Windows.Forms.ContainerControl.AutoValidateChanged> eventos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se desactiva la validación implícita de un formulario y todos sus controles independientes y en su lugar, realiza manualmente la validación de todos los elementos secundarios del formulario cuando se hace clic en un botón del mouse.  
  
 [!code-csharp[ValidateChildren#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ValidateChildren/CS/Form1.cs#1)]
 [!code-vb[ValidateChildren#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ValidateChildren/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Para establecer esta propiedad se utilizó un valor <see cref="T:System.Windows.Forms.AutoValidate" /> no válido.</exception>
        <altmember cref="T:System.Windows.Forms.AutoValidate" />
        <altmember cref="Overload:System.Windows.Forms.ContainerControl.Validate" />
        <altmember cref="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoValidateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoValidateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoValidateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoValidateChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoValidateChanged : EventHandler " Usage="member this.AutoValidateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia la propiedad <see cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 <xref:System.Windows.Forms.ContainerControl.AutoValidate%2A>  
  
 <xref:System.Windows.Forms.ContainerControl.OnAutoValidateChanged%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingContext">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.BindingContext BindingContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingContext BindingContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.BindingContext" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BindingContext As BindingContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::BindingContext ^ BindingContext { System::Windows::Forms::BindingContext ^ get(); void set(System::Windows::Forms::BindingContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingContext : System.Windows.Forms.BindingContext with get, set" Usage="System.Windows.Forms.ContainerControl.BindingContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la plantilla <see cref="T:System.Windows.Forms.BindingContext" /> para el control.</summary>
        <value><see cref="T:System.Windows.Forms.BindingContext" /> del control.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.BindingContext" />
      </Docs>
    </Member>
    <Member MemberName="CanEnableIme">
      <MemberSignature Language="C#" Value="protected override bool CanEnableIme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnableIme" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.CanEnableIme" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CanEnableIme As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanEnableIme { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanEnableIme : bool" Usage="System.Windows.Forms.ContainerControl.CanEnableIme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la propiedad <see cref="P:System.Windows.Forms.Control.ImeMode" /> puede establecerse en un valor activo para habilitar la compatibilidad con el IME.</summary>
        <value><see langword="false" /> en todos los casos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En el [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] y versiones posteriores, funcionalidad IME se controla mediante el marco de trabajo y se deshabilita la compatibilidad nativa con el IME para controles individuales.  
  
 Un control de usuario que se deriva el <xref:System.Windows.Forms.ContainerControl> clase puede habilitar la compatibilidad nativa con el IME mediante la invalidación de esta propiedad para devolver `true`. Sin embargo, la aplicación, a continuación, es responsabilidad suya asegurarse de que no hay ningún conflicto entre el IME nativo y el IME de Windows Forms. No se admite este escenario.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.ContainerControl.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los parámetros de creación necesarios cuando se crea el identificador del control.</summary>
        <value><see cref="T:System.Windows.Forms.CreateParams" /> que contiene los parámetros de creación necesarios cuando se crea el identificador del control.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentAutoScaleDimensions">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF CurrentAutoScaleDimensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.SizeF CurrentAutoScaleDimensions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentAutoScaleDimensions As SizeF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::SizeF CurrentAutoScaleDimensions { System::Drawing::SizeF get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentAutoScaleDimensions : System.Drawing.SizeF" Usage="System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene las dimensiones en tiempo de ejecución actuales de la pantalla.</summary>
        <value><see cref="T:System.Drawing.SizeF" /> que contiene los puntos por pulgada (PPP) o el tamaño de <see cref="T:System.Drawing.Font" /> actuales de la pantalla.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions%2A> propiedad representa las dimensiones de referencia en la pantalla actual. En cambio, el <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A> propiedad representa las dimensiones de referencia en tiempo de diseño del entorno de diseño para el control actual, mientras que el <xref:System.Windows.Forms.ContainerControl.AutoScaleFactor%2A> propiedad es la proporción de los dos.  
  
 La interpretación del valor de dimensión depende el <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A> propiedad de las maneras siguientes:  
  
-   Si el modo es <xref:System.Windows.Forms.AutoScaleMode.Dpi>, esta propiedad representa la resolución de la pantalla, en puntos por pulgada.  
  
-   Si el modo es <xref:System.Windows.Forms.AutoScaleMode.Font>, esta propiedad representa el tamaño de fuente medio carácter en píxeles.  
  
 Si el <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A> propiedad está establecida en <xref:System.Windows.Forms.AutoScaleMode.None>, <xref:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions%2A> está establecida en <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A>.  
  
 Para obtener más información sobre el escalado automático, consulte [el escalado automático en Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">No se pudo crear un contexto de dispositivo de Win32 para la pantalla actual.</exception>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleFactor" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleDimensions" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.PerformAutoScale" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="containerControl.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados que utilizan <see cref="T:System.Windows.Forms.Control" /> y sus controles secundarios, además de liberar los recursos administrados de forma opcional.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="OnAutoValidateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAutoValidateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAutoValidateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.OnAutoValidateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAutoValidateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAutoValidateChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAutoValidateChanged : EventArgs -&gt; unit&#xA;override this.OnAutoValidateChanged : EventArgs -&gt; unit" Usage="containerControl.OnAutoValidateChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.ContainerControl.OnAutoValidateChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see cref="M:System.Windows.Forms.ContainerControl.OnAutoValidateChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.ContainerControl.OnAutoValidateChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para></block>
        <altmember cref="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />
        <altmember cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected override void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnCreateControl();" />
      <MemberSignature Language="F#" Value="override this.OnCreateControl : unit -&gt; unit" Usage="containerControl.OnCreateControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provoca el método <see cref="M:System.Windows.Forms.Control.CreateControl" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCreateControl" />
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnFontChanged : EventArgs -&gt; unit" Usage="containerControl.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.FontChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cambiar la fuente utilizada por un <xref:System.Windows.Forms.ContainerControl> hará que el diseño se vuelven a calcular y se vuelve a aplicar a los controles contenidos si el <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A> propiedad tiene un valor de <xref:System.Windows.Forms.AutoScaleMode.Font>.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.ContainerControl.OnFontChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see cref="M:System.Windows.Forms.ContainerControl.OnFontChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Forms.ContainerControl.OnFontChanged(System.EventArgs)" /> método para que los delegados registrados reciban el evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected override void OnLayout (System.Windows.Forms.LayoutEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLayout (e As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLayout(System::Windows::Forms::LayoutEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit" Usage="containerControl.OnLayout e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.LayoutEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.Layout" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnParentChanged">
      <MemberSignature Language="C#" Value="protected override void OnParentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnParentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.OnParentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnParentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnParentChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnParentChanged : EventArgs -&gt; unit" Usage="containerControl.OnParentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.Control.ParentChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ParentForm">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form ParentForm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form ParentForm" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.ParentForm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentForm As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ ParentForm { System::Windows::Forms::Form ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentForm : System.Windows.Forms.Form" Usage="System.Windows.Forms.ContainerControl.ParentForm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el formulario al que está asignado el control contenedor.</summary>
        <value><see cref="T:System.Windows.Forms.Form" /> al que está asignado el control contenedor. Esta propiedad devolverá null si el control se hospeda en Internet Explorer o en otro contexto de hospedaje donde no hay ningún formulario primario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente muestra cómo crear dos formularios: `Form1` y `Form2`. Establecer el <xref:System.Windows.Forms.Form.IsMdiContainer%2A> propiedad de `Form1` a `true` y dele el <xref:System.Windows.Forms.Form.MdiParent%2A> de `Form2`. A continuación, cree un botón, `button1`, en cada formulario. Cuando se hace clic en el botón en el formulario principal, el controlador de eventos muestra el formulario secundario. Cuando se hace clic en el botón en el formulario secundario, el controlador de eventos muestra la <xref:System.Windows.Forms.Control.Name%2A> propiedad de su formulario principal. Use los siguientes segmentos de código de dos para sobrescribir `button1` controladores de eventos en ambos formatos.  
  
 [!code-cpp[ParentForm2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentForm2/CPP/form1.cpp#1)]
 [!code-csharp[ParentForm2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentForm2/CS/form1.cs#1)]
 [!code-vb[ParentForm2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentForm2/VB/form1.vb#1)]  
  
 [!code-cpp[ParentForm2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentForm2/CPP/form2.cpp#2)]
 [!code-csharp[ParentForm2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentForm2/CS/form2.cs#2)]
 [!code-vb[ParentForm2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentForm2/VB/form2.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas las ventanas obtener este valor de propiedad. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="PerformAutoScale">
      <MemberSignature Language="C#" Value="public void PerformAutoScale ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformAutoScale() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.PerformAutoScale" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformAutoScale ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformAutoScale();" />
      <MemberSignature Language="F#" Value="member this.PerformAutoScale : unit -&gt; unit" Usage="containerControl.PerformAutoScale " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Escala el control contenedor y sus elementos secundarios.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada explícita a la <xref:System.Windows.Forms.ContainerControl.PerformAutoScale%2A> método normalmente es necesario solo después de realizar cambios mediante programación al diseño del tiempo de ejecución. <xref:System.Windows.Forms.ContainerControl.PerformAutoScale%2A> se llama implícitamente desde el <xref:System.Windows.Forms.ContainerControl.OnLayout%2A> método.  
  
 <xref:System.Windows.Forms.ContainerControl.PerformAutoScale%2A> es recursivo; cada control secundario, si es un contenedor, tendrá su versión de este método que se llama cuando se ejecuta la versión del contenedor.  
  
 Para obtener más información sobre el escalado automático, consulte [el escalado automático en Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AutoScale" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleFactor" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="containerControl.ProcessCmdKey (msg, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg"><see cref="T:System.Windows.Forms.Message" /> que se pasa por referencia y que representa el mensaje de ventana que se va a procesar.</param>
        <param name="keyData">Uno de los valores de <see cref="T:System.Windows.Forms.Keys" /> que representa la tecla que se va a procesar.</param>
        <summary>Procesa una tecla de comando.</summary>
        <returns><see langword="true" /> si el control procesó el carácter; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogChar(char charCode);" />
      <MemberSignature Language="F#" Value="override this.ProcessDialogChar : char -&gt; bool" Usage="containerControl.ProcessDialogChar charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Carácter que se va a procesar.</param>
        <summary>Procesa un carácter de diálogo.</summary>
        <returns><see langword="true" /> si el control procesó el carácter; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool" Usage="containerControl.ProcessDialogKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Uno de los valores de <see cref="T:System.Windows.Forms.Keys" /> que representa la tecla que se va a procesar.</param>
        <summary>Procesa una tecla de diálogo.</summary>
        <returns><see langword="true" /> si el control procesó la tecla; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal override bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function ProcessMnemonic (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override bool ProcessMnemonic(char charCode);" />
      <MemberSignature Language="F#" Value="override this.ProcessMnemonic : char -&gt; bool" Usage="containerControl.ProcessMnemonic charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Carácter que se va a procesar.</param>
        <summary>Procesa un carácter de tecla de acceso.</summary>
        <returns><see langword="true" /> si el control procesó el carácter como carácter de tecla de acceso; de lo contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessTabKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessTabKey (bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessTabKey(bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ProcessTabKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessTabKey (forward As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessTabKey(bool forward);" />
      <MemberSignature Language="F#" Value="abstract member ProcessTabKey : bool -&gt; bool&#xA;override this.ProcessTabKey : bool -&gt; bool" Usage="containerControl.ProcessTabKey forward" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forward"><see langword="true" /> para avanzar por los controles de <see cref="T:System.Windows.Forms.ContainerControl" />; en caso contrario, <see langword="false" />.</param>
        <summary>Selecciona el siguiente control disponible y lo convierte en el control activo.</summary>
        <returns><see langword="true" /> si se selecciona un control; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un control con su <xref:System.Windows.Forms.Control.TabStop%2A> propiedad establecida en `false` no se pueden seleccionar, por lo que se seleccionará el siguiente control disponible.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected override void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Select(bool directed, bool forward);" />
      <MemberSignature Language="F#" Value="override this.Select : bool * bool -&gt; unit" Usage="containerControl.Select (directed, forward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed"><see langword="true" /> para especificar la dirección del control que se va a seleccionar; en caso contrario, <see langword="false" />.</param>
        <param name="forward">Es <see langword="true" /> para moverse hacia delante en el orden de tabulación; es <see langword="false" /> para moverse hacia atrás en el orden de tabulación.</param>
        <summary>Activa un control secundario. Opcionalmente, especifica la dirección en que se seleccionará el control en el orden de tabulación.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select(System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IContainerControl.ActivateControl">
      <MemberSignature Language="C#" Value="bool IContainerControl.ActivateControl (System.Windows.Forms.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Forms.IContainerControl.ActivateControl(class System.Windows.Forms.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.System#Windows#Forms#IContainerControl#ActivateControl(System.Windows.Forms.Control)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Forms.IContainerControl.ActivateControl(System::Windows::Forms::Control ^ control) = System::Windows::Forms::IContainerControl::ActivateControl;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IContainerControl.ActivateControl(System.Windows.Forms.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="control"><see cref="T:System.Windows.Forms.Control" /> que se va a activar.</param>
        <summary>Activa el control especificado.</summary>
        <returns><see langword="true" /> si el control se activa correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `control` parámetro debe ser un elemento secundario del control contenedor.  
  
   
  
## Examples  
 El código siguiente muestra cómo heredar de la <xref:System.Windows.Forms.ScrollableControl> clase e implemente el <xref:System.Windows.Forms.IContainerControl> interfaz. Se agrega a la implementación del <xref:System.Windows.Forms.IContainerControl.ActiveControl%2A> propiedad y el <xref:System.Windows.Forms.IContainerControl.ActivateControl%2A> método.  
  
 [!code-cpp[IContainerControl Implementation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/IContainerControl Implementation/CPP/mycontainercontrol.cpp#1)]
 [!code-csharp[IContainerControl Implementation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/IContainerControl Implementation/CS/mycontainercontrol.cs#1)]
 [!code-vb[IContainerControl Implementation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/IContainerControl Implementation/VB/mycontainercontrol.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultButton">
      <MemberSignature Language="C#" Value="protected virtual void UpdateDefaultButton ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void UpdateDefaultButton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.UpdateDefaultButton" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub UpdateDefaultButton ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void UpdateDefaultButton();" />
      <MemberSignature Language="F#" Value="abstract member UpdateDefaultButton : unit -&gt; unit&#xA;override this.UpdateDefaultButton : unit -&gt; unit" Usage="containerControl.UpdateDefaultButton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando lo reemplaza una clase derivada, se actualiza cuál es el botón predeterminado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.ContainerControl> clase no proporciona una implementación para el <xref:System.Windows.Forms.ContainerControl.UpdateDefaultButton%2A> método. Deben implementar las clases que heredan este método <xref:System.Windows.Forms.ContainerControl.UpdateDefaultButton%2A> para actualizar el botón predeterminado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comprueba el valor del control que ha perdido el foco haciendo que los eventos <see cref="E:System.Windows.Forms.Control.Validating" /> y <see cref="E:System.Windows.Forms.Control.Validated" /> se produzcan, en ese orden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public bool Validate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Validate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.Validate" />
      <MemberSignature Language="VB.NET" Value="Public Function Validate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Validate();" />
      <MemberSignature Language="F#" Value="member this.Validate : unit -&gt; bool" Usage="containerControl.Validate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comprueba el valor del control que ha perdido el foco haciendo que los eventos <see cref="E:System.Windows.Forms.Control.Validating" /> y <see cref="E:System.Windows.Forms.Control.Validated" /> se produzcan, en ese orden.</summary>
        <returns><see langword="true" /> si la validación es correcta; en caso contrario, <see langword="false" />. Si se llama desde los controladores de eventos <see cref="E:System.Windows.Forms.Control.Validating" /> o <see cref="E:System.Windows.Forms.Control.Validated" />, este método siempre devolverá <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.ContainerControl.Validate%2A> método valida el último control secundario que no se valida y los antecesores hasta, pero no incluir el control contenedor actual. Esta versión sobrecargada siempre realiza la validación, independientemente del valor de la <xref:System.Windows.Forms.ContainerControl.AutoValidate%2A> propiedad del elemento primario del control. Por lo tanto, usarla para forzar la validación incondicionalmente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />
        <altmember cref="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public bool Validate (bool checkAutoValidate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Validate(bool checkAutoValidate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.Validate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Validate (checkAutoValidate As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Validate(bool checkAutoValidate);" />
      <MemberSignature Language="F#" Value="member this.Validate : bool -&gt; bool" Usage="containerControl.Validate checkAutoValidate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkAutoValidate" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="checkAutoValidate">Si <see langword="true" />, el valor de la propiedad <see cref="P:System.Windows.Forms.ContainerControl.AutoValidate" /> se usa para determinar si se debería realizar la validación; si <see langword="false" />, se realiza la validación incondicionalmente.</param>
        <summary>Comprueba el valor del control que está perdiendo el foco; dependiente condicionalmente de si se activa la validación automática.</summary>
        <returns><see langword="true" /> si la validación es correcta; en caso contrario, <see langword="false" />. Si se llama desde los controladores de eventos <see cref="E:System.Windows.Forms.Control.Validating" /> o <see cref="E:System.Windows.Forms.Control.Validated" />, este método siempre devolverá <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.ContainerControl.Validate%2A> método valida el último control secundario que no se valida y los antecesores hasta, pero no incluir el control contenedor actual. Esta versión sobrecargada realiza la validación según las condiciones siguientes:  
  
-   Si el `checkAutoValidate` parámetro es `true`, validación siempre se produce para los controles secundarios que no se validan.  
  
-   Si el `checkAutoValidate` parámetro es `false`, la validación se produce solo si el <xref:System.Windows.Forms.ContainerControl.AutoValidate%2A> está habilitada la propiedad del elemento primario del control.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateChildren">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Hace que todos los controles secundarios de un control que admiten validación validen sus datos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public virtual bool ValidateChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ValidateChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ValidateChildren" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateChildren () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ValidateChildren();" />
      <MemberSignature Language="F#" Value="abstract member ValidateChildren : unit -&gt; bool&#xA;override this.ValidateChildren : unit -&gt; bool" Usage="containerControl.ValidateChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hace que todos los controles secundarios de un control que admiten validación validen sus datos.</summary>
        <returns><see langword="true" /> si todos los elementos secundarios se validan correctamente; de lo contrario, <see langword="false" />. Si se llama desde los controladores de eventos <see cref="E:System.Windows.Forms.Control.Validating" /> o <see cref="E:System.Windows.Forms.Control.Validated" />, este método siempre devolverá <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> se desciende en una jerarquía de control y examine cada control para ver si admite la validación. Si el usuario puede seleccionar el control y su <xref:System.Windows.Forms.Control.CausesValidation%2A> propiedad es `true`, <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> hará que el <xref:System.Windows.Forms.Control.Validating> eventos que se produzca. Si cualquiera de los controles cancelar el <xref:System.Windows.Forms.Control.Validating> evento, este método devolverá `false`; en caso contrario, devolverá `true`.  
  
 Si un control se enlaza a un origen de datos y el <xref:System.Windows.Forms.Control.Validating> evento tiene lugar, hará que el control va a devolver los datos actuales al origen de datos.  
  
 Una llamada a <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> equivale a llamar a <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> con un <xref:System.Windows.Forms.ValidationConstraints> de <xref:System.Windows.Forms.ValidationConstraints.None>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se desactiva la validación implícita de un formulario y todos sus controles independientes y en su lugar, realiza manualmente la validación de todos los elementos secundarios del formulario cuando se hace clic en un botón del mouse.  
  
 [!code-csharp[ValidateChildren#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ValidateChildren/CS/Form1.cs#1)]
 [!code-vb[ValidateChildren#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ValidateChildren/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public virtual bool ValidateChildren (System.Windows.Forms.ValidationConstraints validationConstraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ValidateChildren(valuetype System.Windows.Forms.ValidationConstraints validationConstraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ValidateChildren(System::Windows::Forms::ValidationConstraints validationConstraints);" />
      <MemberSignature Language="F#" Value="abstract member ValidateChildren : System.Windows.Forms.ValidationConstraints -&gt; bool&#xA;override this.ValidateChildren : System.Windows.Forms.ValidationConstraints -&gt; bool" Usage="containerControl.ValidateChildren validationConstraints" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationConstraints" Type="System.Windows.Forms.ValidationConstraints" />
      </Parameters>
      <Docs>
        <param name="validationConstraints">Especifica restricciones referentes a los controles para los que se genera el evento <see cref="E:System.Windows.Forms.Control.Validating" />.</param>
        <summary>Hace que todos los controles secundarios de un control que admiten validación validen sus datos.</summary>
        <returns><see langword="true" /> si todos los elementos secundarios se validan correctamente; de lo contrario, <see langword="false" />. Si se llama desde los controladores de eventos <see cref="E:System.Windows.Forms.Control.Validating" /> o <see cref="E:System.Windows.Forms.Control.Validated" />, este método siempre devolverá <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> examinará todos los elementos secundarios del control actual, provocando la <xref:System.Windows.Forms.Control.Validating> eventos que se produzca en un control si cumple los criterios especificados por <xref:System.Windows.Forms.ValidationConstraints>.  
  
 Se pueden usar varios <xref:System.Windows.Forms.ValidationConstraints> parámetros a la vez mediante la combinación de ellos con un operador OR bit a bit. Combinación de parámetros con un operador OR bit a bit dará como resultado una operación AND lógica. Por ejemplo, al llamar a `ValidateChildren(ValidationConstraints.ImmediateChildren | ValidationConstraints.Enabled)` solo generará el <xref:System.Windows.Forms.Control.Validating> eventos de los controles que son elementos secundarios inmediatos del contenedor y están habilitadas.  
  
 Independientemente de los parámetros especificados para este método, debe tener un control de su <xref:System.Windows.Forms.Control.CausesValidation%2A> propiedad establecida en `true` en orden para su <xref:System.Windows.Forms.Control.Validating> eventos que se produzca. También debe establecer el <xref:System.Windows.Forms.ContainerControl.AutoValidate%2A> propiedad del control o del contenedor del control a `false` si desea que ocurra sólo cuando se llama a la validación <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A>, y no cuando el usuario desplace el foco del control.  
  
 Si un control se enlaza a un origen de datos y el <xref:System.Windows.Forms.Control.Validating> evento tiene lugar, hará que el control va a devolver los datos actuales al origen de datos.  
  
 No se puede lograr el efecto contrario de una <xref:System.Windows.Forms.ValidationConstraints> parámetro aplicando un operador de negación bit a bit. Por ejemplo, si proporciona el valor negativo de la <xref:System.Windows.Forms.ValidationConstraints.Visible> campo <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A>, no validará los elementos secundarios que no son visibles en el contenedor. Proporcionar cualquier parámetro negativo a <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> no tendrán ningún efecto en el contenedor o sus elementos secundarios.  
  
   
  
## Examples  
 El ejemplo de código siguiente hará que solo el <xref:System.Windows.Forms.Control.Validating> que se produce en los elementos secundarios inmediatos del formulario cuya propiedad <xref:System.Windows.Forms.Control.Enabled%2A> propiedad es `true`.  
  
 [!code-csharp[ValidateChildrenWithConstraints#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ValidateChildrenWithConstraints/CS/Form1.cs#1)]
 [!code-vb[ValidateChildrenWithConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ValidateChildrenWithConstraints/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="containerControl.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m"><see cref="T:System.Windows.Forms.Message" /> de Windows que se va a procesar.</param>
        <summary>Procesa los mensajes de Windows.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>