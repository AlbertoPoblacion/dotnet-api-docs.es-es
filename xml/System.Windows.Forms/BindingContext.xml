<Type Name="BindingContext" FullName="System.Windows.Forms.BindingContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="526cff7ecf243e6e07c759eea454ee6d774a2040" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55390899" /></Metadata><TypeSignature Language="C#" Value="public class BindingContext : System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BindingContext extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.BindingContext" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingContext&#xA;Implements ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingContext : System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type BindingContext = class&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("CollectionChanged")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Administra la colección de objetos <see cref="T:System.Windows.Forms.BindingManagerBase" /> para cualquier objeto que herede de la clase <see cref="T:System.Windows.Forms.Control" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada formulario de Windows tiene al menos una <xref:System.Windows.Forms.BindingContext> objeto que administra el <xref:System.Windows.Forms.BindingManagerBase> objetos para el formulario. Porque el <xref:System.Windows.Forms.BindingManagerBase> clase es abstracta, el tipo de valor devuelto de la <xref:System.Windows.Forms.BindingContext.Item%2A> propiedad sea un <xref:System.Windows.Forms.CurrencyManager> o <xref:System.Windows.Forms.PropertyManager>. Si el origen de datos es un objeto que puede devolver una sola propiedad (en lugar de una lista de objetos), el <xref:System.Type> es un <xref:System.Windows.Forms.PropertyManager>. Por ejemplo, si especifica un <xref:System.Windows.Forms.TextBox> como origen de datos, un <xref:System.Windows.Forms.PropertyManager> se devuelve. Por otro lado, si el origen de datos es un objeto que implementa <xref:System.Collections.IList> o <xref:System.ComponentModel.IBindingList>, un <xref:System.Windows.Forms.CurrencyManager> se devuelve.  
  
 Para cada origen de datos en un formulario de Windows, hay una sola <xref:System.Windows.Forms.CurrencyManager> o <xref:System.Windows.Forms.PropertyManager>. Dado que puede haber varios orígenes de datos asociados a un formulario de Windows, el <xref:System.Windows.Forms.BindingContext> le permite recuperar un determinado <xref:System.Windows.Forms.CurrencyManager> asociado con un origen de datos.  
  
> [!NOTE]
>  Cuando se usa el <xref:System.Windows.Forms.BindingContext.Item%2A> propiedad, el <xref:System.Windows.Forms.BindingContext> crea un nuevo <xref:System.Windows.Forms.BindingManagerBase> si aún no existe. Esto puede provocar cierta confusión, como el objeto devuelto no puede administrar la lista (o cualquier lista) que desea. Para impedir que se devuelva un no válido <xref:System.Windows.Forms.BindingManagerBase>, utilice el <xref:System.Windows.Forms.BindingContext.Contains%2A> método para determinar si el destino <xref:System.Windows.Forms.BindingManagerBase> ya existe.  
  
 Si usa un control contenedor, como un <xref:System.Windows.Forms.GroupBox>, <xref:System.Windows.Forms.Panel>, o <xref:System.Windows.Forms.TabControl>, para contener los controles enlazados a datos, puede crear un <xref:System.Windows.Forms.BindingContext> sólo para ese control contenedor y sus controles. A continuación, cada parte del formulario se puede administrar mediante su propia <xref:System.Windows.Forms.BindingManagerBase>. Consulte la <xref:System.Windows.Forms.BindingContext.%23ctor%2A> constructor para obtener más información acerca de cómo crear varios <xref:System.Windows.Forms.BindingManagerBase> objetos para el mismo origen de datos.  
  
 Si agrega un <xref:System.Windows.Forms.TextBox> control a un formulario y un enlace a una columna de una tabla en un conjunto de datos, el control se comunica con el <xref:System.Windows.Forms.BindingContext> de ese formulario. El <xref:System.Windows.Forms.BindingContext>, en cambio, habla con específico del <xref:System.Windows.Forms.CurrencyManager> para esa asociación de datos. Si ha consultado el `Position` propiedad de la <xref:System.Windows.Forms.CurrencyManager>, se informará de que el registro actual para el enlace de ese <xref:System.Windows.Forms.TextBox> control. En el ejemplo de código siguiente, un <xref:System.Windows.Forms.TextBox> está enlazado el `FirstName` columna de un `Customers` de tabla en el `dataSet1` conjunto de datos a través de la <xref:System.Windows.Forms.BindingContext> para el formulario está en.  
  
```vb  
TextBox1.DataBindings.Add("Text", dataSet1, "Customers.FirstName")  
  
```  
  
```csharp  
textBox1.DataBindings.Add("Text", dataSet1, "Customers.FirstName");  
  
```  
  
```cpp  
textBox1->DataBindings->Add("Text", dataSet1, "Customers.FirstName");  
```  
  
 Puede agregar un segundo <xref:System.Windows.Forms.TextBox> control (`TextBox2`) al formulario y enlazarlo a la `LastName` columna de la `Customers` tabla en el mismo conjunto de datos. El <xref:System.Windows.Forms.BindingContext> es consciente del primer enlace (`TextBox1` a `Customers.FirstName`), por lo que usaría el mismo <xref:System.Windows.Forms.CurrencyManager>, ya que ambos cuadros de texto están enlazados al mismo conjunto de datos (`DataSet1`).  
  
```vb  
TextBox2.DataBindings.Add("Text", dataSet1, "Customers.LastName")  
  
```  
  
```csharp  
textBox2.DataBindings.Add("Text", dataSet1, "Customers.LastName");  
  
```  
  
```cpp  
textBox2->DataBindings->Add("Text", dataSet1, "Customers.LastName");  
```  
  
 Si enlaza `TextBox2` a otro conjunto de datos, el <xref:System.Windows.Forms.BindingContext> crea y administra un segundo <xref:System.Windows.Forms.CurrencyManager>.  
  
 Es importante ser coherente sobre cómo establecer el <xref:System.Windows.Forms.ListControl.DataSource%2A> y <xref:System.Windows.Forms.ListControl.DisplayMember%2A> propiedades; de lo contrario, el <xref:System.Windows.Forms.BindingContext> crea moneda varios administradores para el mismo conjunto de datos, lo que produce errores. El ejemplo de código siguiente muestra algunos ejemplos de cómo establecer las propiedades y sus asociados <xref:System.Windows.Forms.BindingContext> objetos. Puede establecer las propiedades mediante cualquiera de los métodos siguientes, siempre que sean coherentes en todo el código.  
  
```vb  
ComboBox1.DataSource = DataSet1  
ComboBox1.DisplayMember = "Customers.FirstName"  
Me.BindingContext(dataSet1, "Customers").Position = 1  
  
```  
  
```csharp  
comboBox1.DataSource = DataSet1;  
comboBox1.DisplayMember = "Customers.FirstName";  
this.BindingContext[dataSet1, "Customers"].Position = 1;  
  
```  
  
```cpp  
comboBox1->DataSource = dataSet1;  
comboBox1->DisplayMember = "Customers.FirstName";  
this->BindingContext->get_Item(dataSet1, "Customers")->Position = 1;  
  
```  
  
```vb  
ComboBox1.DataSource = DataSet1.Customers  
ComboBox1.DisplayMember = "FirstName"  
Me.BindingContext(dataSet1.Customers).Position = 1  
  
```  
  
```csharp  
comboBox1.DataSource = DataSet1.Customers;  
comboBox1.DisplayMember = "FirstName";  
this.BindingContext[dataSet1.Customers].Position = 1;  
  
```  
  
```cpp  
comboBox1->DataSource = dataSet1->Customers;  
comboBox1->DisplayMember = "FirstName";  
this->BindingContext->get_Item(dataSet1->Customers)->Position = 1;  
  
```  
  
> [!NOTE]
>  La mayoría de las aplicaciones de Windows Forms se enlazan mediante un <xref:System.Windows.Forms.BindingSource>. El <xref:System.Windows.Forms.BindingSource> componente encapsula una <xref:System.Windows.Forms.CurrencyManager> y expone el <xref:System.Windows.Forms.CurrencyManager> interfaz de programación. Cuando se usa un <xref:System.Windows.Forms.BindingSource> para el enlace, debe usar los miembros expuestos por el <xref:System.Windows.Forms.BindingSource> para manipular "moneda" (es decir, `Position`) en lugar de recorrer el <xref:System.Windows.Forms.BindingContext>.  
  
   
  
## Examples  
 El ejemplo de código siguiente crea cuatro <xref:System.Windows.Forms.Binding> objetos que se va a enlazar los cinco controles: un <xref:System.Windows.Forms.DateTimePicker> y cuatro <xref:System.Windows.Forms.TextBox> controles - a varios orígenes de datos. El <xref:System.Windows.Forms.BindingContext> , a continuación, se utiliza para obtener el <xref:System.Windows.Forms.BindingManagerBase> para cada origen de datos.  
  
 [!code-cpp[Classic BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
    <altmember cref="T:System.Windows.Forms.Binding" />
    <altmember cref="T:System.Windows.Forms.BindingsCollection" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Forms.BindingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si desea tener varios <xref:System.Windows.Forms.BindingManagerBase> instancias del mismo origen de datos, cree un nuevo <xref:System.Windows.Forms.BindingContext> y establézcalo como el <xref:System.Windows.Forms.Control.BindingContext%2A> propiedad de un objeto que hereda de la <xref:System.Windows.Forms.Control> clase. Por ejemplo, si tiene dos <xref:System.Windows.Forms.BindingManagerBase> objetos (de dos diferentes <xref:System.Windows.Forms.BindingContext> objetos), puede establecer el <xref:System.Windows.Forms.BindingManagerBase.Position%2A> propiedades de cada <xref:System.Windows.Forms.BindingManagerBase> en valores diferentes. Esto hace que cada conjunto de controles enlazados a datos para mostrar valores diferentes del mismo origen de datos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea dos nuevas <xref:System.Windows.Forms.BindingContext> objetos y asigna cada objeto a la <xref:System.Windows.Forms.BindingContext> propiedad de un <xref:System.Windows.Forms.GroupBox> control. `GroupBox1` contiene `TextBox1`, y `GroupBox2` contiene `TextBox2` (que se logra mediante el <xref:System.Windows.Forms.Control.ControlCollection.AddRange%2A> método de la <xref:System.Windows.Forms.Control.ControlCollection> clase). En el ejemplo, a continuación, agrega <xref:System.Windows.Forms.Binding> objetos a los dos <xref:System.Windows.Forms.TextBox> controles, enlace cada uno para el mismo miembro de datos y el origen de datos. El ejemplo también muestra dos controladores de eventos que usan el <xref:System.Windows.Forms.BindingContext> desde el <xref:System.Windows.Forms.GroupBox> controles para establecer el <xref:System.Windows.Forms.BindingManagerBase.Position%2A> propiedad en diferentes <xref:System.Windows.Forms.BindingManagerBase> objetos.  
  
 [!code-cpp[Classic BindingContext.BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="protected internal void Add (object dataSource, System.Windows.Forms.BindingManagerBase listManager);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Add(object dataSource, class System.Windows.Forms.BindingManagerBase listManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Add(System.Object,System.Windows.Forms.BindingManagerBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Add (dataSource As Object, listManager As BindingManagerBase)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Add(System::Object ^ dataSource, System::Windows::Forms::BindingManagerBase ^ listManager);" />
      <MemberSignature Language="F#" Value="member this.Add : obj * System.Windows.Forms.BindingManagerBase -&gt; unit" Usage="bindingContext.Add (dataSource, listManager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="listManager" Type="System.Windows.Forms.BindingManagerBase" />
      </Parameters>
      <Docs>
        <param name="dataSource">Objeto <see cref="T:System.Object" /> asociado a <see cref="T:System.Windows.Forms.BindingManagerBase" />.</param>
        <param name="listManager"><see cref="T:System.Windows.Forms.BindingManagerBase" /> que se va a agregar.</param>
        <summary>Agrega a la colección el objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> asociado a un origen de datos específico.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCore">
      <MemberSignature Language="C#" Value="protected virtual void AddCore (object dataSource, System.Windows.Forms.BindingManagerBase listManager);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddCore(object dataSource, class System.Windows.Forms.BindingManagerBase listManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.AddCore(System.Object,System.Windows.Forms.BindingManagerBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddCore (dataSource As Object, listManager As BindingManagerBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddCore(System::Object ^ dataSource, System::Windows::Forms::BindingManagerBase ^ listManager);" />
      <MemberSignature Language="F#" Value="abstract member AddCore : obj * System.Windows.Forms.BindingManagerBase -&gt; unit&#xA;override this.AddCore : obj * System.Windows.Forms.BindingManagerBase -&gt; unit" Usage="bindingContext.AddCore (dataSource, listManager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="listManager" Type="System.Windows.Forms.BindingManagerBase" />
      </Parameters>
      <Docs>
        <param name="dataSource">Objeto asociado al objeto <see cref="T:System.Windows.Forms.BindingManagerBase" />.</param>
        <param name="listManager"><see cref="T:System.Windows.Forms.BindingManagerBase" /> que se va a agregar.</param>
        <summary>Agrega a la colección el objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> asociado a un origen de datos específico.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSource" /> es <see langword="null" />.  
  
O bien 
 <paramref name="listManager" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="protected internal void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Clear" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="bindingContext.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra cualquier objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> de la colección.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearCore">
      <MemberSignature Language="C#" Value="protected virtual void ClearCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ClearCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.ClearCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ClearCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ClearCore();" />
      <MemberSignature Language="F#" Value="abstract member ClearCore : unit -&gt; unit&#xA;override this.ClearCore : unit -&gt; unit" Usage="bindingContext.ClearCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra la colección.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CollectionChangeEventHandler CollectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CollectionChangeEventHandler CollectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingContext.CollectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CollectionChanged As CollectionChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CollectionChangeEventHandler ^ CollectionChanged;" />
      <MemberSignature Language="F#" Value="member this.CollectionChanged : System.ComponentModel.CollectionChangeEventHandler " Usage="member this.CollectionChanged : System.ComponentModel.CollectionChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CollectionChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Siempre provoca <see cref="T:System.NotImplementedException" /> cuando se controla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingContext.CollectionChanged> evento está obsoleto y siempre provoca una <xref:System.NotImplementedException> cuando controla. Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Se produce en todos los casos.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un valor que indica si la colección <see cref="T:System.Windows.Forms.BindingContext" /> contiene el objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object dataSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(object dataSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (dataSource As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Object ^ dataSource);" />
      <MemberSignature Language="F#" Value="member this.Contains : obj -&gt; bool" Usage="bindingContext.Contains dataSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource"><see cref="T:System.Object" /> que representa el origen de datos.</param>
        <summary>Obtiene un valor que indica si <see cref="T:System.Windows.Forms.BindingContext" /> contiene el objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> asociado al origen de datos especificado.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Windows.Forms.BindingContext" /> contiene el objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> especificado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consulte la <xref:System.Windows.Forms.Binding> clase para obtener una lista de posibles orígenes de datos e información sobre la creación de enlaces entre los controles y orígenes de datos.  
  
 Consulte la <xref:System.Windows.Forms.BindingContext.Item%2A> propiedad para obtener información sobre cómo devolver un <xref:System.Windows.Forms.BindingManagerBase> con solo un origen de datos.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.BindingContext.Contains%2A> método para determinar si un <xref:System.Windows.Forms.BindingManagerBase> existe para cada control en un formulario. En el ejemplo se pasa cada <xref:System.Data.DataTable> en un <xref:System.Data.DataSet> al método.  
  
 [!code-cpp[Classic BindingContext.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingContext.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object dataSource, string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(object dataSource, string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Contains(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (dataSource As Object, dataMember As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Object ^ dataSource, System::String ^ dataMember);" />
      <MemberSignature Language="F#" Value="member this.Contains : obj * string -&gt; bool" Usage="bindingContext.Contains (dataSource, dataMember)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource"><see cref="T:System.Object" /> que representa el origen de datos.</param>
        <param name="dataMember">Información necesaria para resolver un objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> específico.</param>
        <summary>Obtiene un valor que indica si <see cref="T:System.Windows.Forms.BindingContext" /> contiene el objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> asociado al origen de datos y miembro de datos especificados.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Windows.Forms.BindingContext" /> contiene el objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> especificado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consulte la <xref:System.Windows.Forms.Binding> (clase) para obtener una lista de posibles orígenes de datos y para obtener información acerca de cómo crear enlaces entre los controles y orígenes de datos.  
  
 Consulte la <xref:System.Windows.Forms.BindingContext.Item%2A> propiedad para obtener información sobre cómo devolver un <xref:System.Windows.Forms.BindingManagerBase> con un origen de datos y un miembro de datos.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.BindingContext.Contains%2A> método para comprobar si un determinado <xref:System.Windows.Forms.BindingManagerBase> existe antes de intentar obtenerla a través de la <xref:System.Windows.Forms.BindingContext.Item%2A> propiedad.  
  
 [!code-cpp[Classic BindingContext.Contains1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.Contains1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.Contains1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.Contains1 Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.Contains1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.Contains1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingContext.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Windows.Forms.BindingContext.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la colección es de solo lectura.</summary>
        <value><see langword="true" /> si la colección es de solo lectura; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se deriva de <xref:System.Collections.ICollection> y se reemplaza para que devuelva siempre `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un <see cref="T:System.Windows.Forms.BindingManagerBase" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BindingManagerBase this[object dataSource] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingManagerBase Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(dataSource As Object) As BindingManagerBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BindingManagerBase ^ default[System::Object ^] { System::Windows::Forms::BindingManagerBase ^ get(System::Object ^ dataSource); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : System.Windows.Forms.BindingManagerBase" Usage="System.Windows.Forms.BindingContext.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingManagerBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Origen de datos asociado a un objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> determinado.</param>
        <summary>Obtiene el objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> asociado al origen de datos especificado.</summary>
        <value>Objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> del origen de datos especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga si el <xref:System.Windows.Forms.BindingManagerBase> desea no requiere una ruta de navegación. Por ejemplo, si la <xref:System.Windows.Forms.BindingManagerBase> administra un conjunto de <xref:System.Windows.Forms.Binding> los objetos que utilizan un <xref:System.Collections.ArrayList> o <xref:System.Data.DataTable> como el <xref:System.Windows.Forms.Binding.DataSource%2A>, se requiere ninguna ruta de navegación.  
  
> [!NOTE]
>  El <xref:System.Windows.Forms.BindingContext.Item%2A> propiedad siempre devolverá un <xref:System.Windows.Forms.BindingManagerBase>y nunca devuelven `null`.  
  
 Consulte la <xref:System.Windows.Forms.Binding> (clase) para obtener una lista de posibles orígenes de datos y para obtener información acerca de cómo crear enlaces entre los controles y orígenes de datos.  
  
   
  
## Examples  
 El ejemplo de código siguiente devuelve tres <xref:System.Windows.Forms.BindingManagerBase> objetos: uno para un <xref:System.Data.DataView>, uno para un <xref:System.Collections.ArrayList>y otro para el <xref:System.Windows.Forms.Binding.DataSource%2A> de un <xref:System.Windows.Forms.Binding> que pertenece a un <xref:System.Windows.Forms.TextBox> control.  
  
 [!code-cpp[Classic BindingContext.this Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.this Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.this Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.this Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.this Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.this Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingsCollection" />
        <altmember cref="T:System.Windows.Forms.Binding" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BindingManagerBase this[object dataSource, string dataMember] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingManagerBase Item(object, string)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.Item(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(dataSource As Object, dataMember As String) As BindingManagerBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BindingManagerBase ^ default[System::Object ^, System::String ^] { System::Windows::Forms::BindingManagerBase ^ get(System::Object ^ dataSource, System::String ^ dataMember); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj * string) : System.Windows.Forms.BindingManagerBase" Usage="System.Windows.Forms.BindingContext.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingManagerBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource">Origen de datos asociado a un objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> determinado.</param>
        <param name="dataMember">Ruta de navegación que contiene la información que se resuelve en un objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> específico.</param>
        <summary>Obtiene un objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> asociado al origen de datos y miembro de datos especificados.</summary>
        <value>Objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> para el origen de datos y miembro de datos especificados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga cuando la <xref:System.Windows.Forms.BindingManagerBase> administra un conjunto de <xref:System.Windows.Forms.Binding> objetos para el que el origen de datos contiene varios objetos. Por ejemplo, un <xref:System.Data.DataSet> puede contener varios <xref:System.Data.DataTable> objetos vinculados por <xref:System.Data.DataRelation> objetos. En tal caso, se requiere la ruta de navegación para habilitar el <xref:System.Windows.Forms.BindingContext> para devolver el valor correcto <xref:System.Windows.Forms.BindingManagerBase>.  
  
> [!NOTE]
>  El <xref:System.Windows.Forms.BindingContext.Item%2A> propiedad siempre devolverá un <xref:System.Windows.Forms.BindingManagerBase>, cuando el `dataMember` parámetro es válido. Nunca devolverá `null`.  
  
 Consulte la <xref:System.Windows.Forms.Binding> (clase) para obtener una lista de posibles orígenes de datos y para obtener información acerca de cómo crear enlaces entre los controles y orígenes de datos.  
  
 Si desea <xref:System.Windows.Forms.BindingManagerBase> administra una lista, la ruta de navegación también debe terminar con una lista. Por ejemplo, el código de C# siguiente se enlaza un <xref:System.Windows.Forms.TextBox> control a la fecha de pedido en una tabla de pedidos. La ruta de navegación incluye el <xref:System.Data.DataTable.TableName%2A>, el <xref:System.Data.DataRelation.RelationName%2A>y el <xref:System.Data.DataColumn.ColumnName%2A>. Sin embargo, el <xref:System.Windows.Forms.BindingManagerBase> se deben recuperar usando sólo el <xref:System.Data.DataTable.TableName%2A> y <xref:System.Data.DataRelation.RelationName%2A> (que se resuelve en una lista).  
  
```  
// The navigation path for a Binding ends with a property.  
textBox1.DataBindings.Add  
("Text", dataSet1, "Customers.custToOrders.OrderDate");  
// The navigation path for the BindingManagerBase ends with a list.  
BindingManagerBase bmOrders = this.BindingContext  
[dataSet1, "Customers.custToOrders"];  
```  
  
 Al devolver un <xref:System.Windows.Forms.BindingManagerBase>, debe usar el mismo origen de datos que la <xref:System.Windows.Forms.Binding> y modificar solo la ruta de navegación.  
  
 Use la <xref:System.Windows.Forms.BindingContext.Contains%2A> método para determinar si desea <xref:System.Windows.Forms.BindingManagerBase> ya existe.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Windows.Forms.BindingContext.Item%2A> para recuperar el <xref:System.Windows.Forms.BindingManagerBase> para un enlace determinado. También muestra cómo controlar el <xref:System.Windows.Forms.BindingManagerBase.BindingComplete> eventos para el <xref:System.Windows.Forms.BindingManagerBase> para garantizar que varios controles enlazados al mismo origen de datos permanezcan sincronizados cuando cambia uno de los valores del control. Para ejecutar este ejemplo, pegue el código en un formulario de Windows y llamar a la `InitializeControlsAndData` método desde el constructor del formulario o <xref:System.Windows.Forms.Form.Load> el método de control de eventos.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMultipleControls#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMultipleControls/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.BindingSourceMultipleControls#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMultipleControls/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">El elemento <paramref name="dataMember" /> especificado no existe dentro del origen de datos.</exception>
        <altmember cref="T:System.Windows.Forms.BindingsCollection" />
        <altmember cref="T:System.Windows.Forms.Binding" />
      </Docs>
    </Member>
    <Member MemberName="OnCollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCollectionChanged (System.ComponentModel.CollectionChangeEventArgs ccevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCollectionChanged(class System.ComponentModel.CollectionChangeEventArgs ccevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.OnCollectionChanged(System.ComponentModel.CollectionChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCollectionChanged (ccevent As CollectionChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCollectionChanged(System::ComponentModel::CollectionChangeEventArgs ^ ccevent);" />
      <MemberSignature Language="F#" Value="abstract member OnCollectionChanged : System.ComponentModel.CollectionChangeEventArgs -&gt; unit&#xA;override this.OnCollectionChanged : System.ComponentModel.CollectionChangeEventArgs -&gt; unit" Usage="bindingContext.OnCollectionChanged ccevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ccevent" Type="System.ComponentModel.CollectionChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="ccevent">Objeto <see cref="T:System.ComponentModel.CollectionChangeEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.BindingContext.CollectionChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.BindingContext.OnCollectionChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Al reemplazar <see cref="M:System.Windows.Forms.BindingContext.OnCollectionChanged(System.ComponentModel.CollectionChangeEventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.Windows.Forms.BindingContext.OnCollectionChanged(System.ComponentModel.CollectionChangeEventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected internal void Remove (object dataSource);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Remove(object dataSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Remove (dataSource As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Remove(System::Object ^ dataSource);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="bindingContext.Remove dataSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Origen de datos asociado al objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> que se va a quitar.</param>
        <summary>Elimina el objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> asociado al origen de datos especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveCore">
      <MemberSignature Language="C#" Value="protected virtual void RemoveCore (object dataSource);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RemoveCore(object dataSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.RemoveCore(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RemoveCore (dataSource As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RemoveCore(System::Object ^ dataSource);" />
      <MemberSignature Language="F#" Value="abstract member RemoveCore : obj -&gt; unit&#xA;override this.RemoveCore : obj -&gt; unit" Usage="bindingContext.RemoveCore dataSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Origen de datos asociado al objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> que se va a quitar.</param>
        <summary>Quita el objeto <see cref="T:System.Windows.Forms.BindingManagerBase" /> asociado al origen de datos especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array ar, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array ar, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (ar As Array, index As Integer) Implements ICollection.CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ ar, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ar" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ar">Objeto <see cref="T:System.Array" /> en el que se va a copiar.</param>
        <param name="index">Índice de la colección donde se va a empezar a copiar.</param>
        <summary>Copia los elementos de la colección en la matriz especificada, empezando por el índice de la colección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[Classic BindingContext.ICollection.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.ICollection.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.ICollection.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.ICollection.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.ICollection.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.ICollection.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número total de objetos <see cref="T:System.Windows.Forms.CurrencyManager" /> de la colección administrados por <see cref="T:System.Windows.Forms.BindingContext" />.</summary>
        <value>Número de orígenes de datos administrados por <see cref="T:System.Windows.Forms.BindingContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se devuelve el número de <xref:System.Windows.Forms.CurrencyManager> objetos administrados por el <xref:System.Windows.Forms.BindingContext>.  
  
 [!code-cpp[Classic BindingContext.ICollection.Count Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.ICollection.Count Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.ICollection.Count Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.ICollection.Count Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.ICollection.Count Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.ICollection.Count Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la colección está sincronizada.</summary>
        <value>Es <see langword="true" /> si la colección es segura para la ejecución de subprocesos; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se deriva de <xref:System.Collections.ICollection> y se reemplaza para que devuelva siempre `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que se utiliza para la sincronización (seguridad para la ejecución de subprocesos).</summary>
        <value>Esta propiedad se deriva de <see cref="T:System.Collections.ICollection" /> y se reemplaza para que devuelva siempre <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un enumerador para la colección.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> para la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.IEnumerator> devuelto por la <xref:System.Windows.Forms.BindingContext.System%23Collections%23IEnumerable%23GetEnumerator%2A> método le permite recorrer en iteración la colección administrada por el <xref:System.Windows.Forms.BindingContext>.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Windows.Forms.BindingContext.System%23Collections%23IEnumerable%23GetEnumerator%2A> método devuelva un <xref:System.Collections.IEnumerator> para el <xref:System.Windows.Forms.BindingContext>.  
  
 [!code-cpp[Classic BindingContext.IEnumerable.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.IEnumerable.GetEnumerator Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.IEnumerable.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.IEnumerable.GetEnumerator Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.IEnumerable.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.IEnumerable.GetEnumerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateBinding">
      <MemberSignature Language="C#" Value="public static void UpdateBinding (System.Windows.Forms.BindingContext newBindingContext, System.Windows.Forms.Binding binding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UpdateBinding(class System.Windows.Forms.BindingContext newBindingContext, class System.Windows.Forms.Binding binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.UpdateBinding(System.Windows.Forms.BindingContext,System.Windows.Forms.Binding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UpdateBinding(System::Windows::Forms::BindingContext ^ newBindingContext, System::Windows::Forms::Binding ^ binding);" />
      <MemberSignature Language="F#" Value="static member UpdateBinding : System.Windows.Forms.BindingContext * System.Windows.Forms.Binding -&gt; unit" Usage="System.Windows.Forms.BindingContext.UpdateBinding (newBindingContext, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBindingContext" Type="System.Windows.Forms.BindingContext" />
        <Parameter Name="binding" Type="System.Windows.Forms.Binding" />
      </Parameters>
      <Docs>
        <param name="newBindingContext">Nuevo objeto <see cref="T:System.Windows.Forms.BindingContext" /> que se va a asociar a <see cref="T:System.Windows.Forms.Binding" />.</param>
        <param name="binding">Clase <see cref="T:System.Windows.Forms.Binding" /> que se va a asociar al nuevo objeto <see cref="T:System.Windows.Forms.BindingContext" />.</param>
        <summary>Asocia una clase <see cref="T:System.Windows.Forms.Binding" /> a un nuevo objeto <see cref="T:System.Windows.Forms.BindingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método está diseñado para actualizar los enlaces de componentes que implementan <xref:System.Windows.Forms.IBindableComponent>, cuando su <xref:System.Windows.Forms.BindingContext> cambios.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>