<Type Name="BindingSource" FullName="System.Windows.Forms.BindingSource">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="37807cf706cb60b2fcaf0a83cdb1e84a812e7777" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30641049" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BindingSource : System.ComponentModel.Component, System.Collections.IList, System.ComponentModel.IBindingList, System.ComponentModel.IBindingListView, System.ComponentModel.ICancelAddNew, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.ComponentModel.ITypedList, System.Windows.Forms.ICurrencyManagerProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BindingSource extends System.ComponentModel.Component implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.ComponentModel.IBindingList, class System.ComponentModel.IBindingListView, class System.ComponentModel.ICancelAddNew, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.ComponentModel.ITypedList, class System.Windows.Forms.ICurrencyManagerProvider" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.BindingSource" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingSource&#xA;Inherits Component&#xA;Implements IBindingList, IBindingListView, ICancelAddNew, ICurrencyManagerProvider, IList, ISupportInitialize, ISupportInitializeNotification, ITypedList" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingSource : System::ComponentModel::Component, System::Collections::IList, System::ComponentModel::IBindingList, System::ComponentModel::IBindingListView, System::ComponentModel::ICancelAddNew, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::ComponentModel::ITypedList, System::Windows::Forms::ICurrencyManagerProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IBindingList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IBindingListView</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ICancelAddNew</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ITypedList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.ICurrencyManagerProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.ComplexBindingProperties("DataSource", "DataMember")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("CurrentChanged")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("DataSource")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.BindingSourceDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsula el origen de datos de un formulario.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource> componente sirve para muchos propósitos. En primer lugar, simplifica el enlace de controles en un formulario a los datos proporcionando la gestión de divisas, notificación de cambio y otros servicios entre los controles de formularios Windows Forms y orígenes de datos. Esto se consigue mediante la asociación del <xref:System.Windows.Forms.BindingSource> componente para el origen de datos utilizando el <xref:System.Windows.Forms.BindingSource.DataSource%2A> propiedad. Para los escenarios de enlace complejo, opcionalmente, puede establecer el <xref:System.Windows.Forms.BindingSource.DataMember%2A> propiedad para una columna específica o una lista en el origen de datos. A continuación, enlazar controles a la <xref:System.Windows.Forms.BindingSource>. Toda interacción posterior con los datos se logra con llamadas a la <xref:System.Windows.Forms.BindingSource> componente. Para obtener ejemplos sobre cómo las <xref:System.Windows.Forms.BindingSource> puede simplificar el proceso de enlace, vea [Cómo: enlazar controles de Windows Forms a valores de base de datos DBNull](~/docs/framework/winforms/controls/how-to-bind-windows-forms-controls-to-dbnull-database-values.md) y [Cómo: controlar errores y excepciones que se producen con el enlace de datos](~/docs/framework/winforms/controls/how-to-handle-errors-and-exceptions-that-occur-with-databinding.md). Navegación y la actualización del origen de datos se realiza a través de métodos como <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveLast%2A>, y <xref:System.Windows.Forms.BindingSource.Remove%2A>. Las operaciones como la ordenación y filtrado se controlan a través de la <xref:System.Windows.Forms.BindingSource.Sort%2A> y <xref:System.Windows.Forms.BindingSource.Filter%2A> propiedades. Para obtener más información sobre el uso de ordenación y filtrado con el <xref:System.Windows.Forms.BindingSource>, consulte [Cómo: ordenar y filtrar los datos de ADO.NET con el componente BindingSource de formularios Windows Forms](~/docs/framework/winforms/controls/sort-and-filter-ado-net-data-with-wf-bindingsource-component.md).  
  
 Además, la <xref:System.Windows.Forms.BindingSource> componente puede actuar como un origen de datos fuertemente tipados. Normalmente, el tipo de origen de datos subyacente es fijo a través de uno de los siguientes mecanismos:  
  
-   Use la <xref:System.Windows.Forms.BindingSource.Add%2A> método para agregar un elemento a la <xref:System.Windows.Forms.BindingSource> componente.  
  
-   Establecer el <xref:System.Windows.Forms.BindingSource.DataSource%2A> propiedad a una lista, un solo objeto o un tipo.  
  
 Ambos de estos mecanismos crean una lista fuertemente tipada. Para obtener más información sobre cómo usar el <xref:System.Windows.Forms.BindingSource> para enlazar a un tipo, consulte [Cómo: enlazar un Control de Windows Forms a un tipo](~/docs/framework/winforms/controls/how-to-bind-a-windows-forms-control-to-a-type.md). También puede usar el <xref:System.Windows.Forms.BindingSource> para enlazar los controles a un objeto de fábrica. Para obtener más información sobre cómo hacerlo, consulte [Cómo: enlazar un Control de Windows Forms a un objeto Factory](~/docs/framework/winforms/controls/how-to-bind-a-windows-forms-control-to-a-factory-object.md).  
  
> [!NOTE]
>  Dado que un <xref:System.Windows.Forms.BindingSource> identificadores de los orígenes de datos simples y complejas, terminología es problemático. En esta documentación de clase, el término *lista* hace referencia a una colección de datos en el origen de datos hospedado y *elemento* denota un único elemento. Al explicar la funcionalidad asociada con orígenes de datos complejos, los términos equivalentes *tabla* y *fila* se usan.  
  
 <xref:System.Windows.Forms.BindingSource> proporciona a miembros para tener acceso a los datos subyacentes. El elemento actual se puede recuperar a través de la <xref:System.Windows.Forms.BindingSource.Current%2A> propiedad y toda la lista se pueden recuperar mediante el <xref:System.Windows.Forms.BindingSource.List%2A> propiedad. Se admiten operaciones de edición en el elemento actual a través de <xref:System.Windows.Forms.BindingSource.Current%2A> y <xref:System.Windows.Forms.BindingSource.RemoveCurrent%2A>, <xref:System.Windows.Forms.BindingSource.EndEdit%2A>, <xref:System.Windows.Forms.BindingSource.CancelEdit%2A> y <xref:System.Windows.Forms.BindingSource.Add%2A> y <xref:System.Windows.Forms.BindingSource.AddNew%2A> métodos. Aunque la administración de moneda se controla automáticamente para todos los tipos de orígenes de datos subyacentes, esta clase expone una serie de eventos, como <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> y <xref:System.Windows.Forms.BindingSource.DataSourceChanged>, que permiten la personalización.  
  
 Orígenes de datos que están enlazados a un <xref:System.Windows.Forms.BindingSource> componente también se abrirá y administrado con el <xref:System.Windows.Forms.BindingNavigator> (clase), que proporciona una interfaz de usuario de tipo VCR (UI) para navegar por los elementos de una lista. Aunque <xref:System.Windows.Forms.BindingNavigator> se puede enlazar a cualquier origen de datos, se ha diseñado para integrarse con una <xref:System.Windows.Forms.BindingSource> componente a través de su <xref:System.Windows.Forms.BindingNavigator.BindingSource%2A?displayProperty=nameWithType> propiedad.  
  
 La propiedad predeterminada para el <xref:System.Windows.Forms.BindingSource> clase es <xref:System.Windows.Forms.BindingSource.DataSource%2A>. El evento predeterminado es <xref:System.Windows.Forms.BindingSource.CurrentChanged>.  
  
> [!CAUTION]
>  Muchos de los miembros de la <xref:System.Windows.Forms.BindingSource> clase operan en la lista subyacente representada por la <xref:System.Windows.Forms.BindingSource.List%2A> propiedad y simplemente refieren su operación a la lista subyacente. Por lo tanto, cuando la <xref:System.Windows.Forms.BindingSource> está enlazado a una implementación personalizada de <xref:System.Collections.IList>, el comportamiento exacto de estos miembros puede diferir del comportamiento descrito en la documentación de la clase. Por ejemplo, el <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> llamadas al método <xref:System.Collections.IList.RemoveAt%2A?displayProperty=nameWithType>. El <xref:System.Windows.Forms.BindingSource> documentación se describe la <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> método con la descripción que el <xref:System.Collections.IList.RemoveAt%2A> método para subyacente <xref:System.Collections.IList> se implementa correctamente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra un <xref:System.Windows.Forms.ListBox> enlazados a un <xref:System.Windows.Forms.BindingSource>. El <xref:System.Windows.Forms.BindingSource> está enlazado a un <xref:System.ComponentModel.BindingList%601> que contiene una lista de fuentes.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#0](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#0)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#0](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#0)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.BindingSource" />
    <altmember cref="T:System.Windows.Forms.BindingNavigator" />
    <altmember cref="T:System.Windows.Forms.DataGridView" />
    <altmember cref="T:System.Windows.Forms.CurrencyManager" />
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.ComponentModel.IBindingList" />
    <altmember cref="T:System.ComponentModel.IEditableObject" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Forms.BindingSource" /> utilizando los valores de propiedad predeterminados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra el valor predeterminado <xref:System.Windows.Forms.BindingSource> valores de propiedad inicializados por este constructor.  
  
|Propiedad.|Valor predeterminado|  
|--------------|-------------------|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.DataMember%2A>|<xref:System.String.Empty>|  
|<xref:System.Windows.Forms.BindingSource.Sort%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.Filter%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A>|`true`|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="T:System.Windows.Forms.CurrencyManager" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource (System.ComponentModel.IContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor(System.ComponentModel.IContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (container As IContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingSource(System::ComponentModel::IContainer ^ container);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
      </Parameters>
      <Docs>
        <param name="container">
          <see cref="T:System.ComponentModel.IContainer" /> que se va a agregar al <see cref="T:System.Windows.Forms.BindingSource" /> actual.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Forms.BindingSource" /> y agrega <see cref="T:System.Windows.Forms.BindingSource" /> al contenedor especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor llama al constructor predeterminado y, a continuación, agrega actual <xref:System.Windows.Forms.BindingSource> al contenedor especificado. No suele sirve por el programador de soluciones, pero en su lugar, los autores de entornos en tiempo de diseño.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource (object dataSource, string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object dataSource, string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSource As Object, dataMember As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingSource(System::Object ^ dataSource, System::String ^ dataMember);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource">Origen de datos de <see cref="T:System.Windows.Forms.BindingSource" />.</param>
        <param name="dataMember">La columna concreta o nombre de lista del origen de datos con la que establecer el enlace.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Forms.BindingSource" /> con el origen de datos especificado y el miembro de datos que se hayan especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual int Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Add(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> que se debe agregar a la lista interna.</param>
        <summary>Agrega un elemento existente a la lista interna.</summary>
        <returns>El índice de base cero en el que se agregó <paramref name="value" /> a la lista subyacente, representado por la propiedad <see cref="P:System.Windows.Forms.BindingSource.List" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.Add%2A> método hace referencia a la llamada a la lista subyacente `Add` método.  
  
 La lista interna debe contener tipos homogéneos. Si el <xref:System.Windows.Forms.BindingSource.DataSource%2A> propiedad ya no se ha establecido, a continuación, el primer objeto agregado a la lista define el tipo de la lista.  
  
 Este método provoca el <xref:System.Windows.Forms.BindingSource.ListChanged> eventos.  
  
   
  
## Examples  
 El ejemplo de código siguiente cómo usar el <xref:System.Windows.Forms.BindingSource.Add%2A> método. Para ejecutar este ejemplo, pegue el código en un formulario Windows Forms y llame a la `PopulateBindingSourceWithFonts` método desde el constructor del formulario.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> tiene un tipo distinto del de los elementos existentes en la lista subyacente.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Remove(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AddingNew">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AddingNewEventHandler AddingNew;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AddingNewEventHandler AddingNew" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.AddingNew" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AddingNew As AddingNewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AddingNewEventHandler ^ AddingNew;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AddingNewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce antes de que se agregue un elemento a la lista subyacente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.AddingNew> evento tiene lugar antes de que se agrega un nuevo objeto a la lista subyacente representada por la <xref:System.Windows.Forms.BindingSource.List%2A> propiedad. Este evento se desencadena después de la <xref:System.Windows.Forms.BindingSource.AddNew%2A> método se llama, pero antes de que el nuevo elemento se crea y se agrega a la lista subyacente. Controlando este evento, el programador puede ofrecer la creación de elementos personalizadas y comportamiento de inserción sin estar obligado a derivar de la <xref:System.Windows.Forms.BindingSource> clase. Esto se consigue en el controlador de eventos estableciendo la <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> propiedad de la <xref:System.ComponentModel.AddingNewEventArgs?displayProperty=nameWithType> parámetro para el nuevo elemento. El objeto nuevo creado en la <xref:System.Windows.Forms.BindingSource.AddingNew> eventos deben ser del mismo tipo que el tipo contenido en la lista o se producirá una excepción. No se puede establecer la <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> propiedad cuando se enlaza a un <xref:System.Data.DataView> o <xref:System.Data.DataTable> porque no se puede agregar un nuevo <xref:System.Data.DataRowView> a la lista.  
  
 Para obtener más información sobre cómo proporcionar la funcionalidad personalizada de nuevos elementos, vea el <xref:System.Windows.Forms.BindingSource.AddNew%2A> método. Para obtener más información sobre el control de eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza un <xref:System.Windows.Forms.BindingSource> componente para enlazar una lista a un <xref:System.Windows.Forms.DataGridView> control. Nuevos elementos se agregan a la lista por el <xref:System.Windows.Forms.BindingSource.AddingNew> controlador de eventos. Este ejemplo de código forma parte de un ejemplo más extenso incluido en [Cómo: personalizar la inclusión de elementos con el control BindingSource de formularios de Windows](~/docs/framework/winforms/controls/how-to-customize-item-addition-with-the-windows-forms-bindingsource.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CPP/form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CS/form1.cs#8)]
 [!code-vb[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.AddingNewEventArgs.NewObject" /> no es el mismo tipo que el tipo contenido en la lista.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" />
        <altmember cref="T:System.ComponentModel.AddingNewEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="AddNew">
      <MemberSignature Language="C#" Value="public virtual object AddNew ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.AddNew" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddNew () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ AddNew();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Agrega un nuevo elemento a la lista subyacente.</summary>
        <returns>
          <see cref="T:System.Object" /> creado y agregado a la lista.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.AddNew%2A> método agrega un nuevo elemento a la lista subyacente representada por la <xref:System.Windows.Forms.BindingSource.List%2A> propiedad. Este método configura la siguiente serie de acciones:  
  
1.  El <xref:System.Windows.Forms.BindingSource.EndEdit%2A> llama automáticamente al método para las operaciones de edición pendiente de confirmación.  
  
2.  El <xref:System.Windows.Forms.BindingSource.AddingNew> automáticamente se genera el evento. Este evento se puede administrar mediante programación para construir el nuevo elemento. Esto se consigue en el controlador de eventos estableciendo la <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> propiedad de la <xref:System.ComponentModel.AddingNewEventArgs?displayProperty=nameWithType> parámetro para el nuevo elemento. El objeto nuevo creado en la <xref:System.Windows.Forms.BindingSource.AddingNew> eventos deben ser del mismo tipo que el tipo contenido en la lista o se producirá una excepción.  
  
     Si el <xref:System.Windows.Forms.BindingSource.AddingNew> no se controló el evento y la lista subyacente es un <xref:System.ComponentModel.IBindingList>, a continuación, la solicitud se pasa a la lista <xref:System.ComponentModel.IBindingList.AddNew%2A?displayProperty=nameWithType> método. Si la lista subyacente no es una <xref:System.ComponentModel.IBindingList>, el elemento se crea automáticamente mediante su constructor público predeterminado. En cualquier caso, el nuevo elemento se agrega al final de la lista.  
  
3.  El nuevo elemento se agrega inmediatamente a la lista interna a menos que el origen de datos implementa la <xref:System.ComponentModel.IEditableObject> interfaz. En este caso, el nuevo elemento no se confirma hasta que una llamada explícita a <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23EndNew%2A> se realiza o hasta que se inicia una nueva operación de lista. Antes de que se confirma, el nuevo elemento se pueda revertir mediante una llamada a <xref:System.Windows.Forms.BindingSource.CancelEdit%2A>, en cuyo caso se descarta el nuevo elemento.  
  
 Este método provoca el <xref:System.Windows.Forms.BindingSource.ListChanged> eventos.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza un <xref:System.Windows.Forms.BindingSource> componente para enlazar una lista a un <xref:System.Windows.Forms.DataGridView> control. Nuevos elementos se agregan a la lista por el <xref:System.Windows.Forms.BindingSource.AddingNew> controlador de eventos. Este ejemplo de código forma parte de un ejemplo más extenso incluido en [Cómo: personalizar la inclusión de elementos con el control BindingSource de formularios de Windows](~/docs/framework/winforms/controls/how-to-customize-item-addition-with-the-windows-forms-bindingsource.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Windows.Forms.BindingSource.AllowNew" /> se establece en <see langword="false" />.  
  
 O bien  
  
 No se encontró ningún constructor predeterminado público para el tipo de elemento actual.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="T:System.ComponentModel.AddingNewEventArgs" />
        <altmember cref="E:System.Windows.Forms.BindingSource.AddingNew" />
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowNew" />
        <altmember cref="T:System.ComponentModel.IBindingList" />
      </Docs>
    </Member>
    <Member MemberName="AllowEdit">
      <MemberSignature Language="C#" Value="public virtual bool AllowEdit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowEdit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowEdit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AllowEdit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowEdit { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se pueden editar los elementos de la lista subyacente.</summary>
        <value>
          Es <see langword="true" /> para indicar que se pueden editar los elementos de la lista; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.AllowEdit%2A> propiedad normalmente se utiliza en otros componentes para determinar si se permite la edición de elementos de la lista.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowNew">
      <MemberSignature Language="C#" Value="public virtual bool AllowNew { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowNew" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowNew" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowNew As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowNew { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el método <see cref="M:System.Windows.Forms.BindingSource.AddNew" /> se puede utilizar para agregar elementos a la lista.</summary>
        <value>
          <see langword="true" /> si se puede utilizar <see cref="M:System.Windows.Forms.BindingSource.AddNew" /> para agregar elementos a la lista; en caso contrario, devuelve <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor predeterminado para el <xref:System.Windows.Forms.BindingSource.AllowNew%2A> propiedad depende del tipo de origen de datos subyacente. Si la lista subyacente implementa la <xref:System.ComponentModel.IBindingList> interfaz, esta propiedad suplantará a la lista subyacente. En caso contrario, esta propiedad devolverá `false` si la lista subyacente tiene cualquiera de las siguientes características:  
  
-   Tiene un tamaño fijo, determinado por la <xref:System.Collections.IList.IsFixedSize%2A?displayProperty=nameWithType> propiedad.  
  
-   Es de solo lectura, según lo determinado por la <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> propiedad.  
  
-   El tipo de elemento no tiene un constructor predeterminado.  
  
> [!NOTE]
>  Una vez que se establece el valor de esta propiedad, el captador ya no hace referencia a la llamada a la lista subyacente. En su lugar, simplemente devuelve el valor que se configuró anteriormente hasta que el <xref:System.Windows.Forms.BindingSource.ResetAllowNew%2A> se llama al método.  
  
 Configuración de esta propiedad provoca la <xref:System.Windows.Forms.BindingSource.ListChanged> eventos con <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> establecido en <xref:System.ComponentModel.ListChangedType.Reset?displayProperty=nameWithType>.  
  
 Si establece la <xref:System.Windows.Forms.BindingSource.AllowNew%2A> propiedad `true` y el tipo de lista subyacente no tiene un constructor predeterminado, debe controlar el <xref:System.Windows.Forms.BindingSource.AddingNew> eventos y crear el tipo adecuado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Windows.Forms.BindingSource.AllowNew%2A> propiedad de la <xref:System.Windows.Forms.BindingSource> componente para permitir al usuario agregar nuevos elementos a la <xref:System.Windows.Forms.BindingSource> lista subyacente del componente. Si se establece esta propiedad en `true` hace que el límite <xref:System.Windows.Forms.DataGridView> control para mostrar la fila de nuevos registros.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta propiedad se establece en <see langword="true" /> cuando la lista subyacente representada por la propiedad <see cref="P:System.Windows.Forms.BindingSource.List" /> tiene un tamaño fijo o es de sólo lectura.</exception>
        <exception cref="T:System.MissingMethodException">La propiedad se establece en <see langword="true" /> y no se controla el evento <see cref="E:System.Windows.Forms.BindingSource.AddingNew" /> cuando el tipo de lista subyacente no tiene ningún constructor predeterminado.</exception>
        <altmember cref="P:System.ComponentModel.AddingNewEventArgs.NewObject" />
        <altmember cref="M:System.Windows.Forms.BindingSource.ResetAllowNew" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowEdit" />
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowRemove" />
        <altmember cref="M:System.Windows.Forms.BindingSource.EndEdit" />
        <altmember cref="M:System.Windows.Forms.BindingSource.CancelEdit" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
      </Docs>
    </Member>
    <Member MemberName="AllowRemove">
      <MemberSignature Language="C#" Value="public virtual bool AllowRemove { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowRemove" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowRemove" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AllowRemove As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowRemove { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se pueden quitar elementos de la lista subyacente.</summary>
        <value>
          Es <see langword="true" /> para indicar que se pueden quitar elementos de la lista; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.AllowRemove%2A> propiedad normalmente se utiliza en otros componentes para determinar si se permite la edición de elementos de la lista.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplySort">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ordena el origen de datos con la descripción o las descripciones de ordenación especificadas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplySort">
      <MemberSignature Language="C#" Value="public virtual void ApplySort (System.ComponentModel.ListSortDescriptionCollection sorts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplySort(class System.ComponentModel.ListSortDescriptionCollection sorts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ApplySort(System.ComponentModel.ListSortDescriptionCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ApplySort (sorts As ListSortDescriptionCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplySort(System::ComponentModel::ListSortDescriptionCollection ^ sorts);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sorts" Type="System.ComponentModel.ListSortDescriptionCollection" />
      </Parameters>
      <Docs>
        <param name="sorts">
          <see cref="T:System.ComponentModel.ListSortDescriptionCollection" /> que contiene las descripciones de ordenación que se aplicarán al origen de datos.</param>
        <summary>Ordena el origen de datos con las descripciones de ordenación especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.IBindingListView> implementa la ordenación de varias columnas como un conjunto de pares de dirección y descriptor de propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El origen de datos no es un <see cref="T:System.ComponentModel.IBindingListView" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplySort">
      <MemberSignature Language="C#" Value="public virtual void ApplySort (System.ComponentModel.PropertyDescriptor property, System.ComponentModel.ListSortDirection sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplySort(class System.ComponentModel.PropertyDescriptor property, valuetype System.ComponentModel.ListSortDirection sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ApplySort(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ApplySort (property As PropertyDescriptor, sort As ListSortDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplySort(System::ComponentModel::PropertyDescriptor ^ property, System::ComponentModel::ListSortDirection sort);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="sort" Type="System.ComponentModel.ListSortDirection" />
      </Parameters>
      <Docs>
        <param name="property">
          <see cref="T:System.ComponentModel.PropertyDescriptor" /> que describe la propiedad por la cual se ordenará el origen de datos.</param>
        <param name="sort">
          <see cref="T:System.ComponentModel.ListSortDirection" /> que indica cómo se debe ordenar la lista.</param>
        <summary>Ordena el origen de datos utilizando el descriptor de propiedad y el sentido de ordenación especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.IBindingList> implementa la ordenación de columnas única con un <xref:System.ComponentModel.PropertyDescriptor> para indicar una propiedad que se va a ordenar por y un <xref:System.ComponentModel.ListSortDirection> que indica si el contenido de la propiedad se debe ordenar en orden ascendente o descendente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El origen de datos no es un <see cref="T:System.ComponentModel.IBindingList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BindingComplete">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.BindingCompleteEventHandler BindingComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.BindingCompleteEventHandler BindingComplete" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.BindingComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BindingComplete As BindingCompleteEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::BindingCompleteEventHandler ^ BindingComplete;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingCompleteEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando todos los clientes se han enlazado a este <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.BindingComplete> evento se produce después de todos los clientes, normalmente controles, se han enlazado actual <xref:System.Windows.Forms.BindingSource>. El controlador de este evento puede tomar las acciones apropiadas según el éxito, error o las excepciones producidas en el proceso de enlace, examinando la <xref:System.Windows.Forms.BindingCompleteEventArgs.BindingCompleteState%2A> propiedad de la <xref:System.Windows.Forms.BindingCompleteEventArgs> parámetro.  
  
 Para obtener más información sobre el control de eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se ilustra el control de la <xref:System.Windows.Forms.BindingSource.BindingComplete> eventos. Para ejecutar este código, péguelo en un archivo de código vacío.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingCompleteEventArgs.BindingCompleteState" />
        <altmember cref="T:System.Windows.Forms.BindingCompleteEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="CancelEdit">
      <MemberSignature Language="C#" Value="public void CancelEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.CancelEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelEdit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancela la operación de edición actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método descarta las modificaciones realizadas a los datos desde la última vez guardar o cargar el operación si se cumplen las condiciones siguientes:  
  
-   El origen de datos implementa la <xref:System.ComponentModel.IEditableObject> interfaz.  
  
-   El <xref:System.Windows.Forms.BindingSource.EndEdit%2A> aún no se ha llamado al método.  
  
 Este método llama a la <xref:System.Windows.Forms.CurrencyManager.CancelCurrentEdit%2A> método subyacente <xref:System.Windows.Forms.CurrencyManager>y tiene un ámbito a los cambios de nivel de fila.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.EndEdit" />
        <altmember cref="T:System.ComponentModel.IEditableObject" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los elementos de la lista.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.Clear%2A> método quita todos los elementos de la lista subyacente representada por la <xref:System.Windows.Forms.BindingSource.List%2A> propiedad y establece el <xref:System.Windows.Forms.BindingSource.Count%2A> propiedad en cero.  
  
 Este método provoca el <xref:System.Windows.Forms.BindingSource.ListChanged> eventos.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="M:System.Windows.Forms.BindingSource.CancelEdit" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> que buscar en la lista subyacente representada por la propiedad <see cref="P:System.Windows.Forms.BindingSource.List" />. El valor puede ser <see langword="null" />.</param>
        <summary>Determina si un objeto es un elemento de la lista.</summary>
        <returns>
          Es <see langword="true" /> si se encuentra el parámetro <paramref name="value" /> en la lista <see cref="P:System.Windows.Forms.BindingSource.List" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque la implementación depende de la lista subyacente `Contains` método, normalmente aplican las siguientes características:  
  
-   <xref:System.Windows.Forms.BindingSource.List%2A> se realiza a partir del primer elemento y terminando con el último elemento.  
  
-   El método subyacente realiza una búsqueda lineal; por lo tanto, el tiempo medio de ejecución es proporcional al valor de la <xref:System.Windows.Forms.BindingSource.Count%2A> propiedad.  
  
-   El método subyacente determina la igualdad llamando a la <xref:System.Object.Equals%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CopyTo (arr As Array, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ arr, int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arr" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="arr">Matriz de destino.</param>
        <param name="index">El índice de la matriz de destino por el que va a comenzar la operación de copia.</param>
        <summary>Copia el contenido de <see cref="P:System.Windows.Forms.BindingSource.List" /> a la matriz especificada, comenzando en el valor de índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar este método para combinar elementos de varios orígenes en una matriz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número total de elementos en la lista subyacente, teniendo el valor <see cref="P:System.Windows.Forms.BindingSource.Filter" /> actual en cuenta.</summary>
        <value>Número de elementos contenidos en la lista subyacente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.Count%2A> propiedad obtiene el número de elementos de la lista subyacente representada por la <xref:System.Windows.Forms.BindingSource.List%2A> propiedad tal y como modifica el valor de la <xref:System.Windows.Forms.BindingSource.Filter%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la <xref:System.Windows.Forms.BindingSource.List%2A>, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>, y <xref:System.Windows.Forms.BindingSource.Count%2A> los miembros. Para ejecutar este ejemplo, pegue el código en un formulario que contenga un <xref:System.Windows.Forms.BindingSource> denominado `BindingSource1`, dos etiquetas denominadas `label1` y `label2`y un botón denominado `button1`. Asociar el `button1_Click` método con el <xref:System.Windows.Forms.Control.Click> eventos para `button1`. Los usuarios de Visual Basic, deberá agregar una referencia a System.Data.dll.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
      </Docs>
    </Member>
    <Member MemberName="CurrencyManager">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.CurrencyManager CurrencyManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CurrencyManager CurrencyManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.CurrencyManager" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrencyManager As CurrencyManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::CurrencyManager ^ CurrencyManager { System::Windows::Forms::CurrencyManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.ICurrencyManagerProvider.CurrencyManager</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CurrencyManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el administrador de moneda asociado a este <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <value>
          <see cref="T:System.Windows.Forms.CurrencyManager" /> asociada a esta <see cref="T:System.Windows.Forms.BindingSource" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si desea tener acceso al administrador de moneda para otro enlace para el mismo miembro de datos usan el <xref:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public object Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Current { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el elemento actual de la lista.</summary>
        <value>
          <see cref="T:System.Object" /> que representa el elemento actual de la lista subyacente representada por la propiedad <see cref="P:System.Windows.Forms.BindingSource.List" />, o bien, <see langword="null" /> si la lista no tiene ningún elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice la <xref:System.Windows.Forms.BindingSource.Current%2A> propiedad para obtener acceso al elemento actual, pero usa el <xref:System.Windows.Forms.BindingSource.List%2A> propiedad que se va a obtener la lista completa. Para determinar el tipo del objeto actual, utilice la <xref:System.Object.GetType%2A>, o <xref:System.Object.ToString%2A> métodos.  
  
 Para cambiar el elemento actual, establezca el <xref:System.Windows.Forms.BindingSource.Position%2A> propiedad en un nuevo valor entero, o utilice uno de los métodos de navegación como <xref:System.Windows.Forms.BindingSource.MoveNext%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Windows.Forms.BindingSource.Current%2A> propiedad. Para ejecutar este ejemplo, pegue el código en un formulario y llame a la `PopulateBindingSourceWithFonts` método desde el formulario <xref:System.Windows.Forms.Form.Load> método de control de eventos.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
      </Docs>
    </Member>
    <Member MemberName="CurrentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CurrentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.CurrentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CurrentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CurrentChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el elemento enlazado actualmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.CurrentChanged> evento se desencadena cada vez que la <xref:System.Windows.Forms.BindingSource.Current%2A> cambios de propiedad de cualquiera de los siguientes motivos:  
  
-   La posición actual de la <xref:System.Windows.Forms.BindingSource.List%2A> cambios.  
  
-   El <xref:System.Windows.Forms.BindingSource.DataSource%2A> o <xref:System.Windows.Forms.BindingSource.DataMember%2A> cambio de propiedades.  
  
-   La pertenencia de subyacente <xref:System.Windows.Forms.BindingSource.List%2A> cambia, lo que hace que <xref:System.Windows.Forms.BindingSource.Position%2A> para hacer referencia a un elemento diferente. Algunos ejemplos son la adición o eliminación de un elemento situado delante del elemento actual, eliminar o mover el propio elemento actual o mover un elemento a la posición actual.  
  
-   La lista subyacente se actualiza mediante una nueva ordenación o la operación de filtrado.  
  
 Cuando se desencadena este evento, el <xref:System.Windows.Forms.BindingSource.Current%2A> propiedad ya contendrá su nuevo valor.  
  
 <xref:System.Windows.Forms.BindingSource.CurrentChanged> es el evento predeterminado para el <xref:System.Windows.Forms.BindingSource> clase.  
  
 Para obtener más información sobre el control de eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.BindingManagerBase.CurrentChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.PositionChanged" />
      </Docs>
    </Member>
    <Member MemberName="CurrentItemChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CurrentItemChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentItemChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CurrentItemChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CurrentItemChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia un valor de la propiedad <see cref="P:System.Windows.Forms.BindingSource.Current" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> evento se produce en respuesta a todas las circunstancias que provocan el <xref:System.Windows.Forms.BindingSource.CurrentChanged> eventos. Además, <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> también se desencadena siempre que el valor de una de las propiedades de <xref:System.Windows.Forms.BindingSource.Current%2A> se cambia.  
  
 Para obtener más información sobre el control de eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.PositionChanged" />
      </Docs>
    </Member>
    <Member MemberName="DataError">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.BindingManagerDataErrorEventHandler DataError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.BindingManagerDataErrorEventHandler DataError" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataError" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataError As BindingManagerDataErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::BindingManagerDataErrorEventHandler ^ DataError;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingManagerDataErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aparece cuando el <see cref="T:System.Windows.Forms.BindingSource" /> controla en modo silencioso una excepción relacionada con la moneda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento es informativo y los informes solo las excepciones conformes a CLS. Para determinar qué tipo de excepción se produjo, controle este evento y compruebe el <xref:System.Windows.Forms.BindingManagerDataErrorEventArgs.Exception%2A> propiedad de la <xref:System.Windows.Forms.BindingManagerDataErrorEventArgs>.  
  
 Para obtener más información sobre el control de eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataMember">
      <MemberSignature Language="C#" Value="public string DataMember { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataMember" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.DataMember" />
      <MemberSignature Language="VB.NET" Value="Public Property DataMember As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataMember { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.DataMemberListEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la lista concreta del origen de datos a la que está enlazado el conector en ese momento.</summary>
        <value>El nombre de una lista (o fila) del origen de datos <see cref="P:System.Windows.Forms.BindingSource.DataSource" />. El valor predeterminado es una cadena vacía ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Forms.BindingSource.DataSource%2A> contiene varias listas (o tablas) de datos, debe establecer el <xref:System.Windows.Forms.BindingSource.DataMember%2A> propiedad en el nombre de uno de los orígenes.  
  
 Configuración de esta propiedad provoca la <xref:System.Windows.Forms.BindingSource.DataMemberChanged> eventos  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
      </Docs>
    </Member>
    <Member MemberName="DataMemberChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DataMemberChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataMemberChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataMemberChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataMemberChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.BindingSource.DataMember" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.DataMemberChanged> evento tiene lugar después de la <xref:System.Windows.Forms.BindingSource.DataMember%2A> cambios de propiedad.  
  
 Para obtener más información sobre el control de eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
      </Docs>
    </Member>
    <Member MemberName="DataSource">
      <MemberSignature Language="C#" Value="public object DataSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.DataSource" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataSource { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AttributeProvider(typeof(System.ComponentModel.IListSource))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el origen de datos con el que está enlazado el conector.</summary>
        <value>Objeto <see cref="T:System.Object" /> que funciona como origen de datos. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.DataSource%2A> propiedad puede establecerse en un número de orígenes de datos, incluidos tipos, objetos y listas de tipos. El origen de datos resultante se expondrá como una lista. La tabla siguiente muestran algunos de los orígenes de datos comunes y la evaluación de la lista resultante.  
  
|Propiedad de origen de datos|Resultados de la lista|  
|-------------------------|------------------|  
|`null`|Vacío <xref:System.ComponentModel.IBindingList> de objetos. Agregar un elemento, Establece la lista para el tipo del elemento agregado.|  
|`null` con <xref:System.Windows.Forms.BindingSource.DataMember%2A> establecido|No compatible, provoca <xref:System.ArgumentException>.|  
|Tipo de lista no o un objeto de tipo "T"|Vacía <xref:System.ComponentModel.IBindingList> de tipo "T".|  
|Instancia de la matriz|<xref:System.ComponentModel.IBindingList> que contiene los elementos de matriz.|  
|Instancia de <xref:System.Collections.IEnumerable>|Un <xref:System.ComponentModel.IBindingList> que contiene el <xref:System.Collections.IEnumerable> elementos.|  
|"T" de la instancia que contiene el tipo de lista|<xref:System.ComponentModel.IBindingList> instancia que contiene el tipo "T".|  
  
 Además, <xref:System.Windows.Forms.BindingSource.DataSource%2A> se puede establecer en otros tipos de lista como <xref:System.ComponentModel.IListSource> y <xref:System.ComponentModel.ITypedList> y <xref:System.Windows.Forms.BindingSource> controlará adecuadamente. En este caso, el tipo contenido en la lista debe tener un constructor predeterminado.  
  
 Al establecer un origen de datos, si la referencia proporcionada contiene más de una lista o tabla, debe establecer el <xref:System.Windows.Forms.BindingSource.DataMember%2A> propiedad a una cadena que especifica la lista para enlazar a. Configuración de esta propiedad provoca la <xref:System.Windows.Forms.BindingSource.DataSourceChanged> eventos.  
  
> [!NOTE]
>  Si realiza cambios en la <xref:System.Windows.Forms.BindingSource.DataSource%2A> valor de propiedad, debe hacerlo en el subproceso de interfaz de usuario para asegurarse de que la interfaz de usuario refleja los cambios.  
  
 El <xref:System.Windows.Forms.BindingSource.DataSource%2A> es la propiedad predeterminada para el <xref:System.Windows.Forms.BindingSource> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se asigna una lista de clientes para la <xref:System.Windows.Forms.BindingSource.DataSource%2A> de un <xref:System.Windows.Forms.BindingSource> componente. Este ejemplo de código forma parte de un ejemplo más extenso incluido en [Cómo: provocar notificaciones de cambios mediante el método ResetItem de BindingSource](~/docs/framework/winforms/controls/how-to-raise-change-notifications-using-the-bindingsource-resetitem-method.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.ComponentModel.IListSource" />
      </Docs>
    </Member>
    <Member MemberName="DataSourceChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DataSourceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataSourceChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataSourceChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataSourceChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el valor de la propiedad <see cref="P:System.Windows.Forms.BindingSource.DataSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.DataSourceChanged> evento tiene lugar después de la <xref:System.Windows.Forms.BindingSource.DataSource%2A> cambios de propiedad.  
  
 Para obtener más información sobre el control de eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usa <see cref="T:System.Windows.Forms.BindingSource" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama a este método público `Dispose` método y <xref:System.Object.Finalize%2A> método. `Dispose` se invoca el protegido `Dispose(Boolean)` método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` con `disposing` establecido en `false`.  
  
 Cuando el `disposing` del parámetro es true, este método libera todos los recursos retenidos por los objetos administrados que este <xref:System.Windows.Forms.BindingSource> referencias. Este método invoca al método `Dispose` de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> puede recibir varias llamadas de otros objetos. Al reemplazar <see langword="Dispose(Boolean)" /> tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />. Para obtener más información sobre cómo implementar <see langword="Dispose(Boolean)" />, consulte [implementa un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obtener más información acerca de <see langword="Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [reemplazar el método Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndEdit">
      <MemberSignature Language="C#" Value="public void EndEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.EndEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndEdit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aplica los cambios pendientes al origen de datos subyacente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Windows.Forms.BindingSource.EndEdit%2A> se llama al método, todos los cambios pendientes se aplican al origen de datos subyacente.  
  
 Este método no tiene ningún efecto a menos que los objetos contenidos en el origen de datos implementan el <xref:System.ComponentModel.IEditableObject> interfaz. Si los objetos no implementan la <xref:System.ComponentModel.IEditableObject> interfaz, cambios en los datos se copian en el origen de datos subyacente inmediatamente después de cada cambio.  
  
 Este método provoca el <xref:System.Windows.Forms.BindingSource.ListChanged> eventos.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="T:System.ComponentModel.IEditableObject" />
        <altmember cref="M:System.Windows.Forms.BindingSource.CancelEdit" />
        <altmember cref="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#EndNew(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public virtual string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la expresión utilizada para filtrar las filas que se deben mostrar.</summary>
        <value>Cadena que especifica cómo se van a filtrar las filas. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se utiliza normalmente en escenarios de enlace de datos complejos, la <xref:System.Windows.Forms.BindingSource.Filter%2A> propiedad le permite ver un subconjunto de la <xref:System.Windows.Forms.BindingSource.DataSource%2A>. Solo subyacente muestra que implementan el <xref:System.ComponentModel.IBindingListView> admiten el filtrado de la interfaz.  
  
 Cuando <xref:System.Windows.Forms.BindingSource.Filter%2A> no `null`, el <xref:System.Windows.Forms.BindingSource> pasa esta propiedad a la lista subyacente. Si establece esta propiedad durante la inicialización del objeto, la llamada se aplazará hasta que una vez completada la inicialización.  
  
 Para formar un valor de filtro, especifique el nombre de una columna seguido de un operador y un valor para utilizar como filtro. La sintaxis de filtro aceptada depende del origen de datos subyacente. Si el origen de datos subyacente es un <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, o <xref:System.Data.DataView>, puede especificar expresiones booleanas utilizando la sintaxis documentada para la <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> propiedad.  
  
 El valor de la <xref:System.Windows.Forms.BindingSource.Filter%2A> propiedad afecta al valor de la <xref:System.Windows.Forms.BindingSource.Count%2A> propiedad. Además, el <xref:System.Windows.Forms.BindingSource.Filter%2A> el valor se conservará cuando cambian los datos originales. Para detener el filtro la <xref:System.Windows.Forms.BindingSource.DataSource%2A>, llame a la <xref:System.Windows.Forms.BindingSource.RemoveFilter%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Forms.BindingSource.Filter%2A> propiedad con un <xref:System.Data.DataView>. Para ejecutar este ejemplo, pegue el código en un formulario Windows Forms y llame a `PopulateDataViewAndFilter` desde el constructor del formulario o <xref:System.Windows.Forms.Form.Load> método de control de eventos. El formulario debe importar el <xref:System.Xml> y <xref:System.IO> los espacios de nombres.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Sort" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveFilter" />
        <altmember cref="P:System.ComponentModel.IBindingList.IsSorted" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Find">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca el elemento especificado en el origen de datos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public virtual int Find (System.ComponentModel.PropertyDescriptor prop, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Find(class System.ComponentModel.PropertyDescriptor prop, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Find (prop As PropertyDescriptor, key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Find(System::ComponentModel::PropertyDescriptor ^ prop, System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prop" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="prop">
          <see cref="T:System.ComponentModel.PropertyDescriptor" /> que se va a buscar.</param>
        <param name="key">Valor de <c>prop</c> que debe coincidir.</param>
        <summary>Busca el índice del elemento que tiene el descriptor de propiedad especificado.</summary>
        <returns>El índice de base cero del elemento que tiene el valor especificado para <see cref="T:System.ComponentModel.PropertyDescriptor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza normalmente en casos de enlace de datos complejos para buscar la primera fila donde el valor del campo especificado por el `prop` parámetro es igual al valor de la `key` parámetro  
  
 Este método simplemente hace referencia a la solicitud a la lista subyacente <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType> método. Por ejemplo, si el origen de datos subyacente es un <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, o <xref:System.Data.DataView>, este método llama a la <xref:System.Data.DataView.System%23ComponentModel%23IBindingList%23Find%2A?displayProperty=nameWithType> método. El comportamiento de <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType>, como el valor devuelto si no se encuentra ningún elemento coincidente, depende de la implementación del método en la lista subyacente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el método <xref:System.Windows.Forms.BindingSource.Find%2A>. Para obtener un ejemplo completo, vea el tema de información general sobre la clase.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La lista subyacente no es de tipo <see cref="T:System.ComponentModel.IBindingList" />.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Contains(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string propertyName, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string propertyName, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Find(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (propertyName As String, key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ propertyName, System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de la propiedad que se va a buscar.</param>
        <param name="key">Valor del elemento con el <c>propertyName</c> especificado que se debe buscar.</param>
        <summary>Devuelve el índice del elemento de la lista con el nombre y el valor de propiedad especificados.</summary>
        <returns>El índice de base cero del elemento con el nombre y el valor de propiedad especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.Find%2A> método solo se puede utilizar cuando la lista subyacente es un <xref:System.ComponentModel.IBindingList> con búsqueda implementada. Este método simplemente hace referencia a la solicitud a la lista subyacente <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType> método. Por ejemplo, si el origen de datos subyacente es un <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, o <xref:System.Data.DataView>, este método convierte `propertyName` a una <xref:System.ComponentModel.PropertyDescriptor> y llama a la <xref:System.Data.DataView.System%23ComponentModel%23IBindingList%23Find%2A> método. El comportamiento de <xref:System.Windows.Forms.BindingSource.Find%2A>, como el valor devuelto si no se encuentra ningún elemento coincidente, depende de la implementación del método en la lista subyacente.  
  
 La comparación de nombres de propiedad distingue mayúsculas de minúsculas.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Forms.BindingSource.Find%2A> método con un <xref:System.Data.DataView>. Para ejecutar este ejemplo, pegue el código en un formulario Windows Forms y llame a `PopulateDataViewAndFind` desde el constructor del formulario o <xref:System.Windows.Forms.Form.Load> método de control de eventos. El formulario debe importar el <xref:System.Xml> y <xref:System.IO> los espacios de nombres.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La lista subyacente no es una <see cref="T:System.ComponentModel.IBindingList" /> con funcionalidad de búsqueda implementada.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyName" /> no coincide con ninguna propiedad de la lista.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera un enumerador para <see cref="P:System.Windows.Forms.BindingSource.List" />.</summary>
        <returns>Estructura <see cref="T:System.Collections.IEnumerator" /> para la colección <see cref="P:System.Windows.Forms.BindingSource.List" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProperties">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptorCollection GetItemProperties (System.ComponentModel.PropertyDescriptor[] listAccessors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.PropertyDescriptorCollection GetItemProperties(class System.ComponentModel.PropertyDescriptor[] listAccessors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetItemProperties(System.ComponentModel.PropertyDescriptor[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetItemProperties (listAccessors As PropertyDescriptor()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::PropertyDescriptorCollection ^ GetItemProperties(cli::array &lt;System::ComponentModel::PropertyDescriptor ^&gt; ^ listAccessors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="listAccessors" Type="System.ComponentModel.PropertyDescriptor[]" />
      </Parameters>
      <Docs>
        <param name="listAccessors">Una matriz de objetos <see cref="T:System.ComponentModel.PropertyDescriptor" /> que se van a buscar en la lista como enlazables.</param>
        <summary>Recupera una matriz de objetos <see cref="T:System.ComponentModel.PropertyDescriptor" /> que representan las propiedades enlazables del tipo de lista del origen de datos.</summary>
        <returns>Una matriz de objetos <see cref="T:System.ComponentModel.PropertyDescriptor" /> que representa las propiedades en este tipo de lista que se utiliza para enlazar datos.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.ListBindingHelper" />
      </Docs>
    </Member>
    <Member MemberName="GetListName">
      <MemberSignature Language="C#" Value="public virtual string GetListName (System.ComponentModel.PropertyDescriptor[] listAccessors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetListName(class System.ComponentModel.PropertyDescriptor[] listAccessors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetListName(System.ComponentModel.PropertyDescriptor[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetListName (listAccessors As PropertyDescriptor()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetListName(cli::array &lt;System::ComponentModel::PropertyDescriptor ^&gt; ^ listAccessors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="listAccessors" Type="System.ComponentModel.PropertyDescriptor[]" />
      </Parameters>
      <Docs>
        <param name="listAccessors">Una matriz de objetos <see cref="T:System.ComponentModel.PropertyDescriptor" /> que se van a buscar en la lista como enlazables.</param>
        <summary>Obtiene el nombre de la lista que suministra datos para el enlace.</summary>
        <returns>Nombre de la lista que suministra los datos para el enlace.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.ListBindingHelper" />
      </Docs>
    </Member>
    <Member MemberName="GetRelatedCurrencyManager">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.CurrencyManager GetRelatedCurrencyManager (string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.CurrencyManager GetRelatedCurrencyManager(string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRelatedCurrencyManager (dataMember As String) As CurrencyManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::CurrencyManager ^ GetRelatedCurrencyManager(System::String ^ dataMember);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.ICurrencyManagerProvider.GetRelatedCurrencyManager(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CurrencyManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataMember">Nombre de la columna o la lista, situada en el origen de datos, para la que se va a recuperar el administrador de moneda.</param>
        <summary>Obtiene el administrador de moneda relacionado para el miembro de datos especificado.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.CurrencyManager" /> relacionado para el miembro de datos especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `dataMember` es `null` o una cadena vacía (""), <xref:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager%2A> devuelve el Administrador de moneda principal; en caso contrario, comprueba para otra <xref:System.Windows.Forms.BindingSource> enlazado al miembro de datos especificado y devuelve su administrador de moneda.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> que buscar en la lista subyacente representada por la propiedad <see cref="P:System.Windows.Forms.BindingSource.List" />. El valor puede ser <see langword="null" />.</param>
        <summary>Busca el objeto especificado y devuelve el índice de la primera aparición en toda la lista.</summary>
        <returns>El índice de base cero de la primera aparición del parámetro <paramref name="value" />; de lo contrario, devuelve -1 si <paramref name="value" /> no está en la lista.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque la implementación depende de la lista subyacente `IndexOf` método, normalmente aplican las siguientes características:  
  
-   El <xref:System.Windows.Forms.BindingSource.List%2A> se realiza a partir del primer elemento y terminando con el último elemento.  
  
-   El método subyacente realiza una búsqueda lineal; por lo tanto, el tiempo medio de ejecución es proporcional al valor de la <xref:System.Windows.Forms.BindingSource.Count%2A> propiedad.  
  
-   El método subyacente determina la igualdad llamando a la <xref:System.Object.Equals%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Contains(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public virtual void Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Insert (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero en el que se debe insertar <c>value</c>.</param>
        <param name="value">
          <see cref="T:System.Object" /> que se va a insertar. El valor puede ser <see langword="null" />.</param>
        <summary>Inserta un elemento en el índice especificado de la lista.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método provoca el <xref:System.Windows.Forms.BindingSource.ListChanged> eventos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero o mayor que <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">La lista es de sólo lectura o tiene un tamaño fijo.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsReadOnly" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsFixedSize" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
      </Docs>
    </Member>
    <Member MemberName="IsBindingSuspended">
      <MemberSignature Language="C#" Value="public bool IsBindingSuspended { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBindingSuspended" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsBindingSuspended" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBindingSuspended As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBindingSuspended { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se ha suspendido el enlace a la lista.</summary>
        <value>
          <see langword="true" /> para indicar que el enlace está suspendido; de lo contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la lista subyacente tiene un tamaño fijo.</summary>
        <value>
          Es <see langword="true" /> si la lista subyacente tiene un tamaño fijo; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la lista tiene un tamaño fijo, no permite la adición o eliminación de elementos después de que se ha creado la lista, pero se pueden modificar los elementos existentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la lista subyacente es de solo lectura.</summary>
        <value>
          <see langword="true" /> si la lista es de solo lectura; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una lista que es de solo lectura no permite la adición, eliminación o modificación de los elementos de la lista después de crea la lista.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSorted">
      <MemberSignature Language="C#" Value="public virtual bool IsSorted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSorted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsSorted" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSorted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSorted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si los elementos de la lista subyacente están ordenados.</summary>
        <value>
          Es <see langword="true" /> si la lista es un <see cref="T:System.ComponentModel.IBindingList" /> y está ordenada; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.IsSorted%2A> siempre devuelve `false` si la lista no es un <xref:System.ComponentModel.IBindingList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el acceso a la colección está sincronizado (es seguro para la ejecución de subprocesos).</summary>
        <value>
          Es <see langword="true" /> para indicar que la lista está sincronizada; de lo contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se debe recuperar.</param>
        <summary>Obtiene o establece el elemento de lista que se encuentra en el índice especificado.</summary>
        <value>Elemento en el índice especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.Item%2A> propiedad representa el indizador para esta clase. Acepta `null` como un valor válido y permite elementos duplicados en la lista.  
  
 Configuración de un valor, se producirá la <xref:System.Windows.Forms.BindingSource.ListChanged> eventos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor o igual que cero o mayor que <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
      </Docs>
    </Member>
    <Member MemberName="List">
      <MemberSignature Language="C#" Value="public System.Collections.IList List { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList List" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.List" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property List As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IList ^ List { System::Collections::IList ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la lista a la que está enlazada el conector.</summary>
        <value>
          <see cref="T:System.Collections.IList" /> que representa la lista, o <see langword="null" /> si no hay ninguna lista subyacente asociada a este <see cref="T:System.Windows.Forms.BindingSource" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Forms.BindingSource> clase controla uniformemente los distintos orígenes de datos. Lo ideal es que la <xref:System.Windows.Forms.BindingSource.List%2A> propiedad debe establecerse en general <xref:System.Collections.IList>. Sin embargo, a veces puede ser necesario convertir esta propiedad en un tipo más específico. En la tabla siguiente se muestra el tipo de lista subyacente, que depende del tipo o el valor del origen de datos.  
  
|Tipo de origen de datos|Descripción de la lista subyacente|  
|----------------------|---------------------------------|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A> y <xref:System.Windows.Forms.BindingSource.DataMember%2A> son `null`|Objeto <xref:System.Collections.ArrayList> vacío.|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A> es `null`, pero <xref:System.Windows.Forms.BindingSource.DataMember%2A> no es `null`|None; un intento de obtener la <xref:System.Windows.Forms.BindingSource.List%2A> producirá un <xref:System.ArgumentException>.|  
|Un <xref:System.Array> instancia|Una clase <xref:System.Array>.|  
|Un <xref:System.ComponentModel.IListSource> instancia|El valor devuelto de una llamada a la <xref:System.ComponentModel.IListSource.GetList%2A> método de este <xref:System.ComponentModel.IListSource> instancia.|  
|Un <xref:System.ComponentModel.IBindingList> instancia|Una clase <xref:System.ComponentModel.IBindingList>.|  
|Un <xref:System.Collections.IList> instancia|Una clase <xref:System.Collections.IList>.|  
|No<xref:System.Collections.IList> instancia del tipo "T"|A <xref:System.ComponentModel.BindingList%601> con un elemento.|  
|Un <xref:System.ComponentModel.ICustomTypeDescriptor> instancia|Un <xref:System.Collections.ArrayList> con un elemento.|  
|<xref:System.Collections.IEnumerable>.|Un <xref:System.Collections.ArrayList> con los elementos que se copió.|  
|El <xref:System.Array> escriba con <xref:System.Windows.Forms.BindingSource.DataMember%2A> del elemento de tipo "T"|Objeto <xref:System.ComponentModel.BindingList%601>.|  
|A <xref:System.Type> que representa un <xref:System.ComponentModel.IListSource> o <xref:System.ComponentModel.ITypedList>|Una instancia creada por una llamada a la <xref:System.Activator.CreateInstance%28System.Type%29> método de la <xref:System.Activator> clase. Un <xref:System.NotSupportedException> se puede producir.|  
|El <xref:System.Collections.IList> escriba con <xref:System.Windows.Forms.BindingSource.DataMember%2A> del elemento de tipo "T"<br /><br /> O bien<br /><br /> No<xref:System.Collections.IList> tipo|Objeto <xref:System.ComponentModel.BindingList%601>.|  
|El <xref:System.ComponentModel.ICustomTypeDescriptor> tipo|None; un intento de obtener la <xref:System.Windows.Forms.BindingSource.List%2A> producirá un <xref:System.NotSupportedException>.|  
  
 Si recupera el tipo es el <xref:System.Collections.IList> interfaz, la colección subyacente puede ser más compleja, como un <xref:System.Collections.ArrayList> o <xref:System.Data.DataView> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la <xref:System.Windows.Forms.BindingSource.List%2A>, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>, y <xref:System.Windows.Forms.BindingSource.Count%2A> los miembros. Para ejecutar este ejemplo, pegue el código en un formulario que contenga un <xref:System.Windows.Forms.BindingSource> denominado `BindingSource1`, dos etiquetas denominadas `label1` y `label2`y un botón denominado `button1`. Asociar el `button1_Click` método con el <xref:System.Windows.Forms.Control.Click> eventos para `button1`. Los usuarios de Visual Basic, deberá agregar una referencia a System.Data.dll.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ListChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.ListChangedEventHandler ListChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.ListChangedEventHandler ListChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.ListChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ListChanged As ListChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::ComponentModel::ListChangedEventHandler ^ ListChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia la lista subyacente o se modifica un elemento de la lista.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.ListChanged> evento se produce cuando hay un cambio en los miembros o los metadatos de la lista subyacente representada por la <xref:System.Windows.Forms.BindingSource.List%2A> propiedad. Por ejemplo, este evento se desencadena cuando se agregan, se quitan o se mueve, elementos o la <xref:System.Windows.Forms.BindingSource.DataSource%2A> o <xref:System.Windows.Forms.BindingSource.DataMember%2A> cambio de propiedades. Los valores de la <xref:System.Windows.Forms.BindingSource.Sort%2A> y <xref:System.Windows.Forms.BindingSource.Filter%2A> propiedades se conservarán cuando se produce este evento.  
  
 Este evento puede suprimirse por completo estableciendo la <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> propiedad `false`. Para obtener más información sobre el control de eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se ilustra el control de la <xref:System.Windows.Forms.BindingSource.ListChanged> eventos de la <xref:System.Windows.Forms.BindingSource> componente para detectar cuándo el <xref:System.Windows.Forms.BindingSource> se cambia la lista subyacente del componente.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CPP/form1.cpp#9)]
 [!code-csharp[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CS/form1.cs#9)]
 [!code-vb[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
        <altmember cref="T:System.ComponentModel.ListChangedType" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
      </Docs>
    </Member>
    <Member MemberName="MoveFirst">
      <MemberSignature Language="C#" Value="public void MoveFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveFirst() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveFirst" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFirst ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFirst();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se desplaza al primer elemento de la lista.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cambia el valor actual de la <xref:System.Windows.Forms.BindingSource.Position%2A> propiedad en 0, el primer elemento en el origen de datos subyacente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>, y <xref:System.Windows.Forms.BindingSource.Position%2A> los miembros. Para ejecutar este ejemplo, pegue el código en un formulario que importa el <xref:System.Drawing.Drawing2D> espacio de nombres y contiene un <xref:System.Windows.Forms.BindingSource> denominado `BindingSource1` y un botón denominado `button1`. Asociar el `Form1_Load` y `Form1_Paint` métodos con el <xref:System.Windows.Forms.Form.Load> y <xref:System.Windows.Forms.Control.Paint> eventos para el formulario y asociar el `button1_click` método con el <xref:System.Windows.Forms.Control.Click> eventos para `button1`. Los usuarios de Visual Basic, deberá agregar una referencia a System.Data.dll.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveNext" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MovePrevious" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveLast" />
      </Docs>
    </Member>
    <Member MemberName="MoveLast">
      <MemberSignature Language="C#" Value="public void MoveLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveLast() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveLast" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveLast ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveLast();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se desplaza al último elemento de la lista.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cambia el valor actual de la <xref:System.Windows.Forms.BindingSource.Position%2A> propiedad en el índice del último elemento en el origen de datos subyacente, que es igual al valor de la <xref:System.Windows.Forms.BindingSource.Count%2A> propiedad menos 1.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveNext" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MovePrevious" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public void MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveNext ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se desplaza al siguiente elemento de la lista.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cambia el valor actual de la <xref:System.Windows.Forms.BindingSource.Position%2A> propiedad al elemento siguiente en el origen de datos subyacente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>, y <xref:System.Windows.Forms.BindingSource.Position%2A> los miembros. Para ejecutar este ejemplo, pegue el código en un formulario que importa el <xref:System.Drawing.Drawing2D> espacio de nombres y contiene un <xref:System.Windows.Forms.BindingSource> denominado `BindingSource1` y un botón denominado `button1`. Asociar el `Form1_Load` y `Form1_Paint` métodos con el <xref:System.Windows.Forms.Form.Load> y <xref:System.Windows.Forms.Control.Paint> eventos para el formulario y asociar el `button1_click` método con el <xref:System.Windows.Forms.Control.Click> eventos para `button1`. Los usuarios de Visual Basic, deberá agregar una referencia a System.Data.dll.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveLast" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MovePrevious" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="MovePrevious">
      <MemberSignature Language="C#" Value="public void MovePrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MovePrevious() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MovePrevious" />
      <MemberSignature Language="VB.NET" Value="Public Sub MovePrevious ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MovePrevious();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se desplaza al elemento anterior de la lista.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método cambia el valor actual de la <xref:System.Windows.Forms.BindingSource.Position%2A> propiedad al elemento anterior en el origen de datos subyacente.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveLast" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveNext" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="OnAddingNew">
      <MemberSignature Language="C#" Value="protected virtual void OnAddingNew (System.ComponentModel.AddingNewEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAddingNew(class System.ComponentModel.AddingNewEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAddingNew (e As AddingNewEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAddingNew(System::ComponentModel::AddingNewEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.AddingNewEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.BindingSource.AddingNew" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.BindingSource.OnAddingNew%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.AddingNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnBindingComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnBindingComplete (System.Windows.Forms.BindingCompleteEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBindingComplete(class System.Windows.Forms.BindingCompleteEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBindingComplete (e As BindingCompleteEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBindingComplete(System::Windows::Forms::BindingCompleteEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.BindingCompleteEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.BindingCompleteEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.BindingSource.BindingComplete" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.BindingSource.OnBindingComplete%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCurrentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el control de eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.BindingSource.OnCurrentChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnCurrentItemChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentItemChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentItemChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentItemChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentItemChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.BindingSource.OnCurrentItemChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataError">
      <MemberSignature Language="C#" Value="protected virtual void OnDataError (System.Windows.Forms.BindingManagerDataErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataError(class System.Windows.Forms.BindingManagerDataErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataError (e As BindingManagerDataErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataError(System::Windows::Forms::BindingManagerDataErrorEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.BindingManagerDataErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Forms.BindingManagerDataErrorEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.BindingSource.DataError" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.BindingSource.OnDataError%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDataMemberChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDataMemberChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataMemberChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataMemberChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataMemberChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.BindingSource.OnDataMemberChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" /> de la clase base para que los delegados registrados reciban el evento.  
  
 El método <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" /> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataSourceChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDataSourceChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataSourceChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataSourceChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataSourceChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.BindingSource.OnDataSourceChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnListChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnListChanged (System.ComponentModel.ListChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnListChanged(class System.ComponentModel.ListChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnListChanged (e As ListChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnListChanged(System::ComponentModel::ListChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.ListChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.BindingSource.ListChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.BindingSource.OnListChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
      </Docs>
    </Member>
    <Member MemberName="OnPositionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPositionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPositionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPositionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPositionChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.ComponentModel.ListChangedEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Forms.BindingSource.PositionChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.Windows.Forms.BindingSource.OnPositionChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.PositionChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public int Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Position" />
      <MemberSignature Language="VB.NET" Value="Public Property Position As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Position { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el índice del elemento actual de la lista subyacente.</summary>
        <value>Un índice de base cero que especifica la posición del elemento actual en la lista subyacente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al establecer el <xref:System.Windows.Forms.BindingSource.Position%2A> propiedad, los valores fuera del intervalo se tratan de la siguiente manera:  
  
-   Los valores negativos se tratan como 0.  
  
-   Los valores mayores o iguales a <xref:System.Windows.Forms.BindingSource.Count%2A> se tratan como <xref:System.Windows.Forms.BindingSource.Count%2A> menos 1.  
  
 Cambiar el <xref:System.Windows.Forms.BindingSource.Position%2A> propiedad ajustará el <xref:System.Windows.Forms.BindingSource.Current%2A> propiedad del mismo modo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>, y <xref:System.Windows.Forms.BindingSource.Position%2A> los miembros. Para ejecutar este ejemplo, pegue el código en un formulario que importa el <xref:System.Drawing.Drawing2D> espacio de nombres y contiene un <xref:System.Windows.Forms.BindingSource> denominado `BindingSource1` y un botón denominado `button1`. Asociar el `Form1_Load` y `Form1_Paint` métodos con el <xref:System.Windows.Forms.Form.Load> y <xref:System.Windows.Forms.Control.Paint> eventos para el formulario y asociar el `button1_click` método con el <xref:System.Windows.Forms.Control.Click> eventos para `button1`. Los usuarios de Visual Basic, deberá agregar una referencia a System.Data.dll.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
      </Docs>
    </Member>
    <Member MemberName="PositionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PositionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PositionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.PositionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PositionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PositionChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce después de haber cambiado el valor de la propiedad <see cref="P:System.Windows.Forms.BindingSource.Position" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.PositionChanged> evento tiene lugar después de la <xref:System.Windows.Forms.BindingSource.Position%2A> propiedad ha cambiado.  
  
 Para obtener más información sobre el control de eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseListChangedEvents">
      <MemberSignature Language="C#" Value="public bool RaiseListChangedEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RaiseListChangedEvents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property RaiseListChangedEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RaiseListChangedEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si deben producirse eventos <see cref="E:System.Windows.Forms.BindingSource.ListChanged" />.</summary>
        <value>
          <see langword="true" /> si deben provocarse eventos <see cref="E:System.Windows.Forms.BindingSource.ListChanged" />; en caso contrario, devuelve <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> propiedad es `false`, se suspende la generación de <xref:System.Windows.Forms.BindingSource.ListChanged> eventos. Este evento indica que se han modificado de alguna manera, como agregar, eliminar, insertar o modificar elementos de la lista enlazada.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">El elemento que quitar de la lista subyacente representado por la propiedad <see cref="P:System.Windows.Forms.BindingSource.List" />.</param>
        <summary>Quita de la lista el elemento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.Remove%2A> método hace que la lista que se buscarán los `value` parámetro. Si se encuentra, este método intentará quitar el elemento de la <xref:System.Windows.Forms.BindingSource.List%2A>. Este intento se producirá un error si la lista tiene un tamaño fijo o es de solo lectura. Estas dos condiciones se pueden probar con el <xref:System.Windows.Forms.BindingSource.IsFixedSize%2A> y <xref:System.Windows.Forms.BindingSource.IsReadOnly%2A> propiedades, respectivamente.  
  
 Este método provoca el <xref:System.Windows.Forms.BindingSource.ListChanged> eventos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La lista subyacente tiene un tamaño fijo o es de sólo lectura.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsFixedSize" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsReadOnly" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se va a quitar.</param>
        <summary>Quita el elemento situado en el índice especificado de la lista.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estas dos condiciones se pueden probar con el <xref:System.Windows.Forms.BindingSource.IsFixedSize%2A> y <xref:System.Windows.Forms.BindingSource.IsReadOnly%2A> propiedades, respectivamente.  
  
 Este método provoca el <xref:System.Windows.Forms.BindingSource.ListChanged> eventos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la <xref:System.Windows.Forms.BindingSource.List%2A>, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>, y <xref:System.Windows.Forms.BindingSource.Count%2A> los miembros. Para ejecutar este ejemplo, pegue el código en un formulario que contenga un <xref:System.Windows.Forms.BindingSource> denominado `BindingSource1`, dos etiquetas denominadas `label1` y `label2`y un botón denominado `button1`. Asociar el `button1_Click` método con el <xref:System.Windows.Forms.Control.Click> eventos para `button1`. Los usuarios de Visual Basic, deberá agregar una referencia a System.Data.dll.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero o mayor que el valor de la propiedad <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">La lista subyacente representada por la propiedad <see cref="P:System.Windows.Forms.BindingSource.List" /> es de sólo lectura o tiene un tamaño fijo.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Remove(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsFixedSize" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsReadOnly" />
        <altmember cref="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public void RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveCurrent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveCurrent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita el elemento actual de la lista.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.RemoveCurrent%2A> método es equivalente a la <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Windows.Forms.BindingSource.AllowRemove" /> es <see langword="false" />.  
  
 O bien  
  
 <see cref="P:System.Windows.Forms.BindingSource.Position" /> es menor que cero o mayor que <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">La lista subyacente representada por la propiedad <see cref="P:System.Windows.Forms.BindingSource.List" /> es de sólo lectura o tiene un tamaño fijo.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveFilter">
      <MemberSignature Language="C#" Value="public virtual void RemoveFilter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveFilter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveFilter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveFilter ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveFilter();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita el filtro asociado a <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.RemoveFilter%2A> método hace referencia a la solicitud a la lista subyacente <xref:System.ComponentModel.IBindingListView.RemoveFilter%2A?displayProperty=nameWithType> método. Solo se enumeran que implementan <xref:System.ComponentModel.IBindingListView> admite el filtrado.  
  
 De forma predeterminada, una llamada a este método es equivalente a establecer el <xref:System.Windows.Forms.BindingSource.Filter%2A> propiedad `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La lista subyacente no admite el filtrado.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.Filter" />
      </Docs>
    </Member>
    <Member MemberName="RemoveSort">
      <MemberSignature Language="C#" Value="public virtual void RemoveSort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveSort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveSort" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveSort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveSort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita la ordenación asociada a <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.RemoveSort%2A> método hace referencia a la solicitud a la lista subyacente <xref:System.ComponentModel.IBindingList.RemoveSort%2A?displayProperty=nameWithType> método. Solo se enumeran que implementan <xref:System.ComponentModel.IBindingList> admiten la ordenación.  
  
 De forma predeterminada, una llamada a este método es equivalente a establecer el <xref:System.Windows.Forms.BindingSource.Sort%2A> propiedad `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La lista subyacente no admite la ordenación.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.Sort" />
      </Docs>
    </Member>
    <Member MemberName="ResetAllowNew">
      <MemberSignature Language="C#" Value="public virtual void ResetAllowNew ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetAllowNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetAllowNew" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetAllowNew ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetAllowNew();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reinicializa la propiedad <see cref="P:System.Windows.Forms.BindingSource.AllowNew" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.ResetAllowNew%2A> método reinicializa la <xref:System.Windows.Forms.BindingSource.AllowNew%2A> propiedad para reflejar el valor de la correspondiente <xref:System.Windows.Forms.BindingSource.AllowNew%2A> propiedad en la lista subyacente.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowNew" />
      </Docs>
    </Member>
    <Member MemberName="ResetBindings">
      <MemberSignature Language="C#" Value="public void ResetBindings (bool metadataChanged);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetBindings(bool metadataChanged) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetBindings(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetBindings (metadataChanged As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetBindings(bool metadataChanged);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataChanged" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="metadataChanged">
          Es <see langword="true" /> si ha cambiado el esquema de datos; es <see langword="false" /> si sólo han cambiado los valores.</param>
        <summary>Hace que un control enlazado a <see cref="T:System.Windows.Forms.BindingSource" /> vuelva a leer todos los elementos de la lista y actualice los valores mostrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> método informa a todos los controles enlazados a la <xref:System.Windows.Forms.BindingSource> para actualizar sus valores. El método para ello, cuando se genera el <xref:System.Windows.Forms.BindingSource.ListChanged> eventos al menos una vez; el `metaDataChanged` parámetro indica la naturaleza del cambio subyacente.  
  
-   A `metaDataChanged` valo `true` indica que el esquema de datos de <xref:System.Windows.Forms.BindingSource> ha cambiado. A <xref:System.Windows.Forms.BindingSource.ListChanged> evento se desencadena con <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> establecido en <xref:System.ComponentModel.ListChangedType.PropertyDescriptorChanged?displayProperty=nameWithType>.  
  
-   A `metaDataChanged` valo `false` indica que solo los valores de uno o más elementos han cambiado.  
  
 Independientemente del valor de `metaDataChanged`, <xref:System.Windows.Forms.BindingSource.ListChanged> evento se desencadena con <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> establecido en <xref:System.ComponentModel.ListChangedType.Reset?displayProperty=nameWithType>. En consecuencia, llamar a <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> con un parámetro de `true` producirá dos <xref:System.Windows.Forms.BindingSource.ListChanged> eventos.  
  
 <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> se invoca automáticamente siempre que otro miembro realiza cambios significativos en el enlace de datos, como la configuración de la <xref:System.Windows.Forms.BindingSource.DataSource%2A> o <xref:System.Windows.Forms.BindingSource.DataMember%2A> propiedades. Sin embargo, el programador puede llamar a este método explícitamente.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza un <xref:System.Windows.Forms.BindingSource> componente para enlazar una lista de matrices, que no proporciona notificación de cambio. Se quita un elemento de la lista, y los controles enlazados son una notificación del cambio mediante una llamada a la <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> método. Este ejemplo de código forma parte de un ejemplo más extenso incluido en [Cómo: reflejar las actualizaciones de origen de datos en un Control de formularios Windows Forms con BindingSource](~/docs/framework/winforms/controls/reflect-data-source-updates-in-a-wf-control-with-the-bindingsource.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.ResetItem(System.Int32)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="T:System.ComponentModel.ListChangedType" />
      </Docs>
    </Member>
    <Member MemberName="ResetCurrentItem">
      <MemberSignature Language="C#" Value="public void ResetCurrentItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetCurrentItem() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetCurrentItem" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetCurrentItem ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetCurrentItem();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hace que un control enlazado al <see cref="T:System.Windows.Forms.BindingSource" /> vuelva a leer el elemento seleccionado en ese momento y actualice el valor que se está mostrando.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método hará que el <xref:System.Windows.Forms.BindingSource.ListChanged> que se produzca, evento especifica el elemento cambiado en la posición actual.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetItem">
      <MemberSignature Language="C#" Value="public void ResetItem (int itemIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetItem(int32 itemIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetItem (itemIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetItem(int itemIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="itemIndex">Índice de base cero del elemento que ha cambiado.</param>
        <summary>Hace que un control enlazado al <see cref="T:System.Windows.Forms.BindingSource" /> vuelva a leer el elemento situado en el índice especificado y actualice su valor mostrado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.ResetItem%2A> método notifica a todos los controles enlazados al elemento en el índice especificado <xref:System.Windows.Forms.BindingSource.Position%2A> para actualizar sus valores. El método para ello, cuando se genera el <xref:System.Windows.Forms.BindingSource.ListChanged> eventos con <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> establecido en <xref:System.ComponentModel.ListChangedType.ItemChanged?displayProperty=nameWithType>.  
  
 <xref:System.Windows.Forms.BindingSource.ResetItem%2A> se llama automáticamente cada vez que se realizan cambios en el valor de un elemento individual. Sin embargo, el programador puede llamar a este método explícitamente.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza un <xref:System.Windows.Forms.BindingSource> componente para enlazar una lista a un <xref:System.Windows.Forms.DataGridView> control. La lista no provoca notificaciones de cambios, por lo que la <xref:System.Windows.Forms.BindingSource.ResetItem%2A> método en el <xref:System.Windows.Forms.BindingSource> se usa para generar el <xref:System.Windows.Forms.BindingSource.ListChanged> eventos. Este ejemplo de código forma parte de un ejemplo más extenso incluido en [Cómo: provocar notificaciones de cambios mediante el método ResetItem de BindingSource](~/docs/framework/winforms/controls/how-to-raise-change-notifications-using-the-bindingsource-resetitem-method.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.BindingSource.ResetBindings(System.Boolean)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="T:System.ComponentModel.ListChangedType" />
      </Docs>
    </Member>
    <Member MemberName="ResumeBinding">
      <MemberSignature Language="C#" Value="public void ResumeBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResumeBinding" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeBinding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeBinding();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reanuda el enlace de datos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> y <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> son dos métodos que permiten la suspensión temporal y la reanudación del enlace de datos en un escenario de enlace sencillo. Normalmente, se suspende el enlace de datos si el usuario debe poder realizar varias ediciones en campos de datos antes de que se produce la validación. Por ejemplo, si un campo debe modificarse con arreglo a un segundo, pero la validación el primer campo provocaría que el segundo campo como error.  
  
> [!NOTE]
>  Usar <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> evitar que los cambios que se va a insertar en el origen de datos hasta que <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> se llama, pero realmente no impide que se produzca cualquier evento. Controles que utilizan el enlace de datos complejo, como el <xref:System.Windows.Forms.DataGridView> controlar, actualizan sus valores basados en eventos de cambio como el <xref:System.Windows.Forms.CurrencyManager.ListChanged> eventos, por lo que una llamada a <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> no evitará que recibir los cambios al origen de datos. Por este motivo, esto <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> y <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> están diseñados para su uso con controles enlazados simples, como el <xref:System.Windows.Forms.TextBox> control. También puede utilizar estos métodos en un escenario de enlace complejo si se suprimen los <xref:System.Windows.Forms.BindingSource.ListChanged> eventos estableciendo la <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> propiedad `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.ResumeBinding" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public string Sort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Sort" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Property Sort As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Sort { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece los nombres de columna utilizados para ordenar y el criterio de ordenación para ver las filas del origen de datos.</summary>
        <value>Cadena con distinción entre mayúsculas y minúsculas que contiene el nombre de columna seguido de "ASC" (para el orden ascendente) o "DESC" (para el orden descendente). El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.Sort%2A> propiedad es una cadena entre mayúsculas y minúsculas que especifica los nombres de columna utilizados para ordenar las filas, junto con la dirección de ordenación. Las columnas están ordenadas por orden ascendente de forma predeterminada. Varias columnas pueden estar separadas por comas, como `"State, ZipCode DESC"`.  
  
 Para admitir la ordenación, la lista subyacente debe implementar la <xref:System.ComponentModel.IBindingList> o <xref:System.ComponentModel.IBindingListView> interfaces. Esta capacidad se puede consultar a través de la <xref:System.Windows.Forms.BindingSource.SupportsSorting%2A> propiedad. Ordenar varias columnas está disponible cuando la <xref:System.Windows.Forms.BindingSource.SupportsAdvancedSorting%2A> propiedad es `true`.  
  
 Establecer el <xref:System.Windows.Forms.BindingSource.Sort%2A> propiedad cambiará la lista interna según su tipo:  
  
-   Si la lista es de tipo <xref:System.ComponentModel.IBindingList>, <xref:System.ComponentModel.IBindingList.SortProperty%2A?displayProperty=nameWithType> y <xref:System.ComponentModel.IBindingList.SortDirection%2A?displayProperty=nameWithType> propiedades se establecen en la lista interna.  
  
-   Si la lista es de tipo <xref:System.ComponentModel.IBindingListView>, el <xref:System.ComponentModel.IBindingListView.SortDescriptions%2A?displayProperty=nameWithType> se establece la propiedad.  
  
 Solo se cambian las propiedades de ordenación de la lista interna cuando la cadena de ordenación no es `null`. El `get` descriptor de acceso para esta propiedad no recuperará el valor de ordenación de la lista interna; en su lugar, devolverá el `set` valor de descriptor de acceso. El valor de la <xref:System.Windows.Forms.BindingSource.Sort%2A> propiedad se conservará cuando cambian los datos originales.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Forms.BindingSource.Sort%2A> propiedad que se va a realizar una ordenación básica con un <xref:System.Data.DataView>. Para ejecutar este ejemplo, pegue el código en un formulario Windows Forms y llame a `PopulateDataViewAndSort` desde el constructor del formulario o <xref:System.Windows.Forms.Form.Load> método de control de eventos. El formulario debe importar el <xref:System.Xml> y <xref:System.IO> los espacios de nombres.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#2)]  
  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Forms.BindingSource.Sort%2A> avanzada de propiedad que se va a realizar la ordenación con un <xref:System.Data.DataView>. Para ejecutar este ejemplo, pegue el código en un formulario Windows Forms y llame a `PopulateDataViewAndAdvancedSort` desde el constructor del formulario o <xref:System.Windows.Forms.Form.Load> método de control de eventos. El formulario debe importar el <xref:System.Xml> y <xref:System.IO> los espacios de nombres.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Filter" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveSort" />
      </Docs>
    </Member>
    <Member MemberName="SortDescriptions">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ListSortDescriptionCollection SortDescriptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ListSortDescriptionCollection SortDescriptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortDescriptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortDescriptions As ListSortDescriptionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ListSortDescriptionCollection ^ SortDescriptions { System::ComponentModel::ListSortDescriptionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListSortDescriptionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección de descripciones de ordenación aplicada al origen de datos.</summary>
        <value>Si el origen de datos es <see cref="T:System.ComponentModel.IBindingListView" />, un <see cref="T:System.ComponentModel.ListSortDescriptionCollection" /> que contiene las descripciones de ordenación aplicadas a la lista; de lo contrario, es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la lista no es un <xref:System.ComponentModel.IBindingListView>, <xref:System.Windows.Forms.BindingSource.SortDescriptions%2A> siempre devuelve `null`.  
  
 El <xref:System.ComponentModel.ListSortDescriptionCollection> es una colección de solo lectura.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortDirection">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ListSortDirection SortDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.ListSortDirection SortDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortDirection" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortDirection As ListSortDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ListSortDirection SortDirection { System::ComponentModel::ListSortDirection get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListSortDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la dirección en la que están ordenados los elementos de la lista.</summary>
        <value>Uno de los valores de <see cref="T:System.ComponentModel.ListSortDirection" /> que indica la dirección según la cual se ordena la lista.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la lista subyacente no es un <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.BindingSource.SortDirection%2A> propiedad siempre devolverá <xref:System.ComponentModel.ListSortDirection.Ascending>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortProperty">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptor SortProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.PropertyDescriptor SortProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortProperty" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortProperty As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::PropertyDescriptor ^ SortProperty { System::ComponentModel::PropertyDescriptor ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el <see cref="T:System.ComponentModel.PropertyDescriptor" /> que se utiliza para ordenar la lista.</summary>
        <value>Si la lista es <see cref="T:System.ComponentModel.IBindingList" />, el <see cref="T:System.ComponentModel.PropertyDescriptor" /> que se utiliza para ordenar; de lo contrario, es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la lista no es un <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.BindingSource.SortProperty%2A> siempre devuelve `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsAdvancedSorting">
      <MemberSignature Language="C#" Value="public virtual bool SupportsAdvancedSorting { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAdvancedSorting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsAdvancedSorting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsAdvancedSorting As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsAdvancedSorting { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el origen de datos admite la ordenación de varias columnas.</summary>
        <value>
          Es <see langword="true" /> si la lista es <see cref="T:System.ComponentModel.IBindingListView" /> y admite la ordenación de varias columnas; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la lista no es un <xref:System.ComponentModel.IBindingListView>, <xref:System.Windows.Forms.BindingSource.SupportsAdvancedSorting%2A> siempre devuelve `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsChangeNotification">
      <MemberSignature Language="C#" Value="public virtual bool SupportsChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsChangeNotification" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsChangeNotification" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsChangeNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsChangeNotification { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el origen de datos admite la notificación de cambios.</summary>
        <value>
          <see langword="true" /> en todos los casos.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsFiltering">
      <MemberSignature Language="C#" Value="public virtual bool SupportsFiltering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsFiltering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsFiltering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsFiltering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsFiltering { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el origen de datos admite el filtrado.</summary>
        <value>
          Es <see langword="true" /> si la lista es un <see cref="T:System.ComponentModel.IBindingListView" /> y admite el filtrado; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la lista no es un <xref:System.ComponentModel.IBindingListView>, <xref:System.Windows.Forms.BindingSource.SupportsFiltering%2A> siempre devuelve `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsSearching">
      <MemberSignature Language="C#" Value="public virtual bool SupportsSearching { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsSearching" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsSearching" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsSearching As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsSearching { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el origen de datos permite realizar búsquedas con el método <see cref="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />.</summary>
        <value>
          Es <see langword="true" /> si la lista es <see cref="T:System.ComponentModel.IBindingList" /> y permite realizar búsquedas con el método <see cref="Overload:System.Windows.Forms.BindingSource.Find" />; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el origen de datos no es un <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.BindingSource.SupportsSearching%2A> siempre devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Windows.Forms.BindingSource.SupportsSearching%2A> miembro. Para obtener un ejemplo completo, vea el tema de información general sobre la clase.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsSorting">
      <MemberSignature Language="C#" Value="public virtual bool SupportsSorting { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsSorting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsSorting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsSorting As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsSorting { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el origen de datos admite la ordenación.</summary>
        <value>
          Es <see langword="true" /> si el origen de datos es <see cref="T:System.ComponentModel.IBindingList" /> y admite la ordenación; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el origen de datos no es un <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.BindingSource.SupportsSorting%2A> propiedad siempre devuelve `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuspendBinding">
      <MemberSignature Language="C#" Value="public void SuspendBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SuspendBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.SuspendBinding" />
      <MemberSignature Language="VB.NET" Value="Public Sub SuspendBinding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SuspendBinding();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Suspende el enlace a datos para impedir que los cambios actualicen el origen de datos enlazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> y <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> son dos métodos que permiten la suspensión temporal y la reanudación del enlace de datos en un escenario de enlace sencillo. Normalmente, se suspende el enlace de datos si el usuario debe poder realizar varias ediciones en campos de datos antes de que se produce la validación. Por ejemplo, si un campo debe modificarse con arreglo a un segundo, pero la validación el primer campo provocaría que el segundo campo como error.  
  
> [!NOTE]
>  Usar <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> y evitar que los cambios que se va a insertar en el origen de datos hasta que <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> se llama, pero realmente no impide que se produzca cualquier evento. Controles que utilizan el enlace de datos complejo, como el <xref:System.Windows.Forms.DataGridView> controlar, actualizan sus valores basados en eventos de cambio como el <xref:System.Windows.Forms.CurrencyManager.ListChanged> eventos, por lo que una llamada a <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> no evitará que recibir los cambios al origen de datos. Por este motivo, esto <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> y <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> están diseñados para su uso con controles enlazados simples, como el <xref:System.Windows.Forms.TextBox> control. También puede utilizar estos métodos en un escenario de enlace complejo si se suprimen los <xref:System.Windows.Forms.BindingSource.ListChanged> eventos estableciendo la <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> propiedad `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.SuspendBinding" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que se puede utilizar para sincronizar el acceso a la lista subyacente.</summary>
        <value>Objeto que se puede utilizar para sincronizar el acceso a la lista subyacente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IBindingList.AddIndex">
      <MemberSignature Language="C#" Value="void IBindingList.AddIndex (System.ComponentModel.PropertyDescriptor property);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IBindingList.AddIndex(class System.ComponentModel.PropertyDescriptor property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#IBindingList#AddIndex(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Sub AddIndex (property As PropertyDescriptor) Implements IBindingList.AddIndex" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IBindingList.AddIndex(System::ComponentModel::PropertyDescriptor ^ property) = System::ComponentModel::IBindingList::AddIndex;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="property">
          <see cref="T:System.ComponentModel.PropertyDescriptor" /> que se va a agregar a los índices utilizados para las búsquedas.</param>
        <summary>Agrega <see cref="T:System.ComponentModel.PropertyDescriptor" /> a los índices utilizados para las búsquedas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la lista subyacente es un <xref:System.ComponentModel.IBindingList> tipo, este método agregará el <xref:System.ComponentModel.PropertyDescriptor> a los índices; en caso contrario, la llamada a este método producirá una <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La lista subyacente no es una interfaz <see cref="T:System.ComponentModel.IBindingList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IBindingList.RemoveIndex">
      <MemberSignature Language="C#" Value="void IBindingList.RemoveIndex (System.ComponentModel.PropertyDescriptor prop);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IBindingList.RemoveIndex(class System.ComponentModel.PropertyDescriptor prop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#IBindingList#RemoveIndex(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveIndex (prop As PropertyDescriptor) Implements IBindingList.RemoveIndex" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IBindingList.RemoveIndex(System::ComponentModel::PropertyDescriptor ^ prop) = System::ComponentModel::IBindingList::RemoveIndex;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prop" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="prop">
          <see cref="T:System.ComponentModel.PropertyDescriptor" /> que se va a quitar de los índices utilizados para las búsquedas.</param>
        <summary>Quita el <see cref="T:System.ComponentModel.PropertyDescriptor" /> de los índices utilizados para las búsquedas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la lista subyacente no es un <xref:System.ComponentModel.IBindingList?displayProperty=nameWithType>, este método siempre producirá un <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ICancelAddNew.CancelNew">
      <MemberSignature Language="C#" Value="void ICancelAddNew.CancelNew (int position);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ICancelAddNew.CancelNew(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#CancelNew(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CancelNew (position As Integer) Implements ICancelAddNew.CancelNew" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ICancelAddNew.CancelNew(int position) = System::ComponentModel::ICancelAddNew::CancelNew;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Índice del elemento que se agregó a la colección.</param>
        <summary>Descarta un nuevo elemento pendiente de la colección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23CancelNew%2A> método revierte una adición pendiente de un elemento previamente agregado a la colección en el índice especificado por `position`. El `position` parámetro es necesario porque varios elementos nuevos pueden estar pendientes al mismo tiempo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.ICancelAddNew.CancelNew(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ICancelAddNew.EndNew">
      <MemberSignature Language="C#" Value="void ICancelAddNew.EndNew (int position);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ICancelAddNew.EndNew(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#EndNew(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub EndNew (position As Integer) Implements ICancelAddNew.EndNew" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ICancelAddNew.EndNew(int position) = System::ComponentModel::ICancelAddNew::EndNew;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Índice del elemento que se agregó a la colección.</param>
        <summary>Confirma un nuevo elemento pendiente en la colección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23EndNew%2A> método confirma una adición pendiente de un elemento previamente agregado a la colección en el índice especificado por `position`. El `position` parámetro es necesario porque varios elementos nuevos pueden estar pendientes al mismo tiempo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.ICancelAddNew.EndNew(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.BeginInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitialize#BeginInit" />
      <MemberSignature Language="VB.NET" Value="Sub BeginInit () Implements ISupportInitialize.BeginInit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ISupportInitialize.BeginInit() = System::ComponentModel::ISupportInitialize::BeginInit;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica al <see cref="T:System.Windows.Forms.BindingSource" /> que se está iniciando la inicialización.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.EndInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitialize#EndInit" />
      <MemberSignature Language="VB.NET" Value="Sub EndInit () Implements ISupportInitialize.EndInit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ISupportInitialize.EndInit() = System::ComponentModel::ISupportInitialize::EndInit;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica al <see cref="T:System.Windows.Forms.BindingSource" /> que la inicialización ha finalizado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitializeNotification.IsInitialized">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.ISupportInitializeNotification.IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.ISupportInitializeNotification.IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitializeNotification#IsInitialized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsInitialized As Boolean Implements ISupportInitializeNotification.IsInitialized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.ISupportInitializeNotification.IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Windows.Forms.BindingSource" /> está inicializado.</summary>
        <value>
          <see langword="true" /> para indicar que <see cref="T:System.Windows.Forms.BindingSource" /> está inicializado; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Windows.Forms.BindingSource> se convierte en una interfaz <xref:System.ComponentModel.ISupportInitializeNotification>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>