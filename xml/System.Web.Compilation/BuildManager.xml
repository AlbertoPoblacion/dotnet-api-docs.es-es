<Type Name="BuildManager" FullName="System.Web.Compilation.BuildManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a82244528eac6e037120c521525c7c211c363f52" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53394322" /></Metadata><TypeSignature Language="C#" Value="public sealed class BuildManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BuildManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Compilation.BuildManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BuildManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class BuildManager sealed" />
  <TypeSignature Language="F#" Value="type BuildManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona un conjunto de métodos para ayudar a administrar la compilación de una aplicación ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Web.Compilation.BuildManager> clase administra el proceso de compilación de páginas para una aplicación y ensamblados. Es una clase sellada y no se puede heredar.  
  
 <xref:System.Web.Compilation.BuildManager> contiene a miembros estáticos que proporcionan información sobre los ensamblados compilados.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.Compilation.ClientBuildManager" />
    <altmember cref="T:System.Web.Compilation.BuildProvider" />
    <altmember cref="T:System.Web.Compilation.AssemblyBuilder" />
  </Docs>
  <Members>
    <Member MemberName="AddCompilationDependency">
      <MemberSignature Language="C#" Value="public static void AddCompilationDependency (string dependency);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddCompilationDependency(string dependency) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.AddCompilationDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddCompilationDependency (dependency As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddCompilationDependency(System::String ^ dependency);" />
      <MemberSignature Language="F#" Value="static member AddCompilationDependency : string -&gt; unit" Usage="System.Web.Compilation.BuildManager.AddCompilationDependency dependency" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependency" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dependency">Cadena que representa una dependencia.</param>
        <summary>Especifica una cadena que representa una dependencia utilizada por el administrador de compilación para poder determinar si se requiere una compilación limpia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe llamarse al método durante la `Application_PreStartInit` etapa de la aplicación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="dependency" /> es <see langword="null" /> o una cadena vacía.</exception>
        <exception cref="T:System.InvalidOperationException">El método se llamó tras la fase <see langword="Application_PreStartInit" /> de la aplicación.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddReferencedAssembly">
      <MemberSignature Language="C#" Value="public static void AddReferencedAssembly (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddReferencedAssembly(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.AddReferencedAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddReferencedAssembly(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member AddReferencedAssembly : System.Reflection.Assembly -&gt; unit" Usage="System.Web.Compilation.BuildManager.AddReferencedAssembly assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">Ensamblado que se va a agregar.</param>
        <summary>Agrega un ensamblado al conjunto de ensamblados a los que se hace referencia de la aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método es equivalente a agregar el ensamblado en el archivo Web.config de nivel de aplicación. Debe llamarse al método durante la `Application_PreStartInit` etapa de la aplicación.  
  
 El <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> método devolverá el conjunto de ensamblados que se determinan a partir de los archivos de configuración y los ensamblados que se han agregado mediante este método.  
  
 Si se intenta agregar un ensamblado que ya se ha agregado, se omite la entrada duplicada.  
  
 Este método debe llamarse antes el `Application_Start` se produce el evento en el archivo Global.asax.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="assembly" /> es <see langword="null" /> o está vacío.</exception>
        <exception cref="T:System.InvalidOperationException">No se llamó al método antes de producirse el evento <see langword="Application_Start" /> en el archivo Global.asax.</exception>
      </Docs>
    </Member>
    <Member MemberName="BatchCompilationEnabled">
      <MemberSignature Language="C#" Value="public static Nullable&lt;bool&gt; BatchCompilationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;bool&gt; BatchCompilationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.BatchCompilationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BatchCompilationEnabled As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;bool&gt; BatchCompilationEnabled { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.BatchCompilationEnabled : Nullable&lt;bool&gt; with get, set" Usage="System.Web.Compilation.BuildManager.BatchCompilationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la compilación por lotes está habilitada.</summary>
        <value>Es <see langword="true" /> si la compilación por lotes siempre está habilitada, <see langword="false" /> si la compilación por lotes nunca está habilitada o <see langword="null" /> si la configuración de compilación se determina a partir del archivo de configuración. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad le permite activar o desactivar la compilación por lotes mediante programación. Se corresponde con el `batch` atributo de la `compilation` elemento en el archivo Web.config. Para obtener más información, consulte [compilación Element (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/7c319582-074a-4d2a-a787-03b9d4541c12).  
  
 La propiedad puede establecerse solo en el `PreApplicationStart` método. Para obtener más información sobre el método `PreApplicationStart`, vea <xref:System.Web.PreApplicationStartMethodAttribute>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad no se estableció en el método <see langword="PreApplicationStart" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CodeAssemblies">
      <MemberSignature Language="C#" Value="public static System.Collections.IList CodeAssemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.IList CodeAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.CodeAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CodeAssemblies As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::IList ^ CodeAssemblies { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeAssemblies : System.Collections.IList" Usage="System.Web.Compilation.BuildManager.CodeAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una lista de ensamblados compilados en el directorio App_Code.</summary>
        <value>Una colección <see cref="T:System.Collections.IList" /> que contiene los ensamblados compilados en el directorio App_Code.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCachedFile">
      <MemberSignature Language="C#" Value="public static System.IO.Stream CreateCachedFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream CreateCachedFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.CreateCachedFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCachedFile (fileName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ CreateCachedFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member CreateCachedFile : string -&gt; System.IO.Stream" Usage="System.Web.Compilation.BuildManager.CreateCachedFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre del archivo que se va a crear.</param>
        <summary>Crea un archivo almacenado en memoria caché.</summary>
        <returns>Objeto <see cref="T:System.IO.Stream" /> para el nuevo archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método y el <xref:System.Web.Compilation.BuildManager.ReadCachedFile%2A> método permiten realizar almacenamiento en caché que se conserva entre reinicios del dominio de aplicación en entornos de confianza parcial. Se usa el marco de MVC para la memoria caché los resultados de la búsqueda del controlador.  
  
 Datos en caché, escribe en el <xref:System.IO.Stream> objeto devuelto por este método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromVirtualPath">
      <MemberSignature Language="C#" Value="public static object CreateInstanceFromVirtualPath (string virtualPath, Type requiredBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstanceFromVirtualPath(string virtualPath, class System.Type requiredBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFromVirtualPath (virtualPath As String, requiredBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstanceFromVirtualPath(System::String ^ virtualPath, Type ^ requiredBaseType);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFromVirtualPath : string * Type -&gt; obj" Usage="System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath (virtualPath, requiredBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="requiredBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ruta de acceso virtual del archivo cuya instancia se va a crear.</param>
        <param name="requiredBaseType">Tipo base que define el objeto que se va a crear.</param>
        <summary>Procesa un archivo, dada su ruta de acceso virtual, y crea una instancia del resultado.</summary>
        <returns>La <see cref="T:System.Object" /> que representa la instancia del archivo procesado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath%2A> método funciona para las páginas compiladas y de no compilación.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCachedBuildDependencySet">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un conjunto de dependencias de compilación de la memoria caché de ASP.NET.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCachedBuildDependencySet">
      <MemberSignature Language="C#" Value="public static System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet (System.Web.HttpContext context, string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet(class System.Web.HttpContext context, string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet(System.Web.HttpContext,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachedBuildDependencySet (context As HttpContext, virtualPath As String) As BuildDependencySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Compilation::BuildDependencySet ^ GetCachedBuildDependencySet(System::Web::HttpContext ^ context, System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCachedBuildDependencySet : System.Web.HttpContext * string -&gt; System.Web.Compilation.BuildDependencySet" Usage="System.Web.Compilation.BuildManager.GetCachedBuildDependencySet (context, virtualPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Compilation.BuildDependencySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="context">Contexto de la solicitud.</param>
        <param name="virtualPath">Ruta de acceso virtual a partir de la que se determina el conjunto de dependencias de compilación.</param>
        <summary>Devuelve un conjunto de dependencias de compilación para una ruta de acceso virtual si la ruta se encuentra en la caché de ASP.NET.</summary>
        <returns>Objeto <see cref="T:System.Web.Compilation.BuildDependencySet" /> que está almacenado en la memoria caché o <see langword="null" /> si el objeto <see cref="T:System.Web.Compilation.BuildDependencySet" /> no se puede recuperar de la memoria caché.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.Compilation.BuildDependencySet" />
        <altmember cref="P:System.Web.Compilation.BuildProvider.VirtualPathDependencies" />
      </Docs>
    </Member>
    <Member MemberName="GetCachedBuildDependencySet">
      <MemberSignature Language="C#" Value="public static System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet (System.Web.HttpContext context, string virtualPath, bool ensureIsUpToDate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet(class System.Web.HttpContext context, string virtualPath, bool ensureIsUpToDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet(System.Web.HttpContext,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachedBuildDependencySet (context As HttpContext, virtualPath As String, ensureIsUpToDate As Boolean) As BuildDependencySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Compilation::BuildDependencySet ^ GetCachedBuildDependencySet(System::Web::HttpContext ^ context, System::String ^ virtualPath, bool ensureIsUpToDate);" />
      <MemberSignature Language="F#" Value="static member GetCachedBuildDependencySet : System.Web.HttpContext * string * bool -&gt; System.Web.Compilation.BuildDependencySet" Usage="System.Web.Compilation.BuildManager.GetCachedBuildDependencySet (context, virtualPath, ensureIsUpToDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Compilation.BuildDependencySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="ensureIsUpToDate" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="context">Contexto de la solicitud.</param>
        <param name="virtualPath">Ruta de acceso virtual a partir de la que se determina el conjunto de dependencias de compilación.</param>
        <param name="ensureIsUpToDate">Es <see langword="true" /> para especificar que solo debe devolverse un conjunto de dependencias de compilación actualizado; es <see langword="false" /> para indicar debe devolverse cualquier conjunto de dependencias de compilación, aun cuando no esté actualizado. El valor predeterminado es <see langword="true" />.</param>
        <summary>Devuelve un conjunto de dependencias de compilación de una ruta de acceso virtual si la ruta se encuentra en la caché de ASP.NET, aun cuando el contenido no esté actualizado.</summary>
        <returns>Objeto <see cref="T:System.Web.Compilation.BuildDependencySet" /> que está almacenado en la memoria caché o <see langword="null" /> si el objeto <see cref="T:System.Web.Compilation.BuildDependencySet" /> no se puede recuperar de la memoria caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `ensureIsUpToDate` el valor del parámetro se establece en `true`, <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> sobrecarga del método se comporta como el <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> sobrecarga del método. Ambas sobrecargas devuelven una dependencia de compilación actual establecida si existe alguno, en caso contrario, devuelven `null`.  
  
 Sin embargo, el <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> sobrecarga del método incluye la opción de devolver cualquier conjunto de dependencia de compilación que está disponible, incluso uno anticuado. Si el `ensureIsUpToDate` el valor del parámetro se establece en `false`, el método devolverá cualquier conjunto de dependencia de compilación disponibles.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompiledAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCompiledAssembly (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCompiledAssembly(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledAssembly (virtualPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCompiledAssembly(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledAssembly : string -&gt; System.Reflection.Assembly" Usage="System.Web.Compilation.BuildManager.GetCompiledAssembly virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ruta de acceso virtual en la que se compilará un ensamblado.</param>
        <summary>Compila un archivo en un ensamblado usando la ruta de acceso virtual especificada.</summary>
        <returns>Objeto <see cref="T:System.Reflection.Assembly" /> que se compila desde la ruta de acceso virtual especificada, que está almacenada en la memoria caché de disco o memoria.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.Compilation.BuildProvider" />
        <altmember cref="T:System.Web.Compilation.AssemblyBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetCompiledCustomString">
      <MemberSignature Language="C#" Value="public static string GetCompiledCustomString (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCompiledCustomString(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledCustomString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledCustomString (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCompiledCustomString(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledCustomString : string -&gt; string" Usage="System.Web.Compilation.BuildManager.GetCompiledCustomString virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ruta de acceso virtual del archivo que se va a compilar.</param>
        <summary>Compila un archivo, dada su ruta de acceso virtual, y devuelve una cadena personalizada que el proveedor de compilación conserva en la caché.</summary>
        <returns>Una cadena devuelta por el método <see cref="M:System.Web.Compilation.BuildProvider.GetCustomString(System.CodeDom.Compiler.CompilerResults)" />, que se almacena en caché en memoria o en disco.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.Compilation.BuildProvider.GetCustomString(System.CodeDom.Compiler.CompilerResults)" />
      </Docs>
    </Member>
    <Member MemberName="GetCompiledType">
      <MemberSignature Language="C#" Value="public static Type GetCompiledType (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetCompiledType(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledType (virtualPath As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetCompiledType(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledType : string -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetCompiledType virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ruta de acceso virtual en la que se compilará un tipo.</param>
        <summary>Compila un archivo, dada su ruta de acceso virtual, y devuelve el tipo compilado.</summary>
        <returns>Un objeto <see cref="T:System.Type" /> que representa el tipo generado tras compilar la ruta de acceso virtual.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">Ha ocurrido un error al compilar la ruta de acceso virtual.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="virtualPath" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Web.Compilation.BuildProvider.GetGeneratedType(System.CodeDom.Compiler.CompilerResults)" />
      </Docs>
    </Member>
    <Member MemberName="GetGlobalAsaxType">
      <MemberSignature Language="C#" Value="public static Type GetGlobalAsaxType ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetGlobalAsaxType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetGlobalAsaxType" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalAsaxType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetGlobalAsaxType();" />
      <MemberSignature Language="F#" Value="static member GetGlobalAsaxType : unit -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetGlobalAsaxType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto que representa el tipo de compilación para el archivo Global.asax.</summary>
        <returns>Objeto que representa el tipo de compilación para el archivo Global.asax.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se produce una excepción si se llama a este método antes de que se ha compilado el archivo Global.asax.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se hizo un intento de llamar a este método antes de compilar la página Global.asax.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectFactory">
      <MemberSignature Language="C#" Value="public static System.Web.Util.IWebObjectFactory GetObjectFactory (string virtualPath, bool throwIfNotFound);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Util.IWebObjectFactory GetObjectFactory(string virtualPath, bool throwIfNotFound) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetObjectFactory(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectFactory (virtualPath As String, throwIfNotFound As Boolean) As IWebObjectFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Util::IWebObjectFactory ^ GetObjectFactory(System::String ^ virtualPath, bool throwIfNotFound);" />
      <MemberSignature Language="F#" Value="static member GetObjectFactory : string * bool -&gt; System.Web.Util.IWebObjectFactory" Usage="System.Web.Compilation.BuildManager.GetObjectFactory (virtualPath, throwIfNotFound)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Util.IWebObjectFactory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ruta de acceso virtual.</param>
        <param name="throwIfNotFound">Es <see langword="true" /> si se va a producir un error en caso de que la ruta de acceso virtual no exista; de lo contrario, es <see langword="false" />. Si la ruta de acceso virtual no existe y <paramref name="throwIfNotFound" /> es <see langword="false" />, este método devuelve <see langword="null" />.</param>
        <summary>Obtiene un generador de objetos para la ruta de acceso virtual especificada.</summary>
        <returns>Generador de objetos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve un objeto que le permite generar un tipo mediante la compilación de la ruta de acceso virtual. Devuelve un objeto independientemente de si se precompila el sitio Web.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La ruta de acceso virtual no existe.  
  
O bien 
Una excepción del nivel superior ya existió cuando se llamó a este método.  
  
O bien 
Se llamó a este método mientras el proceso de compilación estaba compilando archivos de nivel superior.  
  
O bien 
Esto es una aplicación precompilada y la ruta de acceso virtual no se encontró en la memoria caché.  
  
O bien 
Se detectó una referencia circular.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public static System.Collections.ICollection GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ICollection GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReferencedAssemblies () As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ICollection ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="static member GetReferencedAssemblies : unit -&gt; System.Collections.ICollection" Usage="System.Web.Compilation.BuildManager.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una lista de referencias del ensamblado a las que todas las compilaciones de página deben hacer referencia.</summary>
        <returns>Una colección <see cref="T:System.Collections.ICollection" /> de referencias del ensamblado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La colección de ensamblados que se devuelve desde el <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> método incluye los ensamblados especificados en el elemento del archivo Web.config, ensamblados compilados a partir de código personalizado en el directorio App_Code y ensamblados en otras carpetas de nivel superior.  
  
 <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> se introdujo en .NET Framework versión 3.5.  Para más información, consulte [Versiones y dependencias de .NET Framework](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca un tipo en los ensamblados de nivel superior o en los ensamblados definidos en la configuración.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un ensamblado de nivel superior hace referencia al archivo Global.asax, o a un archivo que está en el directorio App_GlobalResources, App_WebReferences, App_Code o App_Browsers.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nombre del tipo.</param>
        <param name="throwOnError">Es <see langword="true" /> si se va a producir una excepción en caso de que no se pueda generar un objeto <see cref="T:System.Type" /> para el nombre de tipo; de lo contrario, es <see langword="false" />.</param>
        <summary>Busca un tipo en los ensamblados de nivel superior o en los ensamblados definidos en la configuración y, de manera opcional, produce una excepción en caso de error.</summary>
        <returns>Un objeto <see cref="T:System.Type" /> que representa el tipo de parámetro <paramref name="typeName" /> solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un ensamblado de nivel superior hace referencia al archivo Global.asax, o a un archivo que está en el directorio App_GlobalResources, App_WebReferences, App_Code o App_Browsers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="typeName" /> no es válido.  
  
O bien 
 <paramref name="typeName" /> es ambiguo.  
  
O bien 
 No se encontró <paramref name="typeName" /> y <paramref name="throwOnError" /> es <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nombre del tipo.</param>
        <param name="throwOnError">Es <see langword="true" /> si se va a producir una excepción en caso de que no se pueda generar <see cref="T:System.Type" /> para el nombre de tipo; de lo contrario, es <see langword="false" />.</param>
        <param name="ignoreCase">Es <see langword="true" /> si <paramref name="typeName" /> distingue entre mayúsculas y minúsculas; en caso contrario, es <see langword="false" />.</param>
        <summary>Busca un tipo en los ensamblados de nivel superior, o en los ensamblados definidos en la configuración, utilizando una búsqueda sin distinción entre mayúsculas y minúsculas; opcionalmente, produce una excepción en caso de error.</summary>
        <returns>Un objeto <see cref="T:System.Type" /> que representa el tipo de parámetro <paramref name="typeName" /> solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un ensamblado de nivel superior hace referencia al archivo Global.asax, o a un archivo que está en el directorio App_GlobalResources, App_WebReferences, App_Code o App_Browsers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="typeName" /> no es válido.  
  
O bien 
 <paramref name="typeName" /> es ambiguo.  
  
O bien 
 No se encontró <paramref name="typeName" /> y <paramref name="throwOnError" /> es <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetVirtualPathDependencies">
      <MemberSignature Language="C#" Value="public static System.Collections.ICollection GetVirtualPathDependencies (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ICollection GetVirtualPathDependencies(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetVirtualPathDependencies(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVirtualPathDependencies (virtualPath As String) As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ICollection ^ GetVirtualPathDependencies(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetVirtualPathDependencies : string -&gt; System.Collections.ICollection" Usage="System.Web.Compilation.BuildManager.GetVirtualPathDependencies virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ruta de acceso virtual utilizada para determinar las dependencias.</param>
        <summary>Proporciona una colección de dependencias de ruta de acceso virtual correspondiente a la ruta de acceso virtual especificada.</summary>
        <returns>Una colección <see cref="T:System.Collections.ICollection" /> de archivos representada por las rutas de acceso virtuales que son dependencias de caché para la ruta de acceso virtual.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrecompiledApp">
      <MemberSignature Language="C#" Value="public static bool IsPrecompiledApp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsPrecompiledApp" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.IsPrecompiledApp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsPrecompiledApp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsPrecompiledApp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrecompiledApp : bool" Usage="System.Web.Compilation.BuildManager.IsPrecompiledApp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que especifica si la aplicación está precompilada.</summary>
        <value><see langword="true" /> si la aplicación está precompilada; en caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpdatablePrecompiledApp">
      <MemberSignature Language="C#" Value="public static bool IsUpdatablePrecompiledApp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsUpdatablePrecompiledApp" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.IsUpdatablePrecompiledApp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsUpdatablePrecompiledApp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsUpdatablePrecompiledApp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpdatablePrecompiledApp : bool" Usage="System.Web.Compilation.BuildManager.IsUpdatablePrecompiledApp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que especifica si la aplicación de actual está precompilada como actualizable.</summary>
        <value>Es <see langword="true" /> si la aplicación se precompila como actualizable; de lo contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadCachedFile">
      <MemberSignature Language="C#" Value="public static System.IO.Stream ReadCachedFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream ReadCachedFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.ReadCachedFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadCachedFile (fileName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ ReadCachedFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member ReadCachedFile : string -&gt; System.IO.Stream" Usage="System.Web.Compilation.BuildManager.ReadCachedFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre del archivo que se va a leer.</param>
        <summary>Lee un archivo almacenado en memoria caché.</summary>
        <returns>Objeto <see cref="T:System.IO.Stream" /> del archivo o <see langword="null" /> si el archivo no existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método y el <xref:System.Web.Compilation.BuildManager.CreateCachedFile%2A> método permiten realizar almacenamiento en caché que se conserva entre reinicios del dominio de aplicación en entornos de confianza parcial. Se usa el marco de MVC para la memoria caché los resultados de la búsqueda del controlador.  
  
 Para recuperar los datos almacenados en caché, lee el <xref:System.IO.Stream> objeto devuelto por este método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetFramework">
      <MemberSignature Language="C#" Value="public static System.Runtime.Versioning.FrameworkName TargetFramework { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Versioning.FrameworkName TargetFramework" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.TargetFramework" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TargetFramework As FrameworkName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Versioning::FrameworkName ^ TargetFramework { System::Runtime::Versioning::FrameworkName ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetFramework : System.Runtime.Versioning.FrameworkName" Usage="System.Web.Compilation.BuildManager.TargetFramework" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Versioning.FrameworkName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la versión de destino de .NET Framework del sitio web actual.</summary>
        <value>Versión de destino de .NET Framework del sitio web actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad admite la característica de múltiples versiones de ASP.NET, que le permite usar la versión más reciente de Visual Studio para desarrollar aplicaciones que se ejecutarán con versiones anteriores de .NET Framework. Un proveedor de compilación puede usar esta propiedad para asegurarse de que el proveedor genera código que es adecuado para la versión de .NET Framework de destino. Por ejemplo, desea generar código diferente dependiendo de si un sitio Web, tiene como destino el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]. Para obtener más información acerca de múltiples, consulte [compatibilidad con múltiples versiones de .NET Framework para proyectos Web ASP.NET](https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76).  
  
 Si el sitio Web no tiene un archivo Web.config, ASP.NET se da por supuesto que la versión de framework de destino es la versión que está asociada con el grupo de aplicaciones de IIS que se ejecuta el sitio. Para un sitio Web de sistema de archivos que se ejecuta en Visual Studio, la versión de framework de forma predeterminada es la versión actual de .NET Framework.  
  
 Si el sitio Web tiene un archivo Web.config, ASP.NET determina la plataforma de destino, examine el archivo Web.config.  
  
## <a name="web-sites-that-target-the-net-framework-20"></a>Sitios Web que tienen como destino .NET Framework 2.0  
 Las aplicaciones Web que tienen como destino el [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] se compilan como si fuera el destino de la [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]. El proceso de compilación no se distingue el [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] y [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] porque el archivo Web.config no indica el framework de destino o de versión del compilador cuando se destina a una de estas versiones. (Para el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)], el archivo Web.config especifica la versión del compilador y para el [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], el archivo Web.config especifica la plataforma de destino.) Por lo tanto, para las aplicaciones Web que tienen como destino el [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], esta propiedad devuelve un moniker de la plataforma de destino que indica el [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)].  
  
 Esto normalmente no causará ningún problema. Visual Studio le impide crear referencias a [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] características en un proyecto que está destinada la [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]. Por ejemplo, Visual Studio no proporciona plantillas de elementos para los servicios WCF en un proyecto que está destinada a [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], ya que WCF se introdujo con la [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] y no es compatible con la [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
 Si va a implementar un sitio Web en un [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] entorno de tiempo de ejecución y usa una herramienta distinta a Visual Studio a las características de referencia que sólo son compatibles con [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)], podría crear el proyecto sin generar errores o advertencias. Sin embargo, la aplicación podría generar errores cuando el sitio Web se ejecuta en el [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>