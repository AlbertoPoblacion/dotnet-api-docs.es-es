<Type Name="Animatable" FullName="System.Windows.Media.Animation.Animatable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8ea9713148e10c8f9a95421b6bcd7b78a6cb4d56" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30659869" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Animatable : System.Windows.Freezable, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Animatable extends System.Windows.Freezable implements class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Animation.Animatable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Animatable&#xA;Inherits Freezable&#xA;Implements IAnimatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Animatable abstract : System::Windows::Freezable, System::Windows::Media::Animation::IAnimatable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Freezable</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Clase abstracta que proporciona compatibilidad de animación.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Animatable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Animatable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Media.Animation.Animatable" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Anima el objeto <see cref="T:System.Windows.DependencyProperty" /> con el objeto <see cref="T:System.Windows.Media.Animation.AnimationClock" /> especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp">Propiedad que se va a animar.</param>
        <param name="clock">Reloj con el que se animará la propiedad especificada. Si <c>clock</c> es <see langword="null" />, se quitarán todas las animaciones de la propiedad especificada (pero no se detendrán).</param>
        <summary>Se aplica <see cref="T:System.Windows.Media.Animation.AnimationClock" /> al valor de <see cref="T:System.Windows.DependencyProperty" /> especificado. Si la propiedad ya está animada, se usa el comportamiento de entrega <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que el uso de este método para quitar los relojes de una propiedad no detienen dichos relojes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">Propiedad que se va a animar.</param>
        <param name="clock">Reloj con el que se animará la propiedad especificada. Si <c>handoffBehavior</c> es <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> y <c>clock</c> es <see langword="null" />, se quitarán todas las animaciones de la propiedad especificada (pero no se detendrán). Si <c>handoffBehavior</c> es <see cref="F:System.Windows.Media.Animation.HandoffBehavior.Compose" /> y clock es <see langword="null" />, este método no tiene ningún efecto.</param>
        <param name="handoffBehavior">Valor que especifica la interacción de la nueva animación con cualquier animación actual que ya afecte el valor de propiedad.</param>
        <summary>Se aplica <see cref="T:System.Windows.Media.Animation.AnimationClock" /> al valor de <see cref="T:System.Windows.DependencyProperty" /> especificado. Si la propiedad ya está animada, se usa el objeto <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que al usar este método para quitar los relojes de una propiedad no detienen dichos relojes.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mediante el campo Compose de HandoffBehavior  
 Al aplicar un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una propiedad mediante el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, cualquier <xref:System.Windows.Media.Animation.Clock> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema; el sistema de temporización no quitará estos relojes automáticamente.  
  
 Para evitar problemas de rendimiento cuando se aplica un gran número de relojes con <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado. Hay varias formas de quitar un reloj.  
  
-   Para quitar todos los relojes de una propiedad, utilice la <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método del objeto animado. Especifique la propiedad que se está animada como el primer parámetro, y `null` como el segundo. De este modo, se quitarán todos los relojes de animación de la propiedad.  
  
-   Para quitar un determinado <xref:System.Windows.Media.Animation.AnimationClock> en una lista de relojes, use la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de la <xref:System.Windows.Media.Animation.AnimationClock> para recuperar un <xref:System.Windows.Media.Animation.ClockController>, a continuación, llame a la <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método de la <xref:System.Windows.Media.Animation.ClockController>. Esto se hace normalmente en el <xref:System.Windows.Media.Animation.Clock.Completed> controlador de eventos para un reloj. Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <xref:System.Windows.Media.Animation.ClockController>; el <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de un reloj secundario devolverá `null`. Tenga en cuenta también que la <xref:System.Windows.Media.Animation.Clock.Completed> no se puede llamar el evento si la duración efectiva del reloj es para siempre.  En ese caso, el usuario deberá determinar cuándo se debe llamar a <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.  Cuando un objeto se recolecta como elemento no utilizado, sus relojes también se desconectan y se recolectan como elementos no utilizados.  
  
 Para obtener más información acerca de los objetos de reloj, consulte la [animación y temporización información general del sistema](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo aplicar los relojes de animación utilizando diferentes <xref:System.Windows.Media.Animation.HandoffBehavior> configuración.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aplica una animación a la <see cref="T:System.Windows.DependencyProperty" /> especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp">Propiedad que se va a animar.</param>
        <param name="animation">Animación usada para animar la propiedad especificada.  
  
 Si el valor <see cref="P:System.Windows.Media.Animation.Timeline.BeginTime" /> de la animación es <see langword="null" />, se quitarán las animaciones actuales y se conservará el valor actual de la propiedad.  
  
 Si <c>animation</c> es <see langword="null" />, todas las animaciones se quitarán de la propiedad y el valor de la propiedad se restablecerá a su valor base.</param>
        <summary>Aplica una animación a la <see cref="T:System.Windows.DependencyProperty" /> especificada. La animación se inicia al representar el siguiente fotograma. Si la propiedad especificada ya está animada, se usa el comportamiento de entrega <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la animación tiene un <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> que es mayor que cero, la animación comienza una vez transcurrido ese período de tiempo desde el momento en que se representa el siguiente fotograma.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">Propiedad que se va a animar.</param>
        <param name="animation">Animación usada para animar la propiedad especificada.  
  
 Si <c>handoffBehavior</c> es <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> y la propiedad <see cref="P:System.Windows.Media.Animation.Timeline.BeginTime" /> de la animación es <see langword="null" />, se quitarán las animaciones actuales y se conservará el valor actual de la propiedad.  
  
 Si <c>handoffBehavior</c> es <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> y <c>animation</c> es una referencia de <see langword="null" />, todas las animaciones se quitarán de la propiedad y su valor se restablecerá a su valor base.  
  
 Si <c>handoffBehavior</c> es <see cref="F:System.Windows.Media.Animation.HandoffBehavior.Compose" />, este método no tendrá efecto si el valor de la animación o de su propiedad <see cref="P:System.Windows.Media.Animation.Timeline.BeginTime" /> es <see langword="null" />.</param>
        <param name="handoffBehavior">Valor que especifica la interacción de la nueva animación con cualquier animación actual que ya afecte el valor de propiedad.</param>
        <summary>Aplica una animación a la <see cref="T:System.Windows.DependencyProperty" /> especificada. La animación se inicia al representar el siguiente fotograma. Si la propiedad especificada ya está animada, se usa el objeto <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la animación tiene un <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> que es mayor que cero, la animación comienza una vez transcurrido ese período de tiempo desde el momento en que se representa el siguiente fotograma.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mediante el campo Compose de HandoffBehavior  
 Al aplicar un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una propiedad mediante el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, cualquier <xref:System.Windows.Media.Animation.Clock> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema; el sistema de temporización no quitará estos relojes automáticamente.  
  
 Para evitar problemas de rendimiento cuando se aplica un gran número de relojes con <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado. Hay varias formas de quitar un reloj.  
  
-   Para quitar todos los relojes de una propiedad, utilice la <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método del objeto animado. Especifique la propiedad que se está animada como el primer parámetro, y `null` como el segundo. De este modo, se quitarán todos los relojes de animación de la propiedad.  
  
-   Para quitar un determinado <xref:System.Windows.Media.Animation.AnimationClock> en una lista de relojes, use la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de la <xref:System.Windows.Media.Animation.AnimationClock> para recuperar un <xref:System.Windows.Media.Animation.ClockController>, a continuación, llame a la <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método de la <xref:System.Windows.Media.Animation.ClockController>. Esto se hace normalmente en el <xref:System.Windows.Media.Animation.Clock.Completed> controlador de eventos para un reloj. Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <xref:System.Windows.Media.Animation.ClockController>; el <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de un reloj secundario devolverá `null`. Tenga en cuenta también que la <xref:System.Windows.Media.Animation.Clock.Completed> no se puede llamar el evento si la duración efectiva del reloj es para siempre.  En ese caso, el usuario deberá determinar cuándo se debe llamar a <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.  Cuando un objeto se recolecta como elemento no utilizado, sus relojes también se desconectan y se recolectan como elementos no utilizados.  
  
 Para obtener más información acerca de los objetos de reloj, consulte la [animación y temporización información general del sistema](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo aplicar animaciones mediante diferentes <xref:System.Windows.Media.Animation.HandoffBehavior> configuración.  
  
 [!code-cpp[animateproperty#InteractiveAnimationExampleWholePage](~/samples/snippets/cpp/VS_Snippets_Wpf/animateproperty/CPP/InteractiveExample.cpp#interactiveanimationexamplewholepage)]
 [!code-csharp[animateproperty#InteractiveAnimationExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/animateproperty/CSharp/InteractiveExample.cs#interactiveanimationexamplewholepage)]
 [!code-vb[animateproperty#InteractiveAnimationExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateproperty/VisualBasic/InteractiveExample.vb#interactiveanimationexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.Animatable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Animation.Animatable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Animatable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::Animatable ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.Animatable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un clon modificable de este <see cref="T:System.Windows.Media.Animation.Animatable" /> y hace copias en profundidad de los valores de este objeto. Cuando se copian las propiedades de dependencia de este objeto, este método copia las referencias de recursos y enlaces de datos (aunque no se resuelvan), pero no copia las animaciones ni sus valores actuales.</summary>
        <returns>Clon modificable de esta instancia. En realidad, el clon devuelto es una copia en profundidad del objeto actual. La propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del clon es **false**.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Media.Animation.Animatable.Clone%2A> método se puede utilizar para generar copias modificables de inmovilizado <xref:System.Windows.Freezable> objetos. Para mayor comodidad, este método prevalece sobre el heredados <xref:System.Windows.Freezable.Clone%2A> método para proporcionar una implementación fuertemente tipada.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool FreezeCore(bool isChecking);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          Es <see langword="true" /> si este método debe determinar si se puede inmovilizar esta instancia. Es <see langword="false" /> si esta instancia debe inmovilizarse a sí misma cuando se llame a este método.</param>
        <summary>Convierte este objeto <see cref="T:System.Windows.Media.Animation.Animatable" /> en no modificable o determina si se puede convertir en no modificable.</summary>
        <returns>Si el valor de <paramref name="isChecking" /> es <see langword="true" />, este método devuelve <see langword="true" /> si este objeto <see cref="T:System.Windows.Media.Animation.Animatable" /> se puede convertir en no modificable, o <see langword="false" /> si no se puede convertir en no modificable.  
  
 Si <paramref name="isChecking" /> es <see langword="false" />, este método devuelve <see langword="true" /> si este objeto <see cref="T:System.Windows.Media.Animation.Animatable" /> especificado ahora es no modificable, o <see langword="false" /> si no se puede convertir en no modificable, con el inconveniente de tener que empezar a cambiar su estado de inmovilización.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devolverá **false** cuando <xref:System.Windows.Media.Animation.Animatable.HasAnimatedProperties%2A> es **true**.  
  
 No llame a este método directamente (excepto al llamar a la base de una implementación). Se llama internamente a este método <xref:System.Windows.Freezable.CanFreeze%2A> (con `isChecking` igual a `true`) y <xref:System.Windows.Freezable.Freeze%2A> (con `isChecking` igual que `false`).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Las clases que derivan de <see cref="T:System.Windows.Media.Animation.Animatable" /> deben invalidar este método cuando la clase contenga datos que no se almacenen usando las propiedades de dependencia.  
  
 Una implementación típica podría llamar a la implementación base y después llamar a estático <see cref="M:System.Windows.Freezable.Freeze" /> método en todos los <see cref="T:System.Windows.Freezable" /> propiedades que contiene la clase, devolver con tipo <see langword="true" /> sólo si estaban inmovilizadas todas las propiedades (o se han inmovilizado podría, en el casos de pasar a través de un <see langword="false" /> valor <paramref name="isChecking" />).</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identifica la propiedad cuyo valor base (no animado) se debe recuperar.</param>
        <summary>Devuelve el valor no animado del objeto <see cref="T:System.Windows.DependencyProperty" /> especificado.</summary>
        <returns>Valor que se devolvería si no se animara la propiedad especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la propiedad especificada no está animada, este método devuelve el mismo resultado que <xref:System.Windows.DependencyObject.GetValue%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente, se recuperan los valores de propiedades animadas no animadas y se muestra.  
  
 [!code-csharp[timingbehaviors_procedural_snip#GetAnimationBaseValueExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/GetAnimationBaseValueExample.cs#getanimationbasevalueexamplewholepage)]
 [!code-vb[timingbehaviors_procedural_snip#GetAnimationBaseValueExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/getanimationbasevalueexample.vb#getanimationbasevalueexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Animatable.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si uno o más objetos <see cref="T:System.Windows.Media.Animation.AnimationClock" /> se asocian a cualquiera de las propiedades de dependencia de este objeto.</summary>
        <value>**True** si uno o más <see cref="T:System.Windows.Media.Animation.AnimationClock" /> objetos está asociado a cualquiera de las propiedades de dependencia de este objeto; en caso contrario, **false**.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad no indica si este objeto contiene subobjetos animados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStoredWeakReference">
      <MemberSignature Language="C#" Value="public static bool ShouldSerializeStoredWeakReference (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ShouldSerializeStoredWeakReference(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ShouldSerializeStoredWeakReference (target As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ShouldSerializeStoredWeakReference(System::Windows::DependencyObject ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Representa un objeto que forma parte del sistema de propiedades de dependencia.</param>
        <summary>Especifica si se debe serializar un objeto de dependencia.</summary>
        <returns>
          <see langword="true" /> para serializar <paramref name="target" />; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor> clase utiliza el <xref:System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference%2A> método para determinar si una propiedad se debe serializar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>